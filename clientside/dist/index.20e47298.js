// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function() {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"dTQGj":[function(require,module,exports) {
var Refresh = require('react-refresh/runtime');
Refresh.injectIntoGlobalHook(window);
window.$RefreshReg$ = function() {
};
window.$RefreshSig$ = function() {
    return function(type) {
        return type;
    };
};

},{"react-refresh/runtime":"8nng3"}],"8nng3":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/react-refresh-runtime.development.js');

},{"./cjs/react-refresh-runtime.development.js":"6xTKN"}],"6xTKN":[function(require,module,exports) {
/** @license React v0.9.0
 * react-refresh-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 60103;
    var REACT_PORTAL_TYPE = 60106;
    var REACT_FRAGMENT_TYPE = 60107;
    var REACT_STRICT_MODE_TYPE = 60108;
    var REACT_PROFILER_TYPE = 60114;
    var REACT_PROVIDER_TYPE = 60109;
    var REACT_CONTEXT_TYPE = 60110;
    var REACT_FORWARD_REF_TYPE = 60112;
    var REACT_SUSPENSE_TYPE = 60113;
    var REACT_SUSPENSE_LIST_TYPE = 60120;
    var REACT_MEMO_TYPE = 60115;
    var REACT_LAZY_TYPE = 60116;
    var REACT_BLOCK_TYPE = 60121;
    var REACT_SERVER_BLOCK_TYPE = 60122;
    var REACT_FUNDAMENTAL_TYPE = 60117;
    var REACT_SCOPE_TYPE = 60119;
    var REACT_OPAQUE_ID_TYPE = 60128;
    var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
    var REACT_OFFSCREEN_TYPE = 60130;
    var REACT_LEGACY_HIDDEN_TYPE = 60131;
    if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor('react.element');
        REACT_PORTAL_TYPE = symbolFor('react.portal');
        REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
        REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
        REACT_PROFILER_TYPE = symbolFor('react.profiler');
        REACT_PROVIDER_TYPE = symbolFor('react.provider');
        REACT_CONTEXT_TYPE = symbolFor('react.context');
        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
        REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
        REACT_MEMO_TYPE = symbolFor('react.memo');
        REACT_LAZY_TYPE = symbolFor('react.lazy');
        REACT_BLOCK_TYPE = symbolFor('react.block');
        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
        REACT_SCOPE_TYPE = symbolFor('react.scope');
        REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
        REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
    }
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.
    // It's OK to reference families, but use WeakMap/Set for types.
    var allFamiliesByID = new Map();
    var allFamiliesByType = new PossiblyWeakMap();
    var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families
    // that have actually been edited here. This keeps checks fast.
    // $FlowIssue
    var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.
    // It is an array of [Family, NextType] tuples.
    var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.
    var helpersByRendererID = new Map();
    var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.
    var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.
    var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.
    // It needs to be weak because we do this even for roots that failed to mount.
    // If there is no WeakMap, we won't attempt to do retrying.
    // $FlowIssue
    var rootElements = typeof WeakMap === 'function' ? new WeakMap() : null;
    var isPerformingRefresh = false;
    function computeFullKey(signature) {
        if (signature.fullKey !== null) return signature.fullKey;
        var fullKey = signature.ownKey;
        var hooks;
        try {
            hooks = signature.getCustomHooks();
        } catch (err) {
            // This can happen in an edge case, e.g. if expression like Foo.useSomething
            // depends on Foo which is lazily initialized during rendering.
            // In that case just assume we'll have to remount.
            signature.forceReset = true;
            signature.fullKey = fullKey;
            return fullKey;
        }
        for(var i = 0; i < hooks.length; i++){
            var hook = hooks[i];
            if (typeof hook !== 'function') {
                // Something's wrong. Assume we need to remount.
                signature.forceReset = true;
                signature.fullKey = fullKey;
                return fullKey;
            }
            var nestedHookSignature = allSignaturesByType.get(hook);
            if (nestedHookSignature === undefined) continue;
            var nestedHookKey = computeFullKey(nestedHookSignature);
            if (nestedHookSignature.forceReset) signature.forceReset = true;
            fullKey += '\n---\n' + nestedHookKey;
        }
        signature.fullKey = fullKey;
        return fullKey;
    }
    function haveEqualSignatures(prevType, nextType) {
        var prevSignature = allSignaturesByType.get(prevType);
        var nextSignature = allSignaturesByType.get(nextType);
        if (prevSignature === undefined && nextSignature === undefined) return true;
        if (prevSignature === undefined || nextSignature === undefined) return false;
        if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) return false;
        if (nextSignature.forceReset) return false;
        return true;
    }
    function isReactClass(type) {
        return type.prototype && type.prototype.isReactComponent;
    }
    function canPreserveStateBetween(prevType, nextType) {
        if (isReactClass(prevType) || isReactClass(nextType)) return false;
        if (haveEqualSignatures(prevType, nextType)) return true;
        return false;
    }
    function resolveFamily(type) {
        // Only check updated types to keep lookups fast.
        return updatedFamiliesByType.get(type);
    } // If we didn't care about IE11, we could use new Map/Set(iterable).
    function cloneMap(map) {
        var clone = new Map();
        map.forEach(function(value, key) {
            clone.set(key, value);
        });
        return clone;
    }
    function cloneSet(set) {
        var clone = new Set();
        set.forEach(function(value) {
            clone.add(value);
        });
        return clone;
    }
    function performReactRefresh() {
        if (pendingUpdates.length === 0) return null;
        if (isPerformingRefresh) return null;
        isPerformingRefresh = true;
        try {
            var staleFamilies = new Set();
            var updatedFamilies = new Set();
            var updates = pendingUpdates;
            pendingUpdates = [];
            updates.forEach(function(_ref) {
                var family = _ref[0], nextType = _ref[1];
                // Now that we got a real edit, we can create associations
                // that will be read by the React reconciler.
                var prevType = family.current;
                updatedFamiliesByType.set(prevType, family);
                updatedFamiliesByType.set(nextType, family);
                family.current = nextType; // Determine whether this should be a re-render or a re-mount.
                if (canPreserveStateBetween(prevType, nextType)) updatedFamilies.add(family);
                else staleFamilies.add(family);
            }); // TODO: rename these fields to something more meaningful.
            var update = {
                updatedFamilies: updatedFamilies,
                // Families that will re-render preserving state
                staleFamilies: staleFamilies // Families that will be remounted
            };
            helpersByRendererID.forEach(function(helpers) {
                // Even if there are no roots, set the handler on first update.
                // This ensures that if *new* roots are mounted, they'll use the resolve handler.
                helpers.setRefreshHandler(resolveFamily);
            });
            var didError = false;
            var firstError = null; // We snapshot maps and sets that are mutated during commits.
            // If we don't do this, there is a risk they will be mutated while
            // we iterate over them. For example, trying to recover a failed root
            // may cause another root to be added to the failed list -- an infinite loop.
            var failedRootsSnapshot = cloneSet(failedRoots);
            var mountedRootsSnapshot = cloneSet(mountedRoots);
            var helpersByRootSnapshot = cloneMap(helpersByRoot);
            failedRootsSnapshot.forEach(function(root) {
                var helpers = helpersByRootSnapshot.get(root);
                if (helpers === undefined) throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                failedRoots.has(root);
                if (rootElements === null) return;
                if (!rootElements.has(root)) return;
                var element = rootElements.get(root);
                try {
                    helpers.scheduleRoot(root, element);
                } catch (err) {
                    if (!didError) {
                        didError = true;
                        firstError = err;
                    } // Keep trying other roots.
                }
            });
            mountedRootsSnapshot.forEach(function(root) {
                var helpers = helpersByRootSnapshot.get(root);
                if (helpers === undefined) throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
                mountedRoots.has(root);
                try {
                    helpers.scheduleRefresh(root, update);
                } catch (err) {
                    if (!didError) {
                        didError = true;
                        firstError = err;
                    } // Keep trying other roots.
                }
            });
            if (didError) throw firstError;
            return update;
        } finally{
            isPerformingRefresh = false;
        }
    }
    function register(type, id) {
        if (type === null) return;
        if (typeof type !== 'function' && typeof type !== 'object') return;
         // This can happen in an edge case, e.g. if we register
        // return value of a HOC but it returns a cached component.
        // Ignore anything but the first registration for each type.
        if (allFamiliesByType.has(type)) return;
         // Create family or remember to update it.
        // None of this bookkeeping affects reconciliation
        // until the first performReactRefresh() call above.
        var family = allFamiliesByID.get(id);
        if (family === undefined) {
            family = {
                current: type
            };
            allFamiliesByID.set(id, family);
        } else pendingUpdates.push([
            family,
            type
        ]);
        allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.
        if (typeof type === 'object' && type !== null) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                register(type.render, id + '$render');
                break;
            case REACT_MEMO_TYPE:
                register(type.type, id + '$type');
                break;
        }
    }
    function setSignature(type, key) {
        var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;
        allSignaturesByType.set(type, {
            forceReset: forceReset,
            ownKey: key,
            fullKey: null,
            getCustomHooks: getCustomHooks || function() {
                return [];
            }
        });
    } // This is lazily called during first render for a type.
    // It captures Hook list at that time so inline requires don't break comparisons.
    function collectCustomHooksForSignature(type) {
        var signature = allSignaturesByType.get(type);
        if (signature !== undefined) computeFullKey(signature);
    }
    function getFamilyByID(id) {
        return allFamiliesByID.get(id);
    }
    function getFamilyByType(type) {
        return allFamiliesByType.get(type);
    }
    function findAffectedHostInstances(families) {
        var affectedInstances = new Set();
        mountedRoots.forEach(function(root) {
            var helpers = helpersByRoot.get(root);
            if (helpers === undefined) throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
            var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);
            instancesForRoot.forEach(function(inst) {
                affectedInstances.add(inst);
            });
        });
        return affectedInstances;
    }
    function injectIntoGlobalHook(globalObject) {
        // For React Native, the global hook will be set up by require('react-devtools-core').
        // That code will run before us. So we need to monkeypatch functions on existing hook.
        // For React Web, the global hook will be set up by the extension.
        // This will also run before us.
        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook === undefined) {
            // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.
            // Note that in this case it's important that renderer code runs *after* this method call.
            // Otherwise, the renderer will think that there is no global hook, and won't do the injection.
            var nextID = 0;
            globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
                renderers: new Map(),
                supportsFiber: true,
                inject: function(injected) {
                    return nextID++;
                },
                onScheduleFiberRoot: function(id, root, children) {
                },
                onCommitFiberRoot: function(id, root, maybePriorityLevel, didError) {
                },
                onCommitFiberUnmount: function() {
                }
            };
        } // Here, we just want to get a reference to scheduleRefresh.
        var oldInject = hook.inject;
        hook.inject = function(injected) {
            var id = oldInject.apply(this, arguments);
            if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') // This version supports React Refresh.
            helpersByRendererID.set(id, injected);
            return id;
        }; // Do the same for any already injected roots.
        // This is useful if ReactDOM has already been initialized.
        // https://github.com/facebook/react/issues/17626
        hook.renderers.forEach(function(injected, id) {
            if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') // This version supports React Refresh.
            helpersByRendererID.set(id, injected);
        }); // We also want to track currently mounted roots.
        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;
        var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function() {
        };
        hook.onScheduleFiberRoot = function(id, root, children) {
            if (!isPerformingRefresh) {
                // If it was intentionally scheduled, don't attempt to restore.
                // This includes intentionally scheduled unmounts.
                failedRoots.delete(root);
                if (rootElements !== null) rootElements.set(root, children);
            }
            return oldOnScheduleFiberRoot.apply(this, arguments);
        };
        hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {
            var helpers = helpersByRendererID.get(id);
            if (helpers === undefined) return;
            helpersByRoot.set(root, helpers);
            var current = root.current;
            var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.
            // This logic is copy-pasted from similar logic in the DevTools backend.
            // If this breaks with some refactoring, you'll want to update DevTools too.
            if (alternate !== null) {
                var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;
                var isMounted = current.memoizedState != null && current.memoizedState.element != null;
                if (!wasMounted && isMounted) {
                    // Mount a new root.
                    mountedRoots.add(root);
                    failedRoots.delete(root);
                } else if (wasMounted && isMounted) ;
                else if (wasMounted && !isMounted) {
                    // Unmount an existing root.
                    mountedRoots.delete(root);
                    if (didError) // We'll remount it on future edits.
                    failedRoots.add(root);
                    else helpersByRoot.delete(root);
                } else if (!wasMounted && !isMounted) {
                    if (didError) // We'll remount it on future edits.
                    failedRoots.add(root);
                }
            } else // Mount a new root.
            mountedRoots.add(root);
            return oldOnCommitFiberRoot.apply(this, arguments);
        };
    }
    function hasUnrecoverableErrors() {
        // TODO: delete this after removing dependency in RN.
        return false;
    } // Exposed for testing.
    function _getMountedRootCount() {
        return mountedRoots.size;
    } // This is a wrapper over more primitive functions for setting signature.
    // Signatures let us decide whether the Hook order has changed on refresh.
    //
    // This function is intended to be used as a transform target, e.g.:
    // var _s = createSignatureFunctionForTransform()
    //
    // function Hello() {
    //   const [foo, setFoo] = useState(0);
    //   const value = useCustomHook();
    //   _s(); /* Second call triggers collecting the custom Hook list.
    //          * This doesn't happen during the module evaluation because we
    //          * don't want to change the module order with inline requires.
    //          * Next calls are noops. */
    //   return <h1>Hi</h1>;
    // }
    //
    // /* First call specifies the signature: */
    // _s(
    //   Hello,
    //   'useState{[foo, setFoo]}(0)',
    //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */
    // );
    function createSignatureFunctionForTransform() {
        // We'll fill in the signature in two steps.
        // First, we'll know the signature itself. This happens outside the component.
        // Then, we'll know the references to custom Hooks. This happens inside the component.
        // After that, the returned function will be a fast path no-op.
        var status = 'needsSignature';
        var savedType;
        var hasCustomHooks;
        return function(type, key, forceReset, getCustomHooks) {
            switch(status){
                case 'needsSignature':
                    if (type !== undefined) {
                        // If we received an argument, this is the initial registration call.
                        savedType = type;
                        hasCustomHooks = typeof getCustomHooks === 'function';
                        setSignature(type, key, forceReset, getCustomHooks); // The next call we expect is from inside a function, to fill in the custom Hooks.
                        status = 'needsCustomHooks';
                    }
                    break;
                case 'needsCustomHooks':
                    if (hasCustomHooks) collectCustomHooksForSignature(savedType);
                    status = 'resolved';
                    break;
            }
            return type;
        };
    }
    function isLikelyComponentType(type) {
        switch(typeof type){
            case 'function':
                // First, deal with classes.
                if (type.prototype != null) {
                    if (type.prototype.isReactComponent) // React class.
                    return true;
                    var ownNames = Object.getOwnPropertyNames(type.prototype);
                    if (ownNames.length > 1 || ownNames[0] !== 'constructor') // This looks like a class.
                    return false;
                     // eslint-disable-next-line no-proto
                    if (type.prototype.__proto__ !== Object.prototype) // It has a superclass.
                    return false;
                     // Pass through.
                // This looks like a regular function with empty prototype.
                } // For plain functions and arrows, use name as a heuristic.
                var name = type.name || type.displayName;
                return typeof name === 'string' && /^[A-Z]/.test(name);
            case 'object':
                if (type != null) switch(type.$$typeof){
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_MEMO_TYPE:
                        // Definitely React components.
                        return true;
                    default:
                        return false;
                }
                return false;
            default:
                return false;
        }
    }
    exports._getMountedRootCount = _getMountedRootCount;
    exports.collectCustomHooksForSignature = collectCustomHooksForSignature;
    exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;
    exports.findAffectedHostInstances = findAffectedHostInstances;
    exports.getFamilyByID = getFamilyByID;
    exports.getFamilyByType = getFamilyByType;
    exports.hasUnrecoverableErrors = hasUnrecoverableErrors;
    exports.injectIntoGlobalHook = injectIntoGlobalHook;
    exports.isLikelyComponentType = isLikelyComponentType;
    exports.performReactRefresh = performReactRefresh;
    exports.register = register;
    exports.setSignature = setSignature;
})();

},{}],"4Memt":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "f2c9685dad4863d1";
module.bundle.HMR_BUNDLE_ID = "4e1aa47f20e47298";
"use strict";
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F1() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                } // Render the fancy html overlay
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
            document.body.appendChild(overlay);
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>\n          ").concat(stack, "\n        </pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>' + hint + '</div>';
            }).join(''), "\n        </div>\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') {
        reloadCSS();
        return;
    }
    var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
    if (deps) {
        var fn = new Function('require', 'module', 'exports', asset.output);
        modules[asset.id] = [
            fn,
            deps
        ];
    } else if (bundle.parent) hmrApply(bundle.parent, asset);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) return true;
    return getParents(module.bundle.root, id).some(function(v) {
        return hmrAcceptCheck(v[0], v[1], null);
    });
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"fpYkd":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$26b1 = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$26b1.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _jsxRuntime = require("react/jsx-runtime");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _reactDom = require("react-dom");
var _reactDomDefault = parcelHelpers.interopDefault(_reactDom);
var _indexCss = require("./index.css");
var _w3Css = require("./w3.css");
var _app = require("./App");
var _appDefault = parcelHelpers.interopDefault(_app);
_reactDomDefault.default.render(/*#__PURE__*/ _jsxRuntime.jsx(_reactDefault.default.StrictMode, {
    __source: {
        fileName: "src/index.js",
        lineNumber: 8
    },
    __self: undefined,
    children: /*#__PURE__*/ _jsxRuntime.jsx(_appDefault.default, {
        __source: {
            fileName: "src/index.js",
            lineNumber: 9
        },
        __self: undefined
    })
}), document.getElementById('screen'));

  $parcel$ReactRefreshHelpers$26b1.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-runtime":"5F5p8","react":"cKM0D","react-dom":"ezGwg","./index.css":"4TaF2","./w3.css":"hBKJs","./App":"kMyqb","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"jOwmj"}],"5F5p8":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/react-jsx-runtime.development.js');

},{"./cjs/react-jsx-runtime.development.js":"N3fp8"}],"N3fp8":[function(require,module,exports) {
/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    var React = require('react');
    var _assign = require('object-assign');
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 60103;
    var REACT_PORTAL_TYPE = 60106;
    exports.Fragment = 60107;
    var REACT_STRICT_MODE_TYPE = 60108;
    var REACT_PROFILER_TYPE = 60114;
    var REACT_PROVIDER_TYPE = 60109;
    var REACT_CONTEXT_TYPE = 60110;
    var REACT_FORWARD_REF_TYPE = 60112;
    var REACT_SUSPENSE_TYPE = 60113;
    var REACT_SUSPENSE_LIST_TYPE = 60120;
    var REACT_MEMO_TYPE = 60115;
    var REACT_LAZY_TYPE = 60116;
    var REACT_BLOCK_TYPE = 60121;
    var REACT_SERVER_BLOCK_TYPE = 60122;
    var REACT_FUNDAMENTAL_TYPE = 60117;
    var REACT_SCOPE_TYPE = 60119;
    var REACT_OPAQUE_ID_TYPE = 60128;
    var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
    var REACT_OFFSCREEN_TYPE = 60130;
    var REACT_LEGACY_HIDDEN_TYPE = 60131;
    if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor('react.element');
        REACT_PORTAL_TYPE = symbolFor('react.portal');
        exports.Fragment = symbolFor('react.fragment');
        REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
        REACT_PROFILER_TYPE = symbolFor('react.profiler');
        REACT_PROVIDER_TYPE = symbolFor('react.provider');
        REACT_CONTEXT_TYPE = symbolFor('react.context');
        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
        REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
        REACT_MEMO_TYPE = symbolFor('react.memo');
        REACT_LAZY_TYPE = symbolFor('react.lazy');
        REACT_BLOCK_TYPE = symbolFor('react.block');
        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
        REACT_SCOPE_TYPE = symbolFor('react.scope');
        REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
        REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
    }
    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === 'function') return maybeIterator;
        return null;
    }
    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function error(format) {
        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
        printWarning('error', format, args);
    }
    function printWarning(level, format, args) {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== '') {
            format += '%s';
            args = args.concat([
                stack
            ]);
        }
        var argsWithFormat = args.map(function(item) {
            return '' + item;
        }); // Careful: RN currently depends on this prefix
        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging
        Function.prototype.apply.call(console[level], console, argsWithFormat);
    }
    // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.
    var enableScopeAPI = false; // Experimental Create Event Handle API.
    function isValidElementType(type) {
        if (typeof type === 'string' || typeof type === 'function') return true;
         // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).
        if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) return true;
        if (typeof type === 'object' && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) return true;
        }
        return false;
    }
    function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || '';
        return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
    }
    function getContextName(type) {
        return type.displayName || 'Context';
    }
    function getComponentName(type) {
        if (type == null) // Host root, text node or just invalid type.
        return null;
        if (typeof type.tag === 'number') error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
        if (typeof type === 'function') return type.displayName || type.name || null;
        if (typeof type === 'string') return type;
        switch(type){
            case exports.Fragment:
                return 'Fragment';
            case REACT_PORTAL_TYPE:
                return 'Portal';
            case REACT_PROFILER_TYPE:
                return 'Profiler';
            case REACT_STRICT_MODE_TYPE:
                return 'StrictMode';
            case REACT_SUSPENSE_TYPE:
                return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
                return 'SuspenseList';
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + '.Consumer';
            case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + '.Provider';
            case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, 'ForwardRef');
            case REACT_MEMO_TYPE:
                return getComponentName(type.type);
            case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    return getComponentName(init(payload));
                } catch (x) {
                    return null;
                }
        }
        return null;
    }
    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {
    }
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099
            var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        /* eslint-enable react-internal/no-production-logging */ }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ var props = {
                configurable: true,
                enumerable: true,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                log: _assign({
                }, props, {
                    value: prevLog
                }),
                info: _assign({
                }, props, {
                    value: prevInfo
                }),
                warn: _assign({
                }, props, {
                    value: prevWarn
                }),
                error: _assign({
                }, props, {
                    value: prevError
                }),
                group: _assign({
                }, props, {
                    value: prevGroup
                }),
                groupCollapsed: _assign({
                }, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: _assign({
                }, props, {
                    value: prevGroupEnd
                })
            });
        /* eslint-enable react-internal/no-production-logging */ }
        if (disabledDepth < 0) error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
        if (prefix === undefined) // Extract the VM specific prefix used by each line.
        try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
        }
         // We use the prefix to ensure our stacks line up with native stack frames.
        return '\n' + prefix + name;
    }
    var reentry = false;
    var componentFrameCache;
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
    componentFrameCache = new PossiblyWeakMap();
    function describeNativeComponentFrame(fn, construct) {
        // If something asked for a stack inside a fake render, it should get ignored.
        if (!fn || reentry) return '';
        var frame = componentFrameCache.get(fn);
        if (frame !== undefined) return frame;
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.
        ReactCurrentDispatcher.current = null;
        disableLogs();
        try {
            // This should throw.
            if (construct) {
                // Something should be setting the props in the constructor.
                var Fake = function() {
                    throw Error();
                }; // $FlowFixMe
                Object.defineProperty(Fake.prototype, 'props', {
                    set: function() {
                        // We use a throwing setter instead of frozen or non-writable props
                        // because that won't throw in a non-strict mode function.
                        throw Error();
                    }
                });
                if (typeof Reflect === 'object' && Reflect.construct) {
                    // We construct a different control for this case to include any extra
                    // frames added by the construct call.
                    try {
                        Reflect.construct(Fake, []);
                    } catch (x) {
                        control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                } else {
                    try {
                        Fake.call();
                    } catch (x) {
                        control = x;
                    }
                    fn.call(Fake.prototype);
                }
            } else {
                try {
                    throw Error();
                } catch (x) {
                    control = x;
                }
                fn();
            }
        } catch (sample) {
            // This is inlined manually because closure doesn't do it for us.
            if (sample && control && typeof sample.stack === 'string') {
                // This extracts the first frame from the sample that isn't also in the control.
                // Skipping one frame that we assume is the frame that calls the two.
                var sampleLines = sample.stack.split('\n');
                var controlLines = control.stack.split('\n');
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c])// We expect at least one stack frame to be shared.
                // Typically this will be the root most one. However, stack frames may be
                // cut off due to maximum stack limits. In this case, one maybe cut off
                // earlier than the other. We assume that the sample is longer or the same
                // and there for cut off earlier. So we should find the root most frame in
                // the sample somewhere in the control.
                c--;
                for(; s >= 1 && c >= 0; s--, c--)// Next we find the first one that isn't the same which should be the
                // frame that called our sample function and the control.
                if (sampleLines[s] !== controlLines[c]) {
                    // In V8, the first line is describing the message but other VMs don't.
                    // If we're about to return the first line, and the control is also on the same
                    // line, that's a pretty good indicator that our sample threw at same line as
                    // the control. I.e. before we entered the sample frame. So we ignore this result.
                    // This can happen if you passed a class to function component, or non-function.
                    if (s !== 1 || c !== 1) do {
                        s--;
                        c--; // We may still have similar intermediate frames from the construct call.
                        // The next one that isn't the same should be our match though.
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                            // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                            var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                            if (typeof fn === 'function') componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                    }while (s >= 1 && c >= 0)
                    break;
                }
            }
        } finally{
            reentry = false;
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
            Error.prepareStackTrace = previousPrepareStackTrace;
        } // Fallback to just using the name if we couldn't make it throw.
        var name = fn ? fn.displayName || fn.name : '';
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
        if (typeof fn === 'function') componentFrameCache.set(fn, syntheticFrame);
        return syntheticFrame;
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, false);
    }
    function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) return '';
        if (typeof type === 'function') return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type === 'string') return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame('Suspense');
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame('SuspenseList');
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
                // Memo may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    // Lazy may contain any component type so we recursively resolve it.
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
        }
        return '';
    }
    var loggedTypeFailures = {
    };
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(Object.prototype.hasOwnProperty);
        for(var typeSpecName in typeSpecs)if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.
            try {
                // This is intentionally an invariant that gets caught. It's the same
                // behavior as without this statement except with a better message.
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                    var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                    err.name = 'Invariant Violation';
                    throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
                error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || 'React class', location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                // Only monitor this failure once because there tends to be a lot of the
                // same error.
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error('Failed %s type: %s', location, error$1.message);
                setCurrentlyValidatingElement(null);
            }
        }
    }
    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
    };
    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;
    var didWarnAboutStringRefs;
    didWarnAboutStringRefs = {
    };
    function hasValidRef(config) {
        if (hasOwnProperty.call(config, 'ref')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
            if (getter && getter.isReactWarning) return false;
        }
        return config.ref !== undefined;
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, 'key')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
            if (getter && getter.isReactWarning) return false;
        }
        return config.key !== undefined;
    }
    function warnIfStringRefCannotBeAutoConverted(config, self) {
        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
            var componentName = getComponentName(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
                error("Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref", getComponentName(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
            }
        }
    }
    function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
            get: warnAboutAccessingKey,
            configurable: true
        });
    }
    function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
            get: warnAboutAccessingRef,
            configurable: true
        });
    }
    /**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */ var ReactElement = function(type, key, ref, self, source, owner, props) {
        var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type: type,
            key: key,
            ref: ref,
            props: props,
            // Record the component responsible for creating this element.
            _owner: owner
        };
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {
        }; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.
        Object.defineProperty(element._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
        }); // self and source are DEV only properties.
        Object.defineProperty(element, '_self', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, '_source', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
        });
        if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
        }
        return element;
    };
    /**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */ function jsxDEV(type, config, maybeKey, source, self) {
        var propName; // Reserved names are extracted
        var props = {
        };
        var key = null;
        var ref = null; // Currently, key can be spread in as a prop. This causes a potential
        // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
        // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
        // but as an intermediary step, we will use jsxDEV for everything except
        // <div {...props} key="Hi" />, because we aren't currently able to tell if
        // key is explicitly declared to be undefined or not.
        if (maybeKey !== undefined) key = '' + maybeKey;
        if (hasValidKey(config)) key = '' + config.key;
        if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self);
        } // Remaining properties are added to a new props object
        for(propName in config)if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) props[propName] = config[propName];
         // Resolve default props
        if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for(propName in defaultProps)if (props[propName] === undefined) props[propName] = defaultProps[propName];
        }
        if (key || ref) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) defineKeyPropWarningGetter(props, displayName);
            if (ref) defineRefPropWarningGetter(props, displayName);
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }
    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement$1(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
    var propTypesMisspellWarningShown;
    propTypesMisspellWarningShown = false;
    /**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */ function isValidElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner$1.current) {
            var name = getComponentName(ReactCurrentOwner$1.current.type);
            if (name) return '\n\nCheck the render method of `' + name + '`.';
        }
        return '';
    }
    function getSourceInfoErrorAddendum(source) {
        if (source !== undefined) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, '');
            var lineNumber = source.lineNumber;
            return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
        }
        return '';
    }
    /**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */ var ownerHasKeyUseWarning = {
    };
    function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
            var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
            if (parentName) info = "\n\nCheck the top-level render call using <" + parentName + ">.";
        }
        return info;
    }
    /**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */ function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) return;
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) return;
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
        // property, it may be the creator of the child that's responsible for
        // assigning it a key.
        var childOwner = '';
        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) // Give the component that originally created this child.
        childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
        setCurrentlyValidatingElement$1(element);
        error("Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.", currentComponentErrorInfo, childOwner);
        setCurrentlyValidatingElement$1(null);
    }
    /**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */ function validateChildKeys(node, parentType) {
        if (typeof node !== 'object') return;
        if (Array.isArray(node)) for(var i = 0; i < node.length; i++){
            var child = node[i];
            if (isValidElement(child)) validateExplicitKey(child, parentType);
        }
        else if (isValidElement(node)) // This element was passed in a valid location.
        {
            if (node._store) node._store.validated = true;
        } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === 'function') // Entry iterators used to provide implicit keys,
            // but now we print a separate warning for them later.
            {
                if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while(!(step = iterator.next()).done)if (isValidElement(step.value)) validateExplicitKey(step.value, parentType);
                }
            }
        }
    }
    /**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */ function validatePropTypes(element) {
        var type = element.type;
        if (type === null || type === undefined || typeof type === 'string') return;
        var propTypes;
        if (typeof type === 'function') propTypes = type.propTypes;
        else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Inner props are checked in the reconciler.
        type.$$typeof === REACT_MEMO_TYPE)) propTypes = type.propTypes;
        else return;
        if (propTypes) {
            // Intentionally inside to avoid triggering lazy initializers:
            var name = getComponentName(type);
            checkPropTypes(propTypes, element.props, 'prop', name, element);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:
            var _name = getComponentName(type);
            error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
        }
        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
    /**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */ function validateFragmentProps(fragment) {
        var keys = Object.keys(fragment.props);
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            if (key !== 'children' && key !== 'key') {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
            }
        }
        if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error('Invalid attribute `ref` supplied to `React.Fragment`.');
            setCurrentlyValidatingElement$1(null);
        }
    }
    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
        // succeed and there will likely be errors in render.
        if (!validType) {
            var info = '';
            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            var sourceInfo = getSourceInfoErrorAddendum(source);
            if (sourceInfo) info += sourceInfo;
            else info += getDeclarationErrorAddendum();
            var typeString;
            if (type === null) typeString = 'null';
            else if (Array.isArray(type)) typeString = 'array';
            else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
                info = ' Did you accidentally export a JSX literal instead of a component?';
            } else typeString = typeof type;
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
        }
        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
        // TODO: Drop this when these are no longer allowed as the type argument.
        if (element == null) return element;
         // Skip key warning if the type isn't valid since our key validation logic
        // doesn't expect a non-string/function type and can throw confusing errors.
        // We don't want exception behavior to differ between dev and prod.
        // (Rendering will throw with a helpful message and as soon as the type is
        // fixed, the key warnings will appear.)
        if (validType) {
            var children = props.children;
            if (children !== undefined) {
                if (isStaticChildren) {
                    if (Array.isArray(children)) {
                        for(var i = 0; i < children.length; i++)validateChildKeys(children[i], type);
                        if (Object.freeze) Object.freeze(children);
                    } else error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                } else validateChildKeys(children, type);
            }
        }
        if (type === exports.Fragment) validateFragmentProps(element);
        else validatePropTypes(element);
        return element;
    } // These two functions exist to still get child warnings in dev
    // even with the prod transform. This means that jsxDEV is purely
    // opt-in behavior for better messages but that we won't stop
    // giving you warnings if you use production apis.
    function jsxWithValidationStatic(type, props, key) {
        return jsxWithValidation(type, props, key, true);
    }
    function jsxWithValidationDynamic(type, props, key) {
        return jsxWithValidation(type, props, key, false);
    }
    var jsx = jsxWithValidationDynamic; // we may want to special case jsxs internally to take advantage of static children.
    // for now we can ship identical prod functions
    var jsxs = jsxWithValidationStatic;
    exports.jsx = jsx;
    exports.jsxs = jsxs;
})();

},{"react":"cKM0D","object-assign":"dkHwz"}],"cKM0D":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/react.development.js');

},{"./cjs/react.development.js":"2a8DO"}],"2a8DO":[function(require,module,exports) {
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    var _assign = require('object-assign');
    // TODO: this is special because it gets imported during build.
    var ReactVersion = '17.0.2';
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 60103;
    var REACT_PORTAL_TYPE = 60106;
    exports.Fragment = 60107;
    exports.StrictMode = 60108;
    exports.Profiler = 60114;
    var REACT_PROVIDER_TYPE = 60109;
    var REACT_CONTEXT_TYPE = 60110;
    var REACT_FORWARD_REF_TYPE = 60112;
    exports.Suspense = 60113;
    var REACT_SUSPENSE_LIST_TYPE = 60120;
    var REACT_MEMO_TYPE = 60115;
    var REACT_LAZY_TYPE = 60116;
    var REACT_BLOCK_TYPE = 60121;
    var REACT_SERVER_BLOCK_TYPE = 60122;
    var REACT_FUNDAMENTAL_TYPE = 60117;
    var REACT_SCOPE_TYPE = 60119;
    var REACT_OPAQUE_ID_TYPE = 60128;
    var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
    var REACT_OFFSCREEN_TYPE = 60130;
    var REACT_LEGACY_HIDDEN_TYPE = 60131;
    if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor('react.element');
        REACT_PORTAL_TYPE = symbolFor('react.portal');
        exports.Fragment = symbolFor('react.fragment');
        exports.StrictMode = symbolFor('react.strict_mode');
        exports.Profiler = symbolFor('react.profiler');
        REACT_PROVIDER_TYPE = symbolFor('react.provider');
        REACT_CONTEXT_TYPE = symbolFor('react.context');
        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
        exports.Suspense = symbolFor('react.suspense');
        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
        REACT_MEMO_TYPE = symbolFor('react.memo');
        REACT_LAZY_TYPE = symbolFor('react.lazy');
        REACT_BLOCK_TYPE = symbolFor('react.block');
        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
        REACT_SCOPE_TYPE = symbolFor('react.scope');
        REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
        REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
    }
    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === 'function') return maybeIterator;
        return null;
    }
    /**
 * Keeps track of the current dispatcher.
 */ var ReactCurrentDispatcher = {
        /**
   * @internal
   * @type {ReactComponent}
   */ current: null
    };
    /**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */ var ReactCurrentBatchConfig = {
        transition: 0
    };
    /**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */ var ReactCurrentOwner = {
        /**
   * @internal
   * @type {ReactComponent}
   */ current: null
    };
    var ReactDebugCurrentFrame = {
    };
    var currentExtraStackFrame = null;
    function setExtraStackFrame(stack) {
        currentExtraStackFrame = stack;
    }
    ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
        currentExtraStackFrame = stack;
    }; // Stack implementation injected by the current renderer.
    ReactDebugCurrentFrame.getCurrentStack = null;
    ReactDebugCurrentFrame.getStackAddendum = function() {
        var stack = ''; // Add an extra top frame while an element is being validated
        if (currentExtraStackFrame) stack += currentExtraStackFrame;
         // Delegate to the injected renderer-specific implementation
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        if (impl) stack += impl() || '';
        return stack;
    };
    /**
 * Used by act() to track whether you're inside an act() scope.
 */ var IsSomeRendererActing = {
        current: false
    };
    var ReactSharedInternals = {
        ReactCurrentDispatcher: ReactCurrentDispatcher,
        ReactCurrentBatchConfig: ReactCurrentBatchConfig,
        ReactCurrentOwner: ReactCurrentOwner,
        IsSomeRendererActing: IsSomeRendererActing,
        // Used by renderers to avoid bundling object-assign twice in UMD bundles:
        assign: _assign
    };
    ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
    // by calls to these methods by a Babel plugin.
    //
    // In PROD (or in packages without access to React internals),
    // they are left as they are instead.
    function warn(format) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
        printWarning('warn', format, args);
    }
    function error(format) {
        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
        printWarning('error', format, args);
    }
    function printWarning(level, format, args) {
        var ReactDebugCurrentFrame1 = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame1.getStackAddendum();
        if (stack !== '') {
            format += '%s';
            args = args.concat([
                stack
            ]);
        }
        var argsWithFormat = args.map(function(item) {
            return '' + item;
        }); // Careful: RN currently depends on this prefix
        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging
        Function.prototype.apply.call(console[level], console, argsWithFormat);
    }
    var didWarnStateUpdateForUnmountedComponent = {
    };
    function warnNoop(publicInstance, callerName) {
        var _constructor = publicInstance.constructor;
        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
        var warningKey = componentName + "." + callerName;
        if (didWarnStateUpdateForUnmountedComponent[warningKey]) return;
        error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
    }
    /**
 * This is the abstract API for an update queue.
 */ var ReactNoopUpdateQueue = {
        /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */ isMounted: function(publicInstance) {
            return false;
        },
        /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */ enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, 'forceUpdate');
        },
        /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */ enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, 'replaceState');
        },
        /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */ enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, 'setState');
        }
    };
    var emptyObject = {
    };
    Object.freeze(emptyObject);
    /**
 * Base class helpers for the updating state of a component.
 */ function Component(props, context, updater) {
        this.props = props;
        this.context = context; // If a component has string refs, we will assign a different object later.
        this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
        // renderer.
        this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {
    };
    /**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */ Component.prototype.setState = function(partialState, callback) {
        if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };
    /**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */ Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };
    var deprecatedAPIs = {
        isMounted: [
            'isMounted',
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
            'replaceState',
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
    };
    var defineDeprecationWarning = function(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
            get: function() {
                warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
                return undefined;
            }
        });
    };
    for(var fnName in deprecatedAPIs)if (deprecatedAPIs.hasOwnProperty(fnName)) defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component.prototype;
    /**
 * Convenience component with default shallow equality check for sCU.
 */ function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context; // If a component has string refs, we will assign a different object later.
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.
    _assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    // an immutable object with a single mutable value
    function createRef() {
        var refObject = {
            current: null
        };
        Object.seal(refObject);
        return refObject;
    }
    function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || '';
        return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
    }
    function getContextName(type) {
        return type.displayName || 'Context';
    }
    function getComponentName(type) {
        if (type == null) // Host root, text node or just invalid type.
        return null;
        if (typeof type.tag === 'number') error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
        if (typeof type === 'function') return type.displayName || type.name || null;
        if (typeof type === 'string') return type;
        switch(type){
            case exports.Fragment:
                return 'Fragment';
            case REACT_PORTAL_TYPE:
                return 'Portal';
            case exports.Profiler:
                return 'Profiler';
            case exports.StrictMode:
                return 'StrictMode';
            case exports.Suspense:
                return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
                return 'SuspenseList';
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + '.Consumer';
            case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + '.Provider';
            case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, 'ForwardRef');
            case REACT_MEMO_TYPE:
                return getComponentName(type.type);
            case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    return getComponentName(init(payload));
                } catch (x) {
                    return null;
                }
        }
        return null;
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
    };
    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
    didWarnAboutStringRefs = {
    };
    function hasValidRef(config) {
        if (hasOwnProperty.call(config, 'ref')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
            if (getter && getter.isReactWarning) return false;
        }
        return config.ref !== undefined;
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, 'key')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
            if (getter && getter.isReactWarning) return false;
        }
        return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
            get: warnAboutAccessingKey,
            configurable: true
        });
    }
    function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
            get: warnAboutAccessingRef,
            configurable: true
        });
    }
    function warnIfStringRefCannotBeAutoConverted(config) {
        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
            var componentName = getComponentName(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
                error("Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref", componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
            }
        }
    }
    /**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */ var ReactElement = function(type, key, ref, self, source, owner, props) {
        var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type: type,
            key: key,
            ref: ref,
            props: props,
            // Record the component responsible for creating this element.
            _owner: owner
        };
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {
        }; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.
        Object.defineProperty(element._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
        }); // self and source are DEV only properties.
        Object.defineProperty(element, '_self', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, '_source', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
        });
        if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
        }
        return element;
    };
    /**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */ function createElement(type, config, children) {
        var propName; // Reserved names are extracted
        var props = {
        };
        var key = null;
        var ref = null;
        var self = null;
        var source = null;
        if (config != null) {
            if (hasValidRef(config)) {
                ref = config.ref;
                warnIfStringRefCannotBeAutoConverted(config);
            }
            if (hasValidKey(config)) key = '' + config.key;
            self = config.__self === undefined ? null : config.__self;
            source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object
            for(propName in config)if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) props[propName] = config[propName];
        } // Children can be more than one argument, and those are transferred onto
        // the newly allocated props object.
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) props.children = children;
        else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for(var i = 0; i < childrenLength; i++)childArray[i] = arguments[i + 2];
            if (Object.freeze) Object.freeze(childArray);
            props.children = childArray;
        } // Resolve default props
        if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for(propName in defaultProps)if (props[propName] === undefined) props[propName] = defaultProps[propName];
        }
        if (key || ref) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) defineKeyPropWarningGetter(props, displayName);
            if (ref) defineRefPropWarningGetter(props, displayName);
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }
    function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
    }
    /**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */ function cloneElement(element, config, children) {
        if (!!(element === null || element === undefined)) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        var propName; // Original props are copied
        var props = _assign({
        }, element.props); // Reserved names are extracted
        var key = element.key;
        var ref = element.ref; // Self is preserved since the owner is preserved.
        var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
        // transpiler, and the original source is probably a better indicator of the
        // true owner.
        var source = element._source; // Owner will be preserved, unless ref is overridden
        var owner = element._owner;
        if (config != null) {
            if (hasValidRef(config)) {
                // Silently steal the ref from the parent.
                ref = config.ref;
                owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) key = '' + config.key;
             // Remaining properties override existing props
            var defaultProps;
            if (element.type && element.type.defaultProps) defaultProps = element.type.defaultProps;
            for(propName in config)if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === undefined && defaultProps !== undefined) // Resolve default props
                props[propName] = defaultProps[propName];
                else props[propName] = config[propName];
            }
        } // Children can be more than one argument, and those are transferred onto
        // the newly allocated props object.
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) props.children = children;
        else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for(var i = 0; i < childrenLength; i++)childArray[i] = arguments[i + 2];
            props.children = childArray;
        }
        return ReactElement(element.type, key, ref, self, source, owner, props);
    }
    /**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */ function isValidElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    /**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */ function escape(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
            '=': '=0',
            ':': '=2'
        };
        var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
        });
        return '$' + escapedString;
    }
    /**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */ var didWarnAboutMaps = false;
    var userProvidedKeyEscapeRegex = /\/+/g;
    function escapeUserProvidedKey(text) {
        return text.replace(userProvidedKeyEscapeRegex, '$&/');
    }
    /**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */ function getElementKey(element, index) {
        // Do some typechecking here since we call this blindly. We want to ensure
        // that we don't block potential future ES APIs.
        if (typeof element === 'object' && element !== null && element.key != null) // Explicit key
        return escape('' + element.key);
         // Implicit key determined by the index in the set
        return index.toString(36);
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if (type === 'undefined' || type === 'boolean') // All of the above are perceived as null.
        children = null;
        var invokeCallback = false;
        if (children === null) invokeCallback = true;
        else switch(type){
            case 'string':
            case 'number':
                invokeCallback = true;
                break;
            case 'object':
                switch(children.$$typeof){
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                        invokeCallback = true;
                }
        }
        if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
            // so that it's consistent if the number of children grows:
            var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (Array.isArray(mappedChild)) {
                var escapedChildKey = '';
                if (childKey != null) escapedChildKey = escapeUserProvidedKey(childKey) + '/';
                mapIntoArray(mappedChild, array, escapedChildKey, '', function(c) {
                    return c;
                });
            } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) mappedChild = cloneAndReplaceKey(mappedChild, // traverseAllChildren used to do for objects as children
                escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
                array.push(mappedChild);
            }
            return 1;
        }
        var child;
        var nextName;
        var subtreeCount = 0; // Count of children found in the current subtree.
        var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (Array.isArray(children)) for(var i = 0; i < children.length; i++){
            child = children[i];
            nextName = nextNamePrefix + getElementKey(child, i);
            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
        }
        else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === 'function') {
                var iterableChildren = children;
                // Warn about using Maps as children
                if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    didWarnAboutMaps = true;
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while(!(step = iterator.next()).done){
                    child = step.value;
                    nextName = nextNamePrefix + getElementKey(child, ii++);
                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
            } else if (type === 'object') {
                var childrenString = '' + children;
                throw Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
        }
        return subtreeCount;
    }
    /**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */ function mapChildren(children, func, context) {
        if (children == null) return children;
        var result = [];
        var count = 0;
        mapIntoArray(children, result, '', '', function(child) {
            return func.call(context, child, count++);
        });
        return result;
    }
    /**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */ function countChildren(children) {
        var n = 0;
        mapChildren(children, function() {
            n++; // Don't return anything
        });
        return n;
    }
    /**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */ function forEachChildren(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
            forEachFunc.apply(this, arguments); // Don't return anything.
        }, forEachContext);
    }
    /**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */ function toArray(children) {
        return mapChildren(children, function(child) {
            return child;
        }) || [];
    }
    /**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */ function onlyChild(children) {
        if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
        return children;
    }
    function createContext(defaultValue, calculateChangedBits) {
        if (calculateChangedBits === undefined) calculateChangedBits = null;
        else if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
        var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null
        };
        context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = false;
        var hasWarnedAboutUsingConsumerProvider = false;
        var hasWarnedAboutDisplayNameOnConsumer = false;
        // A separate object, but proxies back to the original context object for
        // backwards compatibility. It has a different $$typeof, so we can properly
        // warn for the incorrect usage of Context as a Consumer.
        var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context,
            _calculateChangedBits: context._calculateChangedBits
        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here
        Object.defineProperties(Consumer, {
            Provider: {
                get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                        hasWarnedAboutUsingConsumerProvider = true;
                        error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                },
                set: function(_Provider) {
                    context.Provider = _Provider;
                }
            },
            _currentValue: {
                get: function() {
                    return context._currentValue;
                },
                set: function(_currentValue) {
                    context._currentValue = _currentValue;
                }
            },
            _currentValue2: {
                get: function() {
                    return context._currentValue2;
                },
                set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                }
            },
            _threadCount: {
                get: function() {
                    return context._threadCount;
                },
                set: function(_threadCount) {
                    context._threadCount = _threadCount;
                }
            },
            Consumer: {
                get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                        hasWarnedAboutUsingNestedContextConsumers = true;
                        error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                }
            },
            displayName: {
                get: function() {
                    return context.displayName;
                },
                set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                        warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                        hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                }
            }
        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty
        context.Consumer = Consumer;
        context._currentRenderer = null;
        context._currentRenderer2 = null;
        return context;
    }
    var Uninitialized = -1;
    var Pending = 0;
    var Resolved = 1;
    var Rejected = 2;
    function lazyInitializer(payload) {
        if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor(); // Transition to the next state.
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
            thenable.then(function(moduleObject) {
                if (payload._status === Pending) {
                    var defaultExport = moduleObject.default;
                    if (defaultExport === undefined) error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                    var resolved = payload;
                    resolved._status = Resolved;
                    resolved._result = defaultExport;
                }
            }, function(error1) {
                if (payload._status === Pending) {
                    // Transition to the next state.
                    var rejected = payload;
                    rejected._status = Rejected;
                    rejected._result = error1;
                }
            });
        }
        if (payload._status === Resolved) return payload._result;
        else throw payload._result;
    }
    function lazy(ctor) {
        var payload = {
            // We use these fields to store the result.
            _status: -1,
            _result: ctor
        };
        var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
        };
        // In production, this would just set it on the object.
        var defaultProps;
        var propTypes; // $FlowFixMe
        Object.defineProperties(lazyType, {
            defaultProps: {
                configurable: true,
                get: function() {
                    return defaultProps;
                },
                set: function(newDefaultProps) {
                    error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps; // Match production behavior more closely:
                    // $FlowFixMe
                    Object.defineProperty(lazyType, 'defaultProps', {
                        enumerable: true
                    });
                }
            },
            propTypes: {
                configurable: true,
                get: function() {
                    return propTypes;
                },
                set: function(newPropTypes) {
                    error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes; // Match production behavior more closely:
                    // $FlowFixMe
                    Object.defineProperty(lazyType, 'propTypes', {
                        enumerable: true
                    });
                }
            }
        });
        return lazyType;
    }
    function forwardRef(render) {
        if (render != null && render.$$typeof === REACT_MEMO_TYPE) error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
        else if (typeof render !== 'function') error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
        else if (render.length !== 0 && render.length !== 2) error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
        if (render != null) {
            if (render.defaultProps != null || render.propTypes != null) error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        }
        var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: render
        };
        var ownName;
        Object.defineProperty(elementType, 'displayName', {
            enumerable: false,
            configurable: true,
            get: function() {
                return ownName;
            },
            set: function(name) {
                ownName = name;
                if (render.displayName == null) render.displayName = name;
            }
        });
        return elementType;
    }
    // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.
    var enableScopeAPI = false; // Experimental Create Event Handle API.
    function isValidElementType(type) {
        if (typeof type === 'string' || typeof type === 'function') return true;
         // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).
        if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) return true;
        if (typeof type === 'object' && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) return true;
        }
        return false;
    }
    function memo(type, compare) {
        if (!isValidElementType(type)) error("memo: The first argument must be a component. Instead received: %s", type === null ? 'null' : typeof type);
        var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type: type,
            compare: compare === undefined ? null : compare
        };
        var ownName;
        Object.defineProperty(elementType, 'displayName', {
            enumerable: false,
            configurable: true,
            get: function() {
                return ownName;
            },
            set: function(name) {
                ownName = name;
                if (type.displayName == null) type.displayName = name;
            }
        });
        return elementType;
    }
    function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        if (!(dispatcher !== null)) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        return dispatcher;
    }
    function useContext(Context, unstable_observedBits) {
        var dispatcher = resolveDispatcher();
        if (unstable_observedBits !== undefined) error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : '');
         // TODO: add a more generic warning for invalid values.
        if (Context._context !== undefined) {
            var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
            // and nobody should be using this in existing code.
            if (realContext.Consumer === Context) error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
            else if (realContext.Provider === Context) error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return dispatcher.useContext(Context, unstable_observedBits);
    }
    function useState(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
    }
    function useReducer(reducer, initialArg, init) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init);
    }
    function useRef(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
    }
    function useEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, deps);
    }
    function useLayoutEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, deps);
    }
    function useCallback(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
    }
    function useMemo(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, deps);
    }
    function useImperativeHandle(ref, create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create, deps);
    }
    function useDebugValue(value, formatterFn) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDebugValue(value, formatterFn);
    }
    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {
    }
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099
            var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        /* eslint-enable react-internal/no-production-logging */ }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ var props = {
                configurable: true,
                enumerable: true,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                log: _assign({
                }, props, {
                    value: prevLog
                }),
                info: _assign({
                }, props, {
                    value: prevInfo
                }),
                warn: _assign({
                }, props, {
                    value: prevWarn
                }),
                error: _assign({
                }, props, {
                    value: prevError
                }),
                group: _assign({
                }, props, {
                    value: prevGroup
                }),
                groupCollapsed: _assign({
                }, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: _assign({
                }, props, {
                    value: prevGroupEnd
                })
            });
        /* eslint-enable react-internal/no-production-logging */ }
        if (disabledDepth < 0) error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
        if (prefix === undefined) // Extract the VM specific prefix used by each line.
        try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
        }
         // We use the prefix to ensure our stacks line up with native stack frames.
        return '\n' + prefix + name;
    }
    var reentry = false;
    var componentFrameCache;
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
    componentFrameCache = new PossiblyWeakMap();
    function describeNativeComponentFrame(fn, construct) {
        // If something asked for a stack inside a fake render, it should get ignored.
        if (!fn || reentry) return '';
        var frame = componentFrameCache.get(fn);
        if (frame !== undefined) return frame;
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.
        ReactCurrentDispatcher$1.current = null;
        disableLogs();
        try {
            // This should throw.
            if (construct) {
                // Something should be setting the props in the constructor.
                var Fake = function() {
                    throw Error();
                }; // $FlowFixMe
                Object.defineProperty(Fake.prototype, 'props', {
                    set: function() {
                        // We use a throwing setter instead of frozen or non-writable props
                        // because that won't throw in a non-strict mode function.
                        throw Error();
                    }
                });
                if (typeof Reflect === 'object' && Reflect.construct) {
                    // We construct a different control for this case to include any extra
                    // frames added by the construct call.
                    try {
                        Reflect.construct(Fake, []);
                    } catch (x) {
                        control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                } else {
                    try {
                        Fake.call();
                    } catch (x) {
                        control = x;
                    }
                    fn.call(Fake.prototype);
                }
            } else {
                try {
                    throw Error();
                } catch (x) {
                    control = x;
                }
                fn();
            }
        } catch (sample) {
            // This is inlined manually because closure doesn't do it for us.
            if (sample && control && typeof sample.stack === 'string') {
                // This extracts the first frame from the sample that isn't also in the control.
                // Skipping one frame that we assume is the frame that calls the two.
                var sampleLines = sample.stack.split('\n');
                var controlLines = control.stack.split('\n');
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c])// We expect at least one stack frame to be shared.
                // Typically this will be the root most one. However, stack frames may be
                // cut off due to maximum stack limits. In this case, one maybe cut off
                // earlier than the other. We assume that the sample is longer or the same
                // and there for cut off earlier. So we should find the root most frame in
                // the sample somewhere in the control.
                c--;
                for(; s >= 1 && c >= 0; s--, c--)// Next we find the first one that isn't the same which should be the
                // frame that called our sample function and the control.
                if (sampleLines[s] !== controlLines[c]) {
                    // In V8, the first line is describing the message but other VMs don't.
                    // If we're about to return the first line, and the control is also on the same
                    // line, that's a pretty good indicator that our sample threw at same line as
                    // the control. I.e. before we entered the sample frame. So we ignore this result.
                    // This can happen if you passed a class to function component, or non-function.
                    if (s !== 1 || c !== 1) do {
                        s--;
                        c--; // We may still have similar intermediate frames from the construct call.
                        // The next one that isn't the same should be our match though.
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                            // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                            var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                            if (typeof fn === 'function') componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                    }while (s >= 1 && c >= 0)
                    break;
                }
            }
        } finally{
            reentry = false;
            ReactCurrentDispatcher$1.current = previousDispatcher;
            reenableLogs();
            Error.prepareStackTrace = previousPrepareStackTrace;
        } // Fallback to just using the name if we couldn't make it throw.
        var name = fn ? fn.displayName || fn.name : '';
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
        if (typeof fn === 'function') componentFrameCache.set(fn, syntheticFrame);
        return syntheticFrame;
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, false);
    }
    function shouldConstruct(Component1) {
        var prototype = Component1.prototype;
        return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) return '';
        if (typeof type === 'function') return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type === 'string') return describeBuiltInComponentFrame(type);
        switch(type){
            case exports.Suspense:
                return describeBuiltInComponentFrame('Suspense');
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame('SuspenseList');
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
                // Memo may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    // Lazy may contain any component type so we recursively resolve it.
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
        }
        return '';
    }
    var loggedTypeFailures = {
    };
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(Object.prototype.hasOwnProperty);
        for(var typeSpecName in typeSpecs)if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.
            try {
                // This is intentionally an invariant that gets caught. It's the same
                // behavior as without this statement except with a better message.
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                    var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                    err.name = 'Invariant Violation';
                    throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
                error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || 'React class', location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                // Only monitor this failure once because there tends to be a lot of the
                // same error.
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error('Failed %s type: %s', location, error$1.message);
                setCurrentlyValidatingElement(null);
            }
        }
    }
    function setCurrentlyValidatingElement$1(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            setExtraStackFrame(stack);
        } else setExtraStackFrame(null);
    }
    var propTypesMisspellWarningShown;
    propTypesMisspellWarningShown = false;
    function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) return '\n\nCheck the render method of `' + name + '`.';
        }
        return '';
    }
    function getSourceInfoErrorAddendum(source) {
        if (source !== undefined) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, '');
            var lineNumber = source.lineNumber;
            return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
        }
        return '';
    }
    function getSourceInfoErrorAddendumForProps(elementProps) {
        if (elementProps !== null && elementProps !== undefined) return getSourceInfoErrorAddendum(elementProps.__source);
        return '';
    }
    /**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */ var ownerHasKeyUseWarning = {
    };
    function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
            var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
            if (parentName) info = "\n\nCheck the top-level render call using <" + parentName + ">.";
        }
        return info;
    }
    /**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */ function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) return;
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) return;
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
        // property, it may be the creator of the child that's responsible for
        // assigning it a key.
        var childOwner = '';
        if (element && element._owner && element._owner !== ReactCurrentOwner.current) // Give the component that originally created this child.
        childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
        setCurrentlyValidatingElement$1(element);
        error("Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.", currentComponentErrorInfo, childOwner);
        setCurrentlyValidatingElement$1(null);
    }
    /**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */ function validateChildKeys(node, parentType) {
        if (typeof node !== 'object') return;
        if (Array.isArray(node)) for(var i = 0; i < node.length; i++){
            var child = node[i];
            if (isValidElement(child)) validateExplicitKey(child, parentType);
        }
        else if (isValidElement(node)) // This element was passed in a valid location.
        {
            if (node._store) node._store.validated = true;
        } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === 'function') // Entry iterators used to provide implicit keys,
            // but now we print a separate warning for them later.
            {
                if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while(!(step = iterator.next()).done)if (isValidElement(step.value)) validateExplicitKey(step.value, parentType);
                }
            }
        }
    }
    /**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */ function validatePropTypes(element) {
        var type = element.type;
        if (type === null || type === undefined || typeof type === 'string') return;
        var propTypes;
        if (typeof type === 'function') propTypes = type.propTypes;
        else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Inner props are checked in the reconciler.
        type.$$typeof === REACT_MEMO_TYPE)) propTypes = type.propTypes;
        else return;
        if (propTypes) {
            // Intentionally inside to avoid triggering lazy initializers:
            var name = getComponentName(type);
            checkPropTypes(propTypes, element.props, 'prop', name, element);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:
            var _name = getComponentName(type);
            error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
        }
        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
    }
    /**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */ function validateFragmentProps(fragment) {
        var keys = Object.keys(fragment.props);
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            if (key !== 'children' && key !== 'key') {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
            }
        }
        if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error('Invalid attribute `ref` supplied to `React.Fragment`.');
            setCurrentlyValidatingElement$1(null);
        }
    }
    function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
        // succeed and there will likely be errors in render.
        if (!validType) {
            var info = '';
            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) info += sourceInfo;
            else info += getDeclarationErrorAddendum();
            var typeString;
            if (type === null) typeString = 'null';
            else if (Array.isArray(type)) typeString = 'array';
            else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
                info = ' Did you accidentally export a JSX literal instead of a component?';
            } else typeString = typeof type;
            error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
        }
        var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
        // TODO: Drop this when these are no longer allowed as the type argument.
        if (element == null) return element;
         // Skip key warning if the type isn't valid since our key validation logic
        // doesn't expect a non-string/function type and can throw confusing errors.
        // We don't want exception behavior to differ between dev and prod.
        // (Rendering will throw with a helpful message and as soon as the type is
        // fixed, the key warnings will appear.)
        if (validType) for(var i = 2; i < arguments.length; i++)validateChildKeys(arguments[i], type);
        if (type === exports.Fragment) validateFragmentProps(element);
        else validatePropTypes(element);
        return element;
    }
    var didWarnAboutDeprecatedCreateFactory = false;
    function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        validatedFactory.type = type;
        if (!didWarnAboutDeprecatedCreateFactory) {
            didWarnAboutDeprecatedCreateFactory = true;
            warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
        } // Legacy hook: remove it
        Object.defineProperty(validatedFactory, 'type', {
            enumerable: false,
            get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, 'type', {
                    value: type
                });
                return type;
            }
        });
        return validatedFactory;
    }
    function cloneElementWithValidation(element, props, children) {
        var newElement = cloneElement.apply(this, arguments);
        for(var i = 2; i < arguments.length; i++)validateChildKeys(arguments[i], newElement.type);
        validatePropTypes(newElement);
        return newElement;
    }
    try {
        var frozenObject = Object.freeze({
        });
        /* eslint-disable no-new */ new Map([
            [
                frozenObject,
                null
            ]
        ]);
        new Set([
            frozenObject
        ]);
    /* eslint-enable no-new */ } catch (e) {
    }
    var createElement$1 = createElementWithValidation;
    var cloneElement$1 = cloneElementWithValidation;
    var createFactory = createFactoryWithValidation;
    var Children = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
    };
    exports.Children = Children;
    exports.Component = Component;
    exports.PureComponent = PureComponent;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
    exports.cloneElement = cloneElement$1;
    exports.createContext = createContext;
    exports.createElement = createElement$1;
    exports.createFactory = createFactory;
    exports.createRef = createRef;
    exports.forwardRef = forwardRef;
    exports.isValidElement = isValidElement;
    exports.lazy = lazy;
    exports.memo = memo;
    exports.useCallback = useCallback;
    exports.useContext = useContext;
    exports.useDebugValue = useDebugValue;
    exports.useEffect = useEffect;
    exports.useImperativeHandle = useImperativeHandle;
    exports.useLayoutEffect = useLayoutEffect;
    exports.useMemo = useMemo;
    exports.useReducer = useReducer;
    exports.useRef = useRef;
    exports.useState = useState;
    exports.version = ReactVersion;
})();

},{"object-assign":"dkHwz"}],"dkHwz":[function(require,module,exports) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ 'use strict';
/* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === undefined) throw new TypeError('Object.assign cannot be called with null or undefined');
    return Object(val);
}
function shouldUseNative() {
    try {
        if (!Object.assign) return false;
        // Detect buggy property enumeration order in older V8 versions.
        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
        var test1 = "abc"; // eslint-disable-line no-new-wrappers
        test1[5] = 'de';
        if (Object.getOwnPropertyNames(test1)[0] === '5') return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test2 = {
        };
        for(var i = 0; i < 10; i++)test2['_' + String.fromCharCode(i)] = i;
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join('') !== '0123456789') return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test3 = {
        };
        'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({
        }, test3)).join('') !== 'abcdefghijklmnopqrst') return false;
        return true;
    } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
    }
}
module.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for(var s = 1; s < arguments.length; s++){
        from = Object(arguments[s]);
        for(var key in from)if (hasOwnProperty.call(from, key)) to[key] = from[key];
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for(var i = 0; i < symbols.length; i++)if (propIsEnumerable.call(from, symbols[i])) to[symbols[i]] = from[symbols[i]];
        }
    }
    return to;
};

},{}],"ezGwg":[function(require,module,exports) {
'use strict';
function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') return;
    var err;
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
}
module.exports = require('./cjs/react-dom.development.js');

},{"./cjs/react-dom.development.js":"89hcc"}],"89hcc":[function(require,module,exports) {
/** @license React v17.0.2
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    var React = require('react');
    var _assign = require('object-assign');
    var Scheduler = require('scheduler');
    var tracing = require('scheduler/tracing');
    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    // by calls to these methods by a Babel plugin.
    //
    // In PROD (or in packages without access to React internals),
    // they are left as they are instead.
    function warn(format) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
        printWarning('warn', format, args);
    }
    function error(format) {
        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
        printWarning('error', format, args);
    }
    function printWarning(level, format, args) {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== '') {
            format += '%s';
            args = args.concat([
                stack
            ]);
        }
        var argsWithFormat = args.map(function(item) {
            return '' + item;
        }); // Careful: RN currently depends on this prefix
        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging
        Function.prototype.apply.call(console[level], console, argsWithFormat);
    }
    if (!React) throw Error("ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.");
    var FunctionComponent = 0;
    var ClassComponent = 1;
    var IndeterminateComponent = 2; // Before we know whether it is function or class
    var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
    var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
    var HostComponent = 5;
    var HostText = 6;
    var Fragment = 7;
    var Mode = 8;
    var ContextConsumer = 9;
    var ContextProvider = 10;
    var ForwardRef = 11;
    var Profiler = 12;
    var SuspenseComponent = 13;
    var MemoComponent = 14;
    var SimpleMemoComponent = 15;
    var LazyComponent = 16;
    var IncompleteClassComponent = 17;
    var DehydratedFragment = 18;
    var SuspenseListComponent = 19;
    var FundamentalComponent = 20;
    var ScopeComponent = 21;
    var Block = 22;
    var OffscreenComponent = 23;
    var LegacyHiddenComponent = 24;
    // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.
    var enableProfilerTimer = true; // Record durations for commit and passive effects phases.
    var enableFundamentalAPI = false; // Experimental Scope support.
    var enableNewReconciler = false; // Errors that are thrown while unmounting (or after in the case of passive effects)
    var warnAboutStringRefs = false;
    var allNativeEvents = new Set();
    /**
 * Mapping from registration name to event name
 */ var registrationNameDependencies = {
    };
    /**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */ var possibleRegistrationNames = {
    }; // Trust the developer to only use possibleRegistrationNames in true
    function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + 'Capture', dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
        if (registrationNameDependencies[registrationName]) error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
        registrationNameDependencies[registrationName] = dependencies;
        var lowerCasedName = registrationName.toLowerCase();
        possibleRegistrationNames[lowerCasedName] = registrationName;
        if (registrationName === 'onDoubleClick') possibleRegistrationNames.ondblclick = registrationName;
        for(var i = 0; i < dependencies.length; i++)allNativeEvents.add(dependencies[i]);
    }
    var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
    // A reserved attribute.
    // It is handled by React separately and shouldn't be written to the DOM.
    var RESERVED = 0; // A simple string attribute.
    // Attributes that aren't in the filter are presumed to have this type.
    var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
    // "enumerated" attributes with "true" and "false" as possible values.
    // When true, it should be set to a "true" string.
    // When false, it should be set to a "false" string.
    var BOOLEANISH_STRING = 2; // A real boolean attribute.
    // When true, it should be present (set either to an empty string or its name).
    // When false, it should be omitted.
    var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
    // When true, it should be present (set either to an empty string or its name).
    // When false, it should be omitted.
    // For any other value, should be present with that value.
    var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
    // When falsy, it should be removed.
    var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
    // When falsy, it should be removed.
    var POSITIVE_NUMERIC = 6;
    /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
    var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var illegalAttributeNameCache = {
    };
    var validatedAttributeNameCache = {
    };
    function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        error('Invalid attribute name: `%s`', attributeName);
        return false;
    }
    function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null) return propertyInfo.type === RESERVED;
        if (isCustomComponentTag) return false;
        if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) return true;
        return false;
    }
    function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) return false;
        switch(typeof value){
            case 'function':
            case 'symbol':
                // eslint-disable-line
                return true;
            case 'boolean':
                if (isCustomComponentTag) return false;
                if (propertyInfo !== null) return !propertyInfo.acceptsBooleans;
                else {
                    var prefix = name.toLowerCase().slice(0, 5);
                    return prefix !== 'data-' && prefix !== 'aria-';
                }
            default:
                return false;
        }
    }
    function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
        if (value === null || typeof value === 'undefined') return true;
        if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) return true;
        if (isCustomComponentTag) return false;
        if (propertyInfo !== null) switch(propertyInfo.type){
            case BOOLEAN:
                return !value;
            case OVERLOADED_BOOLEAN:
                return value === false;
            case NUMERIC:
                return isNaN(value);
            case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
        }
        return false;
    }
    function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
    }
    function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name;
        this.type = type;
        this.sanitizeURL = sanitizeURL;
        this.removeEmptyString = removeEmptyString;
    } // When adding attributes to this list, be sure to also add them to
    // the `possibleStandardNames` module to ensure casing and incorrect
    // name warnings.
    var properties = {
    }; // These props are reserved by React. They shouldn't be written to the DOM.
    var reservedProps = [
        'children',
        'dangerouslySetInnerHTML',
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        'defaultValue',
        'defaultChecked',
        'innerHTML',
        'suppressContentEditableWarning',
        'suppressHydrationWarning',
        'style'
    ];
    reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
    }); // A few React string attributes have a different name.
    // This is a mapping from React prop names to the attribute names.
    [
        [
            'acceptCharset',
            'accept-charset'
        ],
        [
            'className',
            'class'
        ],
        [
            'htmlFor',
            'for'
        ],
        [
            'httpEquiv',
            'http-equiv'
        ]
    ].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
    }); // These are "enumerated" HTML attributes that accept "true" and "false".
    // In React, we let users pass `true` and `false` even though technically
    // these aren't boolean attributes (they are coerced to strings).
    [
        'contentEditable',
        'draggable',
        'spellCheck',
        'value'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
    }); // These are "enumerated" SVG attributes that accept "true" and "false".
    // In React, we let users pass `true` and `false` even though technically
    // these aren't boolean attributes (they are coerced to strings).
    // Since these are SVG attributes, their attribute names are case-sensitive.
    [
        'autoReverse',
        'externalResourcesRequired',
        'focusable',
        'preserveAlpha'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
    }); // These are HTML boolean attributes.
    [
        'allowFullScreen',
        'async',
        // on the client side because the browsers are inconsistent. Instead we call focus().
        'autoFocus',
        'autoPlay',
        'controls',
        'default',
        'defer',
        'disabled',
        'disablePictureInPicture',
        'disableRemotePlayback',
        'formNoValidate',
        'hidden',
        'loop',
        'noModule',
        'noValidate',
        'open',
        'playsInline',
        'readOnly',
        'required',
        'reversed',
        'scoped',
        'seamless',
        'itemScope'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
    }); // These are the few React props that we set as DOM properties
    // rather than attributes. These are all booleans.
    [
        'checked',
        // disabled with `removeAttribute`. We have special logic for handling this.
        'multiple',
        'muted',
        'selected' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
    }); // These are HTML attributes that are "overloaded booleans": they behave like
    // booleans, but can also accept a string value.
    [
        'capture',
        'download' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
    }); // These are HTML attributes that must be positive numbers.
    [
        'cols',
        'rows',
        'size',
        'span' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
    }); // These are HTML attributes that must be numbers.
    [
        'rowSpan',
        'start'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
    });
    var CAMELIZE = /[\-\:]([a-z])/g;
    var capitalize = function(token) {
        return token[1].toUpperCase();
    }; // This is a list of all SVG attributes that need special casing, namespacing,
    // or boolean value assignment. Regular attributes that just accept strings
    // and have the same names are omitted, just like in the HTML attribute filter.
    // Some of these attributes can be hard to find. This list was created by
    // scraping the MDN documentation.
    [
        'accent-height',
        'alignment-baseline',
        'arabic-form',
        'baseline-shift',
        'cap-height',
        'clip-path',
        'clip-rule',
        'color-interpolation',
        'color-interpolation-filters',
        'color-profile',
        'color-rendering',
        'dominant-baseline',
        'enable-background',
        'fill-opacity',
        'fill-rule',
        'flood-color',
        'flood-opacity',
        'font-family',
        'font-size',
        'font-size-adjust',
        'font-stretch',
        'font-style',
        'font-variant',
        'font-weight',
        'glyph-name',
        'glyph-orientation-horizontal',
        'glyph-orientation-vertical',
        'horiz-adv-x',
        'horiz-origin-x',
        'image-rendering',
        'letter-spacing',
        'lighting-color',
        'marker-end',
        'marker-mid',
        'marker-start',
        'overline-position',
        'overline-thickness',
        'paint-order',
        'panose-1',
        'pointer-events',
        'rendering-intent',
        'shape-rendering',
        'stop-color',
        'stop-opacity',
        'strikethrough-position',
        'strikethrough-thickness',
        'stroke-dasharray',
        'stroke-dashoffset',
        'stroke-linecap',
        'stroke-linejoin',
        'stroke-miterlimit',
        'stroke-opacity',
        'stroke-width',
        'text-anchor',
        'text-decoration',
        'text-rendering',
        'underline-position',
        'underline-thickness',
        'unicode-bidi',
        'unicode-range',
        'units-per-em',
        'v-alphabetic',
        'v-hanging',
        'v-ideographic',
        'v-mathematical',
        'vector-effect',
        'vert-adv-y',
        'vert-origin-x',
        'vert-origin-y',
        'word-spacing',
        'writing-mode',
        'xmlns:xlink',
        'x-height' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
    }); // String SVG attributes with the xlink namespace.
    [
        'xlink:actuate',
        'xlink:arcrole',
        'xlink:role',
        'xlink:show',
        'xlink:title',
        'xlink:type' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/1999/xlink', false, false);
    }); // String SVG attributes with the xml namespace.
    [
        'xml:base',
        'xml:lang',
        'xml:space' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/XML/1998/namespace', false, false);
    }); // These attribute exists both in HTML and SVG.
    // The attribute name is case-sensitive in SVG so we can't just use
    // the React name like we do for attributes that exist only in HTML.
    [
        'tabIndex',
        'crossOrigin'
    ].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
    }); // These attributes accept URLs. These must not allow javascript: URLS.
    // These will also need to accept Trusted Types object in the future.
    var xlinkHref = 'xlinkHref';
    properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, 'xlink:href', 'http://www.w3.org/1999/xlink', true, false);
    [
        'src',
        'href',
        'action',
        'formAction'
    ].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
    });
    // and any newline or tab are filtered out as if they're not part of the URL.
    // https://url.spec.whatwg.org/#url-parsing
    // Tab or newline are defined as \r\n\t:
    // https://infra.spec.whatwg.org/#ascii-tab-or-newline
    // A C0 control is a code point in the range \u0000 NULL to \u001F
    // INFORMATION SEPARATOR ONE, inclusive:
    // https://infra.spec.whatwg.org/#c0-control-or-space
    /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
    var didWarn = false;
    function sanitizeURL(url) {
        if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
        }
    }
    /**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */ function getValueForProperty(node, name, expected, propertyInfo) {
        if (propertyInfo.mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            return node[propertyName];
        } else {
            if (propertyInfo.sanitizeURL) // If we haven't fully disabled javascript: URLs, and if
            // the hydration is successful of a javascript: URL, we
            // still want to warn on the client.
            sanitizeURL('' + expected);
            var attributeName = propertyInfo.attributeName;
            var stringValue = null;
            if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                if (node.hasAttribute(attributeName)) {
                    var value = node.getAttribute(attributeName);
                    if (value === '') return true;
                    if (shouldRemoveAttribute(name, expected, propertyInfo, false)) return value;
                    if (value === '' + expected) return expected;
                    return value;
                }
            } else if (node.hasAttribute(attributeName)) {
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) // We had an attribute but shouldn't have had one, so read it
                // for the error message.
                return node.getAttribute(attributeName);
                if (propertyInfo.type === BOOLEAN) // If this was a boolean, it doesn't matter what the value is
                // the fact that we have it is the same as the expected.
                return expected;
                 // Even if this property uses a namespace we use getAttribute
                // because we assume its namespaced name is the same as our config.
                // To use getAttributeNS we need the local name which we don't have
                // in our config atm.
                stringValue = node.getAttribute(attributeName);
            }
            if (shouldRemoveAttribute(name, expected, propertyInfo, false)) return stringValue === null ? expected : stringValue;
            else if (stringValue === '' + expected) return expected;
            else return stringValue;
        }
    }
    /**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */ function getValueForAttribute(node, name, expected) {
        if (!isAttributeNameSafe(name)) return;
         // If the object is an opaque reference ID, it's expected that
        // the next prop is different than the server value, so just return
        // expected
        if (isOpaqueHydratingObject(expected)) return expected;
        if (!node.hasAttribute(name)) return expected === undefined ? undefined : null;
        var value = node.getAttribute(name);
        if (value === '' + expected) return expected;
        return value;
    }
    /**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */ function setValueForProperty(node, name, value, isCustomComponentTag) {
        var propertyInfo = getPropertyInfo(name);
        if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) return;
        if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) value = null;
         // If the prop isn't in the special list, treat it as a simple attribute.
        if (isCustomComponentTag || propertyInfo === null) {
            if (isAttributeNameSafe(name)) {
                var _attributeName = name;
                if (value === null) node.removeAttribute(_attributeName);
                else node.setAttribute(_attributeName, '' + value);
            }
            return;
        }
        var mustUseProperty = propertyInfo.mustUseProperty;
        if (mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            if (value === null) {
                var type = propertyInfo.type;
                node[propertyName] = type === BOOLEAN ? false : '';
            } else // Contrary to `setAttribute`, object properties are properly
            // `toString`ed by IE8/9.
            node[propertyName] = value;
            return;
        } // The rest are treated as attributes with special cases.
        var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
        if (value === null) node.removeAttribute(attributeName);
        else {
            var _type = propertyInfo.type;
            var attributeValue;
            if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) // If attribute type is boolean, we know for sure it won't be an execution sink
            // and we won't require Trusted Type here.
            attributeValue = '';
            else {
                attributeValue = '' + value;
                if (propertyInfo.sanitizeURL) sanitizeURL(attributeValue.toString());
            }
            if (attributeNamespace) node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
            else node.setAttribute(attributeName, attributeValue);
        }
    }
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 60103;
    var REACT_PORTAL_TYPE = 60106;
    var REACT_FRAGMENT_TYPE = 60107;
    var REACT_STRICT_MODE_TYPE = 60108;
    var REACT_PROFILER_TYPE = 60114;
    var REACT_PROVIDER_TYPE = 60109;
    var REACT_CONTEXT_TYPE = 60110;
    var REACT_FORWARD_REF_TYPE = 60112;
    var REACT_SUSPENSE_TYPE = 60113;
    var REACT_SUSPENSE_LIST_TYPE = 60120;
    var REACT_MEMO_TYPE = 60115;
    var REACT_LAZY_TYPE = 60116;
    var REACT_BLOCK_TYPE = 60121;
    var REACT_SERVER_BLOCK_TYPE = 60122;
    var REACT_FUNDAMENTAL_TYPE = 60117;
    var REACT_SCOPE_TYPE = 60119;
    var REACT_OPAQUE_ID_TYPE = 60128;
    var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
    var REACT_OFFSCREEN_TYPE = 60130;
    var REACT_LEGACY_HIDDEN_TYPE = 60131;
    if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor('react.element');
        REACT_PORTAL_TYPE = symbolFor('react.portal');
        REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
        REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
        REACT_PROFILER_TYPE = symbolFor('react.profiler');
        REACT_PROVIDER_TYPE = symbolFor('react.provider');
        REACT_CONTEXT_TYPE = symbolFor('react.context');
        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
        REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
        REACT_MEMO_TYPE = symbolFor('react.memo');
        REACT_LAZY_TYPE = symbolFor('react.lazy');
        REACT_BLOCK_TYPE = symbolFor('react.block');
        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
        REACT_SCOPE_TYPE = symbolFor('react.scope');
        REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
        REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
    }
    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === 'function') return maybeIterator;
        return null;
    }
    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {
    }
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099
            var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        /* eslint-enable react-internal/no-production-logging */ }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ var props = {
                configurable: true,
                enumerable: true,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                log: _assign({
                }, props, {
                    value: prevLog
                }),
                info: _assign({
                }, props, {
                    value: prevInfo
                }),
                warn: _assign({
                }, props, {
                    value: prevWarn
                }),
                error: _assign({
                }, props, {
                    value: prevError
                }),
                group: _assign({
                }, props, {
                    value: prevGroup
                }),
                groupCollapsed: _assign({
                }, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: _assign({
                }, props, {
                    value: prevGroupEnd
                })
            });
        /* eslint-enable react-internal/no-production-logging */ }
        if (disabledDepth < 0) error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
        if (prefix === undefined) // Extract the VM specific prefix used by each line.
        try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
        }
         // We use the prefix to ensure our stacks line up with native stack frames.
        return '\n' + prefix + name;
    }
    var reentry = false;
    var componentFrameCache;
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
    componentFrameCache = new PossiblyWeakMap();
    function describeNativeComponentFrame(fn, construct) {
        // If something asked for a stack inside a fake render, it should get ignored.
        if (!fn || reentry) return '';
        var frame = componentFrameCache.get(fn);
        if (frame !== undefined) return frame;
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.
        ReactCurrentDispatcher.current = null;
        disableLogs();
        try {
            // This should throw.
            if (construct) {
                // Something should be setting the props in the constructor.
                var Fake = function() {
                    throw Error();
                }; // $FlowFixMe
                Object.defineProperty(Fake.prototype, 'props', {
                    set: function() {
                        // We use a throwing setter instead of frozen or non-writable props
                        // because that won't throw in a non-strict mode function.
                        throw Error();
                    }
                });
                if (typeof Reflect === 'object' && Reflect.construct) {
                    // We construct a different control for this case to include any extra
                    // frames added by the construct call.
                    try {
                        Reflect.construct(Fake, []);
                    } catch (x) {
                        control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                } else {
                    try {
                        Fake.call();
                    } catch (x) {
                        control = x;
                    }
                    fn.call(Fake.prototype);
                }
            } else {
                try {
                    throw Error();
                } catch (x) {
                    control = x;
                }
                fn();
            }
        } catch (sample) {
            // This is inlined manually because closure doesn't do it for us.
            if (sample && control && typeof sample.stack === 'string') {
                // This extracts the first frame from the sample that isn't also in the control.
                // Skipping one frame that we assume is the frame that calls the two.
                var sampleLines = sample.stack.split('\n');
                var controlLines = control.stack.split('\n');
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c])// We expect at least one stack frame to be shared.
                // Typically this will be the root most one. However, stack frames may be
                // cut off due to maximum stack limits. In this case, one maybe cut off
                // earlier than the other. We assume that the sample is longer or the same
                // and there for cut off earlier. So we should find the root most frame in
                // the sample somewhere in the control.
                c--;
                for(; s >= 1 && c >= 0; s--, c--)// Next we find the first one that isn't the same which should be the
                // frame that called our sample function and the control.
                if (sampleLines[s] !== controlLines[c]) {
                    // In V8, the first line is describing the message but other VMs don't.
                    // If we're about to return the first line, and the control is also on the same
                    // line, that's a pretty good indicator that our sample threw at same line as
                    // the control. I.e. before we entered the sample frame. So we ignore this result.
                    // This can happen if you passed a class to function component, or non-function.
                    if (s !== 1 || c !== 1) do {
                        s--;
                        c--; // We may still have similar intermediate frames from the construct call.
                        // The next one that isn't the same should be our match though.
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                            // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                            var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');
                            if (typeof fn === 'function') componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                    }while (s >= 1 && c >= 0)
                    break;
                }
            }
        } finally{
            reentry = false;
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
            Error.prepareStackTrace = previousPrepareStackTrace;
        } // Fallback to just using the name if we couldn't make it throw.
        var name = fn ? fn.displayName || fn.name : '';
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
        if (typeof fn === 'function') componentFrameCache.set(fn, syntheticFrame);
        return syntheticFrame;
    }
    function describeClassComponentFrame(ctor, source, ownerFn) {
        return describeNativeComponentFrame(ctor, true);
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, false);
    }
    function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) return '';
        if (typeof type === 'function') return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type === 'string') return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame('Suspense');
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame('SuspenseList');
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
                // Memo may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    // Lazy may contain any component type so we recursively resolve it.
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
        }
        return '';
    }
    function describeFiber(fiber) {
        var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
        var source = fiber._debugSource;
        switch(fiber.tag){
            case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
            case LazyComponent:
                return describeBuiltInComponentFrame('Lazy');
            case SuspenseComponent:
                return describeBuiltInComponentFrame('Suspense');
            case SuspenseListComponent:
                return describeBuiltInComponentFrame('SuspenseList');
            case FunctionComponent:
            case IndeterminateComponent:
            case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
            case ForwardRef:
                return describeFunctionComponentFrame(fiber.type.render);
            case Block:
                return describeFunctionComponentFrame(fiber.type._render);
            case ClassComponent:
                return describeClassComponentFrame(fiber.type);
            default:
                return '';
        }
    }
    function getStackByFiberInDevAndProd(workInProgress) {
        try {
            var info = '';
            var node = workInProgress;
            do {
                info += describeFiber(node);
                node = node.return;
            }while (node)
            return info;
        } catch (x) {
            return '\nError generating stack: ' + x.message + '\n' + x.stack;
        }
    }
    function getWrappedName(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || '';
        return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
    }
    function getContextName(type) {
        return type.displayName || 'Context';
    }
    function getComponentName(type) {
        if (type == null) // Host root, text node or just invalid type.
        return null;
        if (typeof type.tag === 'number') error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
        if (typeof type === 'function') return type.displayName || type.name || null;
        if (typeof type === 'string') return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return 'Fragment';
            case REACT_PORTAL_TYPE:
                return 'Portal';
            case REACT_PROFILER_TYPE:
                return 'Profiler';
            case REACT_STRICT_MODE_TYPE:
                return 'StrictMode';
            case REACT_SUSPENSE_TYPE:
                return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
                return 'SuspenseList';
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + '.Consumer';
            case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + '.Provider';
            case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, 'ForwardRef');
            case REACT_MEMO_TYPE:
                return getComponentName(type.type);
            case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    return getComponentName(init(payload));
                } catch (x) {
                    return null;
                }
        }
        return null;
    }
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var current = null;
    var isRendering = false;
    function getCurrentFiberOwnerNameInDevOrNull() {
        if (current === null) return null;
        var owner = current._debugOwner;
        if (owner !== null && typeof owner !== 'undefined') return getComponentName(owner.type);
        return null;
    }
    function getCurrentFiberStackInDev() {
        if (current === null) return '';
         // Safe because if current fiber exists, we are reconciling,
        // and it is guaranteed to be the work-in-progress version.
        return getStackByFiberInDevAndProd(current);
    }
    function resetCurrentFiber() {
        ReactDebugCurrentFrame.getCurrentStack = null;
        current = null;
        isRendering = false;
    }
    function setCurrentFiber(fiber) {
        ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
        current = fiber;
        isRendering = false;
    }
    function setIsRendering(rendering) {
        isRendering = rendering;
    }
    function getIsRendering() {
        return isRendering;
    }
    // Flow does not allow string concatenation of most non-string types. To work
    // around this limitation, we use an opaque type that can only be obtained by
    // passing the value through getToStringValue first.
    function toString(value) {
        return '' + value;
    }
    function getToStringValue(value) {
        switch(typeof value){
            case 'boolean':
            case 'number':
            case 'object':
            case 'string':
            case 'undefined':
                return value;
            default:
                // function, symbol are assigned as empty strings
                return '';
        }
    }
    var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
    };
    function checkControlledValueProps(tagName, props) {
        if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
        if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function isCheckable(elem) {
        var type = elem.type;
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
    }
    function getTracker(node) {
        return node._valueTracker;
    }
    function detachTracker(node) {
        node._valueTracker = null;
    }
    function getValueFromNode(node) {
        var value = '';
        if (!node) return value;
        if (isCheckable(node)) value = node.checked ? 'true' : 'false';
        else value = node.value;
        return value;
    }
    function trackValueOnNode(node) {
        var valueField = isCheckable(node) ? 'checked' : 'value';
        var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
        var currentValue = '' + node[valueField]; // if someone has already defined a value or Safari, then bail
        // and don't track value will cause over reporting of changes,
        // but it's better then a hard failure
        // (needed for certain tests that spyOn input values and Safari)
        if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') return;
        var get = descriptor.get, set = descriptor.set;
        Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
                return get.call(this);
            },
            set: function(value) {
                currentValue = '' + value;
                set.call(this, value);
            }
        }); // We could've passed this the first time
        // but it triggers a bug in IE11 and Edge 14/15.
        // Calling defineProperty() again should be equivalent.
        // https://github.com/facebook/react/issues/11768
        Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
        });
        var tracker = {
            getValue: function() {
                return currentValue;
            },
            setValue: function(value) {
                currentValue = '' + value;
            },
            stopTracking: function() {
                detachTracker(node);
                delete node[valueField];
            }
        };
        return tracker;
    }
    function track(node) {
        if (getTracker(node)) return;
         // TODO: Once it's just Fiber we can move this to node._wrapperState
        node._valueTracker = trackValueOnNode(node);
    }
    function updateValueIfChanged(node) {
        if (!node) return false;
        var tracker = getTracker(node); // if there is no tracker at this point it's unlikely
        // that trying again will succeed
        if (!tracker) return true;
        var lastValue = tracker.getValue();
        var nextValue = getValueFromNode(node);
        if (nextValue !== lastValue) {
            tracker.setValue(nextValue);
            return true;
        }
        return false;
    }
    function getActiveElement(doc) {
        doc = doc || (typeof document !== 'undefined' ? document : undefined);
        if (typeof doc === 'undefined') return null;
        try {
            return doc.activeElement || doc.body;
        } catch (e) {
            return doc.body;
        }
    }
    var didWarnValueDefaultValue = false;
    var didWarnCheckedDefaultChecked = false;
    var didWarnControlledToUncontrolled = false;
    var didWarnUncontrolledToControlled = false;
    function isControlled(props) {
        var usesChecked = props.type === 'checkbox' || props.type === 'radio';
        return usesChecked ? props.checked != null : props.value != null;
    }
    /**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */ function getHostProps(element, props) {
        var node = element;
        var checked = props.checked;
        var hostProps = _assign({
        }, props, {
            defaultChecked: undefined,
            defaultValue: undefined,
            value: undefined,
            checked: checked != null ? checked : node._wrapperState.initialChecked
        });
        return hostProps;
    }
    function initWrapperState(element, props) {
        checkControlledValueProps('input', props);
        if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);
            didWarnCheckedDefaultChecked = true;
        }
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
            error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);
            didWarnValueDefaultValue = true;
        }
        var node = element;
        var defaultValue = props.defaultValue == null ? '' : props.defaultValue;
        node._wrapperState = {
            initialChecked: props.checked != null ? props.checked : props.defaultChecked,
            initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
            controlled: isControlled(props)
        };
    }
    function updateChecked(element, props) {
        var node = element;
        var checked = props.checked;
        if (checked != null) setValueForProperty(node, 'checked', checked, false);
    }
    function updateWrapper(element, props) {
        var node = element;
        var controlled = isControlled(props);
        if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
            error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
            didWarnUncontrolledToControlled = true;
        }
        if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
            error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
            didWarnControlledToUncontrolled = true;
        }
        updateChecked(element, props);
        var value = getToStringValue(props.value);
        var type = props.type;
        if (value != null) {
            if (type === 'number') {
                if (value === 0 && node.value === '' || // eslint-disable-next-line
                node.value != value) node.value = toString(value);
            } else if (node.value !== toString(value)) node.value = toString(value);
        } else if (type === 'submit' || type === 'reset') {
            // Submit/reset inputs need the attribute removed completely to avoid
            // blank-text buttons.
            node.removeAttribute('value');
            return;
        }
        // When syncing the value attribute, the value comes from a cascade of
        // properties:
        //  1. The value React property
        //  2. The defaultValue React property
        //  3. Otherwise there should be no change
        if (props.hasOwnProperty('value')) setDefaultValue(node, props.type, value);
        else if (props.hasOwnProperty('defaultValue')) setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
        // When syncing the checked attribute, it only changes when it needs
        // to be removed, such as transitioning from a checkbox into a text input
        if (props.checked == null && props.defaultChecked != null) node.defaultChecked = !!props.defaultChecked;
    }
    function postMountWrapper(element, props, isHydrating) {
        var node = element; // Do not assign value if it is already set. This prevents user text input
        // from being lost during SSR hydration.
        if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {
            var type = props.type;
            var isButton = type === 'submit' || type === 'reset'; // Avoid setting value attribute on submit/reset inputs as it overrides the
            // default value provided by the browser. See: #12872
            if (isButton && (props.value === undefined || props.value === null)) return;
            var initialValue = toString(node._wrapperState.initialValue); // Do not assign value if it is already set. This prevents user text input
            // from being lost during SSR hydration.
            if (!isHydrating) // When syncing the value attribute, the value property should use
            // the wrapperState._initialValue property. This uses:
            //
            //   1. The value React property when present
            //   2. The defaultValue React property when present
            //   3. An empty string
            {
                if (initialValue !== node.value) node.value = initialValue;
            }
            // Otherwise, the value attribute is synchronized to the property,
            // so we assign defaultValue to the same thing as the value property
            // assignment step above.
            node.defaultValue = initialValue;
        } // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
        // this is needed to work around a chrome bug where setting defaultChecked
        // will sometimes influence the value of checked (even after detachment).
        // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
        // We need to temporarily unset name to avoid disrupting radio button groups.
        var name = node.name;
        if (name !== '') node.name = '';
        // When syncing the checked attribute, both the checked property and
        // attribute are assigned at the same time using defaultChecked. This uses:
        //
        //   1. The checked React property when present
        //   2. The defaultChecked React property when present
        //   3. Otherwise, false
        node.defaultChecked = !node.defaultChecked;
        node.defaultChecked = !!node._wrapperState.initialChecked;
        if (name !== '') node.name = name;
    }
    function restoreControlledState(element, props) {
        var node = element;
        updateWrapper(node, props);
        updateNamedCousins(node, props);
    }
    function updateNamedCousins(rootNode, props) {
        var name = props.name;
        if (props.type === 'radio' && name != null) {
            var queryRoot = rootNode;
            while(queryRoot.parentNode)queryRoot = queryRoot.parentNode;
             // If `rootNode.form` was non-null, then we could try `form.elements`,
            // but that sometimes behaves strangely in IE8. We could also try using
            // `form.getElementsByName`, but that will only return direct children
            // and won't include inputs that use the HTML5 `form=` attribute. Since
            // the input might not even be in a form. It might not even be in the
            // document. Let's just use the local `querySelectorAll` to ensure we don't
            // miss anything.
            var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
            for(var i = 0; i < group.length; i++){
                var otherNode = group[i];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) continue;
                 // This will throw if radio buttons rendered by different copies of React
                // and the same name are rendered into the same form (same as #1939).
                // That's probably okay; we don't support it just as we don't support
                // mixing React radio buttons with non-React ones.
                var otherProps = getFiberCurrentPropsFromNode(otherNode);
                if (!otherProps) throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                 // We need update the tracked value on the named cousin since the value
                // was changed but the input saw no event or value set
                updateValueIfChanged(otherNode); // If this is a controlled radio button group, forcing the input that
                // was previously checked to update will cause it to be come re-checked
                // as appropriate.
                updateWrapper(otherNode, otherProps);
            }
        }
    } // In Chrome, assigning defaultValue to certain input types triggers input validation.
    // For number inputs, the display value loses trailing decimal points. For email inputs,
    // Chrome raises "The specified value <x> is not a valid email address".
    //
    // Here we check to see if the defaultValue has actually changed, avoiding these problems
    // when the user is inputting text
    //
    // https://github.com/facebook/react/issues/7253
    function setDefaultValue(node, type, value) {
        if (type !== 'number' || getActiveElement(node.ownerDocument) !== node) {
            if (value == null) node.defaultValue = toString(node._wrapperState.initialValue);
            else if (node.defaultValue !== toString(value)) node.defaultValue = toString(value);
        }
    }
    var didWarnSelectedSetOnOption = false;
    var didWarnInvalidChild = false;
    function flattenChildren(children) {
        var content = ''; // Flatten children. We'll warn if they are invalid
        // during validateProps() which runs for hydration too.
        // Note that this would throw on non-element objects.
        // Elements are stringified (which is normally irrelevant
        // but matters for <fbt>).
        React.Children.forEach(children, function(child) {
            if (child == null) return;
            content += child; // Note: we don't warn about invalid children here.
        // Instead, this is done separately below so that
        // it happens during the hydration code path too.
        });
        return content;
    }
    /**
 * Implements an <option> host component that warns when `selected` is set.
 */ function validateProps(element, props) {
        // This mirrors the code path above, but runs for hydration too.
        // Warn about invalid children here so that client and hydration are consistent.
        // TODO: this seems like it could cause a DEV-only throw for hydration
        // if children contains a non-element object. We should try to avoid that.
        if (typeof props.children === 'object' && props.children !== null) React.Children.forEach(props.children, function(child) {
            if (child == null) return;
            if (typeof child === 'string' || typeof child === 'number') return;
            if (typeof child.type !== 'string') return;
            if (!didWarnInvalidChild) {
                didWarnInvalidChild = true;
                error('Only strings and numbers are supported as <option> children.');
            }
        });
         // TODO: Remove support for `selected` in <option>.
        if (props.selected != null && !didWarnSelectedSetOnOption) {
            error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
            didWarnSelectedSetOnOption = true;
        }
    }
    function postMountWrapper$1(element, props) {
        // value="" should make a value attribute (#6219)
        if (props.value != null) element.setAttribute('value', toString(getToStringValue(props.value)));
    }
    function getHostProps$1(element, props) {
        var hostProps = _assign({
            children: undefined
        }, props);
        var content = flattenChildren(props.children);
        if (content) hostProps.children = content;
        return hostProps;
    }
    var didWarnValueDefaultValue$1;
    didWarnValueDefaultValue$1 = false;
    function getDeclarationErrorAddendum() {
        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
        if (ownerName) return '\n\nCheck the render method of `' + ownerName + '`.';
        return '';
    }
    var valuePropNames = [
        'value',
        'defaultValue'
    ];
    /**
 * Validation function for `value` and `defaultValue`.
 */ function checkSelectPropTypes(props) {
        checkControlledValueProps('select', props);
        for(var i = 0; i < valuePropNames.length; i++){
            var propName = valuePropNames[i];
            if (props[propName] == null) continue;
            var isArray = Array.isArray(props[propName]);
            if (props.multiple && !isArray) error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
            else if (!props.multiple && isArray) error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
        }
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
        var options = node.options;
        if (multiple) {
            var selectedValues = propValue;
            var selectedValue = {
            };
            for(var i = 0; i < selectedValues.length; i++)// Prefix to avoid chaos with special keys.
            selectedValue['$' + selectedValues[i]] = true;
            for(var _i = 0; _i < options.length; _i++){
                var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
                if (options[_i].selected !== selected) options[_i].selected = selected;
                if (selected && setDefaultSelected) options[_i].defaultSelected = true;
            }
        } else {
            // Do not set `select.value` as exact behavior isn't consistent across all
            // browsers for all cases.
            var _selectedValue = toString(getToStringValue(propValue));
            var defaultSelected = null;
            for(var _i2 = 0; _i2 < options.length; _i2++){
                if (options[_i2].value === _selectedValue) {
                    options[_i2].selected = true;
                    if (setDefaultSelected) options[_i2].defaultSelected = true;
                    return;
                }
                if (defaultSelected === null && !options[_i2].disabled) defaultSelected = options[_i2];
            }
            if (defaultSelected !== null) defaultSelected.selected = true;
        }
    }
    /**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */ function getHostProps$2(element, props) {
        return _assign({
        }, props, {
            value: undefined
        });
    }
    function initWrapperState$1(element, props) {
        var node = element;
        checkSelectPropTypes(props);
        node._wrapperState = {
            wasMultiple: !!props.multiple
        };
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
            error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnValueDefaultValue$1 = true;
        }
    }
    function postMountWrapper$2(element, props) {
        var node = element;
        node.multiple = !!props.multiple;
        var value = props.value;
        if (value != null) updateOptions(node, !!props.multiple, value, false);
        else if (props.defaultValue != null) updateOptions(node, !!props.multiple, props.defaultValue, true);
    }
    function postUpdateWrapper(element, props) {
        var node = element;
        var wasMultiple = node._wrapperState.wasMultiple;
        node._wrapperState.wasMultiple = !!props.multiple;
        var value = props.value;
        if (value != null) updateOptions(node, !!props.multiple, value, false);
        else if (wasMultiple !== !!props.multiple) {
            // For simplicity, reapply `defaultValue` if `multiple` is toggled.
            if (props.defaultValue != null) updateOptions(node, !!props.multiple, props.defaultValue, true);
            else // Revert the select back to its default unselected state.
            updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
        }
    }
    function restoreControlledState$1(element, props) {
        var node = element;
        var value = props.value;
        if (value != null) updateOptions(node, !!props.multiple, value, false);
    }
    var didWarnValDefaultVal = false;
    /**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */ function getHostProps$3(element, props) {
        var node = element;
        if (!(props.dangerouslySetInnerHTML == null)) throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
         // Always set children to the same thing. In IE9, the selection range will
        // get reset if `textContent` is mutated.  We could add a check in setTextContent
        // to only set the value if/when the value differs from the node value (which would
        // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
        // solution. The value can be a boolean or object so that's why it's forced
        // to be a string.
        var hostProps = _assign({
        }, props, {
            value: undefined,
            defaultValue: undefined,
            children: toString(node._wrapperState.initialValue)
        });
        return hostProps;
    }
    function initWrapperState$2(element, props) {
        var node = element;
        checkControlledValueProps('textarea', props);
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
            error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || 'A component');
            didWarnValDefaultVal = true;
        }
        var initialValue = props.value; // Only bother fetching default value if we're going to use it
        if (initialValue == null) {
            var children = props.children, defaultValue = props.defaultValue;
            if (children != null) {
                error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                if (!(defaultValue == null)) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                if (Array.isArray(children)) {
                    if (!(children.length <= 1)) throw Error("<textarea> can only have at most one child.");
                    children = children[0];
                }
                defaultValue = children;
            }
            if (defaultValue == null) defaultValue = '';
            initialValue = defaultValue;
        }
        node._wrapperState = {
            initialValue: getToStringValue(initialValue)
        };
    }
    function updateWrapper$1(element, props) {
        var node = element;
        var value = getToStringValue(props.value);
        var defaultValue = getToStringValue(props.defaultValue);
        if (value != null) {
            // Cast `value` to a string to ensure the value is set correctly. While
            // browsers typically do this as necessary, jsdom doesn't.
            var newValue = toString(value); // To avoid side effects (such as losing text selection), only set value if changed
            if (newValue !== node.value) node.value = newValue;
            if (props.defaultValue == null && node.defaultValue !== newValue) node.defaultValue = newValue;
        }
        if (defaultValue != null) node.defaultValue = toString(defaultValue);
    }
    function postMountWrapper$3(element, props) {
        var node = element; // This is in postMount because we need access to the DOM node, which is not
        // available until after the component has mounted.
        var textContent = node.textContent; // Only set node.value if textContent is equal to the expected
        // initial value. In IE10/IE11 there is a bug where the placeholder attribute
        // will populate textContent as well.
        // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
        if (textContent === node._wrapperState.initialValue) {
            if (textContent !== '' && textContent !== null) node.value = textContent;
        }
    }
    function restoreControlledState$2(element, props) {
        // DOM component is still mounted; update
        updateWrapper$1(element, props);
    }
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var Namespaces = {
        html: HTML_NAMESPACE,
        mathml: MATH_NAMESPACE,
        svg: SVG_NAMESPACE
    }; // Assumes there is no parent namespace.
    function getIntrinsicNamespace(type) {
        switch(type){
            case 'svg':
                return SVG_NAMESPACE;
            case 'math':
                return MATH_NAMESPACE;
            default:
                return HTML_NAMESPACE;
        }
    }
    function getChildNamespace(parentNamespace, type) {
        if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) // No (or default) parent namespace: potential entry point.
        return getIntrinsicNamespace(type);
        if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') // We're leaving SVG.
        return HTML_NAMESPACE;
         // By default, pass namespace below.
        return parentNamespace;
    }
    /* globals MSApp */ /**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */ var createMicrosoftUnsafeLocalFunction = function(func) {
        if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) return function(arg0, arg1, arg2, arg3) {
            MSApp.execUnsafeLocalFunction(function() {
                return func(arg0, arg1, arg2, arg3);
            });
        };
        else return func;
    };
    var reusableSVGContainer;
    /**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */ var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
        if (node.namespaceURI === Namespaces.svg) {
            if (!('innerHTML' in node)) {
                // IE does not have innerHTML for SVG nodes, so instead we inject the
                // new markup in a temp node and then move the child nodes across into
                // the target node
                reusableSVGContainer = reusableSVGContainer || document.createElement('div');
                reusableSVGContainer.innerHTML = '<svg>' + html.valueOf().toString() + '</svg>';
                var svgNode = reusableSVGContainer.firstChild;
                while(node.firstChild)node.removeChild(node.firstChild);
                while(svgNode.firstChild)node.appendChild(svgNode.firstChild);
                return;
            }
        }
        node.innerHTML = html;
    });
    /**
 * HTML nodeType values that represent the type of the node
 */ var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var COMMENT_NODE = 8;
    var DOCUMENT_NODE = 9;
    var DOCUMENT_FRAGMENT_NODE = 11;
    /**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */ var setTextContent = function(node, text) {
        if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text;
                return;
            }
        }
        node.textContent = text;
    };
    // List derived from Gecko source code:
    // https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
    var shorthandToLonghand = {
        animation: [
            'animationDelay',
            'animationDirection',
            'animationDuration',
            'animationFillMode',
            'animationIterationCount',
            'animationName',
            'animationPlayState',
            'animationTimingFunction'
        ],
        background: [
            'backgroundAttachment',
            'backgroundClip',
            'backgroundColor',
            'backgroundImage',
            'backgroundOrigin',
            'backgroundPositionX',
            'backgroundPositionY',
            'backgroundRepeat',
            'backgroundSize'
        ],
        backgroundPosition: [
            'backgroundPositionX',
            'backgroundPositionY'
        ],
        border: [
            'borderBottomColor',
            'borderBottomStyle',
            'borderBottomWidth',
            'borderImageOutset',
            'borderImageRepeat',
            'borderImageSlice',
            'borderImageSource',
            'borderImageWidth',
            'borderLeftColor',
            'borderLeftStyle',
            'borderLeftWidth',
            'borderRightColor',
            'borderRightStyle',
            'borderRightWidth',
            'borderTopColor',
            'borderTopStyle',
            'borderTopWidth'
        ],
        borderBlockEnd: [
            'borderBlockEndColor',
            'borderBlockEndStyle',
            'borderBlockEndWidth'
        ],
        borderBlockStart: [
            'borderBlockStartColor',
            'borderBlockStartStyle',
            'borderBlockStartWidth'
        ],
        borderBottom: [
            'borderBottomColor',
            'borderBottomStyle',
            'borderBottomWidth'
        ],
        borderColor: [
            'borderBottomColor',
            'borderLeftColor',
            'borderRightColor',
            'borderTopColor'
        ],
        borderImage: [
            'borderImageOutset',
            'borderImageRepeat',
            'borderImageSlice',
            'borderImageSource',
            'borderImageWidth'
        ],
        borderInlineEnd: [
            'borderInlineEndColor',
            'borderInlineEndStyle',
            'borderInlineEndWidth'
        ],
        borderInlineStart: [
            'borderInlineStartColor',
            'borderInlineStartStyle',
            'borderInlineStartWidth'
        ],
        borderLeft: [
            'borderLeftColor',
            'borderLeftStyle',
            'borderLeftWidth'
        ],
        borderRadius: [
            'borderBottomLeftRadius',
            'borderBottomRightRadius',
            'borderTopLeftRadius',
            'borderTopRightRadius'
        ],
        borderRight: [
            'borderRightColor',
            'borderRightStyle',
            'borderRightWidth'
        ],
        borderStyle: [
            'borderBottomStyle',
            'borderLeftStyle',
            'borderRightStyle',
            'borderTopStyle'
        ],
        borderTop: [
            'borderTopColor',
            'borderTopStyle',
            'borderTopWidth'
        ],
        borderWidth: [
            'borderBottomWidth',
            'borderLeftWidth',
            'borderRightWidth',
            'borderTopWidth'
        ],
        columnRule: [
            'columnRuleColor',
            'columnRuleStyle',
            'columnRuleWidth'
        ],
        columns: [
            'columnCount',
            'columnWidth'
        ],
        flex: [
            'flexBasis',
            'flexGrow',
            'flexShrink'
        ],
        flexFlow: [
            'flexDirection',
            'flexWrap'
        ],
        font: [
            'fontFamily',
            'fontFeatureSettings',
            'fontKerning',
            'fontLanguageOverride',
            'fontSize',
            'fontSizeAdjust',
            'fontStretch',
            'fontStyle',
            'fontVariant',
            'fontVariantAlternates',
            'fontVariantCaps',
            'fontVariantEastAsian',
            'fontVariantLigatures',
            'fontVariantNumeric',
            'fontVariantPosition',
            'fontWeight',
            'lineHeight'
        ],
        fontVariant: [
            'fontVariantAlternates',
            'fontVariantCaps',
            'fontVariantEastAsian',
            'fontVariantLigatures',
            'fontVariantNumeric',
            'fontVariantPosition'
        ],
        gap: [
            'columnGap',
            'rowGap'
        ],
        grid: [
            'gridAutoColumns',
            'gridAutoFlow',
            'gridAutoRows',
            'gridTemplateAreas',
            'gridTemplateColumns',
            'gridTemplateRows'
        ],
        gridArea: [
            'gridColumnEnd',
            'gridColumnStart',
            'gridRowEnd',
            'gridRowStart'
        ],
        gridColumn: [
            'gridColumnEnd',
            'gridColumnStart'
        ],
        gridColumnGap: [
            'columnGap'
        ],
        gridGap: [
            'columnGap',
            'rowGap'
        ],
        gridRow: [
            'gridRowEnd',
            'gridRowStart'
        ],
        gridRowGap: [
            'rowGap'
        ],
        gridTemplate: [
            'gridTemplateAreas',
            'gridTemplateColumns',
            'gridTemplateRows'
        ],
        listStyle: [
            'listStyleImage',
            'listStylePosition',
            'listStyleType'
        ],
        margin: [
            'marginBottom',
            'marginLeft',
            'marginRight',
            'marginTop'
        ],
        marker: [
            'markerEnd',
            'markerMid',
            'markerStart'
        ],
        mask: [
            'maskClip',
            'maskComposite',
            'maskImage',
            'maskMode',
            'maskOrigin',
            'maskPositionX',
            'maskPositionY',
            'maskRepeat',
            'maskSize'
        ],
        maskPosition: [
            'maskPositionX',
            'maskPositionY'
        ],
        outline: [
            'outlineColor',
            'outlineStyle',
            'outlineWidth'
        ],
        overflow: [
            'overflowX',
            'overflowY'
        ],
        padding: [
            'paddingBottom',
            'paddingLeft',
            'paddingRight',
            'paddingTop'
        ],
        placeContent: [
            'alignContent',
            'justifyContent'
        ],
        placeItems: [
            'alignItems',
            'justifyItems'
        ],
        placeSelf: [
            'alignSelf',
            'justifySelf'
        ],
        textDecoration: [
            'textDecorationColor',
            'textDecorationLine',
            'textDecorationStyle'
        ],
        textEmphasis: [
            'textEmphasisColor',
            'textEmphasisStyle'
        ],
        transition: [
            'transitionDelay',
            'transitionDuration',
            'transitionProperty',
            'transitionTimingFunction'
        ],
        wordWrap: [
            'overflowWrap'
        ]
    };
    /**
 * CSS properties which accept numbers but are not in units of "px".
 */ var isUnitlessNumber = {
        animationIterationCount: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        // SVG-related properties
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
    };
    /**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */ function prefixKey(prefix1, key) {
        return prefix1 + key.charAt(0).toUpperCase() + key.substring(1);
    }
    /**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */ var prefixes = [
        'Webkit',
        'ms',
        'Moz',
        'O'
    ]; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
    // infinite loop, because it iterates over the newly added props too.
    Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix1) {
            isUnitlessNumber[prefixKey(prefix1, prop)] = isUnitlessNumber[prop];
        });
    });
    /**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */ function dangerousStyleValue(name, value, isCustomProperty) {
        // Note that we've removed escapeTextForBrowser() calls here since the
        // whole string will be escaped when the attribute is injected into
        // the markup. If you provide unsafe user data here they can inject
        // arbitrary CSS which may be problematic (I couldn't repro this):
        // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
        // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
        // This is not an XSS hole but instead a potential CSS injection issue
        // which has lead to a greater discussion about how we're going to
        // trust URLs moving forward. See #2115901
        var isEmpty = value == null || typeof value === 'boolean' || value === '';
        if (isEmpty) return '';
        if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
        return ('' + value).trim();
    }
    var uppercasePattern = /([A-Z])/g;
    var msPattern = /^ms-/;
    /**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */ function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
    }
    var warnValidStyle = function() {
    };
    // 'msTransform' is correct, but the other prefixes should be capitalized
    var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
    var msPattern$1 = /^-ms-/;
    var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon
    var badStyleValueWithSemicolonPattern = /;\s*$/;
    var warnedStyleNames = {
    };
    var warnedStyleValues = {
    };
    var warnedForNaNValue = false;
    var warnedForInfinityValue = false;
    var camelize = function(string) {
        return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
        });
    };
    var warnHyphenatedStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) return;
        warnedStyleNames[name] = true;
        error('Unsupported style property %s. Did you mean %s?', name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
        // is converted to lowercase `ms`.
        camelize(name.replace(msPattern$1, 'ms-')));
    };
    var warnBadVendoredStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) return;
        warnedStyleNames[name] = true;
        error('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
    };
    var warnStyleValueWithSemicolon = function(name, value) {
        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) return;
        warnedStyleValues[value] = true;
        error("Style property values shouldn't contain a semicolon. Try \"%s: %s\" instead.", name, value.replace(badStyleValueWithSemicolonPattern, ''));
    };
    var warnStyleValueIsNaN = function(name, value) {
        if (warnedForNaNValue) return;
        warnedForNaNValue = true;
        error('`NaN` is an invalid value for the `%s` css style property.', name);
    };
    var warnStyleValueIsInfinity = function(name, value) {
        if (warnedForInfinityValue) return;
        warnedForInfinityValue = true;
        error('`Infinity` is an invalid value for the `%s` css style property.', name);
    };
    warnValidStyle = function(name, value) {
        if (name.indexOf('-') > -1) warnHyphenatedStyleName(name);
        else if (badVendoredStyleNamePattern.test(name)) warnBadVendoredStyleName(name);
        else if (badStyleValueWithSemicolonPattern.test(value)) warnStyleValueWithSemicolon(name, value);
        if (typeof value === 'number') {
            if (isNaN(value)) warnStyleValueIsNaN(name, value);
            else if (!isFinite(value)) warnStyleValueIsInfinity(name, value);
        }
    };
    var warnValidStyle$1 = warnValidStyle;
    /**
 * Operations for dealing with CSS properties.
 */ /**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */ function createDangerousStringForStyles(styles) {
        var serialized = '';
        var delimiter = '';
        for(var styleName in styles){
            if (!styles.hasOwnProperty(styleName)) continue;
            var styleValue = styles[styleName];
            if (styleValue != null) {
                var isCustomProperty = styleName.indexOf('--') === 0;
                serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ':';
                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                delimiter = ';';
            }
        }
        return serialized || null;
    }
    /**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */ function setValueForStyles(node, styles) {
        var style = node.style;
        for(var styleName in styles){
            if (!styles.hasOwnProperty(styleName)) continue;
            var isCustomProperty = styleName.indexOf('--') === 0;
            if (!isCustomProperty) warnValidStyle$1(styleName, styles[styleName]);
            var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
            if (styleName === 'float') styleName = 'cssFloat';
            if (isCustomProperty) style.setProperty(styleName, styleValue);
            else style[styleName] = styleValue;
        }
    }
    function isValueEmpty(value) {
        return value == null || typeof value === 'boolean' || value === '';
    }
    /**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */ function expandShorthandMap(styles) {
        var expanded = {
        };
        for(var key in styles){
            var longhands = shorthandToLonghand[key] || [
                key
            ];
            for(var i = 0; i < longhands.length; i++)expanded[longhands[i]] = key;
        }
        return expanded;
    }
    /**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */ function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
        if (!nextStyles) return;
        var expandedUpdates = expandShorthandMap(styleUpdates);
        var expandedStyles = expandShorthandMap(nextStyles);
        var warnedAbout = {
        };
        for(var key in expandedUpdates){
            var originalKey = expandedUpdates[key];
            var correctOriginalKey = expandedStyles[key];
            if (correctOriginalKey && originalKey !== correctOriginalKey) {
                var warningKey = originalKey + ',' + correctOriginalKey;
                if (warnedAbout[warningKey]) continue;
                warnedAbout[warningKey] = true;
                error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating', originalKey, correctOriginalKey);
            }
        }
    }
    // For HTML, certain tags should omit their close tag. We keep a list for
    // those special-case tags.
    var omittedCloseTags = {
        area: true,
        base: true,
        br: true,
        col: true,
        embed: true,
        hr: true,
        img: true,
        input: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true // NOTE: menuitem's close tag should be omitted, but that causes problems.
    };
    // `omittedCloseTags` except that `menuitem` should still have its closing tag.
    var voidElementTags = _assign({
        menuitem: true
    }, omittedCloseTags);
    var HTML = '__html';
    function assertValidProps(tag, props) {
        if (!props) return;
         // Note the use of `==` which checks for null or undefined.
        if (voidElementTags[tag]) {
            if (!(props.children == null && props.dangerouslySetInnerHTML == null)) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        }
        if (props.dangerouslySetInnerHTML != null) {
            if (!(props.children == null)) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if (!(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
        if (!(props.style == null || typeof props.style === 'object')) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
    }
    function isCustomComponent(tagName, props) {
        if (tagName.indexOf('-') === -1) return typeof props.is === 'string';
        switch(tagName){
            // These are reserved SVG and MathML elements.
            // We don't mind this list too much because we expect it to never grow.
            // The alternative is to track the namespace in a few places which is convoluted.
            // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
            case 'annotation-xml':
            case 'color-profile':
            case 'font-face':
            case 'font-face-src':
            case 'font-face-uri':
            case 'font-face-format':
            case 'font-face-name':
            case 'missing-glyph':
                return false;
            default:
                return true;
        }
    }
    // When adding attributes to the HTML or SVG allowed attribute list, be sure to
    // also add them to this module to ensure casing and incorrect name
    // warnings.
    var possibleStandardNames = {
        // HTML
        accept: 'accept',
        acceptcharset: 'acceptCharset',
        'accept-charset': 'acceptCharset',
        accesskey: 'accessKey',
        action: 'action',
        allowfullscreen: 'allowFullScreen',
        alt: 'alt',
        as: 'as',
        async: 'async',
        autocapitalize: 'autoCapitalize',
        autocomplete: 'autoComplete',
        autocorrect: 'autoCorrect',
        autofocus: 'autoFocus',
        autoplay: 'autoPlay',
        autosave: 'autoSave',
        capture: 'capture',
        cellpadding: 'cellPadding',
        cellspacing: 'cellSpacing',
        challenge: 'challenge',
        charset: 'charSet',
        checked: 'checked',
        children: 'children',
        cite: 'cite',
        class: 'className',
        classid: 'classID',
        classname: 'className',
        cols: 'cols',
        colspan: 'colSpan',
        content: 'content',
        contenteditable: 'contentEditable',
        contextmenu: 'contextMenu',
        controls: 'controls',
        controlslist: 'controlsList',
        coords: 'coords',
        crossorigin: 'crossOrigin',
        dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
        data: 'data',
        datetime: 'dateTime',
        default: 'default',
        defaultchecked: 'defaultChecked',
        defaultvalue: 'defaultValue',
        defer: 'defer',
        dir: 'dir',
        disabled: 'disabled',
        disablepictureinpicture: 'disablePictureInPicture',
        disableremoteplayback: 'disableRemotePlayback',
        download: 'download',
        draggable: 'draggable',
        enctype: 'encType',
        enterkeyhint: 'enterKeyHint',
        for: 'htmlFor',
        form: 'form',
        formmethod: 'formMethod',
        formaction: 'formAction',
        formenctype: 'formEncType',
        formnovalidate: 'formNoValidate',
        formtarget: 'formTarget',
        frameborder: 'frameBorder',
        headers: 'headers',
        height: 'height',
        hidden: 'hidden',
        high: 'high',
        href: 'href',
        hreflang: 'hrefLang',
        htmlfor: 'htmlFor',
        httpequiv: 'httpEquiv',
        'http-equiv': 'httpEquiv',
        icon: 'icon',
        id: 'id',
        innerhtml: 'innerHTML',
        inputmode: 'inputMode',
        integrity: 'integrity',
        is: 'is',
        itemid: 'itemID',
        itemprop: 'itemProp',
        itemref: 'itemRef',
        itemscope: 'itemScope',
        itemtype: 'itemType',
        keyparams: 'keyParams',
        keytype: 'keyType',
        kind: 'kind',
        label: 'label',
        lang: 'lang',
        list: 'list',
        loop: 'loop',
        low: 'low',
        manifest: 'manifest',
        marginwidth: 'marginWidth',
        marginheight: 'marginHeight',
        max: 'max',
        maxlength: 'maxLength',
        media: 'media',
        mediagroup: 'mediaGroup',
        method: 'method',
        min: 'min',
        minlength: 'minLength',
        multiple: 'multiple',
        muted: 'muted',
        name: 'name',
        nomodule: 'noModule',
        nonce: 'nonce',
        novalidate: 'noValidate',
        open: 'open',
        optimum: 'optimum',
        pattern: 'pattern',
        placeholder: 'placeholder',
        playsinline: 'playsInline',
        poster: 'poster',
        preload: 'preload',
        profile: 'profile',
        radiogroup: 'radioGroup',
        readonly: 'readOnly',
        referrerpolicy: 'referrerPolicy',
        rel: 'rel',
        required: 'required',
        reversed: 'reversed',
        role: 'role',
        rows: 'rows',
        rowspan: 'rowSpan',
        sandbox: 'sandbox',
        scope: 'scope',
        scoped: 'scoped',
        scrolling: 'scrolling',
        seamless: 'seamless',
        selected: 'selected',
        shape: 'shape',
        size: 'size',
        sizes: 'sizes',
        span: 'span',
        spellcheck: 'spellCheck',
        src: 'src',
        srcdoc: 'srcDoc',
        srclang: 'srcLang',
        srcset: 'srcSet',
        start: 'start',
        step: 'step',
        style: 'style',
        summary: 'summary',
        tabindex: 'tabIndex',
        target: 'target',
        title: 'title',
        type: 'type',
        usemap: 'useMap',
        value: 'value',
        width: 'width',
        wmode: 'wmode',
        wrap: 'wrap',
        // SVG
        about: 'about',
        accentheight: 'accentHeight',
        'accent-height': 'accentHeight',
        accumulate: 'accumulate',
        additive: 'additive',
        alignmentbaseline: 'alignmentBaseline',
        'alignment-baseline': 'alignmentBaseline',
        allowreorder: 'allowReorder',
        alphabetic: 'alphabetic',
        amplitude: 'amplitude',
        arabicform: 'arabicForm',
        'arabic-form': 'arabicForm',
        ascent: 'ascent',
        attributename: 'attributeName',
        attributetype: 'attributeType',
        autoreverse: 'autoReverse',
        azimuth: 'azimuth',
        basefrequency: 'baseFrequency',
        baselineshift: 'baselineShift',
        'baseline-shift': 'baselineShift',
        baseprofile: 'baseProfile',
        bbox: 'bbox',
        begin: 'begin',
        bias: 'bias',
        by: 'by',
        calcmode: 'calcMode',
        capheight: 'capHeight',
        'cap-height': 'capHeight',
        clip: 'clip',
        clippath: 'clipPath',
        'clip-path': 'clipPath',
        clippathunits: 'clipPathUnits',
        cliprule: 'clipRule',
        'clip-rule': 'clipRule',
        color: 'color',
        colorinterpolation: 'colorInterpolation',
        'color-interpolation': 'colorInterpolation',
        colorinterpolationfilters: 'colorInterpolationFilters',
        'color-interpolation-filters': 'colorInterpolationFilters',
        colorprofile: 'colorProfile',
        'color-profile': 'colorProfile',
        colorrendering: 'colorRendering',
        'color-rendering': 'colorRendering',
        contentscripttype: 'contentScriptType',
        contentstyletype: 'contentStyleType',
        cursor: 'cursor',
        cx: 'cx',
        cy: 'cy',
        d: 'd',
        datatype: 'datatype',
        decelerate: 'decelerate',
        descent: 'descent',
        diffuseconstant: 'diffuseConstant',
        direction: 'direction',
        display: 'display',
        divisor: 'divisor',
        dominantbaseline: 'dominantBaseline',
        'dominant-baseline': 'dominantBaseline',
        dur: 'dur',
        dx: 'dx',
        dy: 'dy',
        edgemode: 'edgeMode',
        elevation: 'elevation',
        enablebackground: 'enableBackground',
        'enable-background': 'enableBackground',
        end: 'end',
        exponent: 'exponent',
        externalresourcesrequired: 'externalResourcesRequired',
        fill: 'fill',
        fillopacity: 'fillOpacity',
        'fill-opacity': 'fillOpacity',
        fillrule: 'fillRule',
        'fill-rule': 'fillRule',
        filter: 'filter',
        filterres: 'filterRes',
        filterunits: 'filterUnits',
        floodopacity: 'floodOpacity',
        'flood-opacity': 'floodOpacity',
        floodcolor: 'floodColor',
        'flood-color': 'floodColor',
        focusable: 'focusable',
        fontfamily: 'fontFamily',
        'font-family': 'fontFamily',
        fontsize: 'fontSize',
        'font-size': 'fontSize',
        fontsizeadjust: 'fontSizeAdjust',
        'font-size-adjust': 'fontSizeAdjust',
        fontstretch: 'fontStretch',
        'font-stretch': 'fontStretch',
        fontstyle: 'fontStyle',
        'font-style': 'fontStyle',
        fontvariant: 'fontVariant',
        'font-variant': 'fontVariant',
        fontweight: 'fontWeight',
        'font-weight': 'fontWeight',
        format: 'format',
        from: 'from',
        fx: 'fx',
        fy: 'fy',
        g1: 'g1',
        g2: 'g2',
        glyphname: 'glyphName',
        'glyph-name': 'glyphName',
        glyphorientationhorizontal: 'glyphOrientationHorizontal',
        'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
        glyphorientationvertical: 'glyphOrientationVertical',
        'glyph-orientation-vertical': 'glyphOrientationVertical',
        glyphref: 'glyphRef',
        gradienttransform: 'gradientTransform',
        gradientunits: 'gradientUnits',
        hanging: 'hanging',
        horizadvx: 'horizAdvX',
        'horiz-adv-x': 'horizAdvX',
        horizoriginx: 'horizOriginX',
        'horiz-origin-x': 'horizOriginX',
        ideographic: 'ideographic',
        imagerendering: 'imageRendering',
        'image-rendering': 'imageRendering',
        in2: 'in2',
        in: 'in',
        inlist: 'inlist',
        intercept: 'intercept',
        k1: 'k1',
        k2: 'k2',
        k3: 'k3',
        k4: 'k4',
        k: 'k',
        kernelmatrix: 'kernelMatrix',
        kernelunitlength: 'kernelUnitLength',
        kerning: 'kerning',
        keypoints: 'keyPoints',
        keysplines: 'keySplines',
        keytimes: 'keyTimes',
        lengthadjust: 'lengthAdjust',
        letterspacing: 'letterSpacing',
        'letter-spacing': 'letterSpacing',
        lightingcolor: 'lightingColor',
        'lighting-color': 'lightingColor',
        limitingconeangle: 'limitingConeAngle',
        local: 'local',
        markerend: 'markerEnd',
        'marker-end': 'markerEnd',
        markerheight: 'markerHeight',
        markermid: 'markerMid',
        'marker-mid': 'markerMid',
        markerstart: 'markerStart',
        'marker-start': 'markerStart',
        markerunits: 'markerUnits',
        markerwidth: 'markerWidth',
        mask: 'mask',
        maskcontentunits: 'maskContentUnits',
        maskunits: 'maskUnits',
        mathematical: 'mathematical',
        mode: 'mode',
        numoctaves: 'numOctaves',
        offset: 'offset',
        opacity: 'opacity',
        operator: 'operator',
        order: 'order',
        orient: 'orient',
        orientation: 'orientation',
        origin: 'origin',
        overflow: 'overflow',
        overlineposition: 'overlinePosition',
        'overline-position': 'overlinePosition',
        overlinethickness: 'overlineThickness',
        'overline-thickness': 'overlineThickness',
        paintorder: 'paintOrder',
        'paint-order': 'paintOrder',
        panose1: 'panose1',
        'panose-1': 'panose1',
        pathlength: 'pathLength',
        patterncontentunits: 'patternContentUnits',
        patterntransform: 'patternTransform',
        patternunits: 'patternUnits',
        pointerevents: 'pointerEvents',
        'pointer-events': 'pointerEvents',
        points: 'points',
        pointsatx: 'pointsAtX',
        pointsaty: 'pointsAtY',
        pointsatz: 'pointsAtZ',
        prefix: 'prefix',
        preservealpha: 'preserveAlpha',
        preserveaspectratio: 'preserveAspectRatio',
        primitiveunits: 'primitiveUnits',
        property: 'property',
        r: 'r',
        radius: 'radius',
        refx: 'refX',
        refy: 'refY',
        renderingintent: 'renderingIntent',
        'rendering-intent': 'renderingIntent',
        repeatcount: 'repeatCount',
        repeatdur: 'repeatDur',
        requiredextensions: 'requiredExtensions',
        requiredfeatures: 'requiredFeatures',
        resource: 'resource',
        restart: 'restart',
        result: 'result',
        results: 'results',
        rotate: 'rotate',
        rx: 'rx',
        ry: 'ry',
        scale: 'scale',
        security: 'security',
        seed: 'seed',
        shaperendering: 'shapeRendering',
        'shape-rendering': 'shapeRendering',
        slope: 'slope',
        spacing: 'spacing',
        specularconstant: 'specularConstant',
        specularexponent: 'specularExponent',
        speed: 'speed',
        spreadmethod: 'spreadMethod',
        startoffset: 'startOffset',
        stddeviation: 'stdDeviation',
        stemh: 'stemh',
        stemv: 'stemv',
        stitchtiles: 'stitchTiles',
        stopcolor: 'stopColor',
        'stop-color': 'stopColor',
        stopopacity: 'stopOpacity',
        'stop-opacity': 'stopOpacity',
        strikethroughposition: 'strikethroughPosition',
        'strikethrough-position': 'strikethroughPosition',
        strikethroughthickness: 'strikethroughThickness',
        'strikethrough-thickness': 'strikethroughThickness',
        string: 'string',
        stroke: 'stroke',
        strokedasharray: 'strokeDasharray',
        'stroke-dasharray': 'strokeDasharray',
        strokedashoffset: 'strokeDashoffset',
        'stroke-dashoffset': 'strokeDashoffset',
        strokelinecap: 'strokeLinecap',
        'stroke-linecap': 'strokeLinecap',
        strokelinejoin: 'strokeLinejoin',
        'stroke-linejoin': 'strokeLinejoin',
        strokemiterlimit: 'strokeMiterlimit',
        'stroke-miterlimit': 'strokeMiterlimit',
        strokewidth: 'strokeWidth',
        'stroke-width': 'strokeWidth',
        strokeopacity: 'strokeOpacity',
        'stroke-opacity': 'strokeOpacity',
        suppresscontenteditablewarning: 'suppressContentEditableWarning',
        suppresshydrationwarning: 'suppressHydrationWarning',
        surfacescale: 'surfaceScale',
        systemlanguage: 'systemLanguage',
        tablevalues: 'tableValues',
        targetx: 'targetX',
        targety: 'targetY',
        textanchor: 'textAnchor',
        'text-anchor': 'textAnchor',
        textdecoration: 'textDecoration',
        'text-decoration': 'textDecoration',
        textlength: 'textLength',
        textrendering: 'textRendering',
        'text-rendering': 'textRendering',
        to: 'to',
        transform: 'transform',
        typeof: 'typeof',
        u1: 'u1',
        u2: 'u2',
        underlineposition: 'underlinePosition',
        'underline-position': 'underlinePosition',
        underlinethickness: 'underlineThickness',
        'underline-thickness': 'underlineThickness',
        unicode: 'unicode',
        unicodebidi: 'unicodeBidi',
        'unicode-bidi': 'unicodeBidi',
        unicoderange: 'unicodeRange',
        'unicode-range': 'unicodeRange',
        unitsperem: 'unitsPerEm',
        'units-per-em': 'unitsPerEm',
        unselectable: 'unselectable',
        valphabetic: 'vAlphabetic',
        'v-alphabetic': 'vAlphabetic',
        values: 'values',
        vectoreffect: 'vectorEffect',
        'vector-effect': 'vectorEffect',
        version: 'version',
        vertadvy: 'vertAdvY',
        'vert-adv-y': 'vertAdvY',
        vertoriginx: 'vertOriginX',
        'vert-origin-x': 'vertOriginX',
        vertoriginy: 'vertOriginY',
        'vert-origin-y': 'vertOriginY',
        vhanging: 'vHanging',
        'v-hanging': 'vHanging',
        videographic: 'vIdeographic',
        'v-ideographic': 'vIdeographic',
        viewbox: 'viewBox',
        viewtarget: 'viewTarget',
        visibility: 'visibility',
        vmathematical: 'vMathematical',
        'v-mathematical': 'vMathematical',
        vocab: 'vocab',
        widths: 'widths',
        wordspacing: 'wordSpacing',
        'word-spacing': 'wordSpacing',
        writingmode: 'writingMode',
        'writing-mode': 'writingMode',
        x1: 'x1',
        x2: 'x2',
        x: 'x',
        xchannelselector: 'xChannelSelector',
        xheight: 'xHeight',
        'x-height': 'xHeight',
        xlinkactuate: 'xlinkActuate',
        'xlink:actuate': 'xlinkActuate',
        xlinkarcrole: 'xlinkArcrole',
        'xlink:arcrole': 'xlinkArcrole',
        xlinkhref: 'xlinkHref',
        'xlink:href': 'xlinkHref',
        xlinkrole: 'xlinkRole',
        'xlink:role': 'xlinkRole',
        xlinkshow: 'xlinkShow',
        'xlink:show': 'xlinkShow',
        xlinktitle: 'xlinkTitle',
        'xlink:title': 'xlinkTitle',
        xlinktype: 'xlinkType',
        'xlink:type': 'xlinkType',
        xmlbase: 'xmlBase',
        'xml:base': 'xmlBase',
        xmllang: 'xmlLang',
        'xml:lang': 'xmlLang',
        xmlns: 'xmlns',
        'xml:space': 'xmlSpace',
        xmlnsxlink: 'xmlnsXlink',
        'xmlns:xlink': 'xmlnsXlink',
        xmlspace: 'xmlSpace',
        y1: 'y1',
        y2: 'y2',
        y: 'y',
        ychannelselector: 'yChannelSelector',
        z: 'z',
        zoomandpan: 'zoomAndPan'
    };
    var ariaProperties = {
        'aria-current': 0,
        // state
        'aria-details': 0,
        'aria-disabled': 0,
        // state
        'aria-hidden': 0,
        // state
        'aria-invalid': 0,
        // state
        'aria-keyshortcuts': 0,
        'aria-label': 0,
        'aria-roledescription': 0,
        // Widget Attributes
        'aria-autocomplete': 0,
        'aria-checked': 0,
        'aria-expanded': 0,
        'aria-haspopup': 0,
        'aria-level': 0,
        'aria-modal': 0,
        'aria-multiline': 0,
        'aria-multiselectable': 0,
        'aria-orientation': 0,
        'aria-placeholder': 0,
        'aria-pressed': 0,
        'aria-readonly': 0,
        'aria-required': 0,
        'aria-selected': 0,
        'aria-sort': 0,
        'aria-valuemax': 0,
        'aria-valuemin': 0,
        'aria-valuenow': 0,
        'aria-valuetext': 0,
        // Live Region Attributes
        'aria-atomic': 0,
        'aria-busy': 0,
        'aria-live': 0,
        'aria-relevant': 0,
        // Drag-and-Drop Attributes
        'aria-dropeffect': 0,
        'aria-grabbed': 0,
        // Relationship Attributes
        'aria-activedescendant': 0,
        'aria-colcount': 0,
        'aria-colindex': 0,
        'aria-colspan': 0,
        'aria-controls': 0,
        'aria-describedby': 0,
        'aria-errormessage': 0,
        'aria-flowto': 0,
        'aria-labelledby': 0,
        'aria-owns': 0,
        'aria-posinset': 0,
        'aria-rowcount': 0,
        'aria-rowindex': 0,
        'aria-rowspan': 0,
        'aria-setsize': 0
    };
    var warnedProperties = {
    };
    var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
    var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    function validateProperty(tagName, name) {
        if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) return true;
        if (rARIACamel.test(name)) {
            var ariaName = 'aria-' + name.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM
            // DOM properties, then it is an invalid aria-* attribute.
            if (correctName == null) {
                error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);
                warnedProperties[name] = true;
                return true;
            } // aria-* attributes should be lowercase; suggest the lowercase version.
            if (name !== correctName) {
                error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);
                warnedProperties[name] = true;
                return true;
            }
        }
        if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM
            // DOM properties, then it is an invalid aria-* attribute.
            if (standardName == null) {
                warnedProperties[name] = true;
                return false;
            } // aria-* attributes should be lowercase; suggest the lowercase version.
            if (name !== standardName) {
                error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);
                warnedProperties[name] = true;
                return true;
            }
        }
        return true;
    }
    function warnInvalidARIAProps(type, props) {
        var invalidProps = [];
        for(var key in props){
            var isValid = validateProperty(type, key);
            if (!isValid) invalidProps.push(key);
        }
        var unknownPropString = invalidProps.map(function(prop) {
            return '`' + prop + '`';
        }).join(', ');
        if (invalidProps.length === 1) error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
        else if (invalidProps.length > 1) error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
    }
    function validateProperties(type, props) {
        if (isCustomComponent(type, props)) return;
        warnInvalidARIAProps(type, props);
    }
    var didWarnValueNull = false;
    function validateProperties$1(type, props) {
        if (type !== 'input' && type !== 'textarea' && type !== 'select') return;
        if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === 'select' && props.multiple) error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
            else error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
        }
    }
    var validateProperty$1 = function() {
    };
    var warnedProperties$1 = {
    };
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var EVENT_NAME_REGEX = /^on./;
    var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
    var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
    var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
    validateProperty$1 = function(tagName, name, value, eventRegistry) {
        if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) return true;
        var lowerCasedName = name.toLowerCase();
        if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name] = true;
            return true;
        } // We can't rely on the event system being injected on the server.
        if (eventRegistry != null) {
            var registrationNameDependencies1 = eventRegistry.registrationNameDependencies, possibleRegistrationNames1 = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies1.hasOwnProperty(name)) return true;
            var registrationName = possibleRegistrationNames1.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames1[lowerCasedName] : null;
            if (registrationName != null) {
                error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);
                warnedProperties$1[name] = true;
                return true;
            }
            if (EVENT_NAME_REGEX.test(name)) {
                error('Unknown event handler property `%s`. It will be ignored.', name);
                warnedProperties$1[name] = true;
                return true;
            }
        } else if (EVENT_NAME_REGEX.test(name)) {
            // If no event plugins have been injected, we are in a server environment.
            // So we can't tell if the event name is correct for sure, but we can filter
            // out known bad ones like `onclick`. We can't suggest a specific replacement though.
            if (INVALID_EVENT_NAME_REGEX.test(name)) error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
            warnedProperties$1[name] = true;
            return true;
        } // Let the ARIA attribute hook validate ARIA attributes
        if (rARIA$1.test(name) || rARIACamel$1.test(name)) return true;
        if (lowerCasedName === 'innerhtml') {
            error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name] = true;
            return true;
        }
        if (lowerCasedName === 'aria') {
            error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name] = true;
            return true;
        }
        if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
            warnedProperties$1[name] = true;
            return true;
        }
        if (typeof value === 'number' && isNaN(value)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
            warnedProperties$1[name] = true;
            return true;
        }
        var propertyInfo = getPropertyInfo(name);
        var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name) {
                error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);
                warnedProperties$1[name] = true;
                return true;
            }
        } else if (!isReserved && name !== lowerCasedName) {
            // Unknown attributes should have lowercase casing since that's how they
            // will be cased anyway with server rendering.
            error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
            warnedProperties$1[name] = true;
            return true;
        }
        if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            if (value) error("Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.", value, name, name, value, name);
            else error("Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", value, name, name, value, name, name, name);
            warnedProperties$1[name] = true;
            return true;
        } // Now that we've validated casing, do not validate
        // data types for reserved props
        if (isReserved) return true;
         // Warn when a known attribute is a bad type
        if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            warnedProperties$1[name] = true;
            return false;
        } // Warn when passing the strings 'false' or 'true' into a boolean prop
        if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties$1[name] = true;
            return true;
        }
        return true;
    };
    var warnUnknownProperties = function(type, props, eventRegistry) {
        var unknownProps = [];
        for(var key in props){
            var isValid = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid) unknownProps.push(key);
        }
        var unknownPropString = unknownProps.map(function(prop) {
            return '`' + prop + '`';
        }).join(', ');
        if (unknownProps.length === 1) error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
        else if (unknownProps.length > 1) error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
    };
    function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) return;
        warnUnknownProperties(type, props, eventRegistry);
    }
    var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
    var IS_NON_DELEGATED = 2;
    var IS_CAPTURE_PHASE = 4;
    var IS_REPLAYED = 16;
    // set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when
    // we call willDeferLaterForLegacyFBSupport, thus not bailing out
    // will result in endless cycles like an infinite loop.
    // We also don't want to defer during event replaying.
    var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
    /**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */ function getEventTarget(nativeEvent) {
        // Fallback to nativeEvent.srcElement for IE9
        // https://github.com/facebook/react/issues/12506
        var target = nativeEvent.target || nativeEvent.srcElement || window; // Normalize SVG <use> element events #4963
        if (target.correspondingUseElement) target = target.correspondingUseElement;
         // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
        // @see http://www.quirksmode.org/js/events_properties.html
        return target.nodeType === TEXT_NODE ? target.parentNode : target;
    }
    var restoreImpl = null;
    var restoreTarget = null;
    var restoreQueue = null;
    function restoreStateOfTarget(target) {
        // We perform this translation at the end of the event loop so that we
        // always receive the correct fiber here
        var internalInstance = getInstanceFromNode(target);
        if (!internalInstance) // Unmounted
        return;
        if (!(typeof restoreImpl === 'function')) throw Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var stateNode = internalInstance.stateNode; // Guard against Fiber being unmounted.
        if (stateNode) {
            var _props = getFiberCurrentPropsFromNode(stateNode);
            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
        }
    }
    function setRestoreImplementation(impl) {
        restoreImpl = impl;
    }
    function enqueueStateRestore(target) {
        if (restoreTarget) {
            if (restoreQueue) restoreQueue.push(target);
            else restoreQueue = [
                target
            ];
        } else restoreTarget = target;
    }
    function needsStateRestore() {
        return restoreTarget !== null || restoreQueue !== null;
    }
    function restoreStateIfNeeded() {
        if (!restoreTarget) return;
        var target = restoreTarget;
        var queuedTargets = restoreQueue;
        restoreTarget = null;
        restoreQueue = null;
        restoreStateOfTarget(target);
        if (queuedTargets) for(var i = 0; i < queuedTargets.length; i++)restoreStateOfTarget(queuedTargets[i]);
    }
    // the renderer. Such as when we're dispatching events or if third party
    // libraries need to call batchedUpdates. Eventually, this API will go away when
    // everything is batched by default. We'll then have a similar API to opt-out of
    // scheduled work and instead do synchronous work.
    // Defaults
    var batchedUpdatesImpl = function(fn, bookkeeping) {
        return fn(bookkeeping);
    };
    var discreteUpdatesImpl = function(fn, a, b, c, d) {
        return fn(a, b, c, d);
    };
    var flushDiscreteUpdatesImpl = function() {
    };
    var batchedEventUpdatesImpl = batchedUpdatesImpl;
    var isInsideEventHandler = false;
    var isBatchingEventUpdates = false;
    function finishEventHandler() {
        // Here we wait until all updates have propagated, which is important
        // when using controlled components within layers:
        // https://github.com/facebook/react/issues/1698
        // Then we restore state of any controlled component.
        var controlledComponentsHavePendingUpdates = needsStateRestore();
        if (controlledComponentsHavePendingUpdates) {
            // If a controlled event was fired, we may need to restore the state of
            // the DOM node back to the controlled value. This is necessary when React
            // bails out of the update without touching the DOM.
            flushDiscreteUpdatesImpl();
            restoreStateIfNeeded();
        }
    }
    function batchedUpdates(fn, bookkeeping) {
        if (isInsideEventHandler) // If we are currently inside another batch, we need to wait until it
        // fully completes before restoring state.
        return fn(bookkeeping);
        isInsideEventHandler = true;
        try {
            return batchedUpdatesImpl(fn, bookkeeping);
        } finally{
            isInsideEventHandler = false;
            finishEventHandler();
        }
    }
    function batchedEventUpdates(fn, a, b) {
        if (isBatchingEventUpdates) // If we are currently inside another batch, we need to wait until it
        // fully completes before restoring state.
        return fn(a, b);
        isBatchingEventUpdates = true;
        try {
            return batchedEventUpdatesImpl(fn, a, b);
        } finally{
            isBatchingEventUpdates = false;
            finishEventHandler();
        }
    }
    function discreteUpdates(fn, a, b, c, d) {
        var prevIsInsideEventHandler = isInsideEventHandler;
        isInsideEventHandler = true;
        try {
            return discreteUpdatesImpl(fn, a, b, c, d);
        } finally{
            isInsideEventHandler = prevIsInsideEventHandler;
            if (!isInsideEventHandler) finishEventHandler();
        }
    }
    function flushDiscreteUpdatesIfNeeded(timeStamp) {
        if (!isInsideEventHandler) flushDiscreteUpdatesImpl();
    }
    function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {
        batchedUpdatesImpl = _batchedUpdatesImpl;
        discreteUpdatesImpl = _discreteUpdatesImpl;
        flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;
        batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
    }
    function isInteractive(tag) {
        return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
    }
    function shouldPreventMouseEvent(name, type, props) {
        switch(name){
            case 'onClick':
            case 'onClickCapture':
            case 'onDoubleClick':
            case 'onDoubleClickCapture':
            case 'onMouseDown':
            case 'onMouseDownCapture':
            case 'onMouseMove':
            case 'onMouseMoveCapture':
            case 'onMouseUp':
            case 'onMouseUpCapture':
            case 'onMouseEnter':
                return !!(props.disabled && isInteractive(type));
            default:
                return false;
        }
    }
    /**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */ function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (stateNode === null) // Work in progress (ex: onload events in incremental mode).
        return null;
        var props = getFiberCurrentPropsFromNode(stateNode);
        if (props === null) // Work in progress.
        return null;
        var listener = props[registrationName];
        if (shouldPreventMouseEvent(registrationName, inst.type, props)) return null;
        if (!(!listener || typeof listener === 'function')) throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
        return listener;
    }
    var passiveBrowserEventsSupported = false; // Check if browser support events with passive listeners
    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
    if (canUseDOM) try {
        var options = {
        }; // $FlowFixMe: Ignore Flow complaining about needing a value
        Object.defineProperty(options, 'passive', {
            get: function() {
                passiveBrowserEventsSupported = true;
            }
        });
        window.addEventListener('test', options, options);
        window.removeEventListener('test', options, options);
    } catch (e) {
        passiveBrowserEventsSupported = false;
    }
    function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
        var funcArgs = Array.prototype.slice.call(arguments, 3);
        try {
            func.apply(context, funcArgs);
        } catch (error1) {
            this.onError(error1);
        }
    }
    var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
    // In DEV mode, we swap out invokeGuardedCallback for a special version
    // that plays more nicely with the browser's DevTools. The idea is to preserve
    // "Pause on exceptions" behavior. Because React wraps all user-provided
    // functions in invokeGuardedCallback, and the production version of
    // invokeGuardedCallback uses a try-catch, all user exceptions are treated
    // like caught exceptions, and the DevTools won't pause unless the developer
    // takes the extra step of enabling pause on caught exceptions. This is
    // unintuitive, though, because even though React has caught the error, from
    // the developer's perspective, the error is uncaught.
    //
    // To preserve the expected "Pause on exceptions" behavior, we don't use a
    // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
    // DOM node, and call the user-provided callback from inside an event handler
    // for that fake event. If the callback throws, the error is "captured" using
    // a global event handler. But because the error happens in a different
    // event loop context, it does not interrupt the normal program flow.
    // Effectively, this gives us try-catch behavior without actually using
    // try-catch. Neat!
    // Check that the browser supports the APIs we need to implement our special
    // DEV version of invokeGuardedCallback
    if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
        var fakeNode = document.createElement('react');
        invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
            // If document doesn't exist we know for sure we will crash in this method
            // when we call document.createEvent(). However this can cause confusing
            // errors: https://github.com/facebookincubator/create-react-app/issues/3482
            // So we preemptively throw with a better message instead.
            if (!(typeof document !== 'undefined')) throw Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
            var evt = document.createEvent('Event');
            var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
            // set this to true at the beginning, then set it to false right after
            // calling the function. If the function errors, `didError` will never be
            // set to false. This strategy works even if the browser is flaky and
            // fails to call our global error handler, because it doesn't rely on
            // the error event at all.
            var didError = true; // Keeps track of the value of window.event so that we can reset it
            // during the callback to let user code access window.event in the
            // browsers that support it.
            var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event
            // dispatching: https://github.com/facebook/react/issues/13688
            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');
            function restoreAfterDispatch() {
                // We immediately remove the callback from event listeners so that
                // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
                // nested call would trigger the fake event handlers of any call higher
                // in the stack.
                fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the
                // window.event assignment in both IE <= 10 as they throw an error
                // "Member not found" in strict mode, and in Firefox which does not
                // support window.event.
                if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) window.event = windowEvent;
            } // Create an event handler for our fake event. We will synchronously
            // dispatch our fake event using `dispatchEvent`. Inside the handler, we
            // call the user-provided callback.
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            function callCallback() {
                didCall = true;
                restoreAfterDispatch();
                func.apply(context, funcArgs);
                didError = false;
            } // Create a global error event handler. We use this to capture the value
            // that was thrown. It's possible that this error handler will fire more
            // than once; for example, if non-React code also calls `dispatchEvent`
            // and a handler for that event throws. We should be resilient to most of
            // those cases. Even if our error event handler fires more than once, the
            // last error event is always used. If the callback actually does error,
            // we know that the last error event is the correct one, because it's not
            // possible for anything else to have happened in between our callback
            // erroring and the code that follows the `dispatchEvent` call below. If
            // the callback doesn't error, but the error event was fired, we know to
            // ignore it because `didError` will be false, as described above.
            var error1; // Use this to track whether the error event is ever called.
            var didSetError = false;
            var isCrossOriginError = false;
            function handleWindowError(event) {
                error1 = event.error;
                didSetError = true;
                if (error1 === null && event.colno === 0 && event.lineno === 0) isCrossOriginError = true;
                if (event.defaultPrevented) {
                    // Some other error handler has prevented default.
                    // Browsers silence the error report if this happens.
                    // We'll remember this to later decide whether to log it or not.
                    if (error1 != null && typeof error1 === 'object') try {
                        error1._suppressLogging = true;
                    } catch (inner) {
                    }
                }
            } // Create a fake event type.
            var evtType = "react-" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers
            window.addEventListener('error', handleWindowError);
            fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
            // errors, it will trigger our global error handler.
            evt.initEvent(evtType, false, false);
            fakeNode.dispatchEvent(evt);
            if (windowEventDescriptor) Object.defineProperty(window, 'event', windowEventDescriptor);
            if (didCall && didError) {
                if (!didSetError) // The callback errored, but the error event never fired.
                error1 = new Error("An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the \"Pause on exceptions\" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.");
                else if (isCrossOriginError) error1 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                this.onError(error1);
            } // Remove our event listeners
            window.removeEventListener('error', handleWindowError);
            if (!didCall) {
                // Something went really wrong, and our event was not dispatched.
                // https://github.com/facebook/react/issues/16734
                // https://github.com/facebook/react/issues/16585
                // Fall back to the production implementation.
                restoreAfterDispatch();
                return invokeGuardedCallbackProd.apply(this, arguments);
            }
        };
    }
    var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
    var hasError = false;
    var caughtError = null; // Used by event system to capture/rethrow the first error.
    var hasRethrowError = false;
    var rethrowError = null;
    var reporter = {
        onError: function(error1) {
            hasError = true;
            caughtError = error1;
        }
    };
    /**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */ function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
        hasError = false;
        caughtError = null;
        invokeGuardedCallbackImpl$1.apply(reporter, arguments);
    }
    /**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */ function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
        invokeGuardedCallback.apply(this, arguments);
        if (hasError) {
            var error1 = clearCaughtError();
            if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error1;
            }
        }
    }
    /**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */ function rethrowCaughtError() {
        if (hasRethrowError) {
            var error2 = rethrowError;
            hasRethrowError = false;
            rethrowError = null;
            throw error2;
        }
    }
    function hasCaughtError() {
        return hasError;
    }
    function clearCaughtError() {
        if (hasError) {
            var error3 = caughtError;
            hasError = false;
            caughtError = null;
            return error3;
        } else throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    /**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */ function get(key) {
        return key._reactInternals;
    }
    function has(key) {
        return key._reactInternals !== undefined;
    }
    function set(key, value) {
        key._reactInternals = value;
    }
    // Don't change these two values. They're used by React Dev Tools.
    var NoFlags = /*                      */ 0;
    var PerformedWork = /*                */ 1; // You can change the rest (and add more).
    var Placement = /*                    */ 2;
    var Update = /*                       */ 4;
    var PlacementAndUpdate = /*           */ 6;
    var Deletion = /*                     */ 8;
    var ContentReset = /*                 */ 16;
    var Callback = /*                     */ 32;
    var DidCapture = /*                   */ 64;
    var Ref = /*                          */ 128;
    var Snapshot = /*                     */ 256;
    var Passive = /*                      */ 512; // TODO (effects) Remove this bit once the new reconciler is synced to the old.
    var PassiveUnmountPendingDev = /*     */ 8192;
    var Hydrating = /*                    */ 1024;
    var HydratingAndUpdate = /*           */ 1028; // Passive & Update & Callback & Ref & Snapshot
    var LifecycleEffectMask = /*          */ 932; // Union of all host effects
    var HostEffectMask = /*               */ 2047; // These are not really side effects, but we still reuse this field.
    var Incomplete = /*                   */ 2048;
    var ShouldCapture = /*                */ 4096;
    var ForceUpdateForLegacySuspense = /* */ 16384; // Static tags describe aspects of a fiber that are not specific to a render,
    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    function getNearestMountedFiber(fiber) {
        var node = fiber;
        var nearestMounted = fiber;
        if (!fiber.alternate) {
            // If there is no alternate, this might be a new tree that isn't inserted
            // yet. If it is, then it will have a pending insertion effect on it.
            var nextNode = node;
            do {
                node = nextNode;
                if ((node.flags & (Placement | Hydrating)) !== NoFlags) // This is an insertion or in-progress hydration. The nearest possible
                // mounted fiber is the parent but we need to continue to figure out
                // if that one is still mounted.
                nearestMounted = node.return;
                nextNode = node.return;
            }while (nextNode)
        } else while(node.return)node = node.return;
        if (node.tag === HostRoot) // TODO: Check if this was a nested HostRoot when used with
        // renderContainerIntoSubtree.
        return nearestMounted;
         // If we didn't hit the root, that means that we're in an disconnected tree
        // that has been unmounted.
        return null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
        if (fiber.tag === SuspenseComponent) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState === null) {
                var current1 = fiber.alternate;
                if (current1 !== null) suspenseState = current1.memoizedState;
            }
            if (suspenseState !== null) return suspenseState.dehydrated;
        }
        return null;
    }
    function getContainerFromFiber(fiber) {
        return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
    }
    function isFiberMounted(fiber) {
        return getNearestMountedFiber(fiber) === fiber;
    }
    function isMounted(component) {
        var owner = ReactCurrentOwner.current;
        if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner;
            var instance = ownerFiber.stateNode;
            if (!instance._warnedAboutRefsInRender) error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(ownerFiber.type) || 'A component');
            instance._warnedAboutRefsInRender = true;
        }
        var fiber = get(component);
        if (!fiber) return false;
        return getNearestMountedFiber(fiber) === fiber;
    }
    function assertIsMounted(fiber) {
        if (!(getNearestMountedFiber(fiber) === fiber)) throw Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
            // If there is no alternate, then we only need to check if it is mounted.
            var nearestMounted = getNearestMountedFiber(fiber);
            if (!(nearestMounted !== null)) throw Error("Unable to find node on an unmounted component.");
            if (nearestMounted !== fiber) return null;
            return fiber;
        } // If we have two possible branches, we'll walk backwards up to the root
        // to see what path the root points to. On the way we may hit one of the
        // special cases and we'll deal with them.
        var a = fiber;
        var b = alternate;
        while(true){
            var parentA = a.return;
            if (parentA === null) break;
            var parentB = parentA.alternate;
            if (parentB === null) {
                // There is no alternate. This is an unusual case. Currently, it only
                // happens when a Suspense component is hidden. An extra fragment fiber
                // is inserted in between the Suspense fiber and its children. Skip
                // over this extra fragment fiber and proceed to the next parent.
                var nextParent = parentA.return;
                if (nextParent !== null) {
                    a = b = nextParent;
                    continue;
                } // If there's no parent, we're at the root.
                break;
            } // If both copies of the parent fiber point to the same child, we can
            // assume that the child is current. This happens when we bailout on low
            // priority: the bailed out fiber's child reuses the current child.
            if (parentA.child === parentB.child) {
                var child = parentA.child;
                while(child){
                    if (child === a) {
                        // We've determined that A is the current branch.
                        assertIsMounted(parentA);
                        return fiber;
                    }
                    if (child === b) {
                        // We've determined that B is the current branch.
                        assertIsMounted(parentA);
                        return alternate;
                    }
                    child = child.sibling;
                } // We should never have an alternate for any mounting node. So the only
                throw Error("Unable to find node on an unmounted component.");
            }
            if (a.return !== b.return) {
                // The return pointer of A and the return pointer of B point to different
                // fibers. We assume that return pointers never criss-cross, so A must
                // belong to the child set of A.return, and B must belong to the child
                // set of B.return.
                a = parentA;
                b = parentB;
            } else {
                // The return pointers point to the same fiber. We'll have to use the
                // default, slow path: scan the child sets of each parent alternate to see
                // which child belongs to which set.
                //
                // Search parent A's child set
                var didFindChild = false;
                var _child = parentA.child;
                while(_child){
                    if (_child === a) {
                        didFindChild = true;
                        a = parentA;
                        b = parentB;
                        break;
                    }
                    if (_child === b) {
                        didFindChild = true;
                        b = parentA;
                        a = parentB;
                        break;
                    }
                    _child = _child.sibling;
                }
                if (!didFindChild) {
                    // Search parent B's child set
                    _child = parentB.child;
                    while(_child){
                        if (_child === a) {
                            didFindChild = true;
                            a = parentB;
                            b = parentA;
                            break;
                        }
                        if (_child === b) {
                            didFindChild = true;
                            b = parentB;
                            a = parentA;
                            break;
                        }
                        _child = _child.sibling;
                    }
                    if (!didFindChild) throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                }
            }
            if (!(a.alternate === b)) throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
        } // If the root is not a host container, we're in a disconnected tree. I.e.
        // unmounted.
        if (!(a.tag === HostRoot)) throw Error("Unable to find node on an unmounted component.");
        if (a.stateNode.current === a) // We've determined that A is the current branch.
        return fiber;
         // Otherwise B has to be current branch.
        return alternate;
    }
    function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        if (!currentParent) return null;
         // Next we'll drill down this component to find the first HostComponent/Text.
        var node = currentParent;
        while(true){
            if (node.tag === HostComponent || node.tag === HostText) return node;
            else if (node.child) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === currentParent) return null;
            while(!node.sibling){
                if (!node.return || node.return === currentParent) return null;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        } // Flow needs the return null here, but ESLint complains about it.
        // eslint-disable-next-line no-unreachable
        return null;
    }
    function findCurrentHostFiberWithNoPortals(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        if (!currentParent) return null;
         // Next we'll drill down this component to find the first HostComponent/Text.
        var node = currentParent;
        while(true){
            if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI) return node;
            else if (node.child && node.tag !== HostPortal) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === currentParent) return null;
            while(!node.sibling){
                if (!node.return || node.return === currentParent) return null;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        } // Flow needs the return null here, but ESLint complains about it.
        // eslint-disable-next-line no-unreachable
        return null;
    }
    function doesFiberContain(parentFiber, childFiber) {
        var node = childFiber;
        var parentFiberAlternate = parentFiber.alternate;
        while(node !== null){
            if (node === parentFiber || node === parentFiberAlternate) return true;
            node = node.return;
        }
        return false;
    }
    var attemptUserBlockingHydration;
    function setAttemptUserBlockingHydration(fn) {
        attemptUserBlockingHydration = fn;
    }
    var attemptContinuousHydration;
    function setAttemptContinuousHydration(fn) {
        attemptContinuousHydration = fn;
    }
    var attemptHydrationAtCurrentPriority;
    function setAttemptHydrationAtCurrentPriority(fn) {
        attemptHydrationAtCurrentPriority = fn;
    }
    var attemptHydrationAtPriority;
    function setAttemptHydrationAtPriority(fn) {
        attemptHydrationAtPriority = fn;
    } // TODO: Upgrade this definition once we're on a newer version of Flow that
    var hasScheduledReplayAttempt = false; // The queue of discrete events to be replayed.
    var queuedDiscreteEvents = []; // Indicates if any continuous event targets are non-null for early bailout.
    // if the last target was dehydrated.
    var queuedFocus = null;
    var queuedDrag = null;
    var queuedMouse = null; // For pointer events there can be one latest event per pointerId.
    var queuedPointers = new Map();
    var queuedPointerCaptures = new Map(); // We could consider replaying selectionchange and touchmoves too.
    var queuedExplicitHydrationTargets = [];
    function hasQueuedDiscreteEvents() {
        return queuedDiscreteEvents.length > 0;
    }
    var discreteReplayableEvents = [
        'mousedown',
        'mouseup',
        'touchcancel',
        'touchend',
        'touchstart',
        'auxclick',
        'dblclick',
        'pointercancel',
        'pointerdown',
        'pointerup',
        'dragend',
        'dragstart',
        'drop',
        'compositionend',
        'compositionstart',
        'keydown',
        'keypress',
        'keyup',
        'input',
        'textInput',
        'copy',
        'cut',
        'paste',
        'click',
        'change',
        'contextmenu',
        'reset',
        'submit'
    ];
    function isReplayableDiscreteEvent(eventType) {
        return discreteReplayableEvents.indexOf(eventType) > -1;
    }
    function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        return {
            blockedOn: blockedOn,
            domEventName: domEventName,
            eventSystemFlags: eventSystemFlags | IS_REPLAYED,
            nativeEvent: nativeEvent,
            targetContainers: [
                targetContainer
            ]
        };
    }
    function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
        queuedDiscreteEvents.push(queuedEvent);
    } // Resets the replaying for this type of continuous event to no event.
    function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch(domEventName){
            case 'focusin':
            case 'focusout':
                queuedFocus = null;
                break;
            case 'dragenter':
            case 'dragleave':
                queuedDrag = null;
                break;
            case 'mouseover':
            case 'mouseout':
                queuedMouse = null;
                break;
            case 'pointerover':
            case 'pointerout':
                var pointerId = nativeEvent.pointerId;
                queuedPointers.delete(pointerId);
                break;
            case 'gotpointercapture':
            case 'lostpointercapture':
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
        }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode(blockedOn);
                if (_fiber2 !== null) // Attempt to increase the priority of this target.
                attemptContinuousHydration(_fiber2);
            }
            return queuedEvent;
        } // If we have already queued this exact event, then it's because
        // the different event systems have different DOM event listeners.
        // We can accumulate the flags, and the targetContainers, and
        // store a single event to be replayed.
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        var targetContainers = existingQueuedEvent.targetContainers;
        if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) targetContainers.push(targetContainer);
        return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        // These set relatedTarget to null because the replayed event will be treated as if we
        // moved from outside the window (no target) onto the target once it hydrates.
        // Instead of mutating we could clone the event.
        switch(domEventName){
            case 'focusin':
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                return true;
            case 'dragenter':
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                return true;
            case 'mouseover':
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                return true;
            case 'pointerover':
                var pointerEvent = nativeEvent;
                var pointerId = pointerEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                return true;
            case 'gotpointercapture':
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                return true;
        }
        return false;
    } // Check if this target is unblocked. Returns true if it's unblocked.
    function attemptExplicitHydrationTarget(queuedTarget) {
        // TODO: This function shares a lot of logic with attemptToDispatchEvent.
        // Try to unify them. It's a bit tricky since it would require two return
        // values.
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted !== null) {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                    var instance = getSuspenseInstanceFromFiber(nearestMounted);
                    if (instance !== null) {
                        // We're blocked on hydrating this boundary.
                        // Increase its priority.
                        queuedTarget.blockedOn = instance;
                        attemptHydrationAtPriority(queuedTarget.lanePriority, function() {
                            Scheduler.unstable_runWithPriority(queuedTarget.priority, function() {
                                attemptHydrationAtCurrentPriority(nearestMounted);
                            });
                        });
                        return;
                    }
                } else if (tag === HostRoot) {
                    var root = nearestMounted.stateNode;
                    if (root.hydrate) {
                        queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); // We don't currently have a way to increase the priority of
                        // a root other than sync.
                        return;
                    }
                }
            }
        }
        queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (queuedEvent.blockedOn !== null) return false;
        var targetContainers = queuedEvent.targetContainers;
        while(targetContainers.length > 0){
            var targetContainer = targetContainers[0];
            var nextBlockedOn = attemptToDispatchEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
            if (nextBlockedOn !== null) {
                // We're still blocked. Try again later.
                var _fiber3 = getInstanceFromNode(nextBlockedOn);
                if (_fiber3 !== null) attemptContinuousHydration(_fiber3);
                queuedEvent.blockedOn = nextBlockedOn;
                return false;
            } // This target container was successfully dispatched. Try the next.
            targetContainers.shift();
        }
        return true;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        if (attemptReplayContinuousQueuedEvent(queuedEvent)) map.delete(key);
    }
    function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false; // First replay discrete events.
        while(queuedDiscreteEvents.length > 0){
            var nextDiscreteEvent = queuedDiscreteEvents[0];
            if (nextDiscreteEvent.blockedOn !== null) {
                // We're still blocked.
                // Increase the priority of this boundary to unblock
                // the next discrete event.
                var _fiber4 = getInstanceFromNode(nextDiscreteEvent.blockedOn);
                if (_fiber4 !== null) attemptUserBlockingHydration(_fiber4);
                break;
            }
            var targetContainers = nextDiscreteEvent.targetContainers;
            while(targetContainers.length > 0){
                var targetContainer = targetContainers[0];
                var nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);
                if (nextBlockedOn !== null) {
                    // We're still blocked. Try again later.
                    nextDiscreteEvent.blockedOn = nextBlockedOn;
                    break;
                } // This target container was successfully dispatched. Try the next.
                targetContainers.shift();
            }
            if (nextDiscreteEvent.blockedOn === null) // We've successfully replayed the first event. Let's try the next one.
            queuedDiscreteEvents.shift();
        } // Next replay any continuous events.
        if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) queuedFocus = null;
        if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) queuedDrag = null;
        if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) queuedMouse = null;
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        if (queuedEvent.blockedOn === unblocked) {
            queuedEvent.blockedOn = null;
            if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true; // Schedule a callback to attempt replaying as many events as are
                // now unblocked. This first might not actually be unblocked yet.
                // We could check it early to avoid scheduling an unnecessary callback.
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
            }
        }
    }
    function retryIfBlockedOn(unblocked) {
        // Mark anything that was blocked on this as no longer blocked
        // and eligible for a replay.
        if (queuedDiscreteEvents.length > 0) {
            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked); // This is a exponential search for each boundary that commits. I think it's
            // worth it because we expect very few discrete events to queue up and once
            // we are actually fully unblocked it will be fast to replay them.
            for(var i = 1; i < queuedDiscreteEvents.length; i++){
                var queuedEvent = queuedDiscreteEvents[i];
                if (queuedEvent.blockedOn === unblocked) queuedEvent.blockedOn = null;
            }
        }
        if (queuedFocus !== null) scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        if (queuedDrag !== null) scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        if (queuedMouse !== null) scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        var unblock = function(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        };
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for(var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++){
            var queuedTarget = queuedExplicitHydrationTargets[_i];
            if (queuedTarget.blockedOn === unblocked) queuedTarget.blockedOn = null;
        }
        while(queuedExplicitHydrationTargets.length > 0){
            var nextExplicitTarget = queuedExplicitHydrationTargets[0];
            if (nextExplicitTarget.blockedOn !== null) break;
            else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) // We're unblocked.
                queuedExplicitHydrationTargets.shift();
            }
        }
    }
    var DiscreteEvent = 0;
    var UserBlockingEvent = 1;
    var ContinuousEvent = 2;
    /**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */ function makePrefixMap(styleProp, eventName) {
        var prefixes1 = {
        };
        prefixes1[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes1['Webkit' + styleProp] = 'webkit' + eventName;
        prefixes1['Moz' + styleProp] = 'moz' + eventName;
        return prefixes1;
    }
    /**
 * A list of event names to a configurable list of vendor prefixes.
 */ var vendorPrefixes = {
        animationend: makePrefixMap('Animation', 'AnimationEnd'),
        animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
        animationstart: makePrefixMap('Animation', 'AnimationStart'),
        transitionend: makePrefixMap('Transition', 'TransitionEnd')
    };
    /**
 * Event names that have already been detected and prefixed (if applicable).
 */ var prefixedEventNames = {
    };
    /**
 * Element to check for prefixes on.
 */ var style = {
    };
    /**
 * Bootstrap if a DOM exists.
 */ if (canUseDOM) {
        style = document.createElement('div').style; // On some platforms, in particular some releases of Android 4.x,
        // the un-prefixed "animation" and "transition" properties are defined on the
        // style object but the events that fire will still be prefixed, so we need
        // to check if the un-prefixed events are usable, and if not remove them from the map.
        if (!('AnimationEvent' in window)) {
            delete vendorPrefixes.animationend.animation;
            delete vendorPrefixes.animationiteration.animation;
            delete vendorPrefixes.animationstart.animation;
        } // Same as above
        if (!('TransitionEvent' in window)) delete vendorPrefixes.transitionend.transition;
    }
    /**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */ function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        else if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName];
        for(var styleProp in prefixMap){
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) return prefixedEventNames[eventName] = prefixMap[styleProp];
        }
        return eventName;
    }
    var ANIMATION_END = getVendorPrefixedEventName('animationend');
    var ANIMATION_ITERATION = getVendorPrefixedEventName('animationiteration');
    var ANIMATION_START = getVendorPrefixedEventName('animationstart');
    var TRANSITION_END = getVendorPrefixedEventName('transitionend');
    var topLevelEventsToReactNames = new Map();
    var eventPriorities = new Map(); // We store most of the events in this module in pairs of two strings so we can re-use
    // the code required to apply the same logic for event prioritization and that of the
    // SimpleEventPlugin. This complicates things slightly, but the aim is to reduce code
    // duplication (for which there would be quite a bit). For the events that are not needed
    // for the SimpleEventPlugin (otherDiscreteEvents) we process them separately as an
    // array of top level events.
    // Lastly, we ignore prettier so we can keep the formatting sane.
    // prettier-ignore
    var discreteEventPairsForSimpleEventPlugin = [
        'cancel',
        'cancel',
        'click',
        'click',
        'close',
        'close',
        'contextmenu',
        'contextMenu',
        'copy',
        'copy',
        'cut',
        'cut',
        'auxclick',
        'auxClick',
        'dblclick',
        'doubleClick',
        'dragend',
        'dragEnd',
        'dragstart',
        'dragStart',
        'drop',
        'drop',
        'focusin',
        'focus',
        'focusout',
        'blur',
        'input',
        'input',
        'invalid',
        'invalid',
        'keydown',
        'keyDown',
        'keypress',
        'keyPress',
        'keyup',
        'keyUp',
        'mousedown',
        'mouseDown',
        'mouseup',
        'mouseUp',
        'paste',
        'paste',
        'pause',
        'pause',
        'play',
        'play',
        'pointercancel',
        'pointerCancel',
        'pointerdown',
        'pointerDown',
        'pointerup',
        'pointerUp',
        'ratechange',
        'rateChange',
        'reset',
        'reset',
        'seeked',
        'seeked',
        'submit',
        'submit',
        'touchcancel',
        'touchCancel',
        'touchend',
        'touchEnd',
        'touchstart',
        'touchStart',
        'volumechange',
        'volumeChange'
    ];
    var otherDiscreteEvents = [
        'change',
        'selectionchange',
        'textInput',
        'compositionstart',
        'compositionend',
        'compositionupdate'
    ];
    var userBlockingPairsForSimpleEventPlugin = [
        'drag',
        'drag',
        'dragenter',
        'dragEnter',
        'dragexit',
        'dragExit',
        'dragleave',
        'dragLeave',
        'dragover',
        'dragOver',
        'mousemove',
        'mouseMove',
        'mouseout',
        'mouseOut',
        'mouseover',
        'mouseOver',
        'pointermove',
        'pointerMove',
        'pointerout',
        'pointerOut',
        'pointerover',
        'pointerOver',
        'scroll',
        'scroll',
        'toggle',
        'toggle',
        'touchmove',
        'touchMove',
        'wheel',
        'wheel'
    ]; // prettier-ignore
    var continuousPairsForSimpleEventPlugin = [
        'abort',
        'abort',
        ANIMATION_END,
        'animationEnd',
        ANIMATION_ITERATION,
        'animationIteration',
        ANIMATION_START,
        'animationStart',
        'canplay',
        'canPlay',
        'canplaythrough',
        'canPlayThrough',
        'durationchange',
        'durationChange',
        'emptied',
        'emptied',
        'encrypted',
        'encrypted',
        'ended',
        'ended',
        'error',
        'error',
        'gotpointercapture',
        'gotPointerCapture',
        'load',
        'load',
        'loadeddata',
        'loadedData',
        'loadedmetadata',
        'loadedMetadata',
        'loadstart',
        'loadStart',
        'lostpointercapture',
        'lostPointerCapture',
        'playing',
        'playing',
        'progress',
        'progress',
        'seeking',
        'seeking',
        'stalled',
        'stalled',
        'suspend',
        'suspend',
        'timeupdate',
        'timeUpdate',
        TRANSITION_END,
        'transitionEnd',
        'waiting',
        'waiting'
    ];
    /**
 * Turns
 * ['abort', ...]
 *
 * into
 *
 * topLevelEventsToReactNames = new Map([
 *   ['abort', 'onAbort'],
 * ]);
 *
 * and registers them.
 */ function registerSimplePluginEventsAndSetTheirPriorities(eventTypes, priority) {
        // As the event types are in pairs of two, we need to iterate
        // through in twos. The events are in pairs of two to save code
        // and improve init perf of processing this array, as it will
        // result in far fewer object allocations and property accesses
        // if we only use three arrays to process all the categories of
        // instead of tuples.
        for(var i = 0; i < eventTypes.length; i += 2){
            var topEvent = eventTypes[i];
            var event = eventTypes[i + 1];
            var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
            var reactName = 'on' + capitalizedEvent;
            eventPriorities.set(topEvent, priority);
            topLevelEventsToReactNames.set(topEvent, reactName);
            registerTwoPhaseEvent(reactName, [
                topEvent
            ]);
        }
    }
    function setEventPriorities(eventTypes, priority) {
        for(var i = 0; i < eventTypes.length; i++)eventPriorities.set(eventTypes[i], priority);
    }
    function getEventPriorityForPluginSystem(domEventName) {
        var priority = eventPriorities.get(domEventName); // Default to a ContinuousEvent. Note: we might
        // want to warn if we can't detect the priority
        // for the event.
        return priority === undefined ? ContinuousEvent : priority;
    }
    function registerSimpleEvents() {
        registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);
        registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);
        registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin, ContinuousEvent);
        setEventPriorities(otherDiscreteEvents, DiscreteEvent);
    }
    var Scheduler_now = Scheduler.unstable_now;
    // Provide explicit error message when production+profiling bundle of e.g.
    // react-dom is used with production (non-profiling) bundle of
    // scheduler/tracing
    if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
    // ascending numbers so we can compare them like numbers. They start at 90 to
    // avoid clashing with Scheduler's priorities.
    var ImmediatePriority = 99;
    var UserBlockingPriority = 98;
    var NormalPriority = 97;
    var LowPriority = 96;
    var IdlePriority = 95; // NoPriority is the absence of priority. Also React-only.
    var NoPriority = 90;
    var initialTimeMs = Scheduler_now(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.
    var SyncLanePriority = 15;
    var SyncBatchedLanePriority = 14;
    var InputDiscreteHydrationLanePriority = 13;
    var InputDiscreteLanePriority = 12;
    var InputContinuousHydrationLanePriority = 11;
    var InputContinuousLanePriority = 10;
    var DefaultHydrationLanePriority = 9;
    var DefaultLanePriority = 8;
    var TransitionHydrationPriority = 7;
    var TransitionPriority = 6;
    var RetryLanePriority = 5;
    var SelectiveHydrationLanePriority = 4;
    var IdleHydrationLanePriority = 3;
    var IdleLanePriority = 2;
    var OffscreenLanePriority = 1;
    var NoLanePriority = 0;
    var TotalLanes = 31;
    var NoLanes = /*                        */ 0;
    var NoLane = /*                          */ 0;
    var SyncLane = /*                        */ 1;
    var SyncBatchedLane = /*                 */ 2;
    var InputDiscreteHydrationLane = /*      */ 4;
    var InputDiscreteLanes = /*                    */ 24;
    var InputContinuousHydrationLane = /*           */ 32;
    var InputContinuousLanes = /*                  */ 192;
    var DefaultHydrationLane = /*            */ 256;
    var DefaultLanes = /*                   */ 3584;
    var TransitionHydrationLane = /*                */ 4096;
    var TransitionLanes = /*                       */ 4186112;
    var RetryLanes = /*                            */ 62914560;
    var SomeRetryLane = /*                  */ 33554432;
    var SelectiveHydrationLane = /*          */ 67108864;
    var NonIdleLanes = /*                                 */ 134217727;
    var IdleHydrationLane = /*               */ 134217728;
    var IdleLanes = /*                             */ 805306368;
    var OffscreenLane = /*                   */ 1073741824;
    var NoTimestamp = -1;
    function setCurrentUpdateLanePriority(newLanePriority) {
    } // "Registers" used to "return" multiple values
    // Used by getHighestPriorityLanes and getNextLanes:
    var return_highestLanePriority = DefaultLanePriority;
    function getHighestPriorityLanes(lanes) {
        if ((SyncLane & lanes) !== NoLanes) {
            return_highestLanePriority = SyncLanePriority;
            return SyncLane;
        }
        if ((SyncBatchedLane & lanes) !== NoLanes) {
            return_highestLanePriority = SyncBatchedLanePriority;
            return SyncBatchedLane;
        }
        if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
            return_highestLanePriority = InputDiscreteHydrationLanePriority;
            return InputDiscreteHydrationLane;
        }
        var inputDiscreteLanes = InputDiscreteLanes & lanes;
        if (inputDiscreteLanes !== NoLanes) {
            return_highestLanePriority = InputDiscreteLanePriority;
            return inputDiscreteLanes;
        }
        if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
            return_highestLanePriority = InputContinuousHydrationLanePriority;
            return InputContinuousHydrationLane;
        }
        var inputContinuousLanes = InputContinuousLanes & lanes;
        if (inputContinuousLanes !== NoLanes) {
            return_highestLanePriority = InputContinuousLanePriority;
            return inputContinuousLanes;
        }
        if ((lanes & DefaultHydrationLane) !== NoLanes) {
            return_highestLanePriority = DefaultHydrationLanePriority;
            return DefaultHydrationLane;
        }
        var defaultLanes = DefaultLanes & lanes;
        if (defaultLanes !== NoLanes) {
            return_highestLanePriority = DefaultLanePriority;
            return defaultLanes;
        }
        if ((lanes & TransitionHydrationLane) !== NoLanes) {
            return_highestLanePriority = TransitionHydrationPriority;
            return TransitionHydrationLane;
        }
        var transitionLanes = TransitionLanes & lanes;
        if (transitionLanes !== NoLanes) {
            return_highestLanePriority = TransitionPriority;
            return transitionLanes;
        }
        var retryLanes = RetryLanes & lanes;
        if (retryLanes !== NoLanes) {
            return_highestLanePriority = RetryLanePriority;
            return retryLanes;
        }
        if (lanes & SelectiveHydrationLane) {
            return_highestLanePriority = SelectiveHydrationLanePriority;
            return SelectiveHydrationLane;
        }
        if ((lanes & IdleHydrationLane) !== NoLanes) {
            return_highestLanePriority = IdleHydrationLanePriority;
            return IdleHydrationLane;
        }
        var idleLanes = IdleLanes & lanes;
        if (idleLanes !== NoLanes) {
            return_highestLanePriority = IdleLanePriority;
            return idleLanes;
        }
        if ((OffscreenLane & lanes) !== NoLanes) {
            return_highestLanePriority = OffscreenLanePriority;
            return OffscreenLane;
        }
        error('Should have found matching lanes. This is a bug in React.');
        return_highestLanePriority = DefaultLanePriority;
        return lanes;
    }
    function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
        switch(schedulerPriorityLevel){
            case ImmediatePriority:
                return SyncLanePriority;
            case UserBlockingPriority:
                return InputContinuousLanePriority;
            case NormalPriority:
            case LowPriority:
                // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
                return DefaultLanePriority;
            case IdlePriority:
                return IdleLanePriority;
            default:
                return NoLanePriority;
        }
    }
    function lanePriorityToSchedulerPriority(lanePriority) {
        switch(lanePriority){
            case SyncLanePriority:
            case SyncBatchedLanePriority:
                return ImmediatePriority;
            case InputDiscreteHydrationLanePriority:
            case InputDiscreteLanePriority:
            case InputContinuousHydrationLanePriority:
            case InputContinuousLanePriority:
                return UserBlockingPriority;
            case DefaultHydrationLanePriority:
            case DefaultLanePriority:
            case TransitionHydrationPriority:
            case TransitionPriority:
            case SelectiveHydrationLanePriority:
            case RetryLanePriority:
                return NormalPriority;
            case IdleHydrationLanePriority:
            case IdleLanePriority:
            case OffscreenLanePriority:
                return IdlePriority;
            case NoLanePriority:
                return NoPriority;
            default:
                throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
        }
    }
    function getNextLanes(root, wipLanes) {
        // Early bailout if there's no pending work left.
        var pendingLanes = root.pendingLanes;
        if (pendingLanes === NoLanes) {
            return_highestLanePriority = NoLanePriority;
            return NoLanes;
        }
        var nextLanes = NoLanes;
        var nextLanePriority = NoLanePriority;
        var expiredLanes = root.expiredLanes;
        var suspendedLanes = root.suspendedLanes;
        var pingedLanes = root.pingedLanes; // Check if any work has expired.
        if (expiredLanes !== NoLanes) {
            nextLanes = expiredLanes;
            nextLanePriority = return_highestLanePriority = SyncLanePriority;
        } else {
            // Do not work on any idle work until all the non-idle work has finished,
            // even if the work is suspended.
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
                if (nonIdleUnblockedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
                    nextLanePriority = return_highestLanePriority;
                } else {
                    var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                    if (nonIdlePingedLanes !== NoLanes) {
                        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                        nextLanePriority = return_highestLanePriority;
                    }
                }
            } else {
                // The only remaining work is Idle.
                var unblockedLanes = pendingLanes & ~suspendedLanes;
                if (unblockedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(unblockedLanes);
                    nextLanePriority = return_highestLanePriority;
                } else if (pingedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(pingedLanes);
                    nextLanePriority = return_highestLanePriority;
                }
            }
        }
        if (nextLanes === NoLanes) // This should only be reachable if we're suspended
        // TODO: Consider warning in this path if a fallback timer is not scheduled.
        return NoLanes;
         // If there are higher priority lanes, we'll include them even if they
        // are suspended.
        nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes); // If we're already in the middle of a render, switching lanes will interrupt
        // it and we'll lose our progress. We should only do this if the new lanes are
        // higher priority.
        if (wipLanes !== NoLanes && wipLanes !== nextLanes && // bother waiting until the root is complete.
        (wipLanes & suspendedLanes) === NoLanes) {
            getHighestPriorityLanes(wipLanes);
            var wipLanePriority = return_highestLanePriority;
            if (nextLanePriority <= wipLanePriority) return wipLanes;
            else return_highestLanePriority = nextLanePriority;
        } // Check for entangled lanes and add them to the batch.
        //
        // A lane is said to be entangled with another when it's not allowed to render
        // in a batch that does not also include the other lane. Typically we do this
        // when multiple updates have the same source, and we only want to respond to
        // the most recent event from that source.
        //
        // Note that we apply entanglements *after* checking for partial work above.
        // This means that if a lane is entangled during an interleaved event while
        // it's already rendering, we won't interrupt it. This is intentional, since
        // entanglement is usually "best effort": we'll try our best to render the
        // lanes in the same batch, but it's not worth throwing out partially
        // completed work in order to do it.
        //
        // For those exceptions where entanglement is semantically important, like
        // useMutableSource, we should ensure that there is no partial work at the
        // time we apply the entanglement.
        var entangledLanes = root.entangledLanes;
        if (entangledLanes !== NoLanes) {
            var entanglements = root.entanglements;
            var lanes = nextLanes & entangledLanes;
            while(lanes > 0){
                var index = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index;
                nextLanes |= entanglements[index];
                lanes &= ~lane;
            }
        }
        return nextLanes;
    }
    function getMostRecentEventTime(root, lanes) {
        var eventTimes = root.eventTimes;
        var mostRecentEventTime = NoTimestamp;
        while(lanes > 0){
            var index = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index;
            var eventTime = eventTimes[index];
            if (eventTime > mostRecentEventTime) mostRecentEventTime = eventTime;
            lanes &= ~lane;
        }
        return mostRecentEventTime;
    }
    function computeExpirationTime(lane, currentTime) {
        // TODO: Expiration heuristic is constant per lane, so could use a map.
        getHighestPriorityLanes(lane);
        var priority = return_highestLanePriority;
        if (priority >= InputContinuousLanePriority) // User interactions should expire slightly more quickly.
        //
        // NOTE: This is set to the corresponding constant as in Scheduler.js. When
        // we made it larger, a product metric in www regressed, suggesting there's
        // a user interaction that's being starved by a series of synchronous
        // updates. If that theory is correct, the proper solution is to fix the
        // starvation. However, this scenario supports the idea that expiration
        // times are an important safeguard when starvation does happen.
        //
        // Also note that, in the case of user input specifically, this will soon no
        // longer be an issue because we plan to make user input synchronous by
        // default (until you enter `startTransition`, of course.)
        //
        // If weren't planning to make these updates synchronous soon anyway, I
        // would probably make this number a configurable parameter.
        return currentTime + 250;
        else if (priority >= TransitionPriority) return currentTime + 5000;
        else // Anything idle priority or lower should never expire.
        return NoTimestamp;
    }
    function markStarvedLanesAsExpired(root, currentTime) {
        // TODO: This gets called every time we yield. We can optimize by storing
        // the earliest expiration time on the root. Then use that to quickly bail out
        // of this function.
        var pendingLanes = root.pendingLanes;
        var suspendedLanes = root.suspendedLanes;
        var pingedLanes = root.pingedLanes;
        var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their
        // expiration time. If so, we'll assume the update is being starved and mark
        // it as expired to force it to finish.
        var lanes = pendingLanes;
        while(lanes > 0){
            var index = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index;
            var expirationTime = expirationTimes[index];
            if (expirationTime === NoTimestamp) // Found a pending lane with no expiration time. If it's not suspended, or
            // if it's pinged, assume it's CPU-bound. Compute a new expiration time
            // using the current time.
            {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) // Assumes timestamps are monotonically increasing.
                expirationTimes[index] = computeExpirationTime(lane, currentTime);
            } else if (expirationTime <= currentTime) // This lane expired
            root.expiredLanes |= lane;
            lanes &= ~lane;
        }
    } // This returns the highest priority pending lanes regardless of whether they
    function getLanesToRetrySynchronouslyOnError(root) {
        var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
        if (everythingButOffscreen !== NoLanes) return everythingButOffscreen;
        if (everythingButOffscreen & OffscreenLane) return OffscreenLane;
        return NoLanes;
    }
    function returnNextLanesPriority() {
        return return_highestLanePriority;
    }
    function includesNonIdleWork(lanes) {
        return (lanes & NonIdleLanes) !== NoLanes;
    }
    function includesOnlyRetries(lanes) {
        return (lanes & RetryLanes) === lanes;
    }
    function includesOnlyTransitions(lanes) {
        return (lanes & TransitionLanes) === lanes;
    } // To ensure consistency across multiple updates in the same event, this should
    // be a pure function, so that it always returns the same lane for given inputs.
    function findUpdateLane(lanePriority, wipLanes) {
        switch(lanePriority){
            case NoLanePriority:
                break;
            case SyncLanePriority:
                return SyncLane;
            case SyncBatchedLanePriority:
                return SyncBatchedLane;
            case InputDiscreteLanePriority:
                var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);
                if (_lane === NoLane) // Shift to the next priority level
                return findUpdateLane(InputContinuousLanePriority, wipLanes);
                return _lane;
            case InputContinuousLanePriority:
                var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);
                if (_lane2 === NoLane) // Shift to the next priority level
                return findUpdateLane(DefaultLanePriority, wipLanes);
                return _lane2;
            case DefaultLanePriority:
                var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);
                if (_lane3 === NoLane) {
                    // If all the default lanes are already being worked on, look for a
                    // lane in the transition range.
                    _lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes);
                    if (_lane3 === NoLane) // All the transition lanes are taken, too. This should be very
                    // rare, but as a last resort, pick a default lane. This will have
                    // the effect of interrupting the current work-in-progress render.
                    _lane3 = pickArbitraryLane(DefaultLanes);
                }
                return _lane3;
            case TransitionPriority:
            case RetryLanePriority:
                break;
            case IdleLanePriority:
                var lane = pickArbitraryLane(IdleLanes & ~wipLanes);
                if (lane === NoLane) lane = pickArbitraryLane(IdleLanes);
                return lane;
        }
        throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
    } // To ensure consistency across multiple updates in the same event, this should
    // be pure function, so that it always returns the same lane for given inputs.
    function findTransitionLane(wipLanes, pendingLanes) {
        // First look for lanes that are completely unclaimed, i.e. have no
        // pending work.
        var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);
        if (lane === NoLane) {
            // If all lanes have pending work, look for a lane that isn't currently
            // being worked on.
            lane = pickArbitraryLane(TransitionLanes & ~wipLanes);
            if (lane === NoLane) // If everything is being worked on, pick any lane. This has the
            // effect of interrupting the current work-in-progress.
            lane = pickArbitraryLane(TransitionLanes);
        }
        return lane;
    } // To ensure consistency across multiple updates in the same event, this should
    // be pure function, so that it always returns the same lane for given inputs.
    function findRetryLane(wipLanes) {
        // This is a fork of `findUpdateLane` designed specifically for Suspense
        // "retries" — a special update that attempts to flip a Suspense boundary
        // from its placeholder state to its primary/resolved state.
        var lane = pickArbitraryLane(RetryLanes & ~wipLanes);
        if (lane === NoLane) lane = pickArbitraryLane(RetryLanes);
        return lane;
    }
    function getHighestPriorityLane(lanes) {
        return lanes & -lanes;
    }
    function getLowestPriorityLane(lanes) {
        // This finds the most significant non-zero bit.
        var index = 31 - clz32(lanes);
        return index < 0 ? NoLanes : 1 << index;
    }
    function getEqualOrHigherPriorityLanes(lanes) {
        return (getLowestPriorityLane(lanes) << 1) - 1;
    }
    function pickArbitraryLane(lanes) {
        // This wrapper function gets inlined. Only exists so to communicate that it
        // doesn't matter which bit is selected; you can pick any bit without
        // affecting the algorithms where its used. Here I'm using
        // getHighestPriorityLane because it requires the fewest operations.
        return getHighestPriorityLane(lanes);
    }
    function pickArbitraryLaneIndex(lanes) {
        return 31 - clz32(lanes);
    }
    function laneToIndex(lane) {
        return pickArbitraryLaneIndex(lane);
    }
    function includesSomeLane(a, b) {
        return (a & b) !== NoLanes;
    }
    function isSubsetOfLanes(set1, subset) {
        return (set1 & subset) === subset;
    }
    function mergeLanes(a, b) {
        return a | b;
    }
    function removeLanes(set1, subset) {
        return set1 & ~subset;
    } // Seems redundant, but it changes the type from a single lane (used for
    // updates) to a group of lanes (used for flushing work).
    function laneToLanes(lane) {
        return lane;
    }
    function higherPriorityLane(a, b) {
        // This works because the bit ranges decrease in priority as you go left.
        return a !== NoLane && a < b ? a : b;
    }
    function createLaneMap(initial) {
        // Intentionally pushing one by one.
        // https://v8.dev/blog/elements-kinds#avoid-creating-holes
        var laneMap = [];
        for(var i = 0; i < TotalLanes; i++)laneMap.push(initial);
        return laneMap;
    }
    function markRootUpdated(root, updateLane, eventTime) {
        root.pendingLanes |= updateLane; // TODO: Theoretically, any update to any lane can unblock any other lane. But
        // it's not practical to try every single possible combination. We need a
        // heuristic to decide which lanes to attempt to render, and in which batches.
        // For now, we use the same heuristic as in the old ExpirationTimes model:
        // retry any lane at equal or lower priority, but don't try updates at higher
        // priority without also including the lower priority updates. This works well
        // when considering updates across different priority levels, but isn't
        // sufficient for updates within the same priority, since we want to treat
        // those updates as parallel.
        // Unsuspend any update at equal or lower priority.
        var higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111
        root.suspendedLanes &= higherPriorityLanes;
        root.pingedLanes &= higherPriorityLanes;
        var eventTimes = root.eventTimes;
        var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most
        // recent event, and we assume time is monotonically increasing.
        eventTimes[index] = eventTime;
    }
    function markRootSuspended(root, suspendedLanes) {
        root.suspendedLanes |= suspendedLanes;
        root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.
        var expirationTimes = root.expirationTimes;
        var lanes = suspendedLanes;
        while(lanes > 0){
            var index = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index;
            expirationTimes[index] = NoTimestamp;
            lanes &= ~lane;
        }
    }
    function markRootPinged(root, pingedLanes, eventTime) {
        root.pingedLanes |= root.suspendedLanes & pingedLanes;
    }
    function markDiscreteUpdatesExpired(root) {
        root.expiredLanes |= InputDiscreteLanes & root.pendingLanes;
    }
    function hasDiscreteLanes(lanes) {
        return (lanes & InputDiscreteLanes) !== NoLanes;
    }
    function markRootMutableRead(root, updateLane) {
        root.mutableReadLanes |= updateLane & root.pendingLanes;
    }
    function markRootFinished(root, remainingLanes) {
        var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
        root.pendingLanes = remainingLanes; // Let's try everything again
        root.suspendedLanes = 0;
        root.pingedLanes = 0;
        root.expiredLanes &= remainingLanes;
        root.mutableReadLanes &= remainingLanes;
        root.entangledLanes &= remainingLanes;
        var entanglements = root.entanglements;
        var eventTimes = root.eventTimes;
        var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work
        var lanes = noLongerPendingLanes;
        while(lanes > 0){
            var index = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index;
            entanglements[index] = NoLanes;
            eventTimes[index] = NoTimestamp;
            expirationTimes[index] = NoTimestamp;
            lanes &= ~lane;
        }
    }
    function markRootEntangled(root, entangledLanes) {
        root.entangledLanes |= entangledLanes;
        var entanglements = root.entanglements;
        var lanes = entangledLanes;
        while(lanes > 0){
            var index = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index;
            entanglements[index] |= entangledLanes;
            lanes &= ~lane;
        }
    }
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros. Only used on lanes, so assume input is an integer.
    // Based on:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
    var log = Math.log;
    var LN2 = Math.LN2;
    function clz32Fallback(lanes) {
        if (lanes === 0) return 32;
        return 31 - (log(lanes) / LN2 | 0) | 0;
    }
    // Intentionally not named imports because Rollup would use dynamic dispatch for
    var UserBlockingPriority$1 = Scheduler.unstable_UserBlockingPriority, runWithPriority = Scheduler.unstable_runWithPriority; // TODO: can we stop exporting these?
    var _enabled = true; // This is exported in FB builds for use by legacy FB layer infra.
    // We'd like to remove this but it's not clear if this is safe.
    function setEnabled(enabled) {
        _enabled = !!enabled;
    }
    function isEnabled() {
        return _enabled;
    }
    function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
        var eventPriority = getEventPriorityForPluginSystem(domEventName);
        var listenerWrapper;
        switch(eventPriority){
            case DiscreteEvent:
                listenerWrapper = dispatchDiscreteEvent;
                break;
            case UserBlockingEvent:
                listenerWrapper = dispatchUserBlockingUpdate;
                break;
            case ContinuousEvent:
            default:
                listenerWrapper = dispatchEvent;
                break;
        }
        return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
    }
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);
        discreteUpdates(dispatchEvent, domEventName, eventSystemFlags, container, nativeEvent);
    }
    function dispatchUserBlockingUpdate(domEventName, eventSystemFlags, container, nativeEvent) {
        runWithPriority(UserBlockingPriority$1, dispatchEvent.bind(null, domEventName, eventSystemFlags, container, nativeEvent));
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (!_enabled) return;
        var allowReplay = true;
        // TODO: replaying capture phase events is currently broken
        // because we used to do it during top-level native bubble handlers
        // but now we use different bubble and capture handlers.
        // In eager mode, we attach capture listeners early, so we need
        // to filter them out until we fix the logic to handle them correctly.
        // This could've been outside the flag but I put it inside to reduce risk.
        allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;
        if (allowReplay && hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(domEventName)) {
            // If we already have a queue of discrete events, and this is another discrete
            // event, then we can't dispatch it regardless of its target, since they
            // need to dispatch in order.
            queueDiscreteEvent(null, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            return;
        }
        var blockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
        if (blockedOn === null) {
            // We successfully dispatched this event.
            if (allowReplay) clearIfContinuousEvent(domEventName, nativeEvent);
            return;
        }
        if (allowReplay) {
            if (isReplayableDiscreteEvent(domEventName)) {
                // This this to be replayed later once the target is available.
                queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
                return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) return;
             // We need to clear only if we didn't queue because
            // queueing is accummulative.
            clearIfContinuousEvent(domEventName, nativeEvent);
        } // This is not replayable so we'll invoke it but without a target,
        // in case the event system needs to trace it.
        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
    } // Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.
    function attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        // TODO: Warn if _enabled is false.
        var nativeEventTarget = getEventTarget(nativeEvent);
        var targetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted === null) // This tree has been unmounted already. Dispatch without a target.
            targetInst = null;
            else {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                    var instance = getSuspenseInstanceFromFiber(nearestMounted);
                    if (instance !== null) // Queue the event to be replayed later. Abort dispatching since we
                    // don't want this event dispatched twice through the event system.
                    // TODO: If this is the first discrete event in the queue. Schedule an increased
                    // priority for this boundary.
                    return instance;
                     // This shouldn't happen, something went wrong but to avoid blocking
                    // the whole system, dispatch the event without a target.
                    // TODO: Warn.
                    targetInst = null;
                } else if (tag === HostRoot) {
                    var root = nearestMounted.stateNode;
                    if (root.hydrate) // If this happens during a replay something went wrong and it might block
                    // the whole system.
                    return getContainerFromFiber(nearestMounted);
                    targetInst = null;
                } else if (nearestMounted !== targetInst) // If we get an event (ex: img onload) before committing that
                // component's mount, ignore it for now (that is, treat it as if it was an
                // event on a non-React tree). We might also consider queueing events and
                // dispatching them after the mount.
                targetInst = null;
            }
        }
        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer); // We're not blocked on anything.
        return null;
    }
    function addEventBubbleListener(target, eventType, listener) {
        target.addEventListener(eventType, listener, false);
        return listener;
    }
    function addEventCaptureListener(target, eventType, listener) {
        target.addEventListener(eventType, listener, true);
        return listener;
    }
    function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
        target.addEventListener(eventType, listener, {
            capture: true,
            passive: passive
        });
        return listener;
    }
    function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
        target.addEventListener(eventType, listener, {
            passive: passive
        });
        return listener;
    }
    /**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */ var root = null;
    var startText = null;
    var fallbackText = null;
    function initialize(nativeEventTarget) {
        root = nativeEventTarget;
        startText = getText();
        return true;
    }
    function reset() {
        root = null;
        startText = null;
        fallbackText = null;
    }
    function getData() {
        if (fallbackText) return fallbackText;
        var start;
        var startValue = startText;
        var startLength = startValue.length;
        var end;
        var endValue = getText();
        var endLength = endValue.length;
        for(start = 0; start < startLength; start++){
            if (startValue[start] !== endValue[start]) break;
        }
        var minEnd = startLength - start;
        for(end = 1; end <= minEnd; end++){
            if (startValue[startLength - end] !== endValue[endLength - end]) break;
        }
        var sliceTail = end > 1 ? 1 - end : undefined;
        fallbackText = endValue.slice(start, sliceTail);
        return fallbackText;
    }
    function getText() {
        if ('value' in root) return root.value;
        return root.textContent;
    }
    /**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */ function getEventCharCode(nativeEvent) {
        var charCode;
        var keyCode = nativeEvent.keyCode;
        if ('charCode' in nativeEvent) {
            charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.
            if (charCode === 0 && keyCode === 13) charCode = 13;
        } else // IE8 does not implement `charCode`, but `keyCode` has the correct value.
        charCode = keyCode;
         // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
        // report Enter as charCode 10 when ctrl is pressed.
        if (charCode === 10) charCode = 13;
         // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
        // Must not discard the (non-)printable Enter-key.
        if (charCode >= 32 || charCode === 13) return charCode;
        return 0;
    }
    function functionThatReturnsTrue() {
        return true;
    }
    function functionThatReturnsFalse() {
        return false;
    } // This is intentionally a factory so that we have different returned constructors.
    // If we had a single constructor, it would be megamorphic and engines would deopt.
    function createSyntheticEvent(Interface) {
        /**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   */ function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for(var _propName in Interface){
                if (!Interface.hasOwnProperty(_propName)) continue;
                var normalize = Interface[_propName];
                if (normalize) this[_propName] = normalize(nativeEvent);
                else this[_propName] = nativeEvent[_propName];
            }
            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
            if (defaultPrevented) this.isDefaultPrevented = functionThatReturnsTrue;
            else this.isDefaultPrevented = functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
        }
        _assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) return;
                if (event.preventDefault) event.preventDefault(); // $FlowFixMe - flow is not aware of `unknown` in IE
                else if (typeof event.returnValue !== 'unknown') event.returnValue = false;
                this.isDefaultPrevented = functionThatReturnsTrue;
            },
            stopPropagation: function() {
                var event = this.nativeEvent;
                if (!event) return;
                if (event.stopPropagation) event.stopPropagation(); // $FlowFixMe - flow is not aware of `unknown` in IE
                else if (typeof event.cancelBubble !== 'unknown') // The ChangeEventPlugin registers a "propertychange" event for
                // IE. This event does not support bubbling or cancelling, and
                // any references to cancelBubble throw "Member not found".  A
                // typeof check of "unknown" circumvents this issue (and is also
                // IE specific).
                event.cancelBubble = true;
                this.isPropagationStopped = functionThatReturnsTrue;
            },
            /**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */ persist: function() {
            },
            /**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */ isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
    }
    /**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
            return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
    };
    var SyntheticEvent = createSyntheticEvent(EventInterface);
    var UIEventInterface = _assign({
    }, EventInterface, {
        view: 0,
        detail: 0
    });
    var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
    var lastMovementX;
    var lastMovementY;
    var lastMouseEvent;
    function updateMouseMovementPolyfillState(event) {
        if (event !== lastMouseEvent) {
            if (lastMouseEvent && event.type === 'mousemove') {
                lastMovementX = event.screenX - lastMouseEvent.screenX;
                lastMovementY = event.screenY - lastMouseEvent.screenY;
            } else {
                lastMovementX = 0;
                lastMovementY = 0;
            }
            lastMouseEvent = event;
        }
    }
    /**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var MouseEventInterface = _assign({
    }, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
            if (event.relatedTarget === undefined) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
            return event.relatedTarget;
        },
        movementX: function(event) {
            if ('movementX' in event) return event.movementX;
            updateMouseMovementPolyfillState(event);
            return lastMovementX;
        },
        movementY: function(event) {
            if ('movementY' in event) return event.movementY;
             // Don't need to call updateMouseMovementPolyfillState() here
            // because it's guaranteed to have already run when movementX
            // was copied.
            return lastMovementY;
        }
    });
    var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
    /**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var DragEventInterface = _assign({
    }, MouseEventInterface, {
        dataTransfer: 0
    });
    var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
    /**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var FocusEventInterface = _assign({
    }, UIEventInterface, {
        relatedTarget: 0
    });
    var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
    /**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */ var AnimationEventInterface = _assign({
    }, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    });
    var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
    /**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */ var ClipboardEventInterface = _assign({
    }, EventInterface, {
        clipboardData: function(event) {
            return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
        }
    });
    var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
    /**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */ var CompositionEventInterface = _assign({
    }, EventInterface, {
        data: 0
    });
    var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
    /**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */ // Happens to share the same list for now.
    var SyntheticInputEvent = SyntheticCompositionEvent;
    /**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */ var normalizeKey = {
        Esc: 'Escape',
        Spacebar: ' ',
        Left: 'ArrowLeft',
        Up: 'ArrowUp',
        Right: 'ArrowRight',
        Down: 'ArrowDown',
        Del: 'Delete',
        Win: 'OS',
        Menu: 'ContextMenu',
        Apps: 'ContextMenu',
        Scroll: 'ScrollLock',
        MozPrintableKey: 'Unidentified'
    };
    /**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */ var translateToKey = {
        '8': 'Backspace',
        '9': 'Tab',
        '12': 'Clear',
        '13': 'Enter',
        '16': 'Shift',
        '17': 'Control',
        '18': 'Alt',
        '19': 'Pause',
        '20': 'CapsLock',
        '27': 'Escape',
        '32': ' ',
        '33': 'PageUp',
        '34': 'PageDown',
        '35': 'End',
        '36': 'Home',
        '37': 'ArrowLeft',
        '38': 'ArrowUp',
        '39': 'ArrowRight',
        '40': 'ArrowDown',
        '45': 'Insert',
        '46': 'Delete',
        '112': 'F1',
        '113': 'F2',
        '114': 'F3',
        '115': 'F4',
        '116': 'F5',
        '117': 'F6',
        '118': 'F7',
        '119': 'F8',
        '120': 'F9',
        '121': 'F10',
        '122': 'F11',
        '123': 'F12',
        '144': 'NumLock',
        '145': 'ScrollLock',
        '224': 'Meta'
    };
    /**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */ function getEventKey(nativeEvent) {
        if (nativeEvent.key) {
            // Normalize inconsistent values reported by browsers due to
            // implementations of a working draft specification.
            // FireFox implements `key` but returns `MozPrintableKey` for all
            // printable characters (normalized to `Unidentified`), ignore it.
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if (key !== 'Unidentified') return key;
        } // Browser does not implement `key`, polyfill as much of it as we can.
        if (nativeEvent.type === 'keypress') {
            var charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can
            // thus be captured by `keypress`, no other non-printable key should.
            return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
        }
        if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') // While user keyboard layout determines the actual meaning of each
        // `keyCode` value, almost all function keys have a universal value.
        return translateToKey[nativeEvent.keyCode] || 'Unidentified';
        return '';
    }
    /**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */ var modifierKeyToProp = {
        Alt: 'altKey',
        Control: 'ctrlKey',
        Meta: 'metaKey',
        Shift: 'shiftKey'
    }; // Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
    // getModifierState. If getModifierState is not supported, we map it to a set of
    // modifier keys exposed by the event. In this case, Lock-keys are not supported.
    function modifierStateGetter(keyArg) {
        var syntheticEvent = this;
        var nativeEvent = syntheticEvent.nativeEvent;
        if (nativeEvent.getModifierState) return nativeEvent.getModifierState(keyArg);
        var keyProp = modifierKeyToProp[keyArg];
        return keyProp ? !!nativeEvent[keyProp] : false;
    }
    function getEventModifierState(nativeEvent) {
        return modifierStateGetter;
    }
    /**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var KeyboardEventInterface = _assign({
    }, UIEventInterface, {
        key: getEventKey,
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        // Legacy Interface
        charCode: function(event) {
            // `charCode` is the result of a KeyPress event and represents the value of
            // the actual printable character.
            // KeyPress is deprecated, but its replacement is not yet final and not
            // implemented in any major browser. Only KeyPress has charCode.
            if (event.type === 'keypress') return getEventCharCode(event);
            return 0;
        },
        keyCode: function(event) {
            // `keyCode` is the result of a KeyDown/Up event and represents the value of
            // physical keyboard key.
            // The actual meaning of the value depends on the users' keyboard layout
            // which cannot be detected. Assuming that it is a US keyboard layout
            // provides a surprisingly accurate mapping for US and European users.
            // Due to this, it is left to the user to implement at this time.
            if (event.type === 'keydown' || event.type === 'keyup') return event.keyCode;
            return 0;
        },
        which: function(event) {
            // `which` is an alias for either `keyCode` or `charCode` depending on the
            // type of the event.
            if (event.type === 'keypress') return getEventCharCode(event);
            if (event.type === 'keydown' || event.type === 'keyup') return event.keyCode;
            return 0;
        }
    });
    var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
    /**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */ var PointerEventInterface = _assign({
    }, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    });
    var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
    /**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */ var TouchEventInterface = _assign({
    }, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
    });
    var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
    /**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */ var TransitionEventInterface = _assign({
    }, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    });
    var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
    /**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */ var WheelEventInterface = _assign({
    }, MouseEventInterface, {
        deltaX: function(event) {
            return 'deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
            return 'deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        // Browsers without "deltaMode" is reporting in raw wheel delta where one
        // notch on the scroll is always +/- 120, roughly equivalent to pixels.
        // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
        // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
        deltaMode: 0
    });
    var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
    var END_KEYCODES = [
        9,
        13,
        27,
        32
    ]; // Tab, Return, Esc, Space
    var START_KEYCODE = 229;
    var canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;
    var documentMode = null;
    if (canUseDOM && 'documentMode' in document) documentMode = document.documentMode;
     // Webkit offers a very useful `textInput` event that can be used to
    // directly represent `beforeInput`. The IE `textinput` event is not as
    // useful, so we don't use it.
    var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode; // In IE9+, we have access to composition events, but the data supplied
    // by the native compositionend event may be incorrect. Japanese ideographic
    // spaces, for instance (\u3000) are not recorded correctly.
    var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
    var SPACEBAR_CODE = 32;
    var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
    function registerEvents() {
        registerTwoPhaseEvent('onBeforeInput', [
            'compositionend',
            'keypress',
            'textInput',
            'paste'
        ]);
        registerTwoPhaseEvent('onCompositionEnd', [
            'compositionend',
            'focusout',
            'keydown',
            'keypress',
            'keyup',
            'mousedown'
        ]);
        registerTwoPhaseEvent('onCompositionStart', [
            'compositionstart',
            'focusout',
            'keydown',
            'keypress',
            'keyup',
            'mousedown'
        ]);
        registerTwoPhaseEvent('onCompositionUpdate', [
            'compositionupdate',
            'focusout',
            'keydown',
            'keypress',
            'keyup',
            'mousedown'
        ]);
    } // Track whether we've ever handled a keypress on the space key.
    var hasSpaceKeypress = false;
    /**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */ function isKeypressCommand(nativeEvent) {
        return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
    }
    /**
 * Translate native top level events into event types.
 */ function getCompositionEventType(domEventName) {
        switch(domEventName){
            case 'compositionstart':
                return 'onCompositionStart';
            case 'compositionend':
                return 'onCompositionEnd';
            case 'compositionupdate':
                return 'onCompositionUpdate';
        }
    }
    /**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 */ function isFallbackCompositionStart(domEventName, nativeEvent) {
        return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE;
    }
    /**
 * Does our fallback mode think that this event is the end of composition?
 */ function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch(domEventName){
            case 'keyup':
                // Command keys insert or clear IME input.
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
            case 'keydown':
                // Expect IME keyCode on each keydown. If we get any other
                // code we must have exited earlier.
                return nativeEvent.keyCode !== START_KEYCODE;
            case 'keypress':
            case 'mousedown':
            case 'focusout':
                // Events are not possible without cancelling IME.
                return true;
            default:
                return false;
        }
    }
    /**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */ function getDataFromCustomEvent(nativeEvent) {
        var detail = nativeEvent.detail;
        if (typeof detail === 'object' && 'data' in detail) return detail.data;
        return null;
    }
    /**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */ function isUsingKoreanIME(nativeEvent) {
        return nativeEvent.locale === 'ko';
    } // Track the current IME composition status, if any.
    var isComposing = false;
    /**
 * @return {?object} A SyntheticCompositionEvent.
 */ function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var eventType;
        var fallbackData;
        if (canUseCompositionEvent) eventType = getCompositionEventType(domEventName);
        else if (!isComposing) {
            if (isFallbackCompositionStart(domEventName, nativeEvent)) eventType = 'onCompositionStart';
        } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) eventType = 'onCompositionEnd';
        if (!eventType) return null;
        if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
            // The current composition is stored statically and must not be
            // overwritten while composition continues.
            if (!isComposing && eventType === 'onCompositionStart') isComposing = initialize(nativeEventTarget);
            else if (eventType === 'onCompositionEnd') {
                if (isComposing) fallbackData = getData();
            }
        }
        var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
        if (listeners.length > 0) {
            var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
                event: event,
                listeners: listeners
            });
            if (fallbackData) // Inject data generated from fallback path into the synthetic event.
            // This matches the property of native CompositionEventInterface.
            event.data = fallbackData;
            else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) event.data = customData;
            }
        }
    }
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch(domEventName){
            case 'compositionend':
                return getDataFromCustomEvent(nativeEvent);
            case 'keypress':
                /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */ var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) return null;
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
            case 'textInput':
                // Record the characters to be added to the DOM.
                var chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled
                // it at the keypress level and bail immediately. Android Chrome
                // doesn't give us keycodes, so we need to ignore it.
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) return null;
                return chars;
            default:
                // For other native event types, do nothing.
                return null;
        }
    }
    /**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 */ function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        // If we are currently composing (IME) and using a fallback to do so,
        // try to extract the composed characters from the fallback object.
        // If composition event is available, we extract a string only at
        // compositionevent, otherwise extract it at fallback events.
        if (isComposing) {
            if (domEventName === 'compositionend' || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                var chars = getData();
                reset();
                isComposing = false;
                return chars;
            }
            return null;
        }
        switch(domEventName){
            case 'paste':
                // If a paste event occurs after a keypress, throw out the input
                // chars. Paste events should not lead to BeforeInput events.
                return null;
            case 'keypress':
                /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */ if (!isKeypressCommand(nativeEvent)) {
                    // IE fires the `keypress` event when a user types an emoji via
                    // Touch keyboard of Windows.  In such a case, the `char` property
                    // holds an emoji character like `\uD83D\uDE0A`.  Because its length
                    // is 2, the property `which` does not represent an emoji correctly.
                    // In such a case, we directly return the `char` property instead of
                    // using `which`.
                    if (nativeEvent.char && nativeEvent.char.length > 1) return nativeEvent.char;
                    else if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
                }
                return null;
            case 'compositionend':
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
            default:
                return null;
        }
    }
    /**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */ function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var chars;
        if (canUseTextInputEvent) chars = getNativeBeforeInputChars(domEventName, nativeEvent);
        else chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
         // If no characters are being inserted, no BeforeInput event should
        // be fired.
        if (!chars) return null;
        var listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');
        if (listeners.length > 0) {
            var event = new SyntheticInputEvent('onBeforeInput', 'beforeinput', null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
                event: event,
                listeners: listeners
            });
            event.data = chars;
        }
    }
    /**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */ function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    }
    /**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */ var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        'datetime-local': true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
    };
    function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        if (nodeName === 'input') return !!supportedInputTypes[elem.type];
        if (nodeName === 'textarea') return true;
        return false;
    }
    /**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */ function isEventSupported(eventNameSuffix) {
        if (!canUseDOM) return false;
        var eventName = 'on' + eventNameSuffix;
        var isSupported = eventName in document;
        if (!isSupported) {
            var element = document.createElement('div');
            element.setAttribute(eventName, 'return;');
            isSupported = typeof element[eventName] === 'function';
        }
        return isSupported;
    }
    function registerEvents$1() {
        registerTwoPhaseEvent('onChange', [
            'change',
            'click',
            'focusin',
            'focusout',
            'input',
            'keydown',
            'keyup',
            'selectionchange'
        ]);
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        // Flag this event loop as needing state restore.
        enqueueStateRestore(target);
        var listeners = accumulateTwoPhaseListeners(inst, 'onChange');
        if (listeners.length > 0) {
            var event = new SyntheticEvent('onChange', 'change', null, nativeEvent, target);
            dispatchQueue.push({
                event: event,
                listeners: listeners
            });
        }
    }
    /**
 * For IE shims
 */ var activeElement = null;
    var activeElementInst = null;
    /**
 * SECTION: handle `change` event
 */ function shouldUseChangeEvent(elem) {
        var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
    }
    function manualDispatchChangeEvent(nativeEvent) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the
        // other events and have it go through ReactBrowserEventEmitter. Since it
        // doesn't, we manually listen for the events and so we have to enqueue and
        // process the abstract event manually.
        //
        // Batching is necessary here in order to ensure that all event handlers run
        // before the next rerender (including event handlers attached to ancestor
        // elements instead of directly on the input). Without this, controlled
        // components don't work properly in conjunction with event bubbling because
        // the component is rerendered and the value reverted before all the event
        // handlers can run. See https://github.com/facebook/react/issues/708.
        batchedUpdates(runEventInBatch, dispatchQueue);
    }
    function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
        if (domEventName === 'change') return targetInst;
    }
    /**
 * SECTION: handle `input` event
 */ var isInputEventSupported = false;
    if (canUseDOM) // IE9 claims to support the input event but fails to trigger it when
    // deleting text, so we ignore its input events.
    isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
    /**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */ function startWatchingForValueChange(target, targetInst) {
        activeElement = target;
        activeElementInst = targetInst;
        activeElement.attachEvent('onpropertychange', handlePropertyChange);
    }
    /**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */ function stopWatchingForValueChange() {
        if (!activeElement) return;
        activeElement.detachEvent('onpropertychange', handlePropertyChange);
        activeElement = null;
        activeElementInst = null;
    }
    /**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */ function handlePropertyChange(nativeEvent) {
        if (nativeEvent.propertyName !== 'value') return;
        if (getInstIfValueChanged(activeElementInst)) manualDispatchChangeEvent(nativeEvent);
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        if (domEventName === 'focusin') {
            // In IE9, propertychange fires for most input events but is buggy and
            // doesn't fire when text is deleted, but conveniently, selectionchange
            // appears to fire in all of the remaining cases so we catch those and
            // forward the event if the value has changed
            // In either case, we don't want to call the event handler if the value
            // is changed from JS so we redefine a setter for `.value` that updates
            // our activeElementValue variable, allowing us to ignore those changes
            //
            // stopWatching() should be a noop here but we call it just in case we
            // missed a blur event somehow.
            stopWatchingForValueChange();
            startWatchingForValueChange(target, targetInst);
        } else if (domEventName === 'focusout') stopWatchingForValueChange();
    } // For IE8 and IE9.
    function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
        if (domEventName === 'selectionchange' || domEventName === 'keyup' || domEventName === 'keydown') // On the selectionchange event, the target is just document which isn't
        // helpful for us so just check activeElement instead.
        //
        // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
        // propertychange on the first input event after setting `value` from a
        // script and fires only keydown, keypress, keyup. Catching keyup usually
        // gets it and catching keydown lets us fire an event for the first
        // keystroke if user does a key repeat (it'll be a little delayed: right
        // before the second keystroke). Other input methods (e.g., paste) seem to
        // fire selectionchange normally.
        return getInstIfValueChanged(activeElementInst);
    }
    /**
 * SECTION: handle `click` event
 */ function shouldUseClickEvent(elem) {
        // Use the `click` event to detect changes to checkbox and radio inputs.
        // This approach works across all browsers, whereas `change` does not fire
        // until `blur` in IE8.
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
        if (domEventName === 'click') return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if (domEventName === 'input' || domEventName === 'change') return getInstIfValueChanged(targetInst);
    }
    function handleControlledInputBlur(node) {
        var state = node._wrapperState;
        if (!state || !state.controlled || node.type !== 'number') return;
        // If controlled, assign the value attribute to the current value on blur
        setDefaultValue(node, 'number', node.value);
    }
    /**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */ function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        var getTargetInstFunc, handleEventFunc;
        if (shouldUseChangeEvent(targetNode)) getTargetInstFunc = getTargetInstForChangeEvent;
        else if (isTextInputElement(targetNode)) {
            if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                handleEventFunc = handleEventsForInputEventPolyfill;
            }
        } else if (shouldUseClickEvent(targetNode)) getTargetInstFunc = getTargetInstForClickEvent;
        if (getTargetInstFunc) {
            var inst = getTargetInstFunc(domEventName, targetInst);
            if (inst) {
                createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                return;
            }
        }
        if (handleEventFunc) handleEventFunc(domEventName, targetNode, targetInst);
         // When blurring, set the value attribute for number inputs
        if (domEventName === 'focusout') handleControlledInputBlur(targetNode);
    }
    function registerEvents$2() {
        registerDirectEvent('onMouseEnter', [
            'mouseout',
            'mouseover'
        ]);
        registerDirectEvent('onMouseLeave', [
            'mouseout',
            'mouseover'
        ]);
        registerDirectEvent('onPointerEnter', [
            'pointerout',
            'pointerover'
        ]);
        registerDirectEvent('onPointerLeave', [
            'pointerout',
            'pointerover'
        ]);
    }
    /**
 * For almost every interaction we care about, there will be both a top-level
 * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
 * we do not extract duplicate events. However, moving the mouse into the
 * browser from outside will not fire a `mouseout` event. In this case, we use
 * the `mouseover` top-level event.
 */ function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var isOverEvent = domEventName === 'mouseover' || domEventName === 'pointerover';
        var isOutEvent = domEventName === 'mouseout' || domEventName === 'pointerout';
        if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {
            // If this is an over event with a target, we might have already dispatched
            // the event in the out event of the other target. If this is replayed,
            // then it's because we couldn't dispatch against this target previously
            // so we have to do it now instead.
            var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
            if (related) {
                // If the related node is managed by React, we can assume that we have
                // already dispatched the corresponding events during its mouseout.
                if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) return;
            }
        }
        if (!isOutEvent && !isOverEvent) // Must not be a mouse or pointer in or out - ignoring.
        return;
        var win; // TODO: why is this nullable in the types but we read from it?
        if (nativeEventTarget.window === nativeEventTarget) // `nativeEventTarget` is probably a window object.
        win = nativeEventTarget;
        else {
            // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
            var doc = nativeEventTarget.ownerDocument;
            if (doc) win = doc.defaultView || doc.parentWindow;
            else win = window;
        }
        var from;
        var to;
        if (isOutEvent) {
            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
            from = targetInst;
            to = _related ? getClosestInstanceFromNode(_related) : null;
            if (to !== null) {
                var nearestMounted = getNearestMountedFiber(to);
                if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) to = null;
            }
        } else {
            // Moving to a node from outside the window.
            from = null;
            to = targetInst;
        }
        if (from === to) // Nothing pertains to our managed components.
        return;
        var SyntheticEventCtor = SyntheticMouseEvent;
        var leaveEventType = 'onMouseLeave';
        var enterEventType = 'onMouseEnter';
        var eventTypePrefix = 'mouse';
        if (domEventName === 'pointerout' || domEventName === 'pointerover') {
            SyntheticEventCtor = SyntheticPointerEvent;
            leaveEventType = 'onPointerLeave';
            enterEventType = 'onPointerEnter';
            eventTypePrefix = 'pointer';
        }
        var fromNode = from == null ? win : getNodeFromInstance(from);
        var toNode = to == null ? win : getNodeFromInstance(to);
        var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + 'leave', from, nativeEvent, nativeEventTarget);
        leave.target = fromNode;
        leave.relatedTarget = toNode;
        var enter = null; // We should only process this nativeEvent if we are processing
        // the first ancestor. Next time, we will ignore the event.
        var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (nativeTargetInst === targetInst) {
            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + 'enter', to, nativeEvent, nativeEventTarget);
            enterEvent.target = toNode;
            enterEvent.relatedTarget = fromNode;
            enter = enterEvent;
        }
        accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
    }
    /**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */ function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
        ;
    }
    var objectIs = typeof Object.is === 'function' ? Object.is : is;
    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    /**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */ function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) return false;
        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
         // Test for A's keys different from B.
        for(var i = 0; i < keysA.length; i++){
            if (!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) return false;
        }
        return true;
    }
    /**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */ function getLeafNode(node) {
        while(node && node.firstChild)node = node.firstChild;
        return node;
    }
    /**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */ function getSiblingNode(node) {
        while(node){
            if (node.nextSibling) return node.nextSibling;
            node = node.parentNode;
        }
    }
    /**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */ function getNodeForCharacterOffset(root1, offset) {
        var node = getLeafNode(root1);
        var nodeStart = 0;
        var nodeEnd = 0;
        while(node){
            if (node.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset && nodeEnd >= offset) return {
                    node: node,
                    offset: offset - nodeStart
                };
                nodeStart = nodeEnd;
            }
            node = getLeafNode(getSiblingNode(node));
        }
    }
    /**
 * @param {DOMElement} outerNode
 * @return {?object}
 */ function getOffsets(outerNode) {
        var ownerDocument = outerNode.ownerDocument;
        var win = ownerDocument && ownerDocument.defaultView || window;
        var selection = win.getSelection && win.getSelection();
        if (!selection || selection.rangeCount === 0) return null;
        var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset; // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
        // up/down buttons on an <input type="number">. Anonymous divs do not seem to
        // expose properties, triggering a "Permission denied error" if any of its
        // properties are accessed. The only seemingly possible way to avoid erroring
        // is to access a property that typically works for non-anonymous divs and
        // catch any error that may otherwise arise. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
        try {
            /* eslint-disable no-unused-expressions */ anchorNode.nodeType;
            focusNode.nodeType;
        /* eslint-enable no-unused-expressions */ } catch (e) {
            return null;
        }
        return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
    }
    /**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */ function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
        var length = 0;
        var start = -1;
        var end = -1;
        var indexWithinAnchor = 0;
        var indexWithinFocus = 0;
        var node = outerNode;
        var parentNode = null;
        outer: while(true){
            var next = null;
            while(true){
                if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) start = length + anchorOffset;
                if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) end = length + focusOffset;
                if (node.nodeType === TEXT_NODE) length += node.nodeValue.length;
                if ((next = node.firstChild) === null) break;
                 // Moving from `node` to its first child `next`.
                parentNode = node;
                node = next;
            }
            while(true){
                if (node === outerNode) break outer;
                if (parentNode === anchorNode && (++indexWithinAnchor) === anchorOffset) start = length;
                if (parentNode === focusNode && (++indexWithinFocus) === focusOffset) end = length;
                if ((next = node.nextSibling) !== null) break;
                node = parentNode;
                parentNode = node.parentNode;
            } // Moving from `node` to its next sibling `next`.
            node = next;
        }
        if (start === -1 || end === -1) // This should never happen. (Would happen if the anchor/focus nodes aren't
        // actually inside the passed-in node.)
        return null;
        return {
            start: start,
            end: end
        };
    }
    /**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */ function setOffsets(node, offsets) {
        var doc = node.ownerDocument || document;
        var win = doc && doc.defaultView || window; // Edge fails with "Object expected" in some scenarios.
        // (For instance: TinyMCE editor used in a list component that supports pasting to add more,
        // fails when pasting 100+ items)
        if (!win.getSelection) return;
        var selection = win.getSelection();
        var length = node.textContent.length;
        var start = Math.min(offsets.start, length);
        var end = offsets.end === undefined ? start : Math.min(offsets.end, length); // IE 11 uses modern selection, but doesn't support the extend method.
        // Flip backward selections, so we can set with a single range.
        if (!selection.extend && start > end) {
            var temp = end;
            end = start;
            start = temp;
        }
        var startMarker = getNodeForCharacterOffset(node, start);
        var endMarker = getNodeForCharacterOffset(node, end);
        if (startMarker && endMarker) {
            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) return;
            var range = doc.createRange();
            range.setStart(startMarker.node, startMarker.offset);
            selection.removeAllRanges();
            if (start > end) {
                selection.addRange(range);
                selection.extend(endMarker.node, endMarker.offset);
            } else {
                range.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range);
            }
        }
    }
    function isTextNode(node) {
        return node && node.nodeType === TEXT_NODE;
    }
    function containsNode(outerNode, innerNode) {
        if (!outerNode || !innerNode) return false;
        else if (outerNode === innerNode) return true;
        else if (isTextNode(outerNode)) return false;
        else if (isTextNode(innerNode)) return containsNode(outerNode, innerNode.parentNode);
        else if ('contains' in outerNode) return outerNode.contains(innerNode);
        else if (outerNode.compareDocumentPosition) return !!(outerNode.compareDocumentPosition(innerNode) & 16);
        else return false;
    }
    function isInDocument(node) {
        return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
    }
    function isSameOriginFrame(iframe) {
        try {
            // Accessing the contentDocument of a HTMLIframeElement can cause the browser
            // to throw, e.g. if it has a cross-origin src attribute.
            // Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:
            // iframe.contentDocument.defaultView;
            // A safety way is to access one of the cross origin properties: Window or Location
            // Which might result in "SecurityError" DOM Exception and it is compatible to Safari.
            // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl
            return typeof iframe.contentWindow.location.href === 'string';
        } catch (err) {
            return false;
        }
    }
    function getActiveElementDeep() {
        var win = window;
        var element = getActiveElement();
        while(element instanceof win.HTMLIFrameElement){
            if (isSameOriginFrame(element)) win = element.contentWindow;
            else return element;
            element = getActiveElement(win.document);
        }
        return element;
    }
    /**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */ /**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */ function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');
    }
    function getSelectionInformation() {
        var focusedElem = getActiveElementDeep();
        return {
            focusedElem: focusedElem,
            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
        };
    }
    /**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */ function restoreSelection(priorSelectionInformation) {
        var curFocusedElem = getActiveElementDeep();
        var priorFocusedElem = priorSelectionInformation.focusedElem;
        var priorSelectionRange = priorSelectionInformation.selectionRange;
        if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
            if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) setSelection(priorFocusedElem, priorSelectionRange);
             // Focusing a node can change the scroll position, which is undesirable
            var ancestors = [];
            var ancestor = priorFocusedElem;
            while(ancestor = ancestor.parentNode)if (ancestor.nodeType === ELEMENT_NODE) ancestors.push({
                element: ancestor,
                left: ancestor.scrollLeft,
                top: ancestor.scrollTop
            });
            if (typeof priorFocusedElem.focus === 'function') priorFocusedElem.focus();
            for(var i = 0; i < ancestors.length; i++){
                var info = ancestors[i];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
            }
        }
    }
    /**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */ function getSelection(input) {
        var selection;
        if ('selectionStart' in input) // Modern browser with input or textarea.
        selection = {
            start: input.selectionStart,
            end: input.selectionEnd
        };
        else // Content editable or old IE textarea.
        selection = getOffsets(input);
        return selection || {
            start: 0,
            end: 0
        };
    }
    /**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */ function setSelection(input, offsets) {
        var start = offsets.start;
        var end = offsets.end;
        if (end === undefined) end = start;
        if ('selectionStart' in input) {
            input.selectionStart = start;
            input.selectionEnd = Math.min(end, input.value.length);
        } else setOffsets(input, offsets);
    }
    var skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;
    function registerEvents$3() {
        registerTwoPhaseEvent('onSelect', [
            'focusout',
            'contextmenu',
            'dragend',
            'focusin',
            'keydown',
            'keyup',
            'mousedown',
            'mouseup',
            'selectionchange'
        ]);
    }
    var activeElement$1 = null;
    var activeElementInst$1 = null;
    var lastSelection = null;
    var mouseDown = false;
    /**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 */ function getSelection$1(node) {
        if ('selectionStart' in node && hasSelectionCapabilities(node)) return {
            start: node.selectionStart,
            end: node.selectionEnd
        };
        else {
            var win = node.ownerDocument && node.ownerDocument.defaultView || window;
            var selection = win.getSelection();
            return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
            };
        }
    }
    /**
 * Get document associated with the event target.
 */ function getEventTargetDocument(eventTarget) {
        return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
    }
    /**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */ function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        // Ensure we have the right element, and that the user is not dragging a
        // selection (this matches native `select` event behavior). In HTML5, select
        // fires only on input and textarea thus if there's no focused element we
        // won't dispatch.
        var doc = getEventTargetDocument(nativeEventTarget);
        if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) return;
         // Only fire when selection has actually changed.
        var currentSelection = getSelection$1(activeElement$1);
        if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var listeners = accumulateTwoPhaseListeners(activeElementInst$1, 'onSelect');
            if (listeners.length > 0) {
                var event = new SyntheticEvent('onSelect', 'select', null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                    event: event,
                    listeners: listeners
                });
                event.target = activeElement$1;
            }
        }
    }
    /**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */ function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        switch(domEventName){
            // Track the input node that has focus.
            case 'focusin':
                if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
                    activeElement$1 = targetNode;
                    activeElementInst$1 = targetInst;
                    lastSelection = null;
                }
                break;
            case 'focusout':
                activeElement$1 = null;
                activeElementInst$1 = null;
                lastSelection = null;
                break;
            // Don't fire the event while the user is dragging. This matches the
            // semantics of the native select event.
            case 'mousedown':
                mouseDown = true;
                break;
            case 'contextmenu':
            case 'mouseup':
            case 'dragend':
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
            // Chrome and IE fire non-standard event when selection is changed (and
            // sometimes when it hasn't). IE's event fires out of order with respect
            // to key and input events on deletion, so we discard it.
            //
            // Firefox doesn't support selectionchange, so check selection status
            // after each key entry. The selection changes after keydown and before
            // keyup, but we check on keydown as well in the case of holding down a
            // key, when multiple keydown events are fired but only one keyup is.
            // This is also our approach for IE handling, for the reason above.
            case 'selectionchange':
                if (skipSelectionChangeEvent) break;
            // falls through
            case 'keydown':
            case 'keyup':
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
        }
    }
    function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var reactName = topLevelEventsToReactNames.get(domEventName);
        if (reactName === undefined) return;
        var SyntheticEventCtor = SyntheticEvent;
        var reactEventType = domEventName;
        switch(domEventName){
            case 'keypress':
                // Firefox creates a keypress event for function keys too. This removes
                // the unwanted keypress events. Enter is however both printable and
                // non-printable. One would expect Tab to be as well (but it isn't).
                if (getEventCharCode(nativeEvent) === 0) return;
            /* falls through */ case 'keydown':
            case 'keyup':
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
            case 'focusin':
                reactEventType = 'focus';
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
            case 'focusout':
                reactEventType = 'blur';
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
            case 'beforeblur':
            case 'afterblur':
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
            case 'click':
                // Firefox creates a click event on right mouse clicks. This removes the
                // unwanted click events.
                if (nativeEvent.button === 2) return;
            /* falls through */ case 'auxclick':
            case 'dblclick':
            case 'mousedown':
            case 'mousemove':
            case 'mouseup':
            /* falls through */ case 'mouseout':
            case 'mouseover':
            case 'contextmenu':
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
            case 'drag':
            case 'dragend':
            case 'dragenter':
            case 'dragexit':
            case 'dragleave':
            case 'dragover':
            case 'dragstart':
            case 'drop':
                SyntheticEventCtor = SyntheticDragEvent;
                break;
            case 'touchcancel':
            case 'touchend':
            case 'touchmove':
            case 'touchstart':
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
            case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
            case 'scroll':
                SyntheticEventCtor = SyntheticUIEvent;
                break;
            case 'wheel':
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
            case 'copy':
            case 'cut':
            case 'paste':
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
            case 'gotpointercapture':
            case 'lostpointercapture':
            case 'pointercancel':
            case 'pointerdown':
            case 'pointermove':
            case 'pointerout':
            case 'pointerover':
            case 'pointerup':
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
        }
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        // Some events don't bubble in the browser.
        // In the past, React has always bubbled them, but this can be surprising.
        // We're going to try aligning closer to the browser behavior by not bubbling
        // them in React either. We'll start by not bubbling onScroll, and then expand.
        var accumulateTargetOnly = !inCapturePhase && // nonDelegatedEvents list in DOMPluginEventSystem.
        // Then we can remove this special list.
        // This is a breaking change that can wait until React 18.
        domEventName === 'scroll';
        var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
        if (_listeners.length > 0) {
            // Intentionally create event lazily.
            var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
                event: _event,
                listeners: _listeners
            });
        }
    }
    // TODO: remove top-level side effect.
    registerSimpleEvents();
    registerEvents$2();
    registerEvents$1();
    registerEvents$3();
    registerEvents();
    function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        // TODO: we should remove the concept of a "SimpleEventPlugin".
        // This is the basic functionality of the event system. All
        // the other plugins are essentially polyfills. So the plugin
        // should probably be inlined somewhere and have its logic
        // be core the to event system. This would potentially allow
        // us to ship builds of React without the polyfilled plugins below.
        extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0; // We don't process these events unless we are in the
        // event's native "bubble" phase, which means that we're
        // not in the capture phase. That's because we emulate
        // the capture phase here still. This is a trade-off,
        // because in an ideal world we would not emulate and use
        // the phases properly, like we do with the SimpleEvent
        // plugin. However, the plugins below either expect
        // emulation (EnterLeave) or use state localized to that
        // plugin (BeforeInput, Change, Select). The state in
        // these modules complicates things, as you'll essentially
        // get the case where the capture phase event might change
        // state, only for the following bubble event to come in
        // later and not trigger anything as the state now
        // invalidates the heuristics of the event plugin. We
        // could alter all these plugins to work in such ways, but
        // that might cause other unknown side-effects that we
        // can't forsee right now.
        if (shouldProcessPolyfillPlugins) {
            extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
    } // List of events that need to be individually attached to media elements.
    var mediaEventTypes = [
        'abort',
        'canplay',
        'canplaythrough',
        'durationchange',
        'emptied',
        'encrypted',
        'ended',
        'error',
        'loadeddata',
        'loadedmetadata',
        'loadstart',
        'pause',
        'play',
        'playing',
        'progress',
        'ratechange',
        'seeked',
        'seeking',
        'stalled',
        'suspend',
        'timeupdate',
        'volumechange',
        'waiting'
    ]; // We should not delegate these events to the container, but rather
    // set them on the actual target element itself. This is primarily
    // because these events do not consistently bubble in the DOM.
    var nonDelegatedEvents = new Set([
        'cancel',
        'close',
        'invalid',
        'load',
        'scroll',
        'toggle'
    ].concat(mediaEventTypes));
    function executeDispatch(event, listener, currentTarget) {
        var type = event.type || 'unknown-event';
        event.currentTarget = currentTarget;
        invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
        event.currentTarget = null;
    }
    function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
        var previousInstance;
        if (inCapturePhase) for(var i = dispatchListeners.length - 1; i >= 0; i--){
            var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped()) return;
            executeDispatch(event, listener, currentTarget);
            previousInstance = instance;
        }
        else for(var _i = 0; _i < dispatchListeners.length; _i++){
            var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
            if (_instance !== previousInstance && event.isPropagationStopped()) return;
            executeDispatch(event, _listener, _currentTarget);
            previousInstance = _instance;
        }
    }
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        for(var i = 0; i < dispatchQueue.length; i++){
            var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
            processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn't use pooling.
        } // This would be a good time to rethrow if any of the event handlers threw.
        rethrowCaughtError();
    }
    function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var nativeEventTarget = getEventTarget(nativeEvent);
        var dispatchQueue = [];
        extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        processDispatchQueue(dispatchQueue, eventSystemFlags);
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
        var isCapturePhaseListener = false;
        var listenerSet = getEventListenerSet(targetElement);
        var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
        if (!listenerSet.has(listenerSetKey)) {
            addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
        }
    }
    var listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);
    function listenToAllSupportedEvents(rootContainerElement) {
        if (rootContainerElement[listeningMarker]) // Performance optimization: don't iterate through events
        // for the same portal container or root node more than once.
        // TODO: once we remove the flag, we may be able to also
        // remove some of the bookkeeping maps used for laziness.
        return;
        rootContainerElement[listeningMarker] = true;
        allNativeEvents.forEach(function(domEventName) {
            if (!nonDelegatedEvents.has(domEventName)) listenToNativeEvent(domEventName, false, rootContainerElement, null);
            listenToNativeEvent(domEventName, true, rootContainerElement, null);
        });
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) {
        var eventSystemFlags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var target = rootContainerElement; // selectionchange needs to be attached to the document
        // otherwise it won't capture incoming events that are only
        // triggered on the document directly.
        if (domEventName === 'selectionchange' && rootContainerElement.nodeType !== DOCUMENT_NODE) target = rootContainerElement.ownerDocument;
         // If the event can be delegated (or is capture phase), we can
        // register it to the root container. Otherwise, we should
        // register the event to the target element and mark it as
        // a non-delegated event.
        if (targetElement !== null && !isCapturePhaseListener && nonDelegatedEvents.has(domEventName)) {
            // For all non-delegated events, apart from scroll, we attach
            // their event listeners to the respective elements that their
            // events fire on. That means we can skip this step, as event
            // listener has already been added previously. However, we
            // special case the scroll event because the reality is that any
            // element can scroll.
            // TODO: ideally, we'd eventually apply the same logic to all
            // events from the nonDelegatedEvents list. Then we can remove
            // this special case and use the same logic for all events.
            if (domEventName !== 'scroll') return;
            eventSystemFlags |= IS_NON_DELEGATED;
            target = targetElement;
        }
        var listenerSet = getEventListenerSet(target);
        var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener); // If the listener entry is empty or we should upgrade, then
        // we need to trap an event listener onto the target.
        if (!listenerSet.has(listenerSetKey)) {
            if (isCapturePhaseListener) eventSystemFlags |= IS_CAPTURE_PHASE;
            addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
        }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
        var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags); // If passive option is not supported, then the event will be
        // active and not passive.
        var isPassiveListener = undefined;
        if (passiveBrowserEventsSupported) // Browsers introduced an intervention, making these events
        // passive by default on document. React doesn't bind them
        // to document anymore, but changing this now would undo
        // the performance wins from the change. So we emulate
        // the existing behavior manually on the roots now.
        // https://github.com/facebook/react/issues/19651
        {
            if (domEventName === 'touchstart' || domEventName === 'touchmove' || domEventName === 'wheel') isPassiveListener = true;
        }
        var unsubscribeListener; // When legacyFBSupport is enabled, it's for when we
        if (isCapturePhaseListener) {
            if (isPassiveListener !== undefined) unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            else unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
        } else if (isPassiveListener !== undefined) unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
        else unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
    }
    function isMatchingRootContainer(grandContainer, targetContainer) {
        return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var ancestorInst = targetInst;
        if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
            var targetContainerNode = targetContainer; // If we are using the legacy FB support flag, we
            if (targetInst !== null) {
                // The below logic attempts to work out if we need to change
                // the target fiber to a different ancestor. We had similar logic
                // in the legacy event system, except the big difference between
                // systems is that the modern event system now has an event listener
                // attached to each React Root and React Portal Root. Together,
                // the DOM nodes representing these roots are the "rootContainer".
                // To figure out which ancestor instance we should use, we traverse
                // up the fiber tree from the target instance and attempt to find
                // root boundaries that match that of our current "rootContainer".
                // If we find that "rootContainer", we find the parent fiber
                // sub-tree for that root and make that our ancestor instance.
                var node = targetInst;
                mainLoop: while(true){
                    if (node === null) return;
                    var nodeTag = node.tag;
                    if (nodeTag === HostRoot || nodeTag === HostPortal) {
                        var container = node.stateNode.containerInfo;
                        if (isMatchingRootContainer(container, targetContainerNode)) break;
                        if (nodeTag === HostPortal) {
                            // The target is a portal, but it's not the rootContainer we're looking for.
                            // Normally portals handle their own events all the way down to the root.
                            // So we should be able to stop now. However, we don't know if this portal
                            // was part of *our* root.
                            var grandNode = node.return;
                            while(grandNode !== null){
                                var grandTag = grandNode.tag;
                                if (grandTag === HostRoot || grandTag === HostPortal) {
                                    var grandContainer = grandNode.stateNode.containerInfo;
                                    if (isMatchingRootContainer(grandContainer, targetContainerNode)) // This is the rootContainer we're looking for and we found it as
                                    // a parent of the Portal. That means we can ignore it because the
                                    // Portal will bubble through to us.
                                    return;
                                }
                                grandNode = grandNode.return;
                            }
                        } // Now we need to find it's corresponding host fiber in the other
                        // tree. To do this we can use getClosestInstanceFromNode, but we
                        // need to validate that the fiber is a host instance, otherwise
                        // we need to traverse up through the DOM till we find the correct
                        // node that is from the other tree.
                        while(container !== null){
                            var parentNode = getClosestInstanceFromNode(container);
                            if (parentNode === null) return;
                            var parentTag = parentNode.tag;
                            if (parentTag === HostComponent || parentTag === HostText) {
                                node = ancestorInst = parentNode;
                                continue mainLoop;
                            }
                            container = container.parentNode;
                        }
                    }
                    node = node.return;
                }
            }
        }
        batchedEventUpdates(function() {
            return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
        });
    }
    function createDispatchListener(instance, listener, currentTarget) {
        return {
            instance: instance,
            listener: listener,
            currentTarget: currentTarget
        };
    }
    function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly) {
        var captureName = reactName !== null ? reactName + 'Capture' : null;
        var reactEventName = inCapturePhase ? captureName : reactName;
        var listeners = [];
        var instance = targetFiber;
        var lastHostComponent = null; // Accumulate all instances and listeners via the target -> root path.
        while(instance !== null){
            var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag; // Handle listeners that are on HostComponents (i.e. <div>)
            if (tag === HostComponent && stateNode !== null) {
                lastHostComponent = stateNode; // createEventHandle listeners
                if (reactEventName !== null) {
                    var listener = getListener(instance, reactEventName);
                    if (listener != null) listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                }
            } // If we are only accumulating events for the target, then we don't
            // continue to propagate through the React fiber tree to find other
            // listeners.
            if (accumulateTargetOnly) break;
            instance = instance.return;
        }
        return listeners;
    } // We should only use this function for:
    // - BeforeInputEventPlugin
    // - ChangeEventPlugin
    // - SelectEventPlugin
    // This is because we only process these plugins
    // in the bubble phase, so we need to accumulate two
    // phase event listeners (via emulation).
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
        var captureName = reactName + 'Capture';
        var listeners = [];
        var instance = targetFiber; // Accumulate all instances and listeners via the target -> root path.
        while(instance !== null){
            var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag; // Handle listeners that are on HostComponents (i.e. <div>)
            if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                var captureListener = getListener(instance, captureName);
                if (captureListener != null) listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                var bubbleListener = getListener(instance, reactName);
                if (bubbleListener != null) listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
            }
            instance = instance.return;
        }
        return listeners;
    }
    function getParent(inst) {
        if (inst === null) return null;
        do inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
        while (inst && inst.tag !== HostComponent)
        if (inst) return inst;
        return null;
    }
    /**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */ function getLowestCommonAncestor(instA, instB) {
        var nodeA = instA;
        var nodeB = instB;
        var depthA = 0;
        for(var tempA = nodeA; tempA; tempA = getParent(tempA))depthA++;
        var depthB = 0;
        for(var tempB = nodeB; tempB; tempB = getParent(tempB))depthB++;
         // If A is deeper, crawl up.
        while(depthA - depthB > 0){
            nodeA = getParent(nodeA);
            depthA--;
        } // If B is deeper, crawl up.
        while(depthB - depthA > 0){
            nodeB = getParent(nodeB);
            depthB--;
        } // Walk in lockstep until we find a match.
        var depth = depthA;
        while(depth--){
            if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) return nodeA;
            nodeA = getParent(nodeA);
            nodeB = getParent(nodeB);
        }
        return null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        var registrationName = event._reactName;
        var listeners = [];
        var instance = target;
        while(instance !== null){
            if (instance === common) break;
            var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
            if (alternate !== null && alternate === common) break;
            if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                if (inCapturePhase) {
                    var captureListener = getListener(instance, registrationName);
                    if (captureListener != null) listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                } else if (!inCapturePhase) {
                    var bubbleListener = getListener(instance, registrationName);
                    if (bubbleListener != null) listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
            }
            instance = instance.return;
        }
        if (listeners.length !== 0) dispatchQueue.push({
            event: event,
            listeners: listeners
        });
    } // We should only use this function for:
    // - EnterLeaveEventPlugin
    // This is because we only process this plugin
    // in the bubble phase, so we need to accumulate two
    // phase event listeners.
    function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
        var common = from && to ? getLowestCommonAncestor(from, to) : null;
        if (from !== null) accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
        if (to !== null && enterEvent !== null) accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
    }
    function getListenerSetKey(domEventName, capture) {
        return domEventName + "__" + (capture ? 'capture' : 'bubble');
    }
    var didWarnInvalidHydration = false;
    var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
    var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
    var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
    var AUTOFOCUS = 'autoFocus';
    var CHILDREN = 'children';
    var STYLE = 'style';
    var HTML$1 = '__html';
    var HTML_NAMESPACE$1 = Namespaces.html;
    var warnedUnknownTags;
    var suppressHydrationWarning;
    var validatePropertiesInDevelopment;
    var warnForTextDifference;
    var warnForPropDifference;
    var warnForExtraAttributes;
    var warnForInvalidEventListener;
    var canDiffStyleForHydrationWarning;
    var normalizeMarkupForTextOrAttribute;
    var normalizeHTML;
    warnedUnknownTags = {
        // There are working polyfills for <dialog>. Let people use it.
        dialog: true,
        // Electron ships a custom <webview> tag to display external web content in
        // an isolated frame and process.
        // This tag is not present in non Electron environments such as JSDom which
        // is often used for testing purposes.
        // @see https://electronjs.org/docs/api/webview-tag
        webview: true
    };
    validatePropertiesInDevelopment = function(type, props) {
        validateProperties(type, props);
        validateProperties$1(type, props);
        validateProperties$2(type, props, {
            registrationNameDependencies: registrationNameDependencies,
            possibleRegistrationNames: possibleRegistrationNames
        });
    }; // IE 11 parses & normalizes the style attribute as opposed to other
    // browsers. It adds spaces and sorts the properties in some
    // non-alphabetical order. Handling that would require sorting CSS
    // properties in the client & server versions or applying
    // `expectedStyle` to a temporary DOM node to read its `style` attribute
    // normalized. Since it only affects IE, we're skipping style warnings
    // in that browser completely in favor of doing all that work.
    // See https://github.com/facebook/react/issues/11807
    canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode; // HTML parsing normalizes CR and CRLF to LF.
    // It also can turn \u0000 into \uFFFD inside attributes.
    // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
    // If we have a mismatch, it might be caused by that.
    // We will still patch up in this case but not fire the warning.
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
    var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
    normalizeMarkupForTextOrAttribute = function(markup) {
        var markupString = typeof markup === 'string' ? markup : '' + markup;
        return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
    };
    warnForTextDifference = function(serverText, clientText) {
        if (didWarnInvalidHydration) return;
        var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
        var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
        if (normalizedServerText === normalizedClientText) return;
        didWarnInvalidHydration = true;
        error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
    };
    warnForPropDifference = function(propName, serverValue, clientValue) {
        if (didWarnInvalidHydration) return;
        var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
        var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
        if (normalizedServerValue === normalizedClientValue) return;
        didWarnInvalidHydration = true;
        error('Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
    };
    warnForExtraAttributes = function(attributeNames) {
        if (didWarnInvalidHydration) return;
        didWarnInvalidHydration = true;
        var names = [];
        attributeNames.forEach(function(name) {
            names.push(name);
        });
        error('Extra attributes from the server: %s', names);
    };
    warnForInvalidEventListener = function(registrationName, listener) {
        if (listener === false) error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
        else error('Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);
    }; // Parse the HTML and read it back to normalize the HTML string so that it
    // can be used for comparison.
    normalizeHTML = function(parent, html) {
        // We could have created a separate document here to avoid
        // re-initializing custom elements if they exist. But this breaks
        // how <noscript> is being handled. So we use the same document.
        // See the discussion in https://github.com/facebook/react/pull/11157.
        var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
        testElement.innerHTML = html;
        return testElement.innerHTML;
    };
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function noop() {
    }
    function trapClickOnNonInteractiveElement(node) {
        // Mobile Safari does not fire properly bubble click events on
        // non-interactive elements, which means delegated click listeners do not
        // fire. The workaround for this bug involves attaching an empty click
        // listener on the target node.
        // https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
        // Just set it using the onclick property so that we don't have to manage any
        // bookkeeping for it. Not sure if we need to clear it when the listener is
        // removed.
        // TODO: Only do this for the relevant Safaris maybe?
        node.onclick = noop;
    }
    function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
        for(var propKey in nextProps){
            if (!nextProps.hasOwnProperty(propKey)) continue;
            var nextProp = nextProps[propKey];
            if (propKey === STYLE) {
                if (nextProp) // Freeze the next style object so that we can assume it won't be
                // mutated. We have already warned for this in the past.
                Object.freeze(nextProp);
                setValueForStyles(domElement, nextProp);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
                if (nextHtml != null) setInnerHTML(domElement, nextHtml);
            } else if (propKey === CHILDREN) {
                if (typeof nextProp === 'string') {
                    // Avoid setting initial textContent when the text is empty. In IE11 setting
                    // textContent on a <textarea> will cause the placeholder to not
                    // show within the <textarea> until it has been focused and blurred again.
                    // https://github.com/facebook/react/issues/6731#issuecomment-254874553
                    var canSetTextContent = tag !== 'textarea' || nextProp !== '';
                    if (canSetTextContent) setTextContent(domElement, nextProp);
                } else if (typeof nextProp === 'number') setTextContent(domElement, '' + nextProp);
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
            else if (propKey === AUTOFOCUS) ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                    if (typeof nextProp !== 'function') warnForInvalidEventListener(propKey, nextProp);
                    if (propKey === 'onScroll') listenToNonDelegatedEvent('scroll', domElement);
                }
            } else if (nextProp != null) setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
        }
    }
    function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
        // TODO: Handle wasCustomComponentTag
        for(var i = 0; i < updatePayload.length; i += 2){
            var propKey = updatePayload[i];
            var propValue = updatePayload[i + 1];
            if (propKey === STYLE) setValueForStyles(domElement, propValue);
            else if (propKey === DANGEROUSLY_SET_INNER_HTML) setInnerHTML(domElement, propValue);
            else if (propKey === CHILDREN) setTextContent(domElement, propValue);
            else setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
        }
    }
    function createElement(type, props, rootContainerElement, parentNamespace) {
        var isCustomComponentTag; // We create tags in the namespace of their parent container, except HTML
        // tags get no namespace.
        var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
        var domElement;
        var namespaceURI = parentNamespace;
        if (namespaceURI === HTML_NAMESPACE$1) namespaceURI = getIntrinsicNamespace(type);
        if (namespaceURI === HTML_NAMESPACE$1) {
            isCustomComponentTag = isCustomComponent(type, props); // Should this check be gated by parent namespace? Not sure we want to
            // allow <SVG> or <mATH>.
            if (!isCustomComponentTag && type !== type.toLowerCase()) error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
            if (type === 'script') {
                // Create the script via .innerHTML so its "parser-inserted" flag is
                // set to true and it does not execute
                var div = ownerDocument.createElement('div');
                div.innerHTML = "<script></script>"; // eslint-disable-line
                // This is guaranteed to yield a script element.
                var firstChild = div.firstChild;
                domElement = div.removeChild(firstChild);
            } else if (typeof props.is === 'string') // $FlowIssue `createElement` should be updated for Web Components
            domElement = ownerDocument.createElement(type, {
                is: props.is
            });
            else {
                // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
                // See discussion in https://github.com/facebook/react/pull/6896
                // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
                domElement = ownerDocument.createElement(type); // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`
                // attributes on `select`s needs to be added before `option`s are inserted.
                // This prevents:
                // - a bug where the `select` does not scroll to the correct option because singular
                //  `select` elements automatically pick the first item #13222
                // - a bug where the `select` set the first item as selected despite the `size` attribute #14239
                // See https://github.com/facebook/react/issues/13222
                // and https://github.com/facebook/react/issues/14239
                if (type === 'select') {
                    var node = domElement;
                    if (props.multiple) node.multiple = true;
                    else if (props.size) // Setting a size greater than 1 causes a select to behave like `multiple=true`, where
                    // it is possible that no option is selected.
                    //
                    // This is only necessary when a select in "single selection mode".
                    node.size = props.size;
                }
            }
        } else domElement = ownerDocument.createElementNS(namespaceURI, type);
        if (namespaceURI === HTML_NAMESPACE$1) {
            if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
                warnedUnknownTags[type] = true;
                error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
            }
        }
        return domElement;
    }
    function createTextNode(text, rootContainerElement) {
        return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
    }
    function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
        var isCustomComponentTag = isCustomComponent(tag, rawProps);
        validatePropertiesInDevelopment(tag, rawProps);
        var props;
        switch(tag){
            case 'dialog':
                listenToNonDelegatedEvent('cancel', domElement);
                listenToNonDelegatedEvent('close', domElement);
                props = rawProps;
                break;
            case 'iframe':
            case 'object':
            case 'embed':
                // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the load event.
                listenToNonDelegatedEvent('load', domElement);
                props = rawProps;
                break;
            case 'video':
            case 'audio':
                // We listen to these events in case to ensure emulated bubble
                // listeners still fire for all the media events.
                for(var i = 0; i < mediaEventTypes.length; i++)listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                props = rawProps;
                break;
            case 'source':
                // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the error event.
                listenToNonDelegatedEvent('error', domElement);
                props = rawProps;
                break;
            case 'img':
            case 'image':
            case 'link':
                // We listen to these events in case to ensure emulated bubble
                // listeners still fire for error and load events.
                listenToNonDelegatedEvent('error', domElement);
                listenToNonDelegatedEvent('load', domElement);
                props = rawProps;
                break;
            case 'details':
                // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the toggle event.
                listenToNonDelegatedEvent('toggle', domElement);
                props = rawProps;
                break;
            case 'input':
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the invalid event.
                listenToNonDelegatedEvent('invalid', domElement);
                break;
            case 'option':
                validateProps(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                break;
            case 'select':
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the invalid event.
                listenToNonDelegatedEvent('invalid', domElement);
                break;
            case 'textarea':
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$3(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the invalid event.
                listenToNonDelegatedEvent('invalid', domElement);
                break;
            default:
                props = rawProps;
        }
        assertValidProps(tag, props);
        setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
        switch(tag){
            case 'input':
                // TODO: Make sure we check if this is still unmounted or do any clean
                // up necessary since we never stop tracking anymore.
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
            case 'textarea':
                // TODO: Make sure we check if this is still unmounted or do any clean
                // up necessary since we never stop tracking anymore.
                track(domElement);
                postMountWrapper$3(domElement);
                break;
            case 'option':
                postMountWrapper$1(domElement, rawProps);
                break;
            case 'select':
                postMountWrapper$2(domElement, rawProps);
                break;
            default:
                if (typeof props.onClick === 'function') // TODO: This cast may not be sound for SVG, MathML or custom elements.
                trapClickOnNonInteractiveElement(domElement);
                break;
        }
    } // Calculate the diff between the two objects.
    function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
        validatePropertiesInDevelopment(tag, nextRawProps);
        var updatePayload = null;
        var lastProps;
        var nextProps;
        switch(tag){
            case 'input':
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
            case 'option':
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
            case 'select':
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
            case 'textarea':
                lastProps = getHostProps$3(domElement, lastRawProps);
                nextProps = getHostProps$3(domElement, nextRawProps);
                updatePayload = [];
                break;
            default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') // TODO: This cast may not be sound for SVG, MathML or custom elements.
                trapClickOnNonInteractiveElement(domElement);
                break;
        }
        assertValidProps(tag, nextProps);
        var propKey;
        var styleName;
        var styleUpdates = null;
        for(propKey in lastProps){
            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) continue;
            if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for(styleName in lastStyle)if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) styleUpdates = {
                    };
                    styleUpdates[styleName] = '';
                }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
            else if (propKey === AUTOFOCUS) ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) // This is a special case. If any listener updates we need to ensure
            // that the "current" fiber pointer gets updated so we need a commit
            // to update this element.
            {
                if (!updatePayload) updatePayload = [];
            } else // For all other deleted properties we add it to the queue. We use
            // the allowed property list in the commit phase instead.
            (updatePayload = updatePayload || []).push(propKey, null);
        }
        for(propKey in nextProps){
            var nextProp = nextProps[propKey];
            var lastProp = lastProps != null ? lastProps[propKey] : undefined;
            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) continue;
            if (propKey === STYLE) {
                if (nextProp) // Freeze the next style object so that we can assume it won't be
                // mutated. We have already warned for this in the past.
                Object.freeze(nextProp);
                if (lastProp) {
                    // Unset styles on `lastProp` but not on `nextProp`.
                    for(styleName in lastProp)if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                        if (!styleUpdates) styleUpdates = {
                        };
                        styleUpdates[styleName] = '';
                    }
                     // Update styles that changed since `lastProp`.
                    for(styleName in nextProp)if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                        if (!styleUpdates) styleUpdates = {
                        };
                        styleUpdates[styleName] = nextProp[styleName];
                    }
                } else {
                    // Relies on `updateStylesByID` not mutating `styleUpdates`.
                    if (!styleUpdates) {
                        if (!updatePayload) updatePayload = [];
                        updatePayload.push(propKey, styleUpdates);
                    }
                    styleUpdates = nextProp;
                }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
                var lastHtml = lastProp ? lastProp[HTML$1] : undefined;
                if (nextHtml != null) {
                    if (lastHtml !== nextHtml) (updatePayload = updatePayload || []).push(propKey, nextHtml);
                }
            } else if (propKey === CHILDREN) {
                if (typeof nextProp === 'string' || typeof nextProp === 'number') (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                    // We eagerly listen to this even though we haven't committed yet.
                    if (typeof nextProp !== 'function') warnForInvalidEventListener(propKey, nextProp);
                    if (propKey === 'onScroll') listenToNonDelegatedEvent('scroll', domElement);
                }
                if (!updatePayload && lastProp !== nextProp) // This is a special case. If any listener updates we need to ensure
                // that the "current" props pointer gets updated so we need a commit
                // to update this element.
                updatePayload = [];
            } else if (typeof nextProp === 'object' && nextProp !== null && nextProp.$$typeof === REACT_OPAQUE_ID_TYPE) // If we encounter useOpaqueReference's opaque object, this means we are hydrating.
            // In this case, call the opaque object's toString function which generates a new client
            // ID so client and server IDs match and throws to rerender.
            nextProp.toString();
            else // For any other property we always add it to the queue and then we
            // filter it out using the allowed property list during the commit.
            (updatePayload = updatePayload || []).push(propKey, nextProp);
        }
        if (styleUpdates) {
            validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
        }
        return updatePayload;
    } // Apply the diff.
    function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
        // Update checked *before* name.
        // In the middle of an update, it is possible to have multiple checked.
        // When a checked radio tries to change name, browser makes another radio's checked false.
        if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) updateChecked(domElement, nextRawProps);
        var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
        var isCustomComponentTag = isCustomComponent(tag, nextRawProps); // Apply the diff.
        updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag); // TODO: Ensure that an update gets scheduled if any of the special props
        // changed.
        switch(tag){
            case 'input':
                // Update the wrapper around inputs *after* updating props. This has to
                // happen after `updateDOMProperties`. Otherwise HTML5 input validations
                // raise warnings and prevent the new value from being assigned.
                updateWrapper(domElement, nextRawProps);
                break;
            case 'textarea':
                updateWrapper$1(domElement, nextRawProps);
                break;
            case 'select':
                // <select> value update needs to occur after <option> children
                // reconciliation
                postUpdateWrapper(domElement, nextRawProps);
                break;
        }
    }
    function getPossibleStandardName(propName) {
        var lowerCasedName = propName.toLowerCase();
        if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) return null;
        return possibleStandardNames[lowerCasedName] || null;
    }
    function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
        var isCustomComponentTag;
        var extraAttributeNames;
        suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === true;
        isCustomComponentTag = isCustomComponent(tag, rawProps);
        validatePropertiesInDevelopment(tag, rawProps);
        switch(tag){
            case 'dialog':
                listenToNonDelegatedEvent('cancel', domElement);
                listenToNonDelegatedEvent('close', domElement);
                break;
            case 'iframe':
            case 'object':
            case 'embed':
                // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the load event.
                listenToNonDelegatedEvent('load', domElement);
                break;
            case 'video':
            case 'audio':
                // We listen to these events in case to ensure emulated bubble
                // listeners still fire for all the media events.
                for(var i = 0; i < mediaEventTypes.length; i++)listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                break;
            case 'source':
                // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the error event.
                listenToNonDelegatedEvent('error', domElement);
                break;
            case 'img':
            case 'image':
            case 'link':
                // We listen to these events in case to ensure emulated bubble
                // listeners still fire for error and load events.
                listenToNonDelegatedEvent('error', domElement);
                listenToNonDelegatedEvent('load', domElement);
                break;
            case 'details':
                // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the toggle event.
                listenToNonDelegatedEvent('toggle', domElement);
                break;
            case 'input':
                initWrapperState(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the invalid event.
                listenToNonDelegatedEvent('invalid', domElement);
                break;
            case 'option':
                validateProps(domElement, rawProps);
                break;
            case 'select':
                initWrapperState$1(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the invalid event.
                listenToNonDelegatedEvent('invalid', domElement);
                break;
            case 'textarea':
                initWrapperState$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
                // listeners still fire for the invalid event.
                listenToNonDelegatedEvent('invalid', domElement);
                break;
        }
        assertValidProps(tag, rawProps);
        extraAttributeNames = new Set();
        var attributes = domElement.attributes;
        for(var _i = 0; _i < attributes.length; _i++){
            var name = attributes[_i].name.toLowerCase();
            switch(name){
                // Built-in SSR attribute is allowed
                case 'data-reactroot':
                    break;
                // Controlled attributes are not validated
                // TODO: Only ignore them on controlled tags.
                case 'value':
                    break;
                case 'checked':
                    break;
                case 'selected':
                    break;
                default:
                    // Intentionally use the original name.
                    // See discussion in https://github.com/facebook/react/pull/10676.
                    extraAttributeNames.add(attributes[_i].name);
            }
        }
        var updatePayload = null;
        for(var propKey in rawProps){
            if (!rawProps.hasOwnProperty(propKey)) continue;
            var nextProp = rawProps[propKey];
            if (propKey === CHILDREN) {
                // For text content children we compare against textContent. This
                // might match additional HTML that is hidden when we read it using
                // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
                // satisfies our requirement. Our requirement is not to produce perfect
                // HTML and attributes. Ideally we should preserve structure but it's
                // ok not to if the visible content is still enough to indicate what
                // even listeners these nodes might be wired up to.
                // TODO: Warn if there is more than a single textNode as a child.
                // TODO: Should we use domElement.firstChild.nodeValue to compare?
                if (typeof nextProp === 'string') {
                    if (domElement.textContent !== nextProp) {
                        if (!suppressHydrationWarning) warnForTextDifference(domElement.textContent, nextProp);
                        updatePayload = [
                            CHILDREN,
                            nextProp
                        ];
                    }
                } else if (typeof nextProp === 'number') {
                    if (domElement.textContent !== '' + nextProp) {
                        if (!suppressHydrationWarning) warnForTextDifference(domElement.textContent, nextProp);
                        updatePayload = [
                            CHILDREN,
                            '' + nextProp
                        ];
                    }
                }
            } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                    if (typeof nextProp !== 'function') warnForInvalidEventListener(propKey, nextProp);
                    if (propKey === 'onScroll') listenToNonDelegatedEvent('scroll', domElement);
                }
            } else if (typeof isCustomComponentTag === 'boolean') {
                // Validate that the properties correspond to their expected values.
                var serverValue = void 0;
                var propertyInfo = getPropertyInfo(propKey);
                if (suppressHydrationWarning) ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // TODO: Only ignore them on controlled tags.
                propKey === 'value' || propKey === 'checked' || propKey === 'selected') ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                    var serverHTML = domElement.innerHTML;
                    var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
                    if (nextHtml != null) {
                        var expectedHTML = normalizeHTML(domElement, nextHtml);
                        if (expectedHTML !== serverHTML) warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                } else if (propKey === STYLE) {
                    // $FlowFixMe - Should be inferred as not undefined.
                    extraAttributeNames.delete(propKey);
                    if (canDiffStyleForHydrationWarning) {
                        var expectedStyle = createDangerousStringForStyles(nextProp);
                        serverValue = domElement.getAttribute('style');
                        if (expectedStyle !== serverValue) warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                } else if (isCustomComponentTag) {
                    // $FlowFixMe - Should be inferred as not undefined.
                    extraAttributeNames.delete(propKey.toLowerCase());
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                    if (nextProp !== serverValue) warnForPropDifference(propKey, serverValue, nextProp);
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                    var isMismatchDueToBadCasing = false;
                    if (propertyInfo !== null) {
                        // $FlowFixMe - Should be inferred as not undefined.
                        extraAttributeNames.delete(propertyInfo.attributeName);
                        serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                    } else {
                        var ownNamespace = parentNamespace;
                        if (ownNamespace === HTML_NAMESPACE$1) ownNamespace = getIntrinsicNamespace(tag);
                        if (ownNamespace === HTML_NAMESPACE$1) // $FlowFixMe - Should be inferred as not undefined.
                        extraAttributeNames.delete(propKey.toLowerCase());
                        else {
                            var standardName = getPossibleStandardName(propKey);
                            if (standardName !== null && standardName !== propKey) {
                                // If an SVG prop is supplied with bad casing, it will
                                // be successfully parsed from HTML, but will produce a mismatch
                                // (and would be incorrectly rendered on the client).
                                // However, we already warn about bad casing elsewhere.
                                // So we'll skip the misleading extra mismatch warning in this case.
                                isMismatchDueToBadCasing = true; // $FlowFixMe - Should be inferred as not undefined.
                                extraAttributeNames.delete(standardName);
                            } // $FlowFixMe - Should be inferred as not undefined.
                            extraAttributeNames.delete(propKey);
                        }
                        serverValue = getValueForAttribute(domElement, propKey, nextProp);
                    }
                    if (nextProp !== serverValue && !isMismatchDueToBadCasing) warnForPropDifference(propKey, serverValue, nextProp);
                }
            }
        }
        // $FlowFixMe - Should be inferred as not undefined.
        if (extraAttributeNames.size > 0 && !suppressHydrationWarning) // $FlowFixMe - Should be inferred as not undefined.
        warnForExtraAttributes(extraAttributeNames);
        switch(tag){
            case 'input':
                // TODO: Make sure we check if this is still unmounted or do any clean
                // up necessary since we never stop tracking anymore.
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
            case 'textarea':
                // TODO: Make sure we check if this is still unmounted or do any clean
                // up necessary since we never stop tracking anymore.
                track(domElement);
                postMountWrapper$3(domElement);
                break;
            case 'select':
            case 'option':
                break;
            default:
                if (typeof rawProps.onClick === 'function') // TODO: This cast may not be sound for SVG, MathML or custom elements.
                trapClickOnNonInteractiveElement(domElement);
                break;
        }
        return updatePayload;
    }
    function diffHydratedText(textNode, text) {
        var isDifferent = textNode.nodeValue !== text;
        return isDifferent;
    }
    function warnForUnmatchedText(textNode, text) {
        warnForTextDifference(textNode.nodeValue, text);
    }
    function warnForDeletedHydratableElement(parentNode, child) {
        if (didWarnInvalidHydration) return;
        didWarnInvalidHydration = true;
        error('Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
    }
    function warnForDeletedHydratableText(parentNode, child) {
        if (didWarnInvalidHydration) return;
        didWarnInvalidHydration = true;
        error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
    }
    function warnForInsertedHydratedElement(parentNode, tag, props) {
        if (didWarnInvalidHydration) return;
        didWarnInvalidHydration = true;
        error('Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
    }
    function warnForInsertedHydratedText(parentNode, text) {
        if (text === '') // We expect to insert empty text nodes since they're not represented in
        // the HTML.
        // TODO: Remove this special case if we can just avoid inserting empty
        // text nodes.
        return;
        if (didWarnInvalidHydration) return;
        didWarnInvalidHydration = true;
        error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
    }
    function restoreControlledState$3(domElement, tag, props) {
        switch(tag){
            case 'input':
                restoreControlledState(domElement, props);
                return;
            case 'textarea':
                restoreControlledState$2(domElement, props);
                return;
            case 'select':
                restoreControlledState$1(domElement, props);
                return;
        }
    }
    var validateDOMNesting = function() {
    };
    var updatedAncestorInfo = function() {
    };
    // This validation code was written based on the HTML5 parsing spec:
    // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
    //
    // Note: this does not catch all invalid nesting, nor does it try to (as it's
    // not clear what practical benefit doing so provides); instead, we warn only
    // for cases where the parser will give a parse tree differing from what React
    // intended. For example, <b><div></div></b> is invalid but we don't warn
    // because it still parses correctly; we do warn for other cases like nested
    // <p> tags where the beginning of the second element implicitly closes the
    // first, causing a confusing mess.
    // https://html.spec.whatwg.org/multipage/syntax.html#special
    var specialTags = [
        'address',
        'applet',
        'area',
        'article',
        'aside',
        'base',
        'basefont',
        'bgsound',
        'blockquote',
        'body',
        'br',
        'button',
        'caption',
        'center',
        'col',
        'colgroup',
        'dd',
        'details',
        'dir',
        'div',
        'dl',
        'dt',
        'embed',
        'fieldset',
        'figcaption',
        'figure',
        'footer',
        'form',
        'frame',
        'frameset',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'head',
        'header',
        'hgroup',
        'hr',
        'html',
        'iframe',
        'img',
        'input',
        'isindex',
        'li',
        'link',
        'listing',
        'main',
        'marquee',
        'menu',
        'menuitem',
        'meta',
        'nav',
        'noembed',
        'noframes',
        'noscript',
        'object',
        'ol',
        'p',
        'param',
        'plaintext',
        'pre',
        'script',
        'section',
        'select',
        'source',
        'style',
        'summary',
        'table',
        'tbody',
        'td',
        'template',
        'textarea',
        'tfoot',
        'th',
        'thead',
        'title',
        'tr',
        'track',
        'ul',
        'wbr',
        'xmp'
    ]; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
    var inScopeTags = [
        'applet',
        'caption',
        'html',
        'table',
        'td',
        'th',
        'marquee',
        'object',
        'template',
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        'foreignObject',
        'desc',
        'title'
    ]; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
    var buttonScopeTags = inScopeTags.concat([
        'button'
    ]); // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
    var impliedEndTags = [
        'dd',
        'dt',
        'li',
        'option',
        'optgroup',
        'p',
        'rp',
        'rt'
    ];
    var emptyAncestorInfo = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
    };
    updatedAncestorInfo = function(oldInfo, tag) {
        var ancestorInfo = _assign({
        }, oldInfo || emptyAncestorInfo);
        var info = {
            tag: tag
        };
        if (inScopeTags.indexOf(tag) !== -1) {
            ancestorInfo.aTagInScope = null;
            ancestorInfo.buttonTagInScope = null;
            ancestorInfo.nobrTagInScope = null;
        }
        if (buttonScopeTags.indexOf(tag) !== -1) ancestorInfo.pTagInButtonScope = null;
         // See rules for 'li', 'dd', 'dt' start tags in
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
        if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
            ancestorInfo.listItemTagAutoclosing = null;
            ancestorInfo.dlItemTagAutoclosing = null;
        }
        ancestorInfo.current = info;
        if (tag === 'form') ancestorInfo.formTag = info;
        if (tag === 'a') ancestorInfo.aTagInScope = info;
        if (tag === 'button') ancestorInfo.buttonTagInScope = info;
        if (tag === 'nobr') ancestorInfo.nobrTagInScope = info;
        if (tag === 'p') ancestorInfo.pTagInButtonScope = info;
        if (tag === 'li') ancestorInfo.listItemTagAutoclosing = info;
        if (tag === 'dd' || tag === 'dt') ancestorInfo.dlItemTagAutoclosing = info;
        return ancestorInfo;
    };
    /**
   * Returns whether
   */ var isTagValidWithParent = function(tag, parentTag) {
        // First, let's check if we're in an unusual parsing mode...
        switch(parentTag){
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
            case 'select':
                return tag === 'option' || tag === 'optgroup' || tag === '#text';
            case 'optgroup':
                return tag === 'option' || tag === '#text';
            // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
            // but
            case 'option':
                return tag === '#text';
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
            // No special behavior since these rules fall back to "in body" mode for
            // all except special table nodes which cause bad parsing behavior anyway.
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
            case 'tr':
                return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
            case 'tbody':
            case 'thead':
            case 'tfoot':
                return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
            case 'colgroup':
                return tag === 'col' || tag === 'template';
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
            case 'table':
                return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
            case 'head':
                return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
            // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
            case 'html':
                return tag === 'head' || tag === 'body' || tag === 'frameset';
            case 'frameset':
                return tag === 'frame';
            case '#document':
                return tag === 'html';
        } // Probably in the "in body" parsing mode, so we outlaw only tag combos
        // where the parsing rules cause implicit opens or closes to be added.
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
        switch(tag){
            case 'h1':
            case 'h2':
            case 'h3':
            case 'h4':
            case 'h5':
            case 'h6':
                return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
            case 'rp':
            case 'rt':
                return impliedEndTags.indexOf(parentTag) === -1;
            case 'body':
            case 'caption':
            case 'col':
            case 'colgroup':
            case 'frameset':
            case 'frame':
            case 'head':
            case 'html':
            case 'tbody':
            case 'td':
            case 'tfoot':
            case 'th':
            case 'thead':
            case 'tr':
                // These tags are only valid with a few parents that have special child
                // parsing rules -- if we're down here, then none of those matched and
                // so we allow it only if we don't know what the parent is, as all other
                // cases are invalid.
                return parentTag == null;
        }
        return true;
    };
    /**
   * Returns whether
   */ var findInvalidAncestorForTag = function(tag, ancestorInfo) {
        switch(tag){
            case 'address':
            case 'article':
            case 'aside':
            case 'blockquote':
            case 'center':
            case 'details':
            case 'dialog':
            case 'dir':
            case 'div':
            case 'dl':
            case 'fieldset':
            case 'figcaption':
            case 'figure':
            case 'footer':
            case 'header':
            case 'hgroup':
            case 'main':
            case 'menu':
            case 'nav':
            case 'ol':
            case 'p':
            case 'section':
            case 'summary':
            case 'ul':
            case 'pre':
            case 'listing':
            case 'table':
            case 'hr':
            case 'xmp':
            case 'h1':
            case 'h2':
            case 'h3':
            case 'h4':
            case 'h5':
            case 'h6':
                return ancestorInfo.pTagInButtonScope;
            case 'form':
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case 'li':
                return ancestorInfo.listItemTagAutoclosing;
            case 'dd':
            case 'dt':
                return ancestorInfo.dlItemTagAutoclosing;
            case 'button':
                return ancestorInfo.buttonTagInScope;
            case 'a':
                // Spec says something about storing a list of markers, but it sounds
                // equivalent to this check.
                return ancestorInfo.aTagInScope;
            case 'nobr':
                return ancestorInfo.nobrTagInScope;
        }
        return null;
    };
    var didWarn$1 = {
    };
    validateDOMNesting = function(childTag, childText, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.current;
        var parentTag = parentInfo && parentInfo.tag;
        if (childText != null) {
            if (childTag != null) error('validateDOMNesting: when childText is passed, childTag should be null');
            childTag = '#text';
        }
        var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
        var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
        var invalidParentOrAncestor = invalidParent || invalidAncestor;
        if (!invalidParentOrAncestor) return;
        var ancestorTag = invalidParentOrAncestor.tag;
        var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag;
        if (didWarn$1[warnKey]) return;
        didWarn$1[warnKey] = true;
        var tagDisplayName = childTag;
        var whitespaceInfo = '';
        if (childTag === '#text') {
            if (/\S/.test(childText)) tagDisplayName = 'Text nodes';
            else {
                tagDisplayName = 'Whitespace text nodes';
                whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
            }
        } else tagDisplayName = '<' + childTag + '>';
        if (invalidParent) {
            var info = '';
            if (ancestorTag === 'table' && childTag === 'tr') info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
            error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info);
        } else error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
    };
    var SUPPRESS_HYDRATION_WARNING$1;
    SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
    var SUSPENSE_START_DATA = '$';
    var SUSPENSE_END_DATA = '/$';
    var SUSPENSE_PENDING_START_DATA = '$?';
    var SUSPENSE_FALLBACK_START_DATA = '$!';
    var STYLE$1 = 'style';
    var eventsEnabled = null;
    var selectionInformation = null;
    function shouldAutoFocusHostComponent(type, props) {
        switch(type){
            case 'button':
            case 'input':
            case 'select':
            case 'textarea':
                return !!props.autoFocus;
        }
        return false;
    }
    function getRootHostContext(rootContainerInstance) {
        var type;
        var namespace;
        var nodeType = rootContainerInstance.nodeType;
        switch(nodeType){
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
                type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
                var root1 = rootContainerInstance.documentElement;
                namespace = root1 ? root1.namespaceURI : getChildNamespace(null, '');
                break;
            default:
                var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container.namespaceURI || null;
                type = container.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
        }
        var validatedTag = type.toLowerCase();
        var ancestorInfo = updatedAncestorInfo(null, validatedTag);
        return {
            namespace: namespace,
            ancestorInfo: ancestorInfo
        };
    }
    function getChildHostContext(parentHostContext, type, rootContainerInstance) {
        var parentHostContextDev = parentHostContext;
        var namespace = getChildNamespace(parentHostContextDev.namespace, type);
        var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
        return {
            namespace: namespace,
            ancestorInfo: ancestorInfo
        };
    }
    function getPublicInstance(instance) {
        return instance;
    }
    function prepareForCommit(containerInfo) {
        eventsEnabled = isEnabled();
        selectionInformation = getSelectionInformation();
        var activeInstance = null;
        setEnabled(false);
        return activeInstance;
    }
    function resetAfterCommit(containerInfo) {
        restoreSelection(selectionInformation);
        setEnabled(eventsEnabled);
        eventsEnabled = null;
        selectionInformation = null;
    }
    function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        var parentNamespace;
        // TODO: take namespace into account when validating.
        var hostContextDev = hostContext;
        validateDOMNesting(type, null, hostContextDev.ancestorInfo);
        if (typeof props.children === 'string' || typeof props.children === 'number') {
            var string = '' + props.children;
            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
        }
        parentNamespace = hostContextDev.namespace;
        var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
        precacheFiberNode(internalInstanceHandle, domElement);
        updateFiberProps(domElement, props);
        return domElement;
    }
    function appendInitialChild(parentInstance, child) {
        parentInstance.appendChild(child);
    }
    function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
        setInitialProperties(domElement, type, props, rootContainerInstance);
        return shouldAutoFocusHostComponent(type, props);
    }
    function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
        var hostContextDev = hostContext;
        if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
            var string = '' + newProps.children;
            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
        }
        return diffProperties(domElement, type, oldProps, newProps);
    }
    function shouldSetTextContent(type, props) {
        return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
    }
    function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        var hostContextDev = hostContext;
        validateDOMNesting(null, text, hostContextDev.ancestorInfo);
        var textNode = createTextNode(text, rootContainerInstance);
        precacheFiberNode(internalInstanceHandle, textNode);
        return textNode;
    }
    // if a component just imports ReactDOM (e.g. for findDOMNode).
    // Some environments might not have setTimeout or clearTimeout.
    var scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
    var cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;
    var noTimeout = -1; // -------------------
    function commitMount(domElement, type, newProps, internalInstanceHandle) {
        // Despite the naming that might imply otherwise, this method only
        // fires if there is an `Update` effect scheduled during mounting.
        // This happens if `finalizeInitialChildren` returns `true` (which it
        // does to implement the `autoFocus` attribute on the client). But
        // there are also other cases when this might happen (such as patching
        // up text content during hydration mismatch). So we'll check this again.
        if (shouldAutoFocusHostComponent(type, newProps)) domElement.focus();
    }
    function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
        // Update the props handle so that we know which props are the ones with
        // with current event handlers.
        updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.
        updateProperties(domElement, updatePayload, type, oldProps, newProps);
    }
    function resetTextContent(domElement) {
        setTextContent(domElement, '');
    }
    function commitTextUpdate(textInstance, oldText, newText) {
        textInstance.nodeValue = newText;
    }
    function appendChild(parentInstance, child) {
        parentInstance.appendChild(child);
    }
    function appendChildToContainer(container, child) {
        var parentNode;
        if (container.nodeType === COMMENT_NODE) {
            parentNode = container.parentNode;
            parentNode.insertBefore(child, container);
        } else {
            parentNode = container;
            parentNode.appendChild(child);
        } // This container might be used for a portal.
        // If something inside a portal is clicked, that click should bubble
        // through the React tree. However, on Mobile Safari the click would
        // never bubble through the *DOM* tree unless an ancestor with onclick
        // event exists. So we wouldn't see it and dispatch it.
        // This is why we ensure that non React root containers have inline onclick
        // defined.
        // https://github.com/facebook/react/issues/11918
        var reactRootContainer = container._reactRootContainer;
        if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(parentNode);
    }
    function insertBefore(parentInstance, child, beforeChild) {
        parentInstance.insertBefore(child, beforeChild);
    }
    function insertInContainerBefore(container, child, beforeChild) {
        if (container.nodeType === COMMENT_NODE) container.parentNode.insertBefore(child, beforeChild);
        else container.insertBefore(child, beforeChild);
    }
    function removeChild(parentInstance, child) {
        parentInstance.removeChild(child);
    }
    function removeChildFromContainer(container, child) {
        if (container.nodeType === COMMENT_NODE) container.parentNode.removeChild(child);
        else container.removeChild(child);
    }
    function hideInstance(instance) {
        var style1 = instance.style;
        if (typeof style1.setProperty === 'function') style1.setProperty('display', 'none', 'important');
        else style1.display = 'none';
    }
    function hideTextInstance(textInstance) {
        textInstance.nodeValue = '';
    }
    function unhideInstance(instance, props) {
        var styleProp = props[STYLE$1];
        var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;
        instance.style.display = dangerousStyleValue('display', display);
    }
    function unhideTextInstance(textInstance, text) {
        textInstance.nodeValue = text;
    }
    function clearContainer(container) {
        if (container.nodeType === ELEMENT_NODE) container.textContent = '';
        else if (container.nodeType === DOCUMENT_NODE) {
            var body = container.body;
            if (body != null) body.textContent = '';
        }
    } // -------------------
    function canHydrateInstance(instance, type, props) {
        if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) return null;
         // This has now been refined to an element node.
        return instance;
    }
    function canHydrateTextInstance(instance, text) {
        if (text === '' || instance.nodeType !== TEXT_NODE) // Empty strings are not parsed by HTML so there won't be a correct match here.
        return null;
         // This has now been refined to a text node.
        return instance;
    }
    function isSuspenseInstancePending(instance) {
        return instance.data === SUSPENSE_PENDING_START_DATA;
    }
    function isSuspenseInstanceFallback(instance) {
        return instance.data === SUSPENSE_FALLBACK_START_DATA;
    }
    function getNextHydratable(node) {
        // Skip non-hydratable nodes.
        for(; node != null; node = node.nextSibling){
            var nodeType = node.nodeType;
            if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) break;
        }
        return node;
    }
    function getNextHydratableSibling(instance) {
        return getNextHydratable(instance.nextSibling);
    }
    function getFirstHydratableChild(parentInstance) {
        return getNextHydratable(parentInstance.firstChild);
    }
    function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events
        // get attached.
        updateFiberProps(instance, props);
        var parentNamespace;
        var hostContextDev = hostContext;
        parentNamespace = hostContextDev.namespace;
        return diffHydratedProperties(instance, type, props, parentNamespace);
    }
    function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
        precacheFiberNode(internalInstanceHandle, textInstance);
        return diffHydratedText(textInstance, text);
    }
    function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
        var node = suspenseInstance.nextSibling; // Skip past all nodes within this suspense boundary.
        // There might be nested nodes so we need to keep track of how
        // deep we are and only break out when we're back on top.
        var depth = 0;
        while(node){
            if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_END_DATA) {
                    if (depth === 0) return getNextHydratableSibling(node);
                    else depth--;
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) depth++;
            }
            node = node.nextSibling;
        } // TODO: Warn, we didn't find the end comment boundary.
        return null;
    } // Returns the SuspenseInstance if this node is a direct child of a
    // SuspenseInstance. I.e. if its previous sibling is a Comment with
    // SUSPENSE_x_START_DATA. Otherwise, null.
    function getParentSuspenseInstance(targetInstance) {
        var node = targetInstance.previousSibling; // Skip past all nodes within this suspense boundary.
        // There might be nested nodes so we need to keep track of how
        // deep we are and only break out when we're back on top.
        var depth = 0;
        while(node){
            if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                    if (depth === 0) return node;
                    else depth--;
                } else if (data === SUSPENSE_END_DATA) depth++;
            }
            node = node.previousSibling;
        }
        return null;
    }
    function commitHydratedContainer(container) {
        // Retry if any event replaying was blocked on this.
        retryIfBlockedOn(container);
    }
    function commitHydratedSuspenseInstance(suspenseInstance) {
        // Retry if any event replaying was blocked on this.
        retryIfBlockedOn(suspenseInstance);
    }
    function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
        warnForUnmatchedText(textInstance, text);
    }
    function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) warnForUnmatchedText(textInstance, text);
    }
    function didNotHydrateContainerInstance(parentContainer, instance) {
        if (instance.nodeType === ELEMENT_NODE) warnForDeletedHydratableElement(parentContainer, instance);
        else if (instance.nodeType === COMMENT_NODE) ;
        else warnForDeletedHydratableText(parentContainer, instance);
    }
    function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            if (instance.nodeType === ELEMENT_NODE) warnForDeletedHydratableElement(parentInstance, instance);
            else if (instance.nodeType === COMMENT_NODE) ;
            else warnForDeletedHydratableText(parentInstance, instance);
        }
    }
    function didNotFindHydratableContainerInstance(parentContainer, type, props) {
        warnForInsertedHydratedElement(parentContainer, type);
    }
    function didNotFindHydratableContainerTextInstance(parentContainer, text) {
        warnForInsertedHydratedText(parentContainer, text);
    }
    function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) warnForInsertedHydratedElement(parentInstance, type);
    }
    function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) warnForInsertedHydratedText(parentInstance, text);
    }
    function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
        parentProps[SUPPRESS_HYDRATION_WARNING$1];
    }
    var clientId = 0;
    function makeClientIdInDEV(warnOnAccessInDEV) {
        var id = 'r:' + (clientId++).toString(36);
        return {
            toString: function() {
                warnOnAccessInDEV();
                return id;
            },
            valueOf: function() {
                warnOnAccessInDEV();
                return id;
            }
        };
    }
    function isOpaqueHydratingObject(value) {
        return value !== null && typeof value === 'object' && value.$$typeof === REACT_OPAQUE_ID_TYPE;
    }
    function makeOpaqueHydratingObject(attemptToReadValue) {
        return {
            $$typeof: REACT_OPAQUE_ID_TYPE,
            toString: attemptToReadValue,
            valueOf: attemptToReadValue
        };
    }
    function preparePortalMount(portalInstance) {
        listenToAllSupportedEvents(portalInstance);
    }
    var randomKey = Math.random().toString(36).slice(2);
    var internalInstanceKey = '__reactFiber$' + randomKey;
    var internalPropsKey = '__reactProps$' + randomKey;
    var internalContainerInstanceKey = '__reactContainer$' + randomKey;
    var internalEventHandlersKey = '__reactEvents$' + randomKey;
    function precacheFiberNode(hostInst, node) {
        node[internalInstanceKey] = hostInst;
    }
    function markContainerAsRoot(hostRoot, node) {
        node[internalContainerInstanceKey] = hostRoot;
    }
    function unmarkContainerAsRoot(node) {
        node[internalContainerInstanceKey] = null;
    }
    function isContainerMarkedAsRoot(node) {
        return !!node[internalContainerInstanceKey];
    } // Given a DOM node, return the closest HostComponent or HostText fiber ancestor.
    // If the target node is part of a hydrated or not yet rendered subtree, then
    // this may also return a SuspenseComponent or HostRoot to indicate that.
    // Conceptually the HostRoot fiber is a child of the Container node. So if you
    // pass the Container node as the targetNode, you will not actually get the
    // HostRoot back. To get to the HostRoot, you need to pass a child of it.
    // The same thing applies to Suspense boundaries.
    function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) // Don't return HostRoot or SuspenseComponent here.
        return targetInst;
         // If the direct event target isn't a React owned DOM node, we need to look
        // to see if one of its parents is a React owned DOM node.
        var parentNode = targetNode.parentNode;
        while(parentNode){
            // We'll check if this is a container root that could include
            // React nodes in the future. We need to check this first because
            // if we're a child of a dehydrated container, we need to first
            // find that inner container before moving on to finding the parent
            // instance. Note that we don't check this field on  the targetNode
            // itself because the fibers are conceptually between the container
            // node and the first child. It isn't surrounding the container node.
            // If it's not a container, we check if it's an instance.
            targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
            if (targetInst) {
                // Since this wasn't the direct target of the event, we might have
                // stepped past dehydrated DOM nodes to get here. However they could
                // also have been non-React nodes. We need to answer which one.
                // If we the instance doesn't have any children, then there can't be
                // a nested suspense boundary within it. So we can use this as a fast
                // bailout. Most of the time, when people add non-React children to
                // the tree, it is using a ref to a child-less DOM node.
                // Normally we'd only need to check one of the fibers because if it
                // has ever gone from having children to deleting them or vice versa
                // it would have deleted the dehydrated boundary nested inside already.
                // However, since the HostRoot starts out with an alternate it might
                // have one on the alternate so we need to check in case this was a
                // root.
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                    // Next we need to figure out if the node that skipped past is
                    // nested within a dehydrated boundary and if so, which one.
                    var suspenseInstance = getParentSuspenseInstance(targetNode);
                    while(suspenseInstance !== null){
                        // We found a suspense instance. That means that we haven't
                        // hydrated it yet. Even though we leave the comments in the
                        // DOM after hydrating, and there are boundaries in the DOM
                        // that could already be hydrated, we wouldn't have found them
                        // through this pass since if the target is hydrated it would
                        // have had an internalInstanceKey on it.
                        // Let's get the fiber associated with the SuspenseComponent
                        // as the deepest instance.
                        var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                        if (targetSuspenseInst) return targetSuspenseInst;
                         // If we don't find a Fiber on the comment, it might be because
                        // we haven't gotten to hydrate it yet. There might still be a
                        // parent boundary that hasn't above this one so we need to find
                        // the outer most that is known.
                        suspenseInstance = getParentSuspenseInstance(suspenseInstance); // If we don't find one, then that should mean that the parent
                    // host component also hasn't hydrated yet. We can return it
                    // below since it will bail out on the isMounted check later.
                    }
                }
                return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
        }
        return null;
    }
    /**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */ function getInstanceFromNode(node) {
        var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
        if (inst) {
            if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) return inst;
            else return null;
        }
        return null;
    }
    /**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */ function getNodeFromInstance(inst) {
        if (inst.tag === HostComponent || inst.tag === HostText) // In Fiber this, is just the state node right now. We assume it will be
        // a host component or host text.
        return inst.stateNode;
         // Without this first invariant, passing a non-DOM-component triggers the next
        throw Error("getNodeFromInstance: Invalid argument.");
    }
    function getFiberCurrentPropsFromNode(node) {
        return node[internalPropsKey] || null;
    }
    function updateFiberProps(node, props) {
        node[internalPropsKey] = props;
    }
    function getEventListenerSet(node) {
        var elementListenerSet = node[internalEventHandlersKey];
        if (elementListenerSet === undefined) elementListenerSet = node[internalEventHandlersKey] = new Set();
        return elementListenerSet;
    }
    var loggedTypeFailures = {
    };
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has1 = Function.call.bind(Object.prototype.hasOwnProperty);
        for(var typeSpecName in typeSpecs)if (has1(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.
            try {
                // This is intentionally an invariant that gets caught. It's the same
                // behavior as without this statement except with a better message.
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                    var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                    err.name = 'Invariant Violation';
                    throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
                error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || 'React class', location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                // Only monitor this failure once because there tends to be a lot of the
                // same error.
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error('Failed %s type: %s', location, error$1.message);
                setCurrentlyValidatingElement(null);
            }
        }
    }
    var valueStack = [];
    var fiberStack;
    fiberStack = [];
    var index = -1;
    function createCursor(defaultValue) {
        return {
            current: defaultValue
        };
    }
    function pop(cursor, fiber) {
        if (index < 0) {
            error('Unexpected pop.');
            return;
        }
        if (fiber !== fiberStack[index]) error('Unexpected Fiber popped.');
        cursor.current = valueStack[index];
        valueStack[index] = null;
        fiberStack[index] = null;
        index--;
    }
    function push(cursor, value, fiber) {
        index++;
        valueStack[index] = cursor.current;
        fiberStack[index] = fiber;
        cursor.current = value;
    }
    var warnedAboutMissingGetChildContext;
    warnedAboutMissingGetChildContext = {
    };
    var emptyContextObject = {
    };
    Object.freeze(emptyContextObject);
    var contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.
    var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.
    // We use this to get access to the parent context after we have already
    // pushed the next context provider, and now need to merge their contexts.
    var previousContext = emptyContextObject;
    function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
        if (didPushOwnContextIfProvider && isContextProvider(Component)) // If the fiber is a context provider itself, when we read its context
        // we may have already pushed its own child context on the stack. A context
        // provider should not "see" its own child context. Therefore we read the
        // previous (parent) context instead for a context provider.
        return previousContext;
        return contextStackCursor.current;
    }
    function cacheContext(workInProgress, unmaskedContext, maskedContext) {
        var instance = workInProgress.stateNode;
        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
        instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
    }
    function getMaskedContext(workInProgress, unmaskedContext) {
        var type = workInProgress.type;
        var contextTypes = type.contextTypes;
        if (!contextTypes) return emptyContextObject;
         // Avoid recreating masked context unless unmasked context has changed.
        // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
        // This may trigger infinite loops if componentWillReceiveProps calls setState.
        var instance = workInProgress.stateNode;
        if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) return instance.__reactInternalMemoizedMaskedChildContext;
        var context = {
        };
        for(var key in contextTypes)context[key] = unmaskedContext[key];
        var name = getComponentName(type) || 'Unknown';
        checkPropTypes(contextTypes, context, 'context', name);
        // Context is created before the class component is instantiated so check for instance.
        if (instance) cacheContext(workInProgress, unmaskedContext, context);
        return context;
    }
    function hasContextChanged() {
        return didPerformWorkStackCursor.current;
    }
    function isContextProvider(type) {
        var childContextTypes = type.childContextTypes;
        return childContextTypes !== null && childContextTypes !== undefined;
    }
    function popContext(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
    }
    function popTopLevelContextObject(fiber) {
        pop(didPerformWorkStackCursor, fiber);
        pop(contextStackCursor, fiber);
    }
    function pushTopLevelContextObject(fiber, context, didChange) {
        if (!(contextStackCursor.current === emptyContextObject)) throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        push(contextStackCursor, context, fiber);
        push(didPerformWorkStackCursor, didChange, fiber);
    }
    function processChildContext(fiber, type, parentContext) {
        var instance = fiber.stateNode;
        var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.
        // It has only been added in Fiber to match the (unintentional) behavior in Stack.
        if (typeof instance.getChildContext !== 'function') {
            var componentName = getComponentName(type) || 'Unknown';
            if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
            }
            return parentContext;
        }
        var childContext = instance.getChildContext();
        for(var contextKey in childContext){
            if (!(contextKey in childContextTypes)) throw Error((getComponentName(type) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
        }
        var name = getComponentName(type) || 'Unknown';
        checkPropTypes(childContextTypes, childContext, 'child context', name);
        return _assign({
        }, parentContext, childContext);
    }
    function pushContextProvider(workInProgress) {
        var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.
        // If the instance does not exist yet, we will push null at first,
        // and replace it on the stack later when invalidating the context.
        var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.
        // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
        previousContext = contextStackCursor.current;
        push(contextStackCursor, memoizedMergedChildContext, workInProgress);
        push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
        return true;
    }
    function invalidateContextProvider(workInProgress, type, didChange) {
        var instance = workInProgress.stateNode;
        if (!instance) throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (didChange) {
            // Merge parent and own context.
            // Skip this if we're not updating due to sCU.
            // This avoids unnecessarily recomputing memoized values.
            var mergedContext = processChildContext(workInProgress, type, previousContext);
            instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.
            // It is important to unwind the context in the reverse order.
            pop(didPerformWorkStackCursor, workInProgress);
            pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.
            push(contextStackCursor, mergedContext, workInProgress);
            push(didPerformWorkStackCursor, didChange, workInProgress);
        } else {
            pop(didPerformWorkStackCursor, workInProgress);
            push(didPerformWorkStackCursor, didChange, workInProgress);
        }
    }
    function findCurrentUnmaskedContext(fiber) {
        // Currently this is only used with renderSubtreeIntoContainer; not sure if it
        // makes sense elsewhere
        if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent)) throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var node = fiber;
        do {
            switch(node.tag){
                case HostRoot:
                    return node.stateNode.context;
                case ClassComponent:
                    var Component = node.type;
                    if (isContextProvider(Component)) return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    break;
            }
            node = node.return;
        }while (node !== null)
        throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    var LegacyRoot = 0;
    var BlockingRoot = 1;
    var ConcurrentRoot = 2;
    var rendererID = null;
    var injectedHook = null;
    var hasLoggedError = false;
    var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';
    function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') // No DevTools
        return false;
        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook.isDisabled) // This isn't a real property on the hook, but it can be set to opt out
        // of DevTools integration and associated warnings and logs.
        // https://github.com/facebook/react/issues/3877
        return true;
        if (!hook.supportsFiber) {
            error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
            return true;
        }
        try {
            rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.
            injectedHook = hook;
        } catch (err) {
            error('React instrumentation encountered an error: %s.', err);
        } // DevTools exists
        return true;
    }
    function onScheduleRoot(root1, children) {
        if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') try {
            injectedHook.onScheduleFiberRoot(rendererID, root1, children);
        } catch (err) {
            if (!hasLoggedError) {
                hasLoggedError = true;
                error('React instrumentation encountered an error: %s', err);
            }
        }
    }
    function onCommitRoot(root1, priorityLevel) {
        if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') try {
            var didError = (root1.current.flags & DidCapture) === DidCapture;
            if (enableProfilerTimer) injectedHook.onCommitFiberRoot(rendererID, root1, priorityLevel, didError);
            else injectedHook.onCommitFiberRoot(rendererID, root1, undefined, didError);
        } catch (err) {
            if (!hasLoggedError) {
                hasLoggedError = true;
                error('React instrumentation encountered an error: %s', err);
            }
        }
    }
    function onCommitUnmount(fiber) {
        if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') try {
            injectedHook.onCommitFiberUnmount(rendererID, fiber);
        } catch (err) {
            if (!hasLoggedError) {
                hasLoggedError = true;
                error('React instrumentation encountered an error: %s', err);
            }
        }
    }
    var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority, Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback, Scheduler_cancelCallback = Scheduler.unstable_cancelCallback, Scheduler_shouldYield = Scheduler.unstable_shouldYield, Scheduler_requestPaint = Scheduler.unstable_requestPaint, Scheduler_now$1 = Scheduler.unstable_now, Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority, Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, Scheduler_NormalPriority = Scheduler.unstable_NormalPriority, Scheduler_LowPriority = Scheduler.unstable_LowPriority, Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
    // Provide explicit error message when production+profiling bundle of e.g.
    // react-dom is used with production (non-profiling) bundle of
    // scheduler/tracing
    if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
    var fakeCallbackNode = {
    }; // Except for NoPriority, these correspond to Scheduler priorities. We use
    // ascending numbers so we can compare them like numbers. They start at 90 to
    // avoid clashing with Scheduler's priorities.
    var ImmediatePriority$1 = 99;
    var UserBlockingPriority$2 = 98;
    var NormalPriority$1 = 97;
    var LowPriority$1 = 96;
    var IdlePriority$1 = 95; // NoPriority is the absence of priority. Also React-only.
    var NoPriority$1 = 90;
    var shouldYield = Scheduler_shouldYield;
    var requestPaint = Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : function() {
    };
    var syncQueue = null;
    var immediateQueueCallbackNode = null;
    var isFlushingSyncQueue = false;
    var initialTimeMs$1 = Scheduler_now$1(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.
    // This will be the case for modern browsers that support `performance.now`. In
    // older browsers, Scheduler falls back to `Date.now`, which returns a Unix
    // timestamp. In that case, subtract the module initialization time to simulate
    // the behavior of performance.now and keep our times small enough to fit
    // within 32 bits.
    // TODO: Consider lifting this into Scheduler.
    var now = initialTimeMs$1 < 10000 ? Scheduler_now$1 : function() {
        return Scheduler_now$1() - initialTimeMs$1;
    };
    function getCurrentPriorityLevel() {
        switch(Scheduler_getCurrentPriorityLevel()){
            case Scheduler_ImmediatePriority:
                return ImmediatePriority$1;
            case Scheduler_UserBlockingPriority:
                return UserBlockingPriority$2;
            case Scheduler_NormalPriority:
                return NormalPriority$1;
            case Scheduler_LowPriority:
                return LowPriority$1;
            case Scheduler_IdlePriority:
                return IdlePriority$1;
            default:
                throw Error("Unknown priority level.");
        }
    }
    function reactPriorityToSchedulerPriority(reactPriorityLevel) {
        switch(reactPriorityLevel){
            case ImmediatePriority$1:
                return Scheduler_ImmediatePriority;
            case UserBlockingPriority$2:
                return Scheduler_UserBlockingPriority;
            case NormalPriority$1:
                return Scheduler_NormalPriority;
            case LowPriority$1:
                return Scheduler_LowPriority;
            case IdlePriority$1:
                return Scheduler_IdlePriority;
            default:
                throw Error("Unknown priority level.");
        }
    }
    function runWithPriority$1(reactPriorityLevel, fn) {
        var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
        return Scheduler_runWithPriority(priorityLevel, fn);
    }
    function scheduleCallback(reactPriorityLevel, callback, options1) {
        var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
        return Scheduler_scheduleCallback(priorityLevel, callback, options1);
    }
    function scheduleSyncCallback(callback) {
        // Push this callback into an internal queue. We'll flush these either in
        // the next tick, or earlier if something calls `flushSyncCallbackQueue`.
        if (syncQueue === null) {
            syncQueue = [
                callback
            ]; // Flush the queue in the next tick, at the earliest.
            immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);
        } else // Push onto existing queue. Don't need to schedule a callback because
        // we already scheduled one when we created the queue.
        syncQueue.push(callback);
        return fakeCallbackNode;
    }
    function cancelCallback(callbackNode) {
        if (callbackNode !== fakeCallbackNode) Scheduler_cancelCallback(callbackNode);
    }
    function flushSyncCallbackQueue() {
        if (immediateQueueCallbackNode !== null) {
            var node = immediateQueueCallbackNode;
            immediateQueueCallbackNode = null;
            Scheduler_cancelCallback(node);
        }
        flushSyncCallbackQueueImpl();
    }
    function flushSyncCallbackQueueImpl() {
        if (!isFlushingSyncQueue && syncQueue !== null) {
            // Prevent re-entrancy.
            isFlushingSyncQueue = true;
            var i = 0;
            try {
                var _isSync2 = true;
                var _queue = syncQueue;
                runWithPriority$1(ImmediatePriority$1, function() {
                    for(; i < _queue.length; i++){
                        var callback = _queue[i];
                        do callback = callback(_isSync2);
                        while (callback !== null)
                    }
                });
                syncQueue = null;
            } catch (error4) {
                // If something throws, leave the remaining callbacks on the queue.
                if (syncQueue !== null) syncQueue = syncQueue.slice(i + 1);
                 // Resume flushing in the next tick
                Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);
                throw error4;
            } finally{
                isFlushingSyncQueue = false;
            }
        }
    }
    // TODO: this is special because it gets imported during build.
    var ReactVersion = '17.0.2';
    var NoMode = 0;
    var StrictMode = 1; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root
    // tag instead
    var BlockingMode = 2;
    var ConcurrentMode = 4;
    var ProfileMode = 8;
    var DebugTracingMode = 16;
    var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
    var NoTransition = 0;
    function requestCurrentTransition() {
        return ReactCurrentBatchConfig.transition;
    }
    var ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function(fiber, instance) {
        },
        flushPendingUnsafeLifecycleWarnings: function() {
        },
        recordLegacyContextWarning: function(fiber, instance) {
        },
        flushLegacyContextWarning: function() {
        },
        discardPendingWarnings: function() {
        }
    };
    var findStrictRoot = function(fiber) {
        var maybeStrictRoot = null;
        var node = fiber;
        while(node !== null){
            if (node.mode & StrictMode) maybeStrictRoot = node;
            node = node.return;
        }
        return maybeStrictRoot;
    };
    var setToSortedString = function(set1) {
        var array = [];
        set1.forEach(function(value) {
            array.push(value);
        });
        return array.sort().join(', ');
    };
    var pendingComponentWillMountWarnings = [];
    var pendingUNSAFE_ComponentWillMountWarnings = [];
    var pendingComponentWillReceivePropsWarnings = [];
    var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    var pendingComponentWillUpdateWarnings = [];
    var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.
    var didWarnAboutUnsafeLifecycles = new Set();
    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
        // Dedup strategy: Warn once per component.
        if (didWarnAboutUnsafeLifecycles.has(fiber.type)) return;
        if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) pendingComponentWillMountWarnings.push(fiber);
        if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillMount === 'function') pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
        if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) pendingComponentWillReceivePropsWarnings.push(fiber);
        if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
        if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) pendingComponentWillUpdateWarnings.push(fiber);
        if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillUpdate === 'function') pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
    };
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
        // We do an initial pass to gather component names
        var componentWillMountUniqueNames = new Set();
        if (pendingComponentWillMountWarnings.length > 0) {
            pendingComponentWillMountWarnings.forEach(function(fiber) {
                componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillMountWarnings = [];
        }
        var UNSAFE_componentWillMountUniqueNames = new Set();
        if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
            pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillMountWarnings = [];
        }
        var componentWillReceivePropsUniqueNames = new Set();
        if (pendingComponentWillReceivePropsWarnings.length > 0) {
            pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillReceivePropsWarnings = [];
        }
        var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
        if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
            pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        }
        var componentWillUpdateUniqueNames = new Set();
        if (pendingComponentWillUpdateWarnings.length > 0) {
            pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillUpdateWarnings = [];
        }
        var UNSAFE_componentWillUpdateUniqueNames = new Set();
        if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
            pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
        } // Finally, we flush all the warnings
        // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
        if (UNSAFE_componentWillMountUniqueNames.size > 0) {
            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
            error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
        }
        if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
            error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
        }
        if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
            error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
        }
        if (componentWillMountUniqueNames.size > 0) {
            var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
            warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
        }
        if (componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
            warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
        }
        if (componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
            warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
        }
    };
    var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.
    var didWarnAboutLegacyContext = new Set();
    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
        var strictRoot = findStrictRoot(fiber);
        if (strictRoot === null) {
            error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
            return;
        } // Dedup strategy: Warn once per component.
        if (didWarnAboutLegacyContext.has(fiber.type)) return;
        var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
        if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {
            if (warningsForRoot === undefined) {
                warningsForRoot = [];
                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
            }
            warningsForRoot.push(fiber);
        }
    };
    ReactStrictModeWarnings.flushLegacyContextWarning = function() {
        pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
            if (fiberArray.length === 0) return;
            var firstFiber = fiberArray[0];
            var uniqueNames = new Set();
            fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentName(fiber.type) || 'Component');
                didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            try {
                setCurrentFiber(firstFiber);
                error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
            } finally{
                resetCurrentFiber();
            }
        });
    };
    ReactStrictModeWarnings.discardPendingWarnings = function() {
        pendingComponentWillMountWarnings = [];
        pendingUNSAFE_ComponentWillMountWarnings = [];
        pendingComponentWillReceivePropsWarnings = [];
        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        pendingComponentWillUpdateWarnings = [];
        pendingUNSAFE_ComponentWillUpdateWarnings = [];
        pendingLegacyContextWarning = new Map();
    };
    function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
            // Resolve default props. Taken from ReactElement
            var props = _assign({
            }, baseProps);
            var defaultProps = Component.defaultProps;
            for(var propName in defaultProps)if (props[propName] === undefined) props[propName] = defaultProps[propName];
            return props;
        }
        return baseProps;
    }
    // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
    // Math.pow(2, 30) - 1
    // 0b111111111111111111111111111111
    var MAX_SIGNED_31_BIT_INT = 1073741823;
    var valueCursor = createCursor(null);
    var rendererSigil;
    // Use this to detect multiple renderers using the same context
    rendererSigil = {
    };
    var currentlyRenderingFiber = null;
    var lastContextDependency = null;
    var lastContextWithAllBitsObserved = null;
    var isDisallowedContextReadInDEV = false;
    function resetContextDependencies() {
        // This is called right before React yields execution, to ensure `readContext`
        // cannot be called outside the render phase.
        currentlyRenderingFiber = null;
        lastContextDependency = null;
        lastContextWithAllBitsObserved = null;
        isDisallowedContextReadInDEV = false;
    }
    function enterDisallowedContextReadInDEV() {
        isDisallowedContextReadInDEV = true;
    }
    function exitDisallowedContextReadInDEV() {
        isDisallowedContextReadInDEV = false;
    }
    function pushProvider(providerFiber, nextValue) {
        var context = providerFiber.type._context;
        push(valueCursor, context._currentValue, providerFiber);
        context._currentValue = nextValue;
        if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
        context._currentRenderer = rendererSigil;
    }
    function popProvider(providerFiber) {
        var currentValue = valueCursor.current;
        pop(valueCursor, providerFiber);
        var context = providerFiber.type._context;
        context._currentValue = currentValue;
    }
    function calculateChangedBits(context, newValue, oldValue) {
        if (objectIs(oldValue, newValue)) // No change
        return 0;
        else {
            var changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
            if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) error("calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: %s", changedBits);
            return changedBits | 0;
        }
    }
    function scheduleWorkOnParentPath(parent, renderLanes) {
        // Update the child lanes of all the ancestors, including the alternates.
        var node = parent;
        while(node !== null){
            var alternate = node.alternate;
            if (!isSubsetOfLanes(node.childLanes, renderLanes)) {
                node.childLanes = mergeLanes(node.childLanes, renderLanes);
                if (alternate !== null) alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
            } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
            else break;
            node = node.return;
        }
    }
    function propagateContextChange(workInProgress, context, changedBits, renderLanes) {
        var fiber = workInProgress.child;
        if (fiber !== null) // Set the return pointer of the child to the work-in-progress fiber.
        fiber.return = workInProgress;
        while(fiber !== null){
            var nextFiber = void 0; // Visit this fiber.
            var list = fiber.dependencies;
            if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while(dependency !== null){
                    // Check if the context matches.
                    if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
                        // Match! Schedule an update on this fiber.
                        if (fiber.tag === ClassComponent) {
                            // Schedule a force update on the work-in-progress.
                            var update = createUpdate(NoTimestamp, pickArbitraryLane(renderLanes));
                            update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the
                            // update to the current fiber, too, which means it will persist even if
                            // this render is thrown away. Since it's a race condition, not sure it's
                            // worth fixing.
                            enqueueUpdate(fiber, update);
                        }
                        fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
                        var alternate = fiber.alternate;
                        if (alternate !== null) alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
                        scheduleWorkOnParentPath(fiber.return, renderLanes); // Mark the updated lanes on the list, too.
                        list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the
                        break;
                    }
                    dependency = dependency.next;
                }
            } else if (fiber.tag === ContextProvider) // Don't scan deeper if this is a matching provider
            nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
            else // Traverse down.
            nextFiber = fiber.child;
            if (nextFiber !== null) // Set the return pointer of the child to the work-in-progress fiber.
            nextFiber.return = fiber;
            else {
                // No child. Traverse to next sibling.
                nextFiber = fiber;
                while(nextFiber !== null){
                    if (nextFiber === workInProgress) {
                        // We're back to the root of this subtree. Exit.
                        nextFiber = null;
                        break;
                    }
                    var sibling = nextFiber.sibling;
                    if (sibling !== null) {
                        // Set the return pointer of the sibling to the work-in-progress fiber.
                        sibling.return = nextFiber.return;
                        nextFiber = sibling;
                        break;
                    } // No more siblings. Traverse up.
                    nextFiber = nextFiber.return;
                }
            }
            fiber = nextFiber;
        }
    }
    function prepareToReadContext(workInProgress, renderLanes) {
        currentlyRenderingFiber = workInProgress;
        lastContextDependency = null;
        lastContextWithAllBitsObserved = null;
        var dependencies = workInProgress.dependencies;
        if (dependencies !== null) {
            var firstContext = dependencies.firstContext;
            if (firstContext !== null) {
                if (includesSomeLane(dependencies.lanes, renderLanes)) // Context list has a pending update. Mark that this fiber performed work.
                markWorkInProgressReceivedUpdate();
                 // Reset the work-in-progress list
                dependencies.firstContext = null;
            }
        }
    }
    function readContext(context, observedBits) {
        // This warning would fire if you read context inside a Hook like useMemo.
        // Unlike the class check below, it's not enforced in production for perf.
        if (isDisallowedContextReadInDEV) error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        if (lastContextWithAllBitsObserved === context) ;
        else if (observedBits === false || observedBits === 0) ;
        else {
            var resolvedObservedBits; // Avoid deopting on observable arguments or heterogeneous types.
            if (typeof observedBits !== 'number' || observedBits === MAX_SIGNED_31_BIT_INT) {
                // Observe all updates.
                lastContextWithAllBitsObserved = context;
                resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
            } else resolvedObservedBits = observedBits;
            var contextItem = {
                context: context,
                observedBits: resolvedObservedBits,
                next: null
            };
            if (lastContextDependency === null) {
                if (!(currentlyRenderingFiber !== null)) throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                 // This is the first dependency for this component. Create a new list.
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                    lanes: NoLanes,
                    firstContext: contextItem,
                    responders: null
                };
            } else // Append a new context item.
            lastContextDependency = lastContextDependency.next = contextItem;
        }
        return context._currentValue;
    }
    var UpdateState = 0;
    var ReplaceState = 1;
    var ForceUpdate = 2;
    var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.
    // It should only be read right after calling `processUpdateQueue`, via
    // `checkHasForceUpdateAfterProcessing`.
    var hasForceUpdate = false;
    var didWarnUpdateInsideUpdate;
    var currentlyProcessingQueue;
    didWarnUpdateInsideUpdate = false;
    currentlyProcessingQueue = null;
    function initializeUpdateQueue(fiber) {
        var queue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null
            },
            effects: null
        };
        fiber.updateQueue = queue;
    }
    function cloneUpdateQueue(current2, workInProgress) {
        // Clone the update queue from current. Unless it's already a clone.
        var queue = workInProgress.updateQueue;
        var currentQueue = current2.updateQueue;
        if (queue === currentQueue) {
            var clone = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: currentQueue.firstBaseUpdate,
                lastBaseUpdate: currentQueue.lastBaseUpdate,
                shared: currentQueue.shared,
                effects: currentQueue.effects
            };
            workInProgress.updateQueue = clone;
        }
    }
    function createUpdate(eventTime, lane) {
        var update = {
            eventTime: eventTime,
            lane: lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
        };
        return update;
    }
    function enqueueUpdate(fiber, update) {
        var updateQueue = fiber.updateQueue;
        if (updateQueue === null) // Only occurs if the fiber has been unmounted.
        return;
        var sharedQueue = updateQueue.shared;
        var pending = sharedQueue.pending;
        if (pending === null) // This is the first update. Create a circular list.
        update.next = update;
        else {
            update.next = pending.next;
            pending.next = update;
        }
        sharedQueue.pending = update;
        if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
            error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
            didWarnUpdateInsideUpdate = true;
        }
    }
    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
        // Captured updates are updates that are thrown by a child during the render
        // phase. They should be discarded if the render is aborted. Therefore,
        // we should only put them on the work-in-progress queue, not the current one.
        var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.
        var current2 = workInProgress.alternate;
        if (current2 !== null) {
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
                // The work-in-progress queue is the same as current. This happens when
                // we bail out on a parent fiber that then captures an error thrown by
                // a child. Since we want to append the update only to the work-in
                // -progress queue, we need to clone the updates. We usually clone during
                // processUpdateQueue, but that didn't happen in this case because we
                // skipped over the parent when we bailed out.
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                    // Loop through the updates and clone them.
                    var update = firstBaseUpdate;
                    do {
                        var clone = {
                            eventTime: update.eventTime,
                            lane: update.lane,
                            tag: update.tag,
                            payload: update.payload,
                            callback: update.callback,
                            next: null
                        };
                        if (newLast === null) newFirst = newLast = clone;
                        else {
                            newLast.next = clone;
                            newLast = clone;
                        }
                        update = update.next;
                    }while (update !== null) // Append the captured update the end of the cloned list.
                    if (newLast === null) newFirst = newLast = capturedUpdate;
                    else {
                        newLast.next = capturedUpdate;
                        newLast = capturedUpdate;
                    }
                } else // There are no base updates.
                newFirst = newLast = capturedUpdate;
                queue = {
                    baseState: currentQueue.baseState,
                    firstBaseUpdate: newFirst,
                    lastBaseUpdate: newLast,
                    shared: currentQueue.shared,
                    effects: currentQueue.effects
                };
                workInProgress.updateQueue = queue;
                return;
            }
        } // Append the update to the end of the list.
        var lastBaseUpdate = queue.lastBaseUpdate;
        if (lastBaseUpdate === null) queue.firstBaseUpdate = capturedUpdate;
        else lastBaseUpdate.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
    }
    function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
        switch(update.tag){
            case ReplaceState:
                var payload = update.payload;
                if (typeof payload === 'function') {
                    enterDisallowedContextReadInDEV();
                    var nextState = payload.call(instance, prevState, nextProps);
                    if (workInProgress.mode & StrictMode) {
                        disableLogs();
                        try {
                            payload.call(instance, prevState, nextProps);
                        } finally{
                            reenableLogs();
                        }
                    }
                    exitDisallowedContextReadInDEV();
                    return nextState;
                } // State object
                return payload;
            case CaptureUpdate:
                workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;
            // Intentional fallthrough
            case UpdateState:
                var _payload = update.payload;
                var partialState;
                if (typeof _payload === 'function') {
                    enterDisallowedContextReadInDEV();
                    partialState = _payload.call(instance, prevState, nextProps);
                    if (workInProgress.mode & StrictMode) {
                        disableLogs();
                        try {
                            _payload.call(instance, prevState, nextProps);
                        } finally{
                            reenableLogs();
                        }
                    }
                    exitDisallowedContextReadInDEV();
                } else // Partial state object
                partialState = _payload;
                if (partialState === null || partialState === undefined) // Null and undefined are treated as no-ops.
                return prevState;
                 // Merge the partial state and the previous state.
                return _assign({
                }, prevState, partialState);
            case ForceUpdate:
                hasForceUpdate = true;
                return prevState;
        }
        return prevState;
    }
    function processUpdateQueue(workInProgress, props, instance, renderLanes) {
        // This is always non-null on a ClassComponent or HostRoot
        var queue = workInProgress.updateQueue;
        hasForceUpdate = false;
        currentlyProcessingQueue = queue.shared;
        var firstBaseUpdate = queue.firstBaseUpdate;
        var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.
        var pendingQueue = queue.shared.pending;
        if (pendingQueue !== null) {
            queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first
            // and last so that it's non-circular.
            var lastPendingUpdate = pendingQueue;
            var firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null; // Append pending updates to base queue
            if (lastBaseUpdate === null) firstBaseUpdate = firstPendingUpdate;
            else lastBaseUpdate.next = firstPendingUpdate;
            lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then
            // we need to transfer the updates to that queue, too. Because the base
            // queue is a singly-linked list with no cycles, we can append to both
            // lists and take advantage of structural sharing.
            // TODO: Pass `current` as argument
            var current2 = workInProgress.alternate;
            if (current2 !== null) {
                // This is always non-null on a ClassComponent or HostRoot
                var currentQueue = current2.updateQueue;
                var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                    if (currentLastBaseUpdate === null) currentQueue.firstBaseUpdate = firstPendingUpdate;
                    else currentLastBaseUpdate.next = firstPendingUpdate;
                    currentQueue.lastBaseUpdate = lastPendingUpdate;
                }
            }
        } // These values may change as we process the queue.
        if (firstBaseUpdate !== null) {
            // Iterate through the list of updates to compute the result.
            var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes
            // from the original lanes.
            var newLanes = NoLanes;
            var newBaseState = null;
            var newFirstBaseUpdate = null;
            var newLastBaseUpdate = null;
            var update = firstBaseUpdate;
            do {
                var updateLane = update.lane;
                var updateEventTime = update.eventTime;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                    // Priority is insufficient. Skip this update. If this is the first
                    // skipped update, the previous update/state is the new base
                    // update/state.
                    var clone = {
                        eventTime: updateEventTime,
                        lane: updateLane,
                        tag: update.tag,
                        payload: update.payload,
                        callback: update.callback,
                        next: null
                    };
                    if (newLastBaseUpdate === null) {
                        newFirstBaseUpdate = newLastBaseUpdate = clone;
                        newBaseState = newState;
                    } else newLastBaseUpdate = newLastBaseUpdate.next = clone;
                     // Update the remaining priority in the queue.
                    newLanes = mergeLanes(newLanes, updateLane);
                } else {
                    // This update does have sufficient priority.
                    if (newLastBaseUpdate !== null) {
                        var _clone = {
                            eventTime: updateEventTime,
                            // This update is going to be committed so we never want uncommit
                            // it. Using NoLane works because 0 is a subset of all bitmasks, so
                            // this will never be skipped by the check above.
                            lane: NoLane,
                            tag: update.tag,
                            payload: update.payload,
                            callback: update.callback,
                            next: null
                        };
                        newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                    } // Process this update.
                    newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);
                    var callback = update.callback;
                    if (callback !== null) {
                        workInProgress.flags |= Callback;
                        var effects = queue.effects;
                        if (effects === null) queue.effects = [
                            update
                        ];
                        else effects.push(update);
                    }
                }
                update = update.next;
                if (update === null) {
                    pendingQueue = queue.shared.pending;
                    if (pendingQueue === null) break;
                    else {
                        // An update was scheduled from inside a reducer. Add the new
                        // pending updates to the end of the list and keep processing.
                        var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we
                        // unravel them when transferring them to the base queue.
                        var _firstPendingUpdate = _lastPendingUpdate.next;
                        _lastPendingUpdate.next = null;
                        update = _firstPendingUpdate;
                        queue.lastBaseUpdate = _lastPendingUpdate;
                        queue.shared.pending = null;
                    }
                }
            }while (true)
            if (newLastBaseUpdate === null) newBaseState = newState;
            queue.baseState = newBaseState;
            queue.firstBaseUpdate = newFirstBaseUpdate;
            queue.lastBaseUpdate = newLastBaseUpdate; // Set the remaining expiration time to be whatever is remaining in the queue.
            // This should be fine because the only two other things that contribute to
            // expiration time are props and context. We're already in the middle of the
            // begin phase by the time we start processing the queue, so we've already
            // dealt with the props. Context in components that specify
            // shouldComponentUpdate is tricky; but we'll have to account for
            // that regardless.
            markSkippedUpdateLanes(newLanes);
            workInProgress.lanes = newLanes;
            workInProgress.memoizedState = newState;
        }
        currentlyProcessingQueue = null;
    }
    function callCallback(callback, context) {
        if (!(typeof callback === 'function')) throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
        callback.call(context);
    }
    function resetHasForceUpdateBeforeProcessing() {
        hasForceUpdate = false;
    }
    function checkHasForceUpdateAfterProcessing() {
        return hasForceUpdate;
    }
    function commitUpdateQueue(finishedWork, finishedQueue, instance) {
        // Commit the effects
        var effects = finishedQueue.effects;
        finishedQueue.effects = null;
        if (effects !== null) for(var i = 0; i < effects.length; i++){
            var effect = effects[i];
            var callback = effect.callback;
            if (callback !== null) {
                effect.callback = null;
                callCallback(callback, instance);
            }
        }
    }
    var fakeInternalInstance = {
    };
    var isArray = Array.isArray; // React.Component uses a shared frozen object by default.
    // We'll use it to determine whether we need to initialize legacy refs.
    var emptyRefsObject = new React.Component().refs;
    var didWarnAboutStateAssignmentForComponent;
    var didWarnAboutUninitializedState;
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
    var didWarnAboutLegacyLifecyclesAndDerivedState;
    var didWarnAboutUndefinedDerivedState;
    var warnOnUndefinedDerivedState;
    var warnOnInvalidCallback;
    var didWarnAboutDirectlyAssigningPropsToState;
    var didWarnAboutContextTypeAndContextTypes;
    var didWarnAboutInvalidateContextType;
    didWarnAboutStateAssignmentForComponent = new Set();
    didWarnAboutUninitializedState = new Set();
    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
    didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
    didWarnAboutDirectlyAssigningPropsToState = new Set();
    didWarnAboutUndefinedDerivedState = new Set();
    didWarnAboutContextTypeAndContextTypes = new Set();
    didWarnAboutInvalidateContextType = new Set();
    var didWarnOnInvalidCallback = new Set();
    warnOnInvalidCallback = function(callback, callerName) {
        if (callback === null || typeof callback === 'function') return;
        var key = callerName + '_' + callback;
        if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
        }
    };
    warnOnUndefinedDerivedState = function(type, partialState) {
        if (partialState === undefined) {
            var componentName = getComponentName(type) || 'Component';
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
        }
    }; // This is so gross but it's at least non-critical and can be removed if
    // it causes problems. This is meant to give a nicer error message for
    // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
    // ...)) which otherwise throws a "_processChildContext is not a function"
    // exception.
    Object.defineProperty(fakeInternalInstance, '_processChildContext', {
        enumerable: false,
        value: function() {
            throw Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
    });
    Object.freeze(fakeInternalInstance);
    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress.memoizedState;
        if (workInProgress.mode & StrictMode) {
            disableLogs();
            try {
                // Invoke the function an extra time to help detect side-effects.
                getDerivedStateFromProps(nextProps, prevState);
            } finally{
                reenableLogs();
            }
        }
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        warnOnUndefinedDerivedState(ctor, partialState);
        var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({
        }, prevState, partialState);
        workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the
        // base state.
        if (workInProgress.lanes === NoLanes) {
            // Queue is always non-null for classes
            var updateQueue = workInProgress.updateQueue;
            updateQueue.baseState = memoizedState;
        }
    }
    var classComponentUpdater = {
        isMounted: isMounted,
        enqueueSetState: function(inst, payload, callback) {
            var fiber = get(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.payload = payload;
            if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, 'setState');
                update.callback = callback;
            }
            enqueueUpdate(fiber, update);
            scheduleUpdateOnFiber(fiber, lane, eventTime);
        },
        enqueueReplaceState: function(inst, payload, callback) {
            var fiber = get(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ReplaceState;
            update.payload = payload;
            if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, 'replaceState');
                update.callback = callback;
            }
            enqueueUpdate(fiber, update);
            scheduleUpdateOnFiber(fiber, lane, eventTime);
        },
        enqueueForceUpdate: function(inst, callback) {
            var fiber = get(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ForceUpdate;
            if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, 'forceUpdate');
                update.callback = callback;
            }
            enqueueUpdate(fiber, update);
            scheduleUpdateOnFiber(fiber, lane, eventTime);
        }
    };
    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress.stateNode;
        if (typeof instance.shouldComponentUpdate === 'function') {
            if (workInProgress.mode & StrictMode) {
                disableLogs();
                try {
                    // Invoke the function an extra time to help detect side-effects.
                    instance.shouldComponentUpdate(newProps, newState, nextContext);
                } finally{
                    reenableLogs();
                }
            }
            var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
            if (shouldUpdate === undefined) error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentName(ctor) || 'Component');
            return shouldUpdate;
        }
        if (ctor.prototype && ctor.prototype.isPureReactComponent) return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
        return true;
    }
    function checkClassInstance(workInProgress, ctor, newProps) {
        var instance = workInProgress.stateNode;
        var name = getComponentName(ctor) || 'Component';
        var renderPresent = instance.render;
        if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === 'function') error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
            else error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
        }
        if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
        if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
        if (instance.propTypes) error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
        if (instance.contextType) error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
        if (instance.contextTypes) error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
        if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
            didWarnAboutContextTypeAndContextTypes.add(ctor);
            error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
        }
        if (typeof instance.componentShouldUpdate === 'function') error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
        if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || 'A pure component');
        if (typeof instance.componentDidUnmount === 'function') error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
        if (typeof instance.componentDidReceiveProps === 'function') error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
        if (typeof instance.componentWillRecieveProps === 'function') error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
        if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
        var hasMutatedProps = instance.props !== newProps;
        if (instance.props !== undefined && hasMutatedProps) error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
        if (instance.defaultProps) error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
        if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor));
        }
        if (typeof instance.getDerivedStateFromProps === 'function') error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
        if (typeof instance.getDerivedStateFromError === 'function') error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
        if (typeof ctor.getSnapshotBeforeUpdate === 'function') error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
        var _state = instance.state;
        if (_state && (typeof _state !== 'object' || isArray(_state))) error('%s.state: must be set to an object or null', name);
        if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
    }
    function adoptClassInstance(workInProgress, instance) {
        instance.updater = classComponentUpdater;
        workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates
        set(instance, workInProgress);
        instance._reactInternalInstance = fakeInternalInstance;
    }
    function constructClassInstance(workInProgress, ctor, props) {
        var isLegacyContextConsumer = false;
        var unmaskedContext = emptyContextObject;
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        if ('contextType' in ctor) {
            var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>
            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = '';
                if (contextType === undefined) addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                else if (typeof contextType !== 'object') addendum = ' However, it is set to a ' + typeof contextType + '.';
                else if (contextType.$$typeof === REACT_PROVIDER_TYPE) addendum = ' Did you accidentally pass the Context.Provider instead?';
                else if (contextType._context !== undefined) // <Context.Consumer>
                addendum = ' Did you accidentally pass the Context.Consumer instead?';
                else addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(ctor) || 'Component', addendum);
            }
        }
        if (typeof contextType === 'object' && contextType !== null) context = readContext(contextType);
        else {
            unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
            var contextTypes = ctor.contextTypes;
            isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
            context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
        } // Instantiate twice to help detect side-effects.
        if (workInProgress.mode & StrictMode) {
            disableLogs();
            try {
                new ctor(props, context); // eslint-disable-line no-new
            } finally{
                reenableLogs();
            }
        }
        var instance = new ctor(props, context);
        var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
        adoptClassInstance(workInProgress, instance);
        if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {
            var componentName = getComponentName(ctor) || 'Component';
            if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? 'null' : 'undefined', componentName);
            }
        } // If new component APIs are defined, "unsafe" lifecycles won't be called.
        // Warn about these lifecycles if they are present.
        // Don't warn about react-lifecycles-compat polyfilled methods though.
        if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) foundWillMountName = 'componentWillMount';
            else if (typeof instance.UNSAFE_componentWillMount === 'function') foundWillMountName = 'UNSAFE_componentWillMount';
            if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) foundWillReceivePropsName = 'componentWillReceiveProps';
            else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
            if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) foundWillUpdateName = 'componentWillUpdate';
            else if (typeof instance.UNSAFE_componentWillUpdate === 'function') foundWillUpdateName = 'UNSAFE_componentWillUpdate';
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentName(ctor) || 'Component';
                var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : '', foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : '', foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : '');
                }
            }
        }
        // ReactFiberContext usually updates this cache but can't for newly-created instances.
        if (isLegacyContextConsumer) cacheContext(workInProgress, unmaskedContext, context);
        return instance;
    }
    function callComponentWillMount(workInProgress, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === 'function') instance.componentWillMount();
        if (typeof instance.UNSAFE_componentWillMount === 'function') instance.UNSAFE_componentWillMount();
        if (oldState !== instance.state) {
            error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentName(workInProgress.type) || 'Component');
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
    }
    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
        var oldState = instance.state;
        if (typeof instance.componentWillReceiveProps === 'function') instance.componentWillReceiveProps(newProps, nextContext);
        if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        if (instance.state !== oldState) {
            var componentName = getComponentName(workInProgress.type) || 'Component';
            if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                didWarnAboutStateAssignmentForComponent.add(componentName);
                error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
    } // Invokes the mount life-cycles on a previously never rendered instance.
    function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
        checkClassInstance(workInProgress, ctor, newProps);
        var instance = workInProgress.stateNode;
        instance.props = newProps;
        instance.state = workInProgress.memoizedState;
        instance.refs = emptyRefsObject;
        initializeUpdateQueue(workInProgress);
        var contextType = ctor.contextType;
        if (typeof contextType === 'object' && contextType !== null) instance.context = readContext(contextType);
        else {
            var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
            instance.context = getMaskedContext(workInProgress, unmaskedContext);
        }
        if (instance.state === newProps) {
            var componentName = getComponentName(ctor) || 'Component';
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
        }
        if (workInProgress.mode & StrictMode) ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
        processUpdateQueue(workInProgress, newProps, instance, renderLanes);
        instance.state = workInProgress.memoizedState;
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === 'function') {
            applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
            instance.state = workInProgress.memoizedState;
        } // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for components using the new APIs.
        if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
            callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's
            // process them now.
            processUpdateQueue(workInProgress, newProps, instance, renderLanes);
            instance.state = workInProgress.memoizedState;
        }
        if (typeof instance.componentDidMount === 'function') workInProgress.flags |= Update;
    }
    function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {
        var instance = workInProgress.stateNode;
        var oldProps = workInProgress.memoizedProps;
        instance.props = oldProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = emptyContextObject;
        if (typeof contextType === 'object' && contextType !== null) nextContext = readContext(contextType);
        else {
            var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
            nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
        // ever the previously attempted to render - not the "current". However,
        // during componentDidUpdate we pass the "current" props.
        // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for components using the new APIs.
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
            if (oldProps !== newProps || oldContext !== nextContext) callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
        }
        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress.memoizedState;
        var newState = instance.state = oldState;
        processUpdateQueue(workInProgress, newProps, instance, renderLanes);
        newState = workInProgress.memoizedState;
        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            // If an update was already in progress, we should schedule an Update
            // effect even though we're bailing out, so that cWU/cDU are called.
            if (typeof instance.componentDidMount === 'function') workInProgress.flags |= Update;
            return false;
        }
        if (typeof getDerivedStateFromProps === 'function') {
            applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress.memoizedState;
        }
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);
        if (shouldUpdate) {
            // In order to support react-lifecycles-compat polyfilled components,
            // Unsafe lifecycles should not be invoked for components using the new APIs.
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
                if (typeof instance.componentWillMount === 'function') instance.componentWillMount();
                if (typeof instance.UNSAFE_componentWillMount === 'function') instance.UNSAFE_componentWillMount();
            }
            if (typeof instance.componentDidMount === 'function') workInProgress.flags |= Update;
        } else {
            // If an update was already in progress, we should schedule an Update
            // effect even though we're bailing out, so that cWU/cDU are called.
            if (typeof instance.componentDidMount === 'function') workInProgress.flags |= Update;
             // If shouldComponentUpdate returned false, we should still update the
            // memoized state to indicate that this work can be reused.
            workInProgress.memoizedProps = newProps;
            workInProgress.memoizedState = newState;
        } // Update the existing instance's state, props, and context pointers even
        // if shouldComponentUpdate returns false.
        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
    } // Invokes the update life-cycles and returns false if it shouldn't rerender.
    function updateClassInstance(current3, workInProgress, ctor, newProps, renderLanes) {
        var instance = workInProgress.stateNode;
        cloneUpdateQueue(current3, workInProgress);
        var unresolvedOldProps = workInProgress.memoizedProps;
        var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);
        instance.props = oldProps;
        var unresolvedNewProps = workInProgress.pendingProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = emptyContextObject;
        if (typeof contextType === 'object' && contextType !== null) nextContext = readContext(contextType);
        else {
            var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
            nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
        // ever the previously attempted to render - not the "current". However,
        // during componentDidUpdate we pass the "current" props.
        // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for components using the new APIs.
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
            if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
        }
        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress.memoizedState;
        var newState = instance.state = oldState;
        processUpdateQueue(workInProgress, newProps, instance, renderLanes);
        newState = workInProgress.memoizedState;
        if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            // If an update was already in progress, we should schedule an Update
            // effect even though we're bailing out, so that cWU/cDU are called.
            if (typeof instance.componentDidUpdate === 'function') {
                if (unresolvedOldProps !== current3.memoizedProps || oldState !== current3.memoizedState) workInProgress.flags |= Update;
            }
            if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                if (unresolvedOldProps !== current3.memoizedProps || oldState !== current3.memoizedState) workInProgress.flags |= Snapshot;
            }
            return false;
        }
        if (typeof getDerivedStateFromProps === 'function') {
            applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress.memoizedState;
        }
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);
        if (shouldUpdate) {
            // In order to support react-lifecycles-compat polyfilled components,
            // Unsafe lifecycles should not be invoked for components using the new APIs.
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {
                if (typeof instance.componentWillUpdate === 'function') instance.componentWillUpdate(newProps, newState, nextContext);
                if (typeof instance.UNSAFE_componentWillUpdate === 'function') instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
            }
            if (typeof instance.componentDidUpdate === 'function') workInProgress.flags |= Update;
            if (typeof instance.getSnapshotBeforeUpdate === 'function') workInProgress.flags |= Snapshot;
        } else {
            // If an update was already in progress, we should schedule an Update
            // effect even though we're bailing out, so that cWU/cDU are called.
            if (typeof instance.componentDidUpdate === 'function') {
                if (unresolvedOldProps !== current3.memoizedProps || oldState !== current3.memoizedState) workInProgress.flags |= Update;
            }
            if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                if (unresolvedOldProps !== current3.memoizedProps || oldState !== current3.memoizedState) workInProgress.flags |= Snapshot;
            } // If shouldComponentUpdate returned false, we should still update the
            // memoized props/state to indicate that this work can be reused.
            workInProgress.memoizedProps = newProps;
            workInProgress.memoizedState = newState;
        } // Update the existing instance's state, props, and context pointers even
        // if shouldComponentUpdate returns false.
        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
    }
    var didWarnAboutMaps;
    var didWarnAboutGenerators;
    var didWarnAboutStringRefs;
    var ownerHasKeyUseWarning;
    var ownerHasFunctionTypeWarning;
    var warnForMissingKey = function(child, returnFiber) {
    };
    didWarnAboutMaps = false;
    didWarnAboutGenerators = false;
    didWarnAboutStringRefs = {
    };
    /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */ ownerHasKeyUseWarning = {
    };
    ownerHasFunctionTypeWarning = {
    };
    warnForMissingKey = function(child, returnFiber) {
        if (child === null || typeof child !== 'object') return;
        if (!child._store || child._store.validated || child.key != null) return;
        if (!(typeof child._store === 'object')) throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        child._store.validated = true;
        var componentName = getComponentName(returnFiber.type) || 'Component';
        if (ownerHasKeyUseWarning[componentName]) return;
        ownerHasKeyUseWarning[componentName] = true;
        error("Each child in a list should have a unique \"key\" prop. See https://reactjs.org/link/warning-keys for more information.");
    };
    var isArray$1 = Array.isArray;
    function coerceRef(returnFiber, current3, element) {
        var mixedRef = element.ref;
        if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {
            // TODO: Clean this up once we turn on the string ref warning for
            // everyone, because the strict mode case will no longer be relevant
            if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && // because these cannot be automatically converted to an arrow function
            // using a codemod. Therefore, we don't have to warn about string refs again.
            !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                var componentName = getComponentName(returnFiber.type) || 'Component';
                if (!didWarnAboutStringRefs[componentName]) {
                    error("A string ref, \"%s\", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref", mixedRef);
                    didWarnAboutStringRefs[componentName] = true;
                }
            }
            if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                    var ownerFiber = owner;
                    if (!(ownerFiber.tag === ClassComponent)) throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                    inst = ownerFiber.stateNode;
                }
                if (!inst) throw Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref
                if (current3 !== null && current3.ref !== null && typeof current3.ref === 'function' && current3.ref._stringRef === stringRef) return current3.ref;
                var ref = function(value) {
                    var refs = inst.refs;
                    if (refs === emptyRefsObject) // This is a lazy pooled frozen object, so we need to initialize.
                    refs = inst.refs = {
                    };
                    if (value === null) delete refs[stringRef];
                    else refs[stringRef] = value;
                };
                ref._stringRef = stringRef;
                return ref;
            } else {
                if (!(typeof mixedRef === 'string')) throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                if (!element._owner) throw Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
            }
        }
        return mixedRef;
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
        if (returnFiber.type !== 'textarea') throw Error("Objects are not valid as a React child (found: " + (Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild) + "). If you meant to render a collection of children, use an array instead.");
    }
    function warnOnFunctionType(returnFiber) {
        var componentName = getComponentName(returnFiber.type) || 'Component';
        if (ownerHasFunctionTypeWarning[componentName]) return;
        ownerHasFunctionTypeWarning[componentName] = true;
        error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    } // We avoid inlining this to avoid potential deopts from using try/catch.
    // to be able to optimize each path individually by branching early. This needs
    // a compiler or we can do it manually. Helpers that don't need this branching
    // live outside of this function.
    function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
            if (!shouldTrackSideEffects) // Noop.
            return;
             // Deletions are added in reversed order so we add it to the front.
            // At this point, the return fiber's effect list is empty except for
            // deletions, so we can just append the deletion to the list. The remaining
            // effects aren't added until the complete phase. Once we implement
            // resuming, this may not be true.
            var last = returnFiber.lastEffect;
            if (last !== null) {
                last.nextEffect = childToDelete;
                returnFiber.lastEffect = childToDelete;
            } else returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
            childToDelete.nextEffect = null;
            childToDelete.flags = Deletion;
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) // Noop.
            return null;
             // TODO: For the shouldClone case, this could be micro-optimized a bit by
            // assuming that after the first child we've already added everything.
            var childToDelete = currentFirstChild;
            while(childToDelete !== null){
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
            }
            return null;
        }
        function mapRemainingChildren(returnFiber, currentFirstChild) {
            // Add the remaining children to a temporary map so that we can find them by
            // keys quickly. Implicit (null) keys get added to this set with their index
            // instead.
            var existingChildren = new Map();
            var existingChild = currentFirstChild;
            while(existingChild !== null){
                if (existingChild.key !== null) existingChildren.set(existingChild.key, existingChild);
                else existingChildren.set(existingChild.index, existingChild);
                existingChild = existingChild.sibling;
            }
            return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
            // We currently set sibling to null and index to 0 here because it is easy
            // to forget to do before returning it. E.g. for the single child case.
            var clone = createWorkInProgress(fiber, pendingProps);
            clone.index = 0;
            clone.sibling = null;
            return clone;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects) // Noop.
            return lastPlacedIndex;
            var current3 = newFiber.alternate;
            if (current3 !== null) {
                var oldIndex = current3.index;
                if (oldIndex < lastPlacedIndex) {
                    // This is a move.
                    newFiber.flags = Placement;
                    return lastPlacedIndex;
                } else // This item can stay in place.
                return oldIndex;
            } else {
                // This is an insertion.
                newFiber.flags = Placement;
                return lastPlacedIndex;
            }
        }
        function placeSingleChild(newFiber) {
            // This is simpler for the single child case. We only need to do a
            // placement for inserting new children.
            if (shouldTrackSideEffects && newFiber.alternate === null) newFiber.flags = Placement;
            return newFiber;
        }
        function updateTextNode(returnFiber, current3, textContent, lanes) {
            if (current3 === null || current3.tag !== HostText) {
                // Insert
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
            } else {
                // Update
                var existing = useFiber(current3, textContent);
                existing.return = returnFiber;
                return existing;
            }
        }
        function updateElement(returnFiber, current3, element, lanes) {
            if (current3 !== null) {
                if (current3.elementType === element.type || isCompatibleFamilyForHotReloading(current3, element)) {
                    // Move based on index
                    var existing = useFiber(current3, element.props);
                    existing.ref = coerceRef(returnFiber, current3, element);
                    existing.return = returnFiber;
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                    return existing;
                }
            } // Insert
            var created = createFiberFromElement(element, returnFiber.mode, lanes);
            created.ref = coerceRef(returnFiber, current3, element);
            created.return = returnFiber;
            return created;
        }
        function updatePortal(returnFiber, current3, portal, lanes) {
            if (current3 === null || current3.tag !== HostPortal || current3.stateNode.containerInfo !== portal.containerInfo || current3.stateNode.implementation !== portal.implementation) {
                // Insert
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
            } else {
                // Update
                var existing = useFiber(current3, portal.children || []);
                existing.return = returnFiber;
                return existing;
            }
        }
        function updateFragment(returnFiber, current3, fragment, lanes, key) {
            if (current3 === null || current3.tag !== Fragment) {
                // Insert
                var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                created.return = returnFiber;
                return created;
            } else {
                // Update
                var existing = useFiber(current3, fragment);
                existing.return = returnFiber;
                return existing;
            }
        }
        function createChild(returnFiber, newChild, lanes) {
            if (typeof newChild === 'string' || typeof newChild === 'number') {
                // Text nodes don't have keys. If the previous node is implicitly keyed
                // we can continue to replace it without aborting even if it is not a text
                // node.
                var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
            }
            if (typeof newChild === 'object' && newChild !== null) {
                switch(newChild.$$typeof){
                    case REACT_ELEMENT_TYPE:
                        var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                        _created.ref = coerceRef(returnFiber, null, newChild);
                        _created.return = returnFiber;
                        return _created;
                    case REACT_PORTAL_TYPE:
                        var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                        _created2.return = returnFiber;
                        return _created2;
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                    var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                    _created3.return = returnFiber;
                    return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === 'function') warnOnFunctionType(returnFiber);
            return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            // Update the fiber if the keys match, otherwise return null.
            var key = oldFiber !== null ? oldFiber.key : null;
            if (typeof newChild === 'string' || typeof newChild === 'number') {
                // Text nodes don't have keys. If the previous node is implicitly keyed
                // we can continue to replace it without aborting even if it is not a text
                // node.
                if (key !== null) return null;
                return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
            }
            if (typeof newChild === 'object' && newChild !== null) {
                switch(newChild.$$typeof){
                    case REACT_ELEMENT_TYPE:
                        if (newChild.key === key) {
                            if (newChild.type === REACT_FRAGMENT_TYPE) return updateFragment(returnFiber, oldFiber, newChild.props.children, lanes, key);
                            return updateElement(returnFiber, oldFiber, newChild, lanes);
                        } else return null;
                    case REACT_PORTAL_TYPE:
                        if (newChild.key === key) return updatePortal(returnFiber, oldFiber, newChild, lanes);
                        else return null;
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                    if (key !== null) return null;
                    return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === 'function') warnOnFunctionType(returnFiber);
            return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if (typeof newChild === 'string' || typeof newChild === 'number') {
                // Text nodes don't have keys, so we neither have to check the old nor
                // new node for the key. If both are text nodes, they match.
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);
            }
            if (typeof newChild === 'object' && newChild !== null) {
                switch(newChild.$$typeof){
                    case REACT_ELEMENT_TYPE:
                        var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                        if (newChild.type === REACT_FRAGMENT_TYPE) return updateFragment(returnFiber, _matchedFiber, newChild.props.children, lanes, newChild.key);
                        return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                    case REACT_PORTAL_TYPE:
                        var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                        return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                    var _matchedFiber3 = existingChildren.get(newIdx) || null;
                    return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === 'function') warnOnFunctionType(returnFiber);
            return null;
        }
        /**
   * Warns if there is a duplicate or missing key
   */ function warnOnInvalidKey(child, knownKeys, returnFiber) {
            if (typeof child !== 'object' || child === null) return knownKeys;
            switch(child.$$typeof){
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key = child.key;
                    if (typeof key !== 'string') break;
                    if (knownKeys === null) {
                        knownKeys = new Set();
                        knownKeys.add(key);
                        break;
                    }
                    if (!knownKeys.has(key)) {
                        knownKeys.add(key);
                        break;
                    }
                    error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", key);
                    break;
            }
            return knownKeys;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            // First, validate keys.
            var knownKeys = null;
            for(var i = 0; i < newChildren.length; i++){
                var child = newChildren[i];
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            for(; oldFiber !== null && newIdx < newChildren.length; newIdx++){
                if (oldFiber.index > newIdx) {
                    nextOldFiber = oldFiber;
                    oldFiber = null;
                } else nextOldFiber = oldFiber.sibling;
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                    // TODO: This breaks on empty slots like null children. That's
                    // unfortunate because it triggers the slow path all the time. We need
                    // a better way to communicate whether this was a miss or null,
                    // boolean, undefined, etc.
                    if (oldFiber === null) oldFiber = nextOldFiber;
                    break;
                }
                if (shouldTrackSideEffects) {
                    if (oldFiber && newFiber.alternate === null) // We matched the slot, but we didn't reuse the existing fiber, so we
                    // need to delete the existing child.
                    deleteChild(returnFiber, oldFiber);
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) // TODO: Move out of the loop. This only happens for the first run.
                resultingFirstChild = newFiber;
                else // TODO: Defer siblings if we're not at the right index for this slot.
                // I.e. if we had null values before, then we want to defer this
                // for each null value. However, we also don't want to call updateSlot
                // with the previous one.
                previousNewFiber.sibling = newFiber;
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length) {
                // We've reached the end of the new children. We can delete the rest.
                deleteRemainingChildren(returnFiber, oldFiber);
                return resultingFirstChild;
            }
            if (oldFiber === null) {
                // If we don't have any more existing children we can choose a fast path
                // since the rest will all be insertions.
                for(; newIdx < newChildren.length; newIdx++){
                    var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                    if (_newFiber === null) continue;
                    lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                    if (previousNewFiber === null) // TODO: Move out of the loop. This only happens for the first run.
                    resultingFirstChild = _newFiber;
                    else previousNewFiber.sibling = _newFiber;
                    previousNewFiber = _newFiber;
                }
                return resultingFirstChild;
            } // Add all children to a key map for quick lookups.
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.
            for(; newIdx < newChildren.length; newIdx++){
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                    if (shouldTrackSideEffects) {
                        if (_newFiber2.alternate !== null) // The new fiber is a work in progress, but if there exists a
                        // current, that means that we reused the fiber. We need to delete
                        // it from the child list so that we don't add it to the deletion
                        // list.
                        existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                    lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                    if (previousNewFiber === null) resultingFirstChild = _newFiber2;
                    else previousNewFiber.sibling = _newFiber2;
                    previousNewFiber = _newFiber2;
                }
            }
            if (shouldTrackSideEffects) // Any existing children that weren't consumed above were deleted. We need
            // to add them to the deletion list.
            existingChildren.forEach(function(child) {
                return deleteChild(returnFiber, child);
            });
            return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
            // This is the same implementation as reconcileChildrenArray(),
            // but using the iterator instead.
            var iteratorFn = getIteratorFn(newChildrenIterable);
            if (!(typeof iteratorFn === 'function')) throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            // We don't support rendering Generators because it's a mutation.
            // See https://github.com/facebook/react/issues/12995
            if (typeof Symbol === 'function' && newChildrenIterable[Symbol.toStringTag] === 'Generator') {
                if (!didWarnAboutGenerators) error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                didWarnAboutGenerators = true;
            } // Warn about using Maps as children
            if (newChildrenIterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                didWarnAboutMaps = true;
            } // First, validate keys.
            // We'll get a different iterator later for the main pass.
            var _newChildren = iteratorFn.call(newChildrenIterable);
            if (_newChildren) {
                var knownKeys = null;
                var _step = _newChildren.next();
                for(; !_step.done; _step = _newChildren.next()){
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
            }
            var newChildren = iteratorFn.call(newChildrenIterable);
            if (!(newChildren != null)) throw Error("An iterable object provided no iterator.");
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            var step = newChildren.next();
            for(; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()){
                if (oldFiber.index > newIdx) {
                    nextOldFiber = oldFiber;
                    oldFiber = null;
                } else nextOldFiber = oldFiber.sibling;
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (newFiber === null) {
                    // TODO: This breaks on empty slots like null children. That's
                    // unfortunate because it triggers the slow path all the time. We need
                    // a better way to communicate whether this was a miss or null,
                    // boolean, undefined, etc.
                    if (oldFiber === null) oldFiber = nextOldFiber;
                    break;
                }
                if (shouldTrackSideEffects) {
                    if (oldFiber && newFiber.alternate === null) // We matched the slot, but we didn't reuse the existing fiber, so we
                    // need to delete the existing child.
                    deleteChild(returnFiber, oldFiber);
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) // TODO: Move out of the loop. This only happens for the first run.
                resultingFirstChild = newFiber;
                else // TODO: Defer siblings if we're not at the right index for this slot.
                // I.e. if we had null values before, then we want to defer this
                // for each null value. However, we also don't want to call updateSlot
                // with the previous one.
                previousNewFiber.sibling = newFiber;
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
            }
            if (step.done) {
                // We've reached the end of the new children. We can delete the rest.
                deleteRemainingChildren(returnFiber, oldFiber);
                return resultingFirstChild;
            }
            if (oldFiber === null) {
                // If we don't have any more existing children we can choose a fast path
                // since the rest will all be insertions.
                for(; !step.done; newIdx++, step = newChildren.next()){
                    var _newFiber3 = createChild(returnFiber, step.value, lanes);
                    if (_newFiber3 === null) continue;
                    lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                    if (previousNewFiber === null) // TODO: Move out of the loop. This only happens for the first run.
                    resultingFirstChild = _newFiber3;
                    else previousNewFiber.sibling = _newFiber3;
                    previousNewFiber = _newFiber3;
                }
                return resultingFirstChild;
            } // Add all children to a key map for quick lookups.
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.
            for(; !step.done; newIdx++, step = newChildren.next()){
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                if (_newFiber4 !== null) {
                    if (shouldTrackSideEffects) {
                        if (_newFiber4.alternate !== null) // The new fiber is a work in progress, but if there exists a
                        // current, that means that we reused the fiber. We need to delete
                        // it from the child list so that we don't add it to the deletion
                        // list.
                        existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                    lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                    if (previousNewFiber === null) resultingFirstChild = _newFiber4;
                    else previousNewFiber.sibling = _newFiber4;
                    previousNewFiber = _newFiber4;
                }
            }
            if (shouldTrackSideEffects) // Any existing children that weren't consumed above were deleted. We need
            // to add them to the deletion list.
            existingChildren.forEach(function(child) {
                return deleteChild(returnFiber, child);
            });
            return resultingFirstChild;
        }
        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
            // There's no need to check for keys on text nodes since we don't have a
            // way to define them.
            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                // We already have an existing node so let's just update it and delete
                // the rest.
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
            } // The existing first child is not a text node so we need to create one
            // and delete the existing ones.
            deleteRemainingChildren(returnFiber, currentFirstChild);
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
        }
        function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
            var key = element.key;
            var child = currentFirstChild;
            while(child !== null){
                // TODO: If key === null and child.key === null, then this only applies to
                // the first item in the list.
                if (child.key === key) {
                    switch(child.tag){
                        case Fragment:
                            if (element.type === REACT_FRAGMENT_TYPE) {
                                deleteRemainingChildren(returnFiber, child.sibling);
                                var existing = useFiber(child, element.props.children);
                                existing.return = returnFiber;
                                existing._debugSource = element._source;
                                existing._debugOwner = element._owner;
                                return existing;
                            }
                            break;
                        case Block:
                        // We intentionally fallthrough here if enableBlocksAPI is not on.
                        // eslint-disable-next-lined no-fallthrough
                        default:
                            if (child.elementType === element.type || isCompatibleFamilyForHotReloading(child, element)) {
                                deleteRemainingChildren(returnFiber, child.sibling);
                                var _existing3 = useFiber(child, element.props);
                                _existing3.ref = coerceRef(returnFiber, child, element);
                                _existing3.return = returnFiber;
                                _existing3._debugSource = element._source;
                                _existing3._debugOwner = element._owner;
                                return _existing3;
                            }
                            break;
                    } // Didn't match.
                    deleteRemainingChildren(returnFiber, child);
                    break;
                } else deleteChild(returnFiber, child);
                child = child.sibling;
            }
            if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
            } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
            }
        }
        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
            var key = portal.key;
            var child = currentFirstChild;
            while(child !== null){
                // TODO: If key === null and child.key === null, then this only applies to
                // the first item in the list.
                if (child.key === key) {
                    if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                        deleteRemainingChildren(returnFiber, child.sibling);
                        var existing = useFiber(child, portal.children || []);
                        existing.return = returnFiber;
                        return existing;
                    } else {
                        deleteRemainingChildren(returnFiber, child);
                        break;
                    }
                } else deleteChild(returnFiber, child);
                child = child.sibling;
            }
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
        } // This API will tag the children with the side-effect of the reconciliation
        // itself. They will be added to the side-effect list as we pass through the
        // children and the parent.
        function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {
            // This function is not recursive.
            // If the top level item is an array, we treat it as a set of children,
            // not as a fragment. Nested arrays on the other hand will be treated as
            // fragment nodes. Recursion happens at the normal flow.
            // Handle top level unkeyed fragments as if they were arrays.
            // This leads to an ambiguity between <>{[...]}</> and <>...</>.
            // We treat the ambiguous cases above the same.
            var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
            if (isUnkeyedTopLevelFragment) newChild = newChild.props.children;
             // Handle object types
            var isObject = typeof newChild === 'object' && newChild !== null;
            if (isObject) switch(newChild.$$typeof){
                case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
            }
            if (typeof newChild === 'string' || typeof newChild === 'number') return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));
            if (isArray$1(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
            if (getIteratorFn(newChild)) return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
            if (isObject) throwOnInvalidObjectType(returnFiber, newChild);
            if (typeof newChild === 'function') warnOnFunctionType(returnFiber);
            if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) // If the new child is undefined, and the return fiber is a composite
            // component, throw an error. If Fiber return types are disabled,
            // we already threw above.
            switch(returnFiber.tag){
                case ClassComponent:
                    var instance = returnFiber.stateNode;
                    if (instance.render._isMockFunction) break;
                // Intentionally fall through to the next case, which handles both
                // functions and classes
                // eslint-disable-next-lined no-fallthrough
                case Block:
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent:
                    throw Error((getComponentName(returnFiber.type) || 'Component') + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
            }
             // Remaining cases are all treated as empty.
            return deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return reconcileChildFibers;
    }
    var reconcileChildFibers = ChildReconciler(true);
    var mountChildFibers = ChildReconciler(false);
    function cloneChildFibers(current3, workInProgress) {
        if (!(current3 === null || workInProgress.child === current3.child)) throw Error("Resuming work not yet implemented.");
        if (workInProgress.child === null) return;
        var currentChild = workInProgress.child;
        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
        workInProgress.child = newChild;
        newChild.return = workInProgress;
        while(currentChild.sibling !== null){
            currentChild = currentChild.sibling;
            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
            newChild.return = workInProgress;
        }
        newChild.sibling = null;
    } // Reset a workInProgress child set to prepare it for a second pass.
    function resetChildFibers(workInProgress, lanes) {
        var child = workInProgress.child;
        while(child !== null){
            resetWorkInProgress(child, lanes);
            child = child.sibling;
        }
    }
    var NO_CONTEXT = {
    };
    var contextStackCursor$1 = createCursor(NO_CONTEXT);
    var contextFiberStackCursor = createCursor(NO_CONTEXT);
    var rootInstanceStackCursor = createCursor(NO_CONTEXT);
    function requiredContext(c) {
        if (!(c !== NO_CONTEXT)) throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
        return c;
    }
    function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
    }
    function pushHostContainer(fiber, nextRootInstance) {
        // Push current root instance onto the stack;
        // This allows us to reset root when portals are popped.
        push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.
        // This enables us to pop only Fibers that provide unique contexts.
        push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.
        // However, we can't just call getRootHostContext() and push it because
        // we'd have a different number of entries on the stack depending on
        // whether getRootHostContext() throws somewhere in renderer code or not.
        // So we push an empty value first. This lets us safely unwind on errors.
        push(contextStackCursor$1, NO_CONTEXT, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.
        pop(contextStackCursor$1, fiber);
        push(contextStackCursor$1, nextRootContext, fiber);
    }
    function popHostContainer(fiber) {
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
        var context = requiredContext(contextStackCursor$1.current);
        return context;
    }
    function pushHostContext(fiber) {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        var context = requiredContext(contextStackCursor$1.current);
        var nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.
        if (context === nextContext) return;
         // Track the context and the Fiber that provided it.
        // This enables us to pop only Fibers that provide unique contexts.
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, nextContext, fiber);
    }
    function popHostContext(fiber) {
        // Do not pop unless this Fiber provided the current context.
        // pushHostContext() only pushes Fibers that provide unique contexts.
        if (contextFiberStackCursor.current !== fiber) return;
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
    }
    var DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is
    // inherited deeply down the subtree. The upper bits only affect
    // this immediate suspense boundary and gets reset each new
    // boundary or suspense list.
    var SubtreeSuspenseContextMask = 1; // Subtree Flags:
    // InvisibleParentSuspenseContext indicates that one of our parent Suspense
    // boundaries is not currently showing visible main content.
    // Either because it is already showing a fallback or is not mounted at all.
    // We can use this to determine if it is desirable to trigger a fallback at
    // the parent. If not, then we might need to trigger undesirable boundaries
    // and/or suspend the commit to avoid hiding the parent content.
    var InvisibleParentSuspenseContext = 1; // Shallow Flags:
    // ForceSuspenseFallback can be used by SuspenseList to force newly added
    // items into their fallback state during one of the render passes.
    var ForceSuspenseFallback = 2;
    var suspenseStackCursor = createCursor(DefaultSuspenseContext);
    function hasSuspenseContext(parentContext, flag) {
        return (parentContext & flag) !== 0;
    }
    function setDefaultShallowSuspenseContext(parentContext) {
        return parentContext & SubtreeSuspenseContextMask;
    }
    function setShallowSuspenseContext(parentContext, shallowContext) {
        return parentContext & SubtreeSuspenseContextMask | shallowContext;
    }
    function addSubtreeSuspenseContext(parentContext, subtreeContext) {
        return parentContext | subtreeContext;
    }
    function pushSuspenseContext(fiber, newContext) {
        push(suspenseStackCursor, newContext, fiber);
    }
    function popSuspenseContext(fiber) {
        pop(suspenseStackCursor, fiber);
    }
    function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {
        // If it was the primary children that just suspended, capture and render the
        // fallback. Otherwise, don't capture and bubble to the next boundary.
        var nextState = workInProgress.memoizedState;
        if (nextState !== null) {
            if (nextState.dehydrated !== null) // A dehydrated boundary always captures.
            return true;
            return false;
        }
        var props = workInProgress.memoizedProps; // In order to capture, the Suspense component must have a fallback prop.
        if (props.fallback === undefined) return false;
         // Regular boundaries always capture.
        if (props.unstable_avoidThisFallback !== true) return true;
         // If it's a boundary we should avoid, then we prefer to bubble up to the
        // parent boundary if it is currently invisible.
        if (hasInvisibleParent) return false;
         // If the parent is not able to handle it, we must handle it.
        return true;
    }
    function findFirstSuspended(row) {
        var node = row;
        while(node !== null){
            if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                    var dehydrated = state.dehydrated;
                    if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) return node;
                }
            } else if (node.tag === SuspenseListComponent && // keep track of whether it suspended or not.
            node.memoizedProps.revealOrder !== undefined) {
                var didSuspend = (node.flags & DidCapture) !== NoFlags;
                if (didSuspend) return node;
            } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === row) return null;
            while(node.sibling === null){
                if (node.return === null || node.return === row) return null;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
        return null;
    }
    var NoFlags$1 = /*  */ 0; // Represents whether effect should fire.
    var HasEffect = /* */ 1; // Represents the phase in which the effect (not the clean-up) fires.
    var Layout = /*    */ 2;
    var Passive$1 = /*   */ 4;
    // This may have been an insertion or a hydration.
    var hydrationParentFiber = null;
    var nextHydratableInstance = null;
    var isHydrating = false;
    function enterHydrationState(fiber) {
        var parentInstance = fiber.stateNode.containerInfo;
        nextHydratableInstance = getFirstHydratableChild(parentInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        return true;
    }
    function deleteHydratableInstance(returnFiber, instance) {
        switch(returnFiber.tag){
            case HostRoot:
                didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
                break;
            case HostComponent:
                didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
                break;
        }
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance;
        childToDelete.return = returnFiber;
        childToDelete.flags = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,
        // these children are not part of the reconciliation list of children.
        // Even if we abort and rereconcile the children, that will try to hydrate
        // again and the nodes are still in the host tree so these will be
        // recreated.
        if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = childToDelete;
            returnFiber.lastEffect = childToDelete;
        } else returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
    function insertNonHydratedInstance(returnFiber, fiber) {
        fiber.flags = fiber.flags & ~Hydrating | Placement;
        switch(returnFiber.tag){
            case HostRoot:
                var parentContainer = returnFiber.stateNode.containerInfo;
                switch(fiber.tag){
                    case HostComponent:
                        var type = fiber.type;
                        var props = fiber.pendingProps;
                        didNotFindHydratableContainerInstance(parentContainer, type);
                        break;
                    case HostText:
                        var text = fiber.pendingProps;
                        didNotFindHydratableContainerTextInstance(parentContainer, text);
                        break;
                }
                break;
            case HostComponent:
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                switch(fiber.tag){
                    case HostComponent:
                        var _type = fiber.type;
                        var _props = fiber.pendingProps;
                        didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);
                        break;
                    case HostText:
                        var _text = fiber.pendingProps;
                        didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                        break;
                    case SuspenseComponent:
                        didNotFindHydratableSuspenseInstance(parentType, parentProps);
                        break;
                }
                break;
            default:
                return;
        }
    }
    function tryHydrate(fiber, nextInstance) {
        switch(fiber.tag){
            case HostComponent:
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                    fiber.stateNode = instance;
                    return true;
                }
                return false;
            case HostText:
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);
                if (textInstance !== null) {
                    fiber.stateNode = textInstance;
                    return true;
                }
                return false;
            case SuspenseComponent:
                return false;
            default:
                return false;
        }
    }
    function tryToClaimNextHydratableInstance(fiber) {
        if (!isHydrating) return;
        var nextInstance = nextHydratableInstance;
        if (!nextInstance) {
            // Nothing to hydrate. Make it an insertion.
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
        }
        var firstAttemptedInstance = nextInstance;
        if (!tryHydrate(fiber, nextInstance)) {
            // If we can't hydrate this instance let's try the next one.
            // We use this as a heuristic. It's based on intuition and not data so it
            // might be flawed or unnecessary.
            nextInstance = getNextHydratableSibling(firstAttemptedInstance);
            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                // Nothing to hydrate. Make it an insertion.
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
            } // We matched the next one, we'll now assume that the first one was
            // superfluous and we'll delete it. Since we can't eagerly delete it
            // we'll have to schedule a deletion. To do that, this node needs a dummy
            // fiber associated with it.
            deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
        }
        hydrationParentFiber = fiber;
        nextHydratableInstance = getFirstHydratableChild(nextInstance);
    }
    function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        var instance = fiber.stateNode;
        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.
        fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
        // is a new ref we mark this as an update.
        if (updatePayload !== null) return true;
        return false;
    }
    function prepareToHydrateHostTextInstance(fiber) {
        var textInstance = fiber.stateNode;
        var textContent = fiber.memoizedProps;
        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
        if (shouldUpdate) {
            // We assume that prepareToHydrateHostTextInstance is called in a context where the
            // hydration parent is the parent host component of this host text.
            var returnFiber = hydrationParentFiber;
            if (returnFiber !== null) switch(returnFiber.tag){
                case HostRoot:
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                    break;
                case HostComponent:
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                    break;
            }
        }
        return shouldUpdate;
    }
    function skipPastDehydratedSuspenseInstance(fiber) {
        var suspenseState = fiber.memoizedState;
        var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
    }
    function popToNextHostParent(fiber) {
        var parent = fiber.return;
        while(parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent)parent = parent.return;
        hydrationParentFiber = parent;
    }
    function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) // We're deeper than the current hydration context, inside an inserted
        // tree.
        return false;
        if (!isHydrating) {
            // If we're not currently hydrating but we're in a hydration context, then
            // we were an insertion and now need to pop up reenter hydration of our
            // siblings.
            popToNextHostParent(fiber);
            isHydrating = true;
            return false;
        }
        var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.
        // We only do this deeper than head and body since they tend to have random
        // other nodes in them. We also ignore components with pure text content in
        // side of them.
        // TODO: Better heuristic.
        if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
            var nextInstance = nextHydratableInstance;
            while(nextInstance){
                deleteHydratableInstance(fiber, nextInstance);
                nextInstance = getNextHydratableSibling(nextInstance);
            }
        }
        popToNextHostParent(fiber);
        if (fiber.tag === SuspenseComponent) nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
        else nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        return true;
    }
    function resetHydrationState() {
        hydrationParentFiber = null;
        nextHydratableInstance = null;
        isHydrating = false;
    }
    function getIsHydrating() {
        return isHydrating;
    }
    // and should be reset before starting a new render.
    // This tracks which mutable sources need to be reset after a render.
    var workInProgressSources = [];
    var rendererSigil$1;
    // Used to detect multiple renderers using the same mutable source.
    rendererSigil$1 = {
    };
    function markSourceAsDirty(mutableSource) {
        workInProgressSources.push(mutableSource);
    }
    function resetWorkInProgressVersions() {
        for(var i = 0; i < workInProgressSources.length; i++){
            var mutableSource = workInProgressSources[i];
            mutableSource._workInProgressVersionPrimary = null;
        }
        workInProgressSources.length = 0;
    }
    function getWorkInProgressVersion(mutableSource) {
        return mutableSource._workInProgressVersionPrimary;
    }
    function setWorkInProgressVersion(mutableSource, version) {
        mutableSource._workInProgressVersionPrimary = version;
        workInProgressSources.push(mutableSource);
    }
    function warnAboutMultipleRenderersDEV(mutableSource) {
        if (mutableSource._currentPrimaryRenderer == null) mutableSource._currentPrimaryRenderer = rendererSigil$1;
        else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) error("Detected multiple renderers concurrently rendering the same mutable source. This is currently unsupported.");
    } // Eager reads the version of a mutable source and stores it on the root.
    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
    var didWarnAboutMismatchedHooksForComponent;
    var didWarnAboutUseOpaqueIdentifier;
    didWarnAboutUseOpaqueIdentifier = {
    };
    didWarnAboutMismatchedHooksForComponent = new Set();
    // These are set right before calling the component.
    var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from
    // the work-in-progress hook.
    var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The
    // current hook list is the list that belongs to the current fiber. The
    // work-in-progress hook list is a new list that will be added to the
    // work-in-progress fiber.
    var currentHook = null;
    var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This
    // does not get reset if we do another render pass; only when we're completely
    // finished evaluating this component. This is an optimization so we know
    // whether we need to clear render phase updates after a throw.
    var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This
    // gets reset after each attempt.
    // TODO: Maybe there's some way to consolidate this with
    // `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.
    var didScheduleRenderPhaseUpdateDuringThisPass = false;
    var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook
    var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.
    // The list stores the order of hooks used during the initial render (mount).
    // Subsequent renders (updates) reference this list.
    var hookTypesDev = null;
    var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore
    // the dependencies for Hooks that need them (e.g. useEffect or useMemo).
    // When true, such Hooks will always be "remounted". Only used during hot reload.
    var ignorePreviousDependencies = false;
    function mountHookTypesDev() {
        var hookName = currentHookNameInDev;
        if (hookTypesDev === null) hookTypesDev = [
            hookName
        ];
        else hookTypesDev.push(hookName);
    }
    function updateHookTypesDev() {
        var hookName = currentHookNameInDev;
        if (hookTypesDev !== null) {
            hookTypesUpdateIndexDev++;
            if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) warnOnHookMismatchInDev(hookName);
        }
    }
    function checkDepsAreArrayDev(deps) {
        if (deps !== undefined && deps !== null && !Array.isArray(deps)) // Verify deps, but only on mount to avoid extra checks.
        // It's unlikely their type would change as usually you define them inline.
        error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
    }
    function warnOnHookMismatchInDev(currentHookName) {
        var componentName = getComponentName(currentlyRenderingFiber$1.type);
        if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
            didWarnAboutMismatchedHooksForComponent.add(componentName);
            if (hookTypesDev !== null) {
                var table = '';
                var secondColumnStart = 30;
                for(var i = 0; i <= hookTypesUpdateIndexDev; i++){
                    var oldHookName = hookTypesDev[i];
                    var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i + 1 + ". " + oldHookName; // Extra space so second column lines up
                    // lol @ IE not supporting String#repeat
                    while(row.length < secondColumnStart)row += ' ';
                    row += newHookName + '\n';
                    table += row;
                }
                error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
            }
        }
    }
    function throwInvalidHookError() {
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
        if (ignorePreviousDependencies) // Only true when this component is being hot reloaded.
        return false;
        if (prevDeps === null) {
            error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            return false;
        }
        // Don't bother comparing lengths in prod because these arrays should be
        // passed inline.
        if (nextDeps.length !== prevDeps.length) error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(', ') + "]", "[" + nextDeps.join(', ') + "]");
        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){
            if (objectIs(nextDeps[i], prevDeps[i])) continue;
            return false;
        }
        return true;
    }
    function renderWithHooks(current3, workInProgress, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber$1 = workInProgress;
        hookTypesDev = current3 !== null ? current3._debugHookTypes : null;
        hookTypesUpdateIndexDev = -1; // Used for hot reloading:
        ignorePreviousDependencies = current3 !== null && current3.type !== workInProgress.type;
        workInProgress.memoizedState = null;
        workInProgress.updateQueue = null;
        workInProgress.lanes = NoLanes; // The following should have already been reset
        if (current3 !== null && current3.memoizedState !== null) ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
        else if (hookTypesDev !== null) // This dispatcher handles an edge case where a component is updating,
        // but no stateful hooks have been used.
        // We want to match the production code behavior (which will use HooksDispatcherOnMount),
        // but with the extra DEV validation to ensure hooks ordering hasn't changed.
        // This dispatcher does that.
        ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
        else ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
        var children = Component(props, secondArg); // Check if there was a render phase update
        if (didScheduleRenderPhaseUpdateDuringThisPass) {
            // Keep rendering in a loop for as long as render phase updates continue to
            // be scheduled. Use a counter to prevent infinite loops.
            var numberOfReRenders = 0;
            do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                if (!(numberOfReRenders < RE_RENDER_LIMIT)) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                numberOfReRenders += 1;
                // Even when hot reloading, allow dependencies to stabilize
                // after first render to prevent infinite render phase updates.
                ignorePreviousDependencies = false;
                currentHook = null;
                workInProgressHook = null;
                workInProgress.updateQueue = null;
                // Also validate hook order for cascading updates.
                hookTypesUpdateIndexDev = -1;
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component(props, secondArg);
            }while (didScheduleRenderPhaseUpdateDuringThisPass)
        } // We can assume the previous dispatcher is always this one, since we set it
        // at the beginning of the render phase and there's no re-entrancy.
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        workInProgress._debugHookTypes = hookTypesDev;
        // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
        var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
        renderLanes = NoLanes;
        currentlyRenderingFiber$1 = null;
        currentHook = null;
        workInProgressHook = null;
        currentHookNameInDev = null;
        hookTypesDev = null;
        hookTypesUpdateIndexDev = -1;
        didScheduleRenderPhaseUpdate = false;
        if (!!didRenderTooFewHooks) throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
        return children;
    }
    function bailoutHooks(current3, workInProgress, lanes) {
        workInProgress.updateQueue = current3.updateQueue;
        workInProgress.flags &= ~(Passive | Update);
        current3.lanes = removeLanes(current3.lanes, lanes);
    }
    function resetHooksAfterThrow() {
        // We can assume the previous dispatcher is always this one, since we set it
        // at the beginning of the render phase and there's no re-entrancy.
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        if (didScheduleRenderPhaseUpdate) {
            // There were render phase updates. These are only valid for this render
            // phase, which we are now aborting. Remove the updates from the queues so
            // they do not persist to the next render. Do not remove updates from hooks
            // that weren't processed.
            //
            // Only reset the updates from the queue if it has a clone. If it does
            // not have a clone, that means it wasn't processed, and the updates were
            // scheduled before we entered the render phase.
            var hook = currentlyRenderingFiber$1.memoizedState;
            while(hook !== null){
                var queue = hook.queue;
                if (queue !== null) queue.pending = null;
                hook = hook.next;
            }
            didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = NoLanes;
        currentlyRenderingFiber$1 = null;
        currentHook = null;
        workInProgressHook = null;
        hookTypesDev = null;
        hookTypesUpdateIndexDev = -1;
        currentHookNameInDev = null;
        isUpdatingOpaqueValueInRenderPhase = false;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
    }
    function mountWorkInProgressHook() {
        var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        if (workInProgressHook === null) // This is the first hook in the list
        currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
        else // Append to the end of the list
        workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
    }
    function updateWorkInProgressHook() {
        // This function is used both for updates and for re-renders triggered by a
        // render phase update. It assumes there is either a current hook we can
        // clone, or a work-in-progress hook from a previous render pass that we can
        // use as a base. When we reach the end of the base list, we must switch to
        // the dispatcher used for mounts.
        var nextCurrentHook;
        if (currentHook === null) {
            var current3 = currentlyRenderingFiber$1.alternate;
            if (current3 !== null) nextCurrentHook = current3.memoizedState;
            else nextCurrentHook = null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook;
        if (workInProgressHook === null) nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
        else nextWorkInProgressHook = workInProgressHook.next;
        if (nextWorkInProgressHook !== null) {
            // There's already a work-in-progress. Reuse it.
            workInProgressHook = nextWorkInProgressHook;
            nextWorkInProgressHook = workInProgressHook.next;
            currentHook = nextCurrentHook;
        } else {
            // Clone from the current hook.
            if (!(nextCurrentHook !== null)) throw Error("Rendered more hooks than during the previous render.");
            currentHook = nextCurrentHook;
            var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
            };
            if (workInProgressHook === null) // This is the first hook in the list.
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
            else // Append to the end of the list.
            workInProgressHook = workInProgressHook.next = newHook;
        }
        return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
        return {
            lastEffect: null
        };
    }
    function basicStateReducer(state, action) {
        // $FlowFixMe: Flow doesn't like mixed types
        return typeof action === 'function' ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        var initialState;
        if (init !== undefined) initialState = init(initialArg);
        else initialState = initialArg;
        hook.memoizedState = hook.baseState = initialState;
        var queue = hook.queue = {
            pending: null,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
        };
        var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
        return [
            hook.memoizedState,
            dispatch
        ];
    }
    function updateReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue = hook.queue;
        if (!(queue !== null)) throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        queue.lastRenderedReducer = reducer;
        var current4 = currentHook; // The last rebase update that is NOT part of the base state.
        var baseQueue = current4.baseQueue; // The last pending update that hasn't been processed yet.
        var pendingQueue = queue.pending;
        if (pendingQueue !== null) {
            // We have new updates that haven't been processed yet.
            // We'll add them to the base queue.
            if (baseQueue !== null) {
                // Merge the pending queue and the base queue.
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
            }
            if (current4.baseQueue !== baseQueue) // Internal invariant that should never happen, but feasibly could in
            // the future if we implement resuming, or some form of that.
            error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
            current4.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
        }
        if (baseQueue !== null) {
            // We have a queue to process.
            var first = baseQueue.next;
            var newState = current4.baseState;
            var newBaseState = null;
            var newBaseQueueFirst = null;
            var newBaseQueueLast = null;
            var update = first;
            do {
                var updateLane = update.lane;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                    // Priority is insufficient. Skip this update. If this is the first
                    // skipped update, the previous update/state is the new base
                    // update/state.
                    var clone = {
                        lane: updateLane,
                        action: update.action,
                        eagerReducer: update.eagerReducer,
                        eagerState: update.eagerState,
                        next: null
                    };
                    if (newBaseQueueLast === null) {
                        newBaseQueueFirst = newBaseQueueLast = clone;
                        newBaseState = newState;
                    } else newBaseQueueLast = newBaseQueueLast.next = clone;
                     // Update the remaining priority in the queue.
                    // TODO: Don't need to accumulate this. Instead, we can remove
                    // renderLanes from the original lanes.
                    currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                    markSkippedUpdateLanes(updateLane);
                } else {
                    // This update does have sufficient priority.
                    if (newBaseQueueLast !== null) {
                        var _clone = {
                            // This update is going to be committed so we never want uncommit
                            // it. Using NoLane works because 0 is a subset of all bitmasks, so
                            // this will never be skipped by the check above.
                            lane: NoLane,
                            action: update.action,
                            eagerReducer: update.eagerReducer,
                            eagerState: update.eagerState,
                            next: null
                        };
                        newBaseQueueLast = newBaseQueueLast.next = _clone;
                    } // Process this update.
                    if (update.eagerReducer === reducer) // If this update was processed eagerly, and its reducer matches the
                    // current reducer, we can use the eagerly computed state.
                    newState = update.eagerState;
                    else {
                        var action = update.action;
                        newState = reducer(newState, action);
                    }
                }
                update = update.next;
            }while (update !== null && update !== first)
            if (newBaseQueueLast === null) newBaseState = newState;
            else newBaseQueueLast.next = newBaseQueueFirst;
             // Mark that the fiber performed work, but only if the new state is
            // different from the current state.
            if (!objectIs(newState, hook.memoizedState)) markWorkInProgressReceivedUpdate();
            hook.memoizedState = newState;
            hook.baseState = newBaseState;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = newState;
        }
        var dispatch = queue.dispatch;
        return [
            hook.memoizedState,
            dispatch
        ];
    }
    function rerenderReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue = hook.queue;
        if (!(queue !== null)) throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous
        // work-in-progress hook.
        var dispatch = queue.dispatch;
        var lastRenderPhaseUpdate = queue.pending;
        var newState = hook.memoizedState;
        if (lastRenderPhaseUpdate !== null) {
            // The queue doesn't persist past this render pass.
            queue.pending = null;
            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            var update = firstRenderPhaseUpdate;
            do {
                // Process this render phase update. We don't have to check the
                // priority because it will always be the same as the current
                // render's.
                var action = update.action;
                newState = reducer(newState, action);
                update = update.next;
            }while (update !== firstRenderPhaseUpdate) // Mark that the fiber performed work, but only if the new state is
            // different from the current state.
            if (!objectIs(newState, hook.memoizedState)) markWorkInProgressReceivedUpdate();
            hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to
            // the base state unless the queue is empty.
            // TODO: Not sure if this is the desired semantics, but it's what we
            // do for gDSFP. I can't remember why.
            if (hook.baseQueue === null) hook.baseState = newState;
            queue.lastRenderedState = newState;
        }
        return [
            newState,
            dispatch
        ];
    }
    function readFromUnsubcribedMutableSource(root1, source, getSnapshot) {
        warnAboutMultipleRenderersDEV(source);
        var getVersion = source._getVersion;
        var version = getVersion(source._source); // Is it safe for this component to read from this source during the current render?
        var isSafeToReadFromSource = false; // Check the version first.
        // If this render has already been started with a specific version,
        // we can use it alone to determine if we can safely read from the source.
        var currentRenderVersion = getWorkInProgressVersion(source);
        if (currentRenderVersion !== null) // It's safe to read if the store hasn't been mutated since the last time
        // we read something.
        isSafeToReadFromSource = currentRenderVersion === version;
        else {
            // If there's no version, then this is the first time we've read from the
            // source during the current render pass, so we need to do a bit more work.
            // What we need to determine is if there are any hooks that already
            // subscribed to the source, and if so, whether there are any pending
            // mutations that haven't been synchronized yet.
            //
            // If there are no pending mutations, then `root.mutableReadLanes` will be
            // empty, and we know we can safely read.
            //
            // If there *are* pending mutations, we may still be able to safely read
            // if the currently rendering lanes are inclusive of the pending mutation
            // lanes, since that guarantees that the value we're about to read from
            // the source is consistent with the values that we read during the most
            // recent mutation.
            isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root1.mutableReadLanes);
            if (isSafeToReadFromSource) // If it's safe to read from this source during the current render,
            // store the version in case other components read from it.
            // A changed version number will let those components know to throw and restart the render.
            setWorkInProgressVersion(source, version);
        }
        if (isSafeToReadFromSource) {
            var snapshot = getSnapshot(source._source);
            if (typeof snapshot === 'function') error("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.");
            return snapshot;
        } else {
            // This handles the special case of a mutable source being shared between renderers.
            // In that case, if the source is mutated between the first and second renderer,
            // The second renderer don't know that it needs to reset the WIP version during unwind,
            // (because the hook only marks sources as dirty if it's written to their WIP version).
            // That would cause this tear check to throw again and eventually be visible to the user.
            // We can avoid this infinite loop by explicitly marking the source as dirty.
            //
            // This can lead to tearing in the first renderer when it resumes,
            // but there's nothing we can do about that (short of throwing here and refusing to continue the render).
            markSourceAsDirty(source);
            throw Error("Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue.");
        }
    }
    function useMutableSource(hook, source, getSnapshot, subscribe) {
        var root1 = getWorkInProgressRoot();
        if (!(root1 !== null)) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        var getVersion = source._getVersion;
        var version = getVersion(source._source);
        var dispatcher = ReactCurrentDispatcher$1.current; // eslint-disable-next-line prefer-const
        var _dispatcher$useState = dispatcher.useState(function() {
            return readFromUnsubcribedMutableSource(root1, source, getSnapshot);
        }), currentSnapshot = _dispatcher$useState[0], setSnapshot = _dispatcher$useState[1];
        var snapshot = currentSnapshot; // Grab a handle to the state hook as well.
        // We use it to clear the pending update queue if we have a new source.
        var stateHook = workInProgressHook;
        var memoizedState = hook.memoizedState;
        var refs = memoizedState.refs;
        var prevGetSnapshot = refs.getSnapshot;
        var prevSource = memoizedState.source;
        var prevSubscribe = memoizedState.subscribe;
        var fiber = currentlyRenderingFiber$1;
        hook.memoizedState = {
            refs: refs,
            source: source,
            subscribe: subscribe
        }; // Sync the values needed by our subscription handler after each commit.
        dispatcher.useEffect(function() {
            refs.getSnapshot = getSnapshot; // Normally the dispatch function for a state hook never changes,
            // but this hook recreates the queue in certain cases  to avoid updates from stale sources.
            // handleChange() below needs to reference the dispatch function without re-subscribing,
            // so we use a ref to ensure that it always has the latest version.
            refs.setSnapshot = setSnapshot; // Check for a possible change between when we last rendered now.
            var maybeNewVersion = getVersion(source._source);
            if (!objectIs(version, maybeNewVersion)) {
                var maybeNewSnapshot = getSnapshot(source._source);
                if (typeof maybeNewSnapshot === 'function') error("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.");
                if (!objectIs(snapshot, maybeNewSnapshot)) {
                    setSnapshot(maybeNewSnapshot);
                    var lane = requestUpdateLane(fiber);
                    markRootMutableRead(root1, lane);
                } // If the source mutated between render and now,
                // there may be state updates already scheduled from the old source.
                // Entangle the updates so that they render in the same batch.
                markRootEntangled(root1, root1.mutableReadLanes);
            }
        }, [
            getSnapshot,
            source,
            subscribe
        ]); // If we got a new source or subscribe function, re-subscribe in a passive effect.
        dispatcher.useEffect(function() {
            var handleChange = function() {
                var latestGetSnapshot = refs.getSnapshot;
                var latestSetSnapshot = refs.setSnapshot;
                try {
                    latestSetSnapshot(latestGetSnapshot(source._source)); // Record a pending mutable source update with the same expiration time.
                    var lane = requestUpdateLane(fiber);
                    markRootMutableRead(root1, lane);
                } catch (error4) {
                    // A selector might throw after a source mutation.
                    // e.g. it might try to read from a part of the store that no longer exists.
                    // In this case we should still schedule an update with React.
                    // Worst case the selector will throw again and then an error boundary will handle it.
                    latestSetSnapshot(function() {
                        throw error4;
                    });
                }
            };
            var unsubscribe = subscribe(source._source, handleChange);
            if (typeof unsubscribe !== 'function') error('Mutable source subscribe function must return an unsubscribe function.');
            return unsubscribe;
        }, [
            source,
            subscribe
        ]); // If any of the inputs to useMutableSource change, reading is potentially unsafe.
        //
        // If either the source or the subscription have changed we can't can't trust the update queue.
        // Maybe the source changed in a way that the old subscription ignored but the new one depends on.
        //
        // If the getSnapshot function changed, we also shouldn't rely on the update queue.
        // It's possible that the underlying source was mutated between the when the last "change" event fired,
        // and when the current render (with the new getSnapshot function) is processed.
        //
        // In both cases, we need to throw away pending updates (since they are no longer relevant)
        // and treat reading from the source as we do in the mount case.
        if (!objectIs(prevGetSnapshot, getSnapshot) || !objectIs(prevSource, source) || !objectIs(prevSubscribe, subscribe)) {
            // Create a new queue and setState method,
            // So if there are interleaved updates, they get pushed to the older queue.
            // When this becomes current, the previous queue and dispatch method will be discarded,
            // including any interleaving updates that occur.
            var newQueue = {
                pending: null,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: snapshot
            };
            newQueue.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, newQueue);
            stateHook.queue = newQueue;
            stateHook.baseQueue = null;
            snapshot = readFromUnsubcribedMutableSource(root1, source, getSnapshot);
            stateHook.memoizedState = stateHook.baseState = snapshot;
        }
        return snapshot;
    }
    function mountMutableSource(source, getSnapshot, subscribe) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = {
            refs: {
                getSnapshot: getSnapshot,
                setSnapshot: null
            },
            source: source,
            subscribe: subscribe
        };
        return useMutableSource(hook, source, getSnapshot, subscribe);
    }
    function updateMutableSource(source, getSnapshot, subscribe) {
        var hook = updateWorkInProgressHook();
        return useMutableSource(hook, source, getSnapshot, subscribe);
    }
    function mountState(initialState) {
        var hook = mountWorkInProgressHook();
        if (typeof initialState === 'function') // $FlowFixMe: Flow doesn't like mixed types
        initialState = initialState();
        hook.memoizedState = hook.baseState = initialState;
        var queue = hook.queue = {
            pending: null,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
        };
        var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
        return [
            hook.memoizedState,
            dispatch
        ];
    }
    function updateState(initialState) {
        return updateReducer(basicStateReducer);
    }
    function rerenderState(initialState) {
        return rerenderReducer(basicStateReducer);
    }
    function pushEffect(tag, create, destroy, deps) {
        var effect = {
            tag: tag,
            create: create,
            destroy: destroy,
            deps: deps,
            // Circular
            next: null
        };
        var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.lastEffect = effect.next = effect;
        } else {
            var lastEffect = componentUpdateQueue.lastEffect;
            if (lastEffect === null) componentUpdateQueue.lastEffect = effect.next = effect;
            else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect;
                effect.next = firstEffect;
                componentUpdateQueue.lastEffect = effect;
            }
        }
        return effect;
    }
    function mountRef(initialValue) {
        var hook = mountWorkInProgressHook();
        var ref = {
            current: initialValue
        };
        Object.seal(ref);
        hook.memoizedState = ref;
        return ref;
    }
    function updateRef(initialValue) {
        var hook = updateWorkInProgressHook();
        return hook.memoizedState;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var destroy = undefined;
        if (currentHook !== null) {
            var prevEffect = currentHook.memoizedState;
            destroy = prevEffect.destroy;
            if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                    pushEffect(hookFlags, create, destroy, nextDeps);
                    return;
                }
            }
        }
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
    }
    function mountEffect(create, deps) {
        // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
        if ('undefined' !== typeof jest) warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
        return mountEffectImpl(Update | Passive, Passive$1, create, deps);
    }
    function updateEffect(create, deps) {
        // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
        if ('undefined' !== typeof jest) warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
        return updateEffectImpl(Update | Passive, Passive$1, create, deps);
    }
    function mountLayoutEffect(create, deps) {
        return mountEffectImpl(Update, Layout, create, deps);
    }
    function updateLayoutEffect(create, deps) {
        return updateEffectImpl(Update, Layout, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
        if (typeof ref === 'function') {
            var refCallback = ref;
            var _inst = create();
            refCallback(_inst);
            return function() {
                refCallback(null);
            };
        } else if (ref !== null && ref !== undefined) {
            var refObject = ref;
            if (!refObject.hasOwnProperty('current')) error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", 'an object with keys {' + Object.keys(refObject).join(', ') + '}');
            var _inst2 = create();
            refObject.current = _inst2;
            return function() {
                refObject.current = null;
            };
        }
    }
    function mountImperativeHandle(ref, create, deps) {
        if (typeof create !== 'function') error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : 'null');
        var effectDeps = deps !== null && deps !== undefined ? deps.concat([
            ref
        ]) : null;
        return mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
    }
    function updateImperativeHandle(ref, create, deps) {
        if (typeof create !== 'function') error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : 'null');
        var effectDeps = deps !== null && deps !== undefined ? deps.concat([
            ref
        ]) : null;
        return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
    }
    function mountDebugValue(value, formatterFn) {
    // The react-debug-hooks package injects its own implementation
    // so that e.g. DevTools can display custom hook values.
    }
    var updateDebugValue = mountDebugValue;
    function mountCallback(callback, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        hook.memoizedState = [
            callback,
            nextDeps
        ];
        return callback;
    }
    function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var prevState = hook.memoizedState;
        if (prevState !== null) {
            if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) return prevState[0];
            }
        }
        hook.memoizedState = [
            callback,
            nextDeps
        ];
        return callback;
    }
    function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var nextValue = nextCreate();
        hook.memoizedState = [
            nextValue,
            nextDeps
        ];
        return nextValue;
    }
    function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var prevState = hook.memoizedState;
        if (prevState !== null) // Assume these are defined. If they're not, areHookInputsEqual will warn.
        {
            if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) return prevState[0];
            }
        }
        var nextValue = nextCreate();
        hook.memoizedState = [
            nextValue,
            nextDeps
        ];
        return nextValue;
    }
    function mountDeferredValue(value) {
        var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];
        mountEffect(function() {
            var prevTransition = ReactCurrentBatchConfig$1.transition;
            ReactCurrentBatchConfig$1.transition = 1;
            try {
                setValue(value);
            } finally{
                ReactCurrentBatchConfig$1.transition = prevTransition;
            }
        }, [
            value
        ]);
        return prevValue;
    }
    function updateDeferredValue(value) {
        var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];
        updateEffect(function() {
            var prevTransition = ReactCurrentBatchConfig$1.transition;
            ReactCurrentBatchConfig$1.transition = 1;
            try {
                setValue(value);
            } finally{
                ReactCurrentBatchConfig$1.transition = prevTransition;
            }
        }, [
            value
        ]);
        return prevValue;
    }
    function rerenderDeferredValue(value) {
        var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];
        updateEffect(function() {
            var prevTransition = ReactCurrentBatchConfig$1.transition;
            ReactCurrentBatchConfig$1.transition = 1;
            try {
                setValue(value);
            } finally{
                ReactCurrentBatchConfig$1.transition = prevTransition;
            }
        }, [
            value
        ]);
        return prevValue;
    }
    function startTransition(setPending, callback) {
        var priorityLevel = getCurrentPriorityLevel();
        runWithPriority$1(priorityLevel < UserBlockingPriority$2 ? UserBlockingPriority$2 : priorityLevel, function() {
            setPending(true);
        });
        runWithPriority$1(priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel, function() {
            var prevTransition = ReactCurrentBatchConfig$1.transition;
            ReactCurrentBatchConfig$1.transition = 1;
            try {
                setPending(false);
                callback();
            } finally{
                ReactCurrentBatchConfig$1.transition = prevTransition;
            }
        });
    }
    function mountTransition() {
        var _mountState2 = mountState(false), isPending = _mountState2[0], setPending = _mountState2[1]; // The `start` method can be stored on a ref, since `setPending`
        // never changes.
        var start = startTransition.bind(null, setPending);
        mountRef(start);
        return [
            start,
            isPending
        ];
    }
    function updateTransition() {
        var _updateState2 = updateState(), isPending = _updateState2[0];
        var startRef = updateRef();
        var start = startRef.current;
        return [
            start,
            isPending
        ];
    }
    function rerenderTransition() {
        var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0];
        var startRef = updateRef();
        var start = startRef.current;
        return [
            start,
            isPending
        ];
    }
    var isUpdatingOpaqueValueInRenderPhase = false;
    function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
        return isUpdatingOpaqueValueInRenderPhase;
    }
    function warnOnOpaqueIdentifierAccessInDEV(fiber) {
        // TODO: Should warn in effects and callbacks, too
        var name = getComponentName(fiber.type) || 'Unknown';
        if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name]) {
            error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
            didWarnAboutUseOpaqueIdentifier[name] = true;
        }
    }
    function mountOpaqueIdentifier() {
        var makeId = makeClientIdInDEV.bind(null, warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1));
        if (getIsHydrating()) {
            var didUpgrade = false;
            var fiber = currentlyRenderingFiber$1;
            var readValue = function() {
                if (!didUpgrade) {
                    // Only upgrade once. This works even inside the render phase because
                    // the update is added to a shared queue, which outlasts the
                    // in-progress render.
                    didUpgrade = true;
                    isUpdatingOpaqueValueInRenderPhase = true;
                    setId(makeId());
                    isUpdatingOpaqueValueInRenderPhase = false;
                    warnOnOpaqueIdentifierAccessInDEV(fiber);
                }
                throw Error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
            };
            var id = makeOpaqueHydratingObject(readValue);
            var setId = mountState(id)[1];
            if ((currentlyRenderingFiber$1.mode & BlockingMode) === NoMode) {
                currentlyRenderingFiber$1.flags |= Update | Passive;
                pushEffect(HasEffect | Passive$1, function() {
                    setId(makeId());
                }, undefined, null);
            }
            return id;
        } else {
            var _id = makeId();
            mountState(_id);
            return _id;
        }
    }
    function updateOpaqueIdentifier() {
        var id = updateState()[0];
        return id;
    }
    function rerenderOpaqueIdentifier() {
        var id = rerenderState()[0];
        return id;
    }
    function dispatchAction(fiber, queue, action) {
        if (typeof arguments[3] === 'function') error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
        var eventTime = requestEventTime();
        var lane = requestUpdateLane(fiber);
        var update = {
            lane: lane,
            action: action,
            eagerReducer: null,
            eagerState: null,
            next: null
        }; // Append the update to the end of the list.
        var pending = queue.pending;
        if (pending === null) // This is the first update. Create a circular list.
        update.next = update;
        else {
            update.next = pending.next;
            pending.next = update;
        }
        queue.pending = update;
        var alternate = fiber.alternate;
        if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) // This is a render phase update. Stash it in a lazily-created map of
        // queue -> linked list of updates. After this render pass, we'll restart
        // and apply the stashed updates on top of the work-in-progress hook.
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        else {
            if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                // The queue is currently empty, which means we can eagerly compute the
                // next state before entering the render phase. If the new state is the
                // same as the current state, we may be able to bail out entirely.
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                    var prevDispatcher;
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        var currentState = queue.lastRenderedState;
                        var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute
                        // it, on the update object. If the reducer hasn't changed by the
                        // time we enter the render phase, then the eager state can be used
                        // without calling the reducer again.
                        update.eagerReducer = lastRenderedReducer;
                        update.eagerState = eagerState;
                        if (objectIs(eagerState, currentState)) // Fast path. We can bail out without scheduling React to re-render.
                        // It's still possible that we'll need to rebase this update later,
                        // if the component re-renders for a different reason and by that
                        // time the reducer has changed.
                        return;
                    } catch (error4) {
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                }
            }
            // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
            if ('undefined' !== typeof jest) {
                warnIfNotScopedWithMatchingAct(fiber);
                warnIfNotCurrentlyActingUpdatesInDev(fiber);
            }
            scheduleUpdateOnFiber(fiber, lane, eventTime);
        }
    }
    var ContextOnlyDispatcher = {
        readContext: readContext,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useMutableSource: throwInvalidHookError,
        useOpaqueIdentifier: throwInvalidHookError,
        unstable_isNewReconciler: enableNewReconciler
    };
    var HooksDispatcherOnMountInDEV = null;
    var HooksDispatcherOnMountWithHookTypesInDEV = null;
    var HooksDispatcherOnUpdateInDEV = null;
    var HooksDispatcherOnRerenderInDEV = null;
    var InvalidNestedHooksDispatcherOnMountInDEV = null;
    var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
    var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    var warnInvalidContextAccess = function() {
        error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    };
    var warnInvalidHookAccess = function() {
        error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
    };
    HooksDispatcherOnMountInDEV = {
        readContext: function(context, observedBits) {
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            mountHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            mountHookTypesDev();
            return mountRef(initialValue);
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            mountHookTypesDev();
            return mountDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            mountHookTypesDev();
            return mountDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            mountHookTypesDev();
            return mountTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            mountHookTypesDev();
            return mountMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            mountHookTypesDev();
            return mountOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    HooksDispatcherOnMountWithHookTypesInDEV = {
        readContext: function(context, observedBits) {
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            updateHookTypesDev();
            return mountCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            updateHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            updateHookTypesDev();
            return mountEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            updateHookTypesDev();
            return mountRef(initialValue);
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            updateHookTypesDev();
            return mountDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            updateHookTypesDev();
            return mountDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            updateHookTypesDev();
            return mountTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            updateHookTypesDev();
            return mountMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            updateHookTypesDev();
            return mountOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    HooksDispatcherOnUpdateInDEV = {
        readContext: function(context, observedBits) {
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            updateHookTypesDev();
            return updateCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            updateHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            updateHookTypesDev();
            return updateEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            updateHookTypesDev();
            return updateRef();
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            updateHookTypesDev();
            return updateDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            updateHookTypesDev();
            return updateDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            updateHookTypesDev();
            return updateTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            updateHookTypesDev();
            return updateMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            updateHookTypesDev();
            return updateOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    HooksDispatcherOnRerenderInDEV = {
        readContext: function(context, observedBits) {
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            updateHookTypesDev();
            return updateCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            updateHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            updateHookTypesDev();
            return updateEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
                return updateMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
                return rerenderReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            updateHookTypesDev();
            return updateRef();
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
                return rerenderState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            updateHookTypesDev();
            return updateDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            updateHookTypesDev();
            return rerenderDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            updateHookTypesDev();
            return rerenderTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            updateHookTypesDev();
            return updateMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            updateHookTypesDev();
            return rerenderOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    InvalidNestedHooksDispatcherOnMountInDEV = {
        readContext: function(context, observedBits) {
            warnInvalidContextAccess();
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
                return mountState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV = {
        readContext: function(context, observedBits) {
            warnInvalidContextAccess();
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef();
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV = {
        readContext: function(context, observedBits) {
            warnInvalidContextAccess();
            return readContext(context, observedBits);
        },
        useCallback: function(callback, deps) {
            currentHookNameInDev = 'useCallback';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
        },
        useContext: function(context, observedBits) {
            currentHookNameInDev = 'useContext';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context, observedBits);
        },
        useEffect: function(create, deps) {
            currentHookNameInDev = 'useEffect';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create, deps);
        },
        useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = 'useImperativeHandle';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
        },
        useLayoutEffect: function(create, deps) {
            currentHookNameInDev = 'useLayoutEffect';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
        },
        useMemo: function(create, deps) {
            currentHookNameInDev = 'useMemo';
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return updateMemo(create, deps);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = 'useReducer';
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return rerenderReducer(reducer, initialArg, init);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useRef: function(initialValue) {
            currentHookNameInDev = 'useRef';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef();
        },
        useState: function(initialState) {
            currentHookNameInDev = 'useState';
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
                return rerenderState(initialState);
            } finally{
                ReactCurrentDispatcher$1.current = prevDispatcher;
            }
        },
        useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = 'useDebugValue';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue();
        },
        useDeferredValue: function(value) {
            currentHookNameInDev = 'useDeferredValue';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value);
        },
        useTransition: function() {
            currentHookNameInDev = 'useTransition';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = 'useMutableSource';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource(source, getSnapshot, subscribe);
        },
        useOpaqueIdentifier: function() {
            currentHookNameInDev = 'useOpaqueIdentifier';
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderOpaqueIdentifier();
        },
        unstable_isNewReconciler: enableNewReconciler
    };
    var now$1 = Scheduler.unstable_now;
    var commitTime = 0;
    var profilerStartTime = -1;
    function getCommitTime() {
        return commitTime;
    }
    function recordCommitTime() {
        commitTime = now$1();
    }
    function startProfilerTimer(fiber) {
        profilerStartTime = now$1();
        if (fiber.actualStartTime < 0) fiber.actualStartTime = now$1();
    }
    function stopProfilerTimerIfRunning(fiber) {
        profilerStartTime = -1;
    }
    function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
        if (profilerStartTime >= 0) {
            var elapsedTime = now$1() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            if (overrideBaseTime) fiber.selfBaseDuration = elapsedTime;
            profilerStartTime = -1;
        }
    }
    function transferActualDuration(fiber) {
        // Transfer time spent rendering these children so we don't lose it
        // after we rerender. This is used as a helper in special cases
        // where we should count the work of multiple passes.
        var child = fiber.child;
        while(child){
            fiber.actualDuration += child.actualDuration;
            child = child.sibling;
        }
    }
    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
    var didReceiveUpdate = false;
    var didWarnAboutBadClass;
    var didWarnAboutModulePatternComponent;
    var didWarnAboutContextTypeOnFunctionComponent;
    var didWarnAboutGetDerivedStateOnFunctionComponent;
    var didWarnAboutFunctionRefs;
    var didWarnAboutReassigningProps;
    var didWarnAboutRevealOrder;
    var didWarnAboutTailOptions;
    didWarnAboutBadClass = {
    };
    didWarnAboutModulePatternComponent = {
    };
    didWarnAboutContextTypeOnFunctionComponent = {
    };
    didWarnAboutGetDerivedStateOnFunctionComponent = {
    };
    didWarnAboutFunctionRefs = {
    };
    didWarnAboutReassigningProps = false;
    didWarnAboutRevealOrder = {
    };
    didWarnAboutTailOptions = {
    };
    function reconcileChildren(current4, workInProgress, nextChildren, renderLanes1) {
        if (current4 === null) // If this is a fresh new component that hasn't been rendered yet, we
        // won't update its child set by applying minimal side-effects. Instead,
        // we will add them all to the child before it gets rendered. That means
        // we can optimize this reconciliation pass by not tracking side-effects.
        workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes1);
        else // If the current child is the same as the work in progress, it means that
        // we haven't yet started any work on these children. Therefore, we use
        // the clone algorithm to create a copy of all the current children.
        // If we had any progressed work already, that is invalid at this point so
        // let's throw it out.
        workInProgress.child = reconcileChildFibers(workInProgress, current4.child, nextChildren, renderLanes1);
    }
    function forceUnmountCurrentAndReconcile(current4, workInProgress, nextChildren, renderLanes1) {
        // This function is fork of reconcileChildren. It's used in cases where we
        // want to reconcile without matching against the existing set. This has the
        // effect of all current children being unmounted; even if the type and key
        // are the same, the old child is unmounted and a new child is created.
        //
        // To do this, we're going to go through the reconcile algorithm twice. In
        // the first pass, we schedule a deletion for all the current children by
        // passing null.
        workInProgress.child = reconcileChildFibers(workInProgress, current4.child, null, renderLanes1); // In the second pass, we mount the new children. The trick here is that we
        // pass null in place of where we usually pass the current child set. This has
        // the effect of remounting all children regardless of whether their
        // identities match.
        workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes1);
    }
    function updateForwardRef(current4, workInProgress, Component, nextProps, renderLanes1) {
        if (workInProgress.type !== workInProgress.elementType) {
            // Lazy component props can't be validated in createElement
            // because they're only guaranteed to be resolved here.
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentName(Component));
        }
        var render = Component.render;
        var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent
        var nextChildren;
        prepareToReadContext(workInProgress, renderLanes1);
        ReactCurrentOwner$1.current = workInProgress;
        setIsRendering(true);
        nextChildren = renderWithHooks(current4, workInProgress, render, nextProps, ref, renderLanes1);
        if (workInProgress.mode & StrictMode) {
            disableLogs();
            try {
                nextChildren = renderWithHooks(current4, workInProgress, render, nextProps, ref, renderLanes1);
            } finally{
                reenableLogs();
            }
        }
        setIsRendering(false);
        if (current4 !== null && !didReceiveUpdate) {
            bailoutHooks(current4, workInProgress, renderLanes1);
            return bailoutOnAlreadyFinishedWork(current4, workInProgress, renderLanes1);
        } // React DevTools reads this flag.
        workInProgress.flags |= PerformedWork;
        reconcileChildren(current4, workInProgress, nextChildren, renderLanes1);
        return workInProgress.child;
    }
    function updateMemoComponent(current4, workInProgress, Component, nextProps, updateLanes, renderLanes1) {
        if (current4 === null) {
            var type = Component.type;
            if (isSimpleFunctionComponent(type) && Component.compare === null && Component.defaultProps === undefined) {
                var resolvedType = type;
                resolvedType = resolveFunctionForHotReloading(type);
                // and with only the default shallow comparison, we upgrade it
                // to a SimpleMemoComponent to allow fast path updates.
                workInProgress.tag = SimpleMemoComponent;
                workInProgress.type = resolvedType;
                validateFunctionComponentInDev(workInProgress, type);
                return updateSimpleMemoComponent(current4, workInProgress, resolvedType, nextProps, updateLanes, renderLanes1);
            }
            var innerPropTypes = type.propTypes;
            if (innerPropTypes) // Inner memo component props aren't currently validated in createElement.
            // We could move it there, but we'd still need this for lazy code path.
            checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentName(type));
            var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes1);
            child.ref = workInProgress.ref;
            child.return = workInProgress;
            workInProgress.child = child;
            return child;
        }
        var _type = Component.type;
        var _innerPropTypes = _type.propTypes;
        if (_innerPropTypes) // Inner memo component props aren't currently validated in createElement.
        // We could move it there, but we'd still need this for lazy code path.
        checkPropTypes(_innerPropTypes, nextProps, 'prop', getComponentName(_type));
        var currentChild = current4.child; // This is always exactly one child
        if (!includesSomeLane(updateLanes, renderLanes1)) {
            // This will be the props with resolved defaultProps,
            // unlike current.memoizedProps which will be the unresolved ones.
            var prevProps = currentChild.memoizedProps; // Default to shallow comparison
            var compare = Component.compare;
            compare = compare !== null ? compare : shallowEqual;
            if (compare(prevProps, nextProps) && current4.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current4, workInProgress, renderLanes1);
        } // React DevTools reads this flag.
        workInProgress.flags |= PerformedWork;
        var newChild = createWorkInProgress(currentChild, nextProps);
        newChild.ref = workInProgress.ref;
        newChild.return = workInProgress;
        workInProgress.child = newChild;
        return newChild;
    }
    function updateSimpleMemoComponent(current4, workInProgress, Component, nextProps, updateLanes, renderLanes1) {
        if (workInProgress.type !== workInProgress.elementType) {
            // Lazy component props can't be validated in createElement
            // because they're only guaranteed to be resolved here.
            var outerMemoType = workInProgress.elementType;
            if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                // We warn when you define propTypes on lazy()
                // so let's just skip over it to find memo() outer wrapper.
                // Inner props for memo are validated later.
                var lazyComponent = outerMemoType;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    outerMemoType = init(payload);
                } catch (x) {
                    outerMemoType = null;
                } // Inner propTypes will be validated in the function component path.
                var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                if (outerPropTypes) checkPropTypes(outerPropTypes, nextProps, 'prop', getComponentName(outerMemoType));
            }
        }
        if (current4 !== null) {
            var prevProps = current4.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current4.ref === workInProgress.ref && workInProgress.type === current4.type) {
                didReceiveUpdate = false;
                if (!includesSomeLane(renderLanes1, updateLanes)) {
                    // The pending lanes were cleared at the beginning of beginWork. We're
                    // about to bail out, but there might be other lanes that weren't
                    // included in the current render. Usually, the priority level of the
                    // remaining updates is accumlated during the evaluation of the
                    // component (i.e. when processing the update queue). But since since
                    // we're bailing out early *without* evaluating the component, we need
                    // to account for it here, too. Reset to the value of the current fiber.
                    // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
                    // because a MemoComponent fiber does not have hooks or an update queue;
                    // rather, it wraps around an inner component, which may or may not
                    // contains hooks.
                    // TODO: Move the reset at in beginWork out of the common path so that
                    // this is no longer necessary.
                    workInProgress.lanes = current4.lanes;
                    return bailoutOnAlreadyFinishedWork(current4, workInProgress, renderLanes1);
                } else if ((current4.flags & ForceUpdateForLegacySuspense) !== NoFlags) // This is a special case that only exists for legacy mode.
                // See https://github.com/facebook/react/pull/19216.
                didReceiveUpdate = true;
            }
        }
        return updateFunctionComponent(current4, workInProgress, Component, nextProps, renderLanes1);
    }
    function updateOffscreenComponent(current4, workInProgress, renderLanes1) {
        var nextProps = workInProgress.pendingProps;
        var nextChildren = nextProps.children;
        var prevState = current4 !== null ? current4.memoizedState : null;
        if (nextProps.mode === 'hidden' || nextProps.mode === 'unstable-defer-without-hiding') {
            if ((workInProgress.mode & ConcurrentMode) === NoMode) {
                // In legacy sync mode, don't defer the subtree. Render it now.
                // TODO: Figure out what we should do in Blocking mode.
                var nextState = {
                    baseLanes: NoLanes
                };
                workInProgress.memoizedState = nextState;
                pushRenderLanes(workInProgress, renderLanes1);
            } else if (!includesSomeLane(renderLanes1, OffscreenLane)) {
                var nextBaseLanes;
                if (prevState !== null) {
                    var prevBaseLanes = prevState.baseLanes;
                    nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes1);
                } else nextBaseLanes = renderLanes1;
                 // Schedule this fiber to re-render at offscreen priority. Then bailout.
                markSpawnedWork(OffscreenLane);
                workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                    baseLanes: nextBaseLanes
                };
                workInProgress.memoizedState = _nextState; // We're about to bail out, but we need to push this to the stack anyway
                // to avoid a push/pop misalignment.
                pushRenderLanes(workInProgress, nextBaseLanes);
                return null;
            } else {
                // Rendering at offscreen, so we can clear the base lanes.
                var _nextState2 = {
                    baseLanes: NoLanes
                };
                workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.
                var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes1;
                pushRenderLanes(workInProgress, subtreeRenderLanes);
            }
        } else {
            var _subtreeRenderLanes;
            if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes1); // Since we're not hidden anymore, reset the state
                workInProgress.memoizedState = null;
            } else // We weren't previously hidden, and we still aren't, so there's nothing
            // special to do. Need to push to the stack regardless, though, to avoid
            // a push/pop misalignment.
            _subtreeRenderLanes = renderLanes1;
            pushRenderLanes(workInProgress, _subtreeRenderLanes);
        }
        reconcileChildren(current4, workInProgress, nextChildren, renderLanes1);
        return workInProgress.child;
    } // Note: These happen to have identical begin phases, for now. We shouldn't hold
    // ourselves to this constraint, though. If the behavior diverges, we should
    // fork the function.
    var updateLegacyHiddenComponent = updateOffscreenComponent;
    function updateFragment(current4, workInProgress, renderLanes1) {
        var nextChildren = workInProgress.pendingProps;
        reconcileChildren(current4, workInProgress, nextChildren, renderLanes1);
        return workInProgress.child;
    }
    function updateMode(current4, workInProgress, renderLanes1) {
        var nextChildren = workInProgress.pendingProps.children;
        reconcileChildren(current4, workInProgress, nextChildren, renderLanes1);
        return workInProgress.child;
    }
    function updateProfiler(current4, workInProgress, renderLanes1) {
        workInProgress.flags |= Update; // Reset effect durations for the next eventual effect phase.
        // These are reset during render to allow the DevTools commit hook a chance to read them,
        var stateNode = workInProgress.stateNode;
        stateNode.effectDuration = 0;
        stateNode.passiveEffectDuration = 0;
        var nextProps = workInProgress.pendingProps;
        var nextChildren = nextProps.children;
        reconcileChildren(current4, workInProgress, nextChildren, renderLanes1);
        return workInProgress.child;
    }
    function markRef(current4, workInProgress) {
        var ref = workInProgress.ref;
        if (current4 === null && ref !== null || current4 !== null && current4.ref !== ref) // Schedule a Ref effect
        workInProgress.flags |= Ref;
    }
    function updateFunctionComponent(current4, workInProgress, Component, nextProps, renderLanes1) {
        if (workInProgress.type !== workInProgress.elementType) {
            // Lazy component props can't be validated in createElement
            // because they're only guaranteed to be resolved here.
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentName(Component));
        }
        var context;
        var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
        context = getMaskedContext(workInProgress, unmaskedContext);
        var nextChildren;
        prepareToReadContext(workInProgress, renderLanes1);
        ReactCurrentOwner$1.current = workInProgress;
        setIsRendering(true);
        nextChildren = renderWithHooks(current4, workInProgress, Component, nextProps, context, renderLanes1);
        if (workInProgress.mode & StrictMode) {
            disableLogs();
            try {
                nextChildren = renderWithHooks(current4, workInProgress, Component, nextProps, context, renderLanes1);
            } finally{
                reenableLogs();
            }
        }
        setIsRendering(false);
        if (current4 !== null && !didReceiveUpdate) {
            bailoutHooks(current4, workInProgress, renderLanes1);
            return bailoutOnAlreadyFinishedWork(current4, workInProgress, renderLanes1);
        } // React DevTools reads this flag.
        workInProgress.flags |= PerformedWork;
        reconcileChildren(current4, workInProgress, nextChildren, renderLanes1);
        return workInProgress.child;
    }
    function updateClassComponent(current4, workInProgress, Component, nextProps, renderLanes1) {
        if (workInProgress.type !== workInProgress.elementType) {
            // Lazy component props can't be validated in createElement
            // because they're only guaranteed to be resolved here.
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentName(Component));
        }
        // During mounting we don't know the child context yet as the instance doesn't exist.
        // We will invalidate the child context in finishClassComponent() right after rendering.
        var hasContext;
        if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress);
        } else hasContext = false;
        prepareToReadContext(workInProgress, renderLanes1);
        var instance = workInProgress.stateNode;
        var shouldUpdate;
        if (instance === null) {
            if (current4 !== null) {
                // A class component without an instance only mounts if it suspended
                // inside a non-concurrent tree, in an inconsistent state. We want to
                // treat it like a new mount, even though an empty version of it already
                // committed. Disconnect the alternate pointers.
                current4.alternate = null;
                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
                workInProgress.flags |= Placement;
            } // In the initial pass we might need to construct the instance.
            constructClassInstance(workInProgress, Component, nextProps);
            mountClassInstance(workInProgress, Component, nextProps, renderLanes1);
            shouldUpdate = true;
        } else if (current4 === null) // In a resume, we'll already have an instance we can reuse.
        shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes1);
        else shouldUpdate = updateClassInstance(current4, workInProgress, Component, nextProps, renderLanes1);
        var nextUnitOfWork = finishClassComponent(current4, workInProgress, Component, shouldUpdate, hasContext, renderLanes1);
        var inst = workInProgress.stateNode;
        if (shouldUpdate && inst.props !== nextProps) {
            if (!didWarnAboutReassigningProps) error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentName(workInProgress.type) || 'a component');
            didWarnAboutReassigningProps = true;
        }
        return nextUnitOfWork;
    }
    function finishClassComponent(current4, workInProgress, Component, shouldUpdate, hasContext, renderLanes1) {
        // Refs should update even if shouldComponentUpdate returns false
        markRef(current4, workInProgress);
        var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;
        if (!shouldUpdate && !didCaptureError) {
            // Context providers should defer to sCU for rendering
            if (hasContext) invalidateContextProvider(workInProgress, Component, false);
            return bailoutOnAlreadyFinishedWork(current4, workInProgress, renderLanes1);
        }
        var instance = workInProgress.stateNode; // Rerender
        ReactCurrentOwner$1.current = workInProgress;
        var nextChildren;
        if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {
            // If we captured an error, but getDerivedStateFromError is not defined,
            // unmount all the children. componentDidCatch will schedule an update to
            // re-render a fallback. This is temporary until we migrate everyone to
            // the new API.
            // TODO: Warn in a future release.
            nextChildren = null;
            stopProfilerTimerIfRunning();
        } else {
            setIsRendering(true);
            nextChildren = instance.render();
            if (workInProgress.mode & StrictMode) {
                disableLogs();
                try {
                    instance.render();
                } finally{
                    reenableLogs();
                }
            }
            setIsRendering(false);
        } // React DevTools reads this flag.
        workInProgress.flags |= PerformedWork;
        if (current4 !== null && didCaptureError) // If we're recovering from an error, reconcile without reusing any of
        // the existing children. Conceptually, the normal children and the children
        // that are shown on error are two different sets, so we shouldn't reuse
        // normal children even if their identities match.
        forceUnmountCurrentAndReconcile(current4, workInProgress, nextChildren, renderLanes1);
        else reconcileChildren(current4, workInProgress, nextChildren, renderLanes1);
         // Memoize state using the values we just used to render.
        // TODO: Restructure so we never read values from the instance.
        workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.
        if (hasContext) invalidateContextProvider(workInProgress, Component, true);
        return workInProgress.child;
    }
    function pushHostRootContext(workInProgress) {
        var root1 = workInProgress.stateNode;
        if (root1.pendingContext) pushTopLevelContextObject(workInProgress, root1.pendingContext, root1.pendingContext !== root1.context);
        else if (root1.context) // Should always be set
        pushTopLevelContextObject(workInProgress, root1.context, false);
        pushHostContainer(workInProgress, root1.containerInfo);
    }
    function updateHostRoot(current4, workInProgress, renderLanes1) {
        pushHostRootContext(workInProgress);
        var updateQueue = workInProgress.updateQueue;
        if (!(current4 !== null && updateQueue !== null)) throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");
        var nextProps = workInProgress.pendingProps;
        var prevState = workInProgress.memoizedState;
        var prevChildren = prevState !== null ? prevState.element : null;
        cloneUpdateQueue(current4, workInProgress);
        processUpdateQueue(workInProgress, nextProps, null, renderLanes1);
        var nextState = workInProgress.memoizedState; // Caution: React DevTools currently depends on this property
        // being called "element".
        var nextChildren = nextState.element;
        if (nextChildren === prevChildren) {
            resetHydrationState();
            return bailoutOnAlreadyFinishedWork(current4, workInProgress, renderLanes1);
        }
        var root1 = workInProgress.stateNode;
        if (root1.hydrate && enterHydrationState(workInProgress)) {
            var mutableSourceEagerHydrationData = root1.mutableSourceEagerHydrationData;
            if (mutableSourceEagerHydrationData != null) for(var i = 0; i < mutableSourceEagerHydrationData.length; i += 2){
                var mutableSource = mutableSourceEagerHydrationData[i];
                var version = mutableSourceEagerHydrationData[i + 1];
                setWorkInProgressVersion(mutableSource, version);
            }
            var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes1);
            workInProgress.child = child;
            var node = child;
            while(node){
                // Mark each child as hydrating. This is a fast path to know whether this
                // tree is part of a hydrating tree. This is used to determine if a child
                // node has fully mounted yet, and for scheduling event replaying.
                // Conceptually this is similar to Placement in that a new subtree is
                // inserted into the React tree here. It just happens to not need DOM
                // mutations because it already exists.
                node.flags = node.flags & ~Placement | Hydrating;
                node = node.sibling;
            }
        } else {
            // Otherwise reset hydration state in case we aborted and resumed another
            // root.
            reconcileChildren(current4, workInProgress, nextChildren, renderLanes1);
            resetHydrationState();
        }
        return workInProgress.child;
    }
    function updateHostComponent(current4, workInProgress, renderLanes1) {
        pushHostContext(workInProgress);
        if (current4 === null) tryToClaimNextHydratableInstance(workInProgress);
        var type = workInProgress.type;
        var nextProps = workInProgress.pendingProps;
        var prevProps = current4 !== null ? current4.memoizedProps : null;
        var nextChildren = nextProps.children;
        var isDirectTextChild = shouldSetTextContent(type, nextProps);
        if (isDirectTextChild) // We special case a direct text child of a host node. This is a common
        // case. We won't handle it as a reified child. We will instead handle
        // this in the host environment that also has access to this prop. That
        // avoids allocating another HostText fiber and traversing it.
        nextChildren = null;
        else if (prevProps !== null && shouldSetTextContent(type, prevProps)) // If we're switching from a direct text child to a normal child, or to
        // empty, we need to schedule the text content to be reset.
        workInProgress.flags |= ContentReset;
        markRef(current4, workInProgress);
        reconcileChildren(current4, workInProgress, nextChildren, renderLanes1);
        return workInProgress.child;
    }
    function updateHostText(current4, workInProgress) {
        if (current4 === null) tryToClaimNextHydratableInstance(workInProgress);
         // Nothing to do here. This is terminal. We'll do the completion step
        // immediately after.
        return null;
    }
    function mountLazyComponent(_current, workInProgress, elementType, updateLanes, renderLanes1) {
        if (_current !== null) {
            // A lazy component only mounts if it suspended inside a non-
            // concurrent tree, in an inconsistent state. We want to treat it like
            // a new mount, even though an empty version of it already committed.
            // Disconnect the alternate pointers.
            _current.alternate = null;
            workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
            workInProgress.flags |= Placement;
        }
        var props = workInProgress.pendingProps;
        var lazyComponent = elementType;
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;
        var Component = init(payload); // Store the unwrapped component in the type.
        workInProgress.type = Component;
        var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
        var resolvedProps = resolveDefaultProps(Component, props);
        var child;
        switch(resolvedTag){
            case FunctionComponent:
                validateFunctionComponentInDev(workInProgress, Component);
                workInProgress.type = Component = resolveFunctionForHotReloading(Component);
                child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes1);
                return child;
            case ClassComponent:
                workInProgress.type = Component = resolveClassForHotReloading(Component);
                child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes1);
                return child;
            case ForwardRef:
                workInProgress.type = Component = resolveForwardRefForHotReloading(Component);
                child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes1);
                return child;
            case MemoComponent:
                if (workInProgress.type !== workInProgress.elementType) {
                    var outerPropTypes = Component.propTypes;
                    if (outerPropTypes) checkPropTypes(outerPropTypes, resolvedProps, 'prop', getComponentName(Component));
                }
                child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), updateLanes, renderLanes1);
                return child;
        }
        var hint = '';
        if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) hint = ' Did you wrap a component in React.lazy() more than once?';
        throw Error("Element type is invalid. Received a promise that resolves to: " + Component + ". Lazy element type must resolve to a class or function." + hint);
    }
    function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes1) {
        if (_current !== null) {
            // An incomplete component only mounts if it suspended inside a non-
            // concurrent tree, in an inconsistent state. We want to treat it like
            // a new mount, even though an empty version of it already committed.
            // Disconnect the alternate pointers.
            _current.alternate = null;
            workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
            workInProgress.flags |= Placement;
        } // Promote the fiber to a class and try rendering again.
        workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`
        // Push context providers early to prevent context stack mismatches.
        // During mounting we don't know the child context yet as the instance doesn't exist.
        // We will invalidate the child context in finishClassComponent() right after rendering.
        var hasContext;
        if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress);
        } else hasContext = false;
        prepareToReadContext(workInProgress, renderLanes1);
        constructClassInstance(workInProgress, Component, nextProps);
        mountClassInstance(workInProgress, Component, nextProps, renderLanes1);
        return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes1);
    }
    function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes1) {
        if (_current !== null) {
            // An indeterminate component only mounts if it suspended inside a non-
            // concurrent tree, in an inconsistent state. We want to treat it like
            // a new mount, even though an empty version of it already committed.
            // Disconnect the alternate pointers.
            _current.alternate = null;
            workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect
            workInProgress.flags |= Placement;
        }
        var props = workInProgress.pendingProps;
        var context;
        var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
        context = getMaskedContext(workInProgress, unmaskedContext);
        prepareToReadContext(workInProgress, renderLanes1);
        var value;
        if (Component.prototype && typeof Component.prototype.render === 'function') {
            var componentName = getComponentName(Component) || 'Unknown';
            if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
            }
        }
        if (workInProgress.mode & StrictMode) ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
        setIsRendering(true);
        ReactCurrentOwner$1.current = workInProgress;
        value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes1);
        setIsRendering(false);
        workInProgress.flags |= PerformedWork;
        // Support for module components is deprecated and is removed behind a flag.
        // Whether or not it would crash later, we want to show a good message in DEV first.
        if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
            var _componentName = getComponentName(Component) || 'Unknown';
            if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
            }
        }
        if (// Eventually we'll delete this branch altogether.
        typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
            var _componentName2 = getComponentName(Component) || 'Unknown';
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
            }
            workInProgress.tag = ClassComponent; // Throw out any hooks that were used.
            workInProgress.memoizedState = null;
            workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.
            // During mounting we don't know the child context yet as the instance doesn't exist.
            // We will invalidate the child context in finishClassComponent() right after rendering.
            var hasContext = false;
            if (isContextProvider(Component)) {
                hasContext = true;
                pushContextProvider(workInProgress);
            } else hasContext = false;
            workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
            initializeUpdateQueue(workInProgress);
            var getDerivedStateFromProps = Component.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === 'function') applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
            adoptClassInstance(workInProgress, value);
            mountClassInstance(workInProgress, Component, props, renderLanes1);
            return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes1);
        } else {
            // Proceed under the assumption that this is a function component
            workInProgress.tag = FunctionComponent;
            if (workInProgress.mode & StrictMode) {
                disableLogs();
                try {
                    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes1);
                } finally{
                    reenableLogs();
                }
            }
            reconcileChildren(null, workInProgress, value, renderLanes1);
            validateFunctionComponentInDev(workInProgress, Component);
            return workInProgress.child;
        }
    }
    function validateFunctionComponentInDev(workInProgress, Component) {
        if (Component) {
            if (Component.childContextTypes) error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');
        }
        if (workInProgress.ref !== null) {
            var info = '';
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) info += '\n\nCheck the render method of `' + ownerName + '`.';
            var warningKey = ownerName || workInProgress._debugID || '';
            var debugSource = workInProgress._debugSource;
            if (debugSource) warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
            if (!didWarnAboutFunctionRefs[warningKey]) {
                didWarnAboutFunctionRefs[warningKey] = true;
                error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
            }
        }
        if (typeof Component.getDerivedStateFromProps === 'function') {
            var _componentName3 = getComponentName(Component) || 'Unknown';
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
        }
        if (typeof Component.contextType === 'object' && Component.contextType !== null) {
            var _componentName4 = getComponentName(Component) || 'Unknown';
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error('%s: Function components do not support contextType.', _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
        }
    }
    var SUSPENDED_MARKER = {
        dehydrated: null,
        retryLane: NoLane
    };
    function mountSuspenseOffscreenState(renderLanes1) {
        return {
            baseLanes: renderLanes1
        };
    }
    function updateSuspenseOffscreenState(prevOffscreenState, renderLanes1) {
        return {
            baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes1)
        };
    } // TODO: Probably should inline this back
    function shouldRemainOnFallback(suspenseContext, current4, workInProgress, renderLanes1) {
        // If we're already showing a fallback, there are cases where we need to
        // remain on that fallback regardless of whether the content has resolved.
        // For example, SuspenseList coordinates when nested content appears.
        if (current4 !== null) {
            var suspenseState = current4.memoizedState;
            if (suspenseState === null) // Currently showing content. Don't hide it, even if ForceSuspenseFallack
            // is true. More precise name might be "ForceRemainSuspenseFallback".
            // Note: This is a factoring smell. Can't remain on a fallback if there's
            // no fallback to remain on.
            return false;
        } // Not currently showing content. Consult the Suspense context.
        return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
    }
    function getRemainingWorkInPrimaryTree(current4, renderLanes1) {
        // TODO: Should not remove render lanes that were pinged during this render
        return removeLanes(current4.childLanes, renderLanes1);
    }
    function updateSuspenseComponent(current4, workInProgress, renderLanes1) {
        var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.
        if (shouldSuspend(workInProgress)) workInProgress.flags |= DidCapture;
        var suspenseContext = suspenseStackCursor.current;
        var showFallback = false;
        var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;
        if (didSuspend || shouldRemainOnFallback(suspenseContext, current4)) {
            // Something in this boundary's subtree already suspended. Switch to
            // rendering the fallback children.
            showFallback = true;
            workInProgress.flags &= ~DidCapture;
        } else {
            // Attempting the main content
            if (current4 === null || current4.memoizedState !== null) // This is a new mount or this boundary is already showing a fallback state.
            // Mark this subtree context as having at least one invisible parent that could
            // handle the fallback state.
            // Boundaries without fallbacks or should be avoided are not considered since
            // they cannot handle preferred fallback states.
            {
                if (nextProps.fallback !== undefined && nextProps.unstable_avoidThisFallback !== true) suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
            }
        }
        suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense
        // boundary's children. This involves some custom reconcilation logic. Two
        // main reasons this is so complicated.
        //
        // First, Legacy Mode has different semantics for backwards compatibility. The
        // primary tree will commit in an inconsistent state, so when we do the
        // second pass to render the fallback, we do some exceedingly, uh, clever
        // hacks to make that not totally break. Like transferring effects and
        // deletions from hidden tree. In Concurrent Mode, it's much simpler,
        // because we bailout on the primary tree completely and leave it in its old
        // state, no effects. Same as what we do for Offscreen (except that
        // Offscreen doesn't have the first render pass).
        //
        // Second is hydration. During hydration, the Suspense fiber has a slightly
        // different layout, where the child points to a dehydrated fragment, which
        // contains the DOM rendered by the server.
        //
        // Third, even if you set all that aside, Suspense is like error boundaries in
        // that we first we try to render one tree, and if that fails, we render again
        // and switch to a different tree. Like a try/catch block. So we have to track
        // which branch we're currently rendering. Ideally we would model this using
        // a stack.
        if (current4 === null) {
            // Initial mount
            // If we're currently hydrating, try to hydrate this boundary.
            // But only if this has a fallback.
            if (nextProps.fallback !== undefined) tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes1);
                var primaryChildFragment = workInProgress.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes1);
                workInProgress.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
            } else if (typeof nextProps.unstable_expectedLoadTime === 'number') {
                // This is a CPU-bound tree. Skip this tree and show a placeholder to
                // unblock the surrounding content. Then immediately retry after the
                // initial commit.
                var _fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes1);
                var _primaryChildFragment = workInProgress.child;
                _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes1);
                workInProgress.memoizedState = SUSPENDED_MARKER; // Since nothing actually suspended, there will nothing to ping this to
                // get it started back up to attempt the next item. While in terms of
                // priority this work has the same priority as this current render, it's
                // not part of the same transition once the transition has committed. If
                // it's sync, we still want to yield so that it can be painted.
                // Conceptually, this is really the same as pinging. We can use any
                // RetryLane even if it's the one currently rendering since we're leaving
                // it behind on this node.
                workInProgress.lanes = SomeRetryLane;
                markSpawnedWork(SomeRetryLane);
                return _fallbackFragment;
            } else return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren, renderLanes1);
        } else {
            // This is an update.
            // If the current fiber has a SuspenseState, that means it's already showing
            // a fallback.
            var prevState = current4.memoizedState;
            if (prevState !== null) {
                if (showFallback) {
                    var _nextFallbackChildren2 = nextProps.fallback;
                    var _nextPrimaryChildren2 = nextProps.children;
                    var _fallbackChildFragment = updateSuspenseFallbackChildren(current4, workInProgress, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes1);
                    var _primaryChildFragment3 = workInProgress.child;
                    var prevOffscreenState = current4.child.memoizedState;
                    _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes1) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes1);
                    _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current4, renderLanes1);
                    workInProgress.memoizedState = SUSPENDED_MARKER;
                    return _fallbackChildFragment;
                } else {
                    var _nextPrimaryChildren3 = nextProps.children;
                    var _primaryChildFragment4 = updateSuspensePrimaryChildren(current4, workInProgress, _nextPrimaryChildren3, renderLanes1);
                    workInProgress.memoizedState = null;
                    return _primaryChildFragment4;
                }
            } else // The current tree is not already showing a fallback.
            if (showFallback) {
                // Timed out.
                var _nextFallbackChildren3 = nextProps.fallback;
                var _nextPrimaryChildren4 = nextProps.children;
                var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current4, workInProgress, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes1);
                var _primaryChildFragment5 = workInProgress.child;
                var _prevOffscreenState = current4.child.memoizedState;
                _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes1) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes1);
                _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current4, renderLanes1); // Skip the primary children, and continue working on the
                // fallback children.
                workInProgress.memoizedState = SUSPENDED_MARKER;
                return _fallbackChildFragment2;
            } else {
                // Still haven't timed out. Continue rendering the children, like we
                // normally do.
                var _nextPrimaryChildren5 = nextProps.children;
                var _primaryChildFragment6 = updateSuspensePrimaryChildren(current4, workInProgress, _nextPrimaryChildren5, renderLanes1);
                workInProgress.memoizedState = null;
                return _primaryChildFragment6;
            }
        }
    }
    function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes1) {
        var mode = workInProgress.mode;
        var primaryChildProps = {
            mode: 'visible',
            children: primaryChildren
        };
        var primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes1, null);
        primaryChildFragment.return = workInProgress;
        workInProgress.child = primaryChildFragment;
        return primaryChildFragment;
    }
    function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes1) {
        var mode = workInProgress.mode;
        var progressedPrimaryFragment = workInProgress.child;
        var primaryChildProps = {
            mode: 'hidden',
            children: primaryChildren
        };
        var primaryChildFragment;
        var fallbackChildFragment;
        if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {
            // In legacy mode, we commit the primary tree as if it successfully
            // completed, even though it's in an inconsistent state.
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress.mode & ProfileMode) {
                // Reset the durations from the first pass so they aren't included in the
                // final amounts. This seems counterintuitive, since we're intentionally
                // not measuring part of the render phase, but this makes it match what we
                // do in Concurrent Mode.
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
            }
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes1, null);
        } else {
            primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, NoLanes, null);
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes1, null);
        }
        primaryChildFragment.return = workInProgress;
        fallbackChildFragment.return = workInProgress;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress.child = primaryChildFragment;
        return fallbackChildFragment;
    }
    function createWorkInProgressOffscreenFiber(current4, offscreenProps) {
        // The props argument to `createWorkInProgress` is `any` typed, so we use this
        // wrapper function to constrain it.
        return createWorkInProgress(current4, offscreenProps);
    }
    function updateSuspensePrimaryChildren(current4, workInProgress, primaryChildren, renderLanes1) {
        var currentPrimaryChildFragment = current4.child;
        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
        var primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
            mode: 'visible',
            children: primaryChildren
        });
        if ((workInProgress.mode & BlockingMode) === NoMode) primaryChildFragment.lanes = renderLanes1;
        primaryChildFragment.return = workInProgress;
        primaryChildFragment.sibling = null;
        if (currentFallbackChildFragment !== null) {
            // Delete the fallback child fragment
            currentFallbackChildFragment.nextEffect = null;
            currentFallbackChildFragment.flags = Deletion;
            workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChildFragment;
        }
        workInProgress.child = primaryChildFragment;
        return primaryChildFragment;
    }
    function updateSuspenseFallbackChildren(current4, workInProgress, primaryChildren, fallbackChildren, renderLanes1) {
        var mode = workInProgress.mode;
        var currentPrimaryChildFragment = current4.child;
        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
        var primaryChildProps = {
            mode: 'hidden',
            children: primaryChildren
        };
        var primaryChildFragment;
        if (// completed, even though it's in an inconsistent state.
        (mode & BlockingMode) === NoMode && // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        workInProgress.child !== currentPrimaryChildFragment) {
            var progressedPrimaryFragment = workInProgress.child;
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress.mode & ProfileMode) {
                // Reset the durations from the first pass so they aren't included in the
                // final amounts. This seems counterintuitive, since we're intentionally
                // not measuring part of the render phase, but this makes it match what we
                // do in Concurrent Mode.
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
            } // The fallback fiber was added as a deletion effect during the first pass.
            // However, since we're going to remain on the fallback, we no longer want
            // to delete it. So we need to remove it from the list. Deletions are stored
            // on the same list as effects. We want to keep the effects from the primary
            // tree. So we copy the primary child fragment's effect list, which does not
            // include the fallback deletion effect.
            var progressedLastEffect = primaryChildFragment.lastEffect;
            if (progressedLastEffect !== null) {
                workInProgress.firstEffect = primaryChildFragment.firstEffect;
                workInProgress.lastEffect = progressedLastEffect;
                progressedLastEffect.nextEffect = null;
            } else // TODO: Reset this somewhere else? Lol legacy mode is so weird.
            workInProgress.firstEffect = workInProgress.lastEffect = null;
        } else primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
        var fallbackChildFragment;
        if (currentFallbackChildFragment !== null) fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
        else {
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes1, null); // Needs a placement effect because the parent (the Suspense boundary) already
            // mounted but this is a new fiber.
            fallbackChildFragment.flags |= Placement;
        }
        fallbackChildFragment.return = workInProgress;
        primaryChildFragment.return = workInProgress;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress.child = primaryChildFragment;
        return fallbackChildFragment;
    }
    function scheduleWorkOnFiber(fiber, renderLanes1) {
        fiber.lanes = mergeLanes(fiber.lanes, renderLanes1);
        var alternate = fiber.alternate;
        if (alternate !== null) alternate.lanes = mergeLanes(alternate.lanes, renderLanes1);
        scheduleWorkOnParentPath(fiber.return, renderLanes1);
    }
    function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes1) {
        // Mark any Suspense boundaries with fallbacks as having work to do.
        // If they were previously forced into fallbacks, they may now be able
        // to unblock.
        var node = firstChild;
        while(node !== null){
            if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) scheduleWorkOnFiber(node, renderLanes1);
            } else if (node.tag === SuspenseListComponent) // If the tail is hidden there might not be an Suspense boundaries
            // to schedule work on. In this case we have to schedule it on the
            // list itself.
            // We don't have to traverse to the children of the list since
            // the list will propagate the change when it rerenders.
            scheduleWorkOnFiber(node, renderLanes1);
            else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === workInProgress) return;
            while(node.sibling === null){
                if (node.return === null || node.return === workInProgress) return;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    function findLastContentRow(firstChild) {
        // This is going to find the last row among these children that is already
        // showing content on the screen, as opposed to being in fallback state or
        // new. If a row has multiple Suspense boundaries, any of them being in the
        // fallback state, counts as the whole row being in a fallback state.
        // Note that the "rows" will be workInProgress, but any nested children
        // will still be current since we haven't rendered them yet. The mounted
        // order may not be the same as the new order. We use the new order.
        var row = firstChild;
        var lastContentRow = null;
        while(row !== null){
            var currentRow = row.alternate; // New rows can't be content rows.
            if (currentRow !== null && findFirstSuspended(currentRow) === null) lastContentRow = row;
            row = row.sibling;
        }
        return lastContentRow;
    }
    function validateRevealOrder(revealOrder) {
        if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {
            didWarnAboutRevealOrder[revealOrder] = true;
            if (typeof revealOrder === 'string') switch(revealOrder.toLowerCase()){
                case 'together':
                case 'forwards':
                case 'backwards':
                    error("\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.", revealOrder, revealOrder.toLowerCase());
                    break;
                case 'forward':
                case 'backward':
                    error("\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.", revealOrder, revealOrder.toLowerCase());
                    break;
                default:
                    error("\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?", revealOrder);
                    break;
            }
            else error("%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?", revealOrder);
        }
    }
    function validateTailOptions(tailMode, revealOrder) {
        if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {
            if (tailMode !== 'collapsed' && tailMode !== 'hidden') {
                didWarnAboutTailOptions[tailMode] = true;
                error("\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"collapsed\" or \"hidden\"?", tailMode);
            } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {
                didWarnAboutTailOptions[tailMode] = true;
                error("<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?", tailMode);
            }
        }
    }
    function validateSuspenseListNestedChild(childSlot, index1) {
        var isArray1 = Array.isArray(childSlot);
        var isIterable = !isArray1 && typeof getIteratorFn(childSlot) === 'function';
        if (isArray1 || isIterable) {
            var type = isArray1 ? 'array' : 'iterable';
            error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index1, type);
            return false;
        }
        return true;
    }
    function validateSuspenseListChildren(children, revealOrder) {
        if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {
            if (Array.isArray(children)) for(var i = 0; i < children.length; i++){
                if (!validateSuspenseListNestedChild(children[i], i)) return;
            }
            else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === 'function') {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                        var step = childrenIterator.next();
                        var _i = 0;
                        for(; !step.done; step = childrenIterator.next()){
                            if (!validateSuspenseListNestedChild(step.value, _i)) return;
                            _i++;
                        }
                    }
                } else error("A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?", revealOrder);
            }
        }
    }
    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {
        var renderState = workInProgress.memoizedState;
        if (renderState === null) workInProgress.memoizedState = {
            isBackwards: isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail: tail,
            tailMode: tailMode,
            lastEffect: lastEffectBeforeRendering
        };
        else {
            // We can reuse the existing object from previous renders.
            renderState.isBackwards = isBackwards;
            renderState.rendering = null;
            renderState.renderingStartTime = 0;
            renderState.last = lastContentRow;
            renderState.tail = tail;
            renderState.tailMode = tailMode;
            renderState.lastEffect = lastEffectBeforeRendering;
        }
    } // This can end up rendering this component multiple passes.
    // The first pass splits the children fibers into two sets. A head and tail.
    // We first render the head. If anything is in fallback state, we do another
    // pass through beginWork to rerender all children (including the tail) with
    // the force suspend context. If the first render didn't have anything in
    // in fallback state. Then we render each row in the tail one-by-one.
    // That happens in the completeWork phase without going back to beginWork.
    function updateSuspenseListComponent(current4, workInProgress, renderLanes1) {
        var nextProps = workInProgress.pendingProps;
        var revealOrder = nextProps.revealOrder;
        var tailMode = nextProps.tail;
        var newChildren = nextProps.children;
        validateRevealOrder(revealOrder);
        validateTailOptions(tailMode, revealOrder);
        validateSuspenseListChildren(newChildren, revealOrder);
        reconcileChildren(current4, workInProgress, newChildren, renderLanes1);
        var suspenseContext = suspenseStackCursor.current;
        var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        if (shouldForceFallback) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
            workInProgress.flags |= DidCapture;
        } else {
            var didSuspendBefore = current4 !== null && (current4.flags & DidCapture) !== NoFlags;
            if (didSuspendBefore) // If we previously forced a fallback, we need to schedule work
            // on any nested boundaries to let them know to try to render
            // again. This is the same as context updating.
            propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes1);
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        }
        pushSuspenseContext(workInProgress, suspenseContext);
        if ((workInProgress.mode & BlockingMode) === NoMode) // In legacy mode, SuspenseList doesn't work so we just
        // use make it a noop by treating it as the default revealOrder.
        workInProgress.memoizedState = null;
        else switch(revealOrder){
            case 'forwards':
                var lastContentRow = findLastContentRow(workInProgress.child);
                var tail;
                if (lastContentRow === null) {
                    // The whole list is part of the tail.
                    // TODO: We could fast path by just rendering the tail now.
                    tail = workInProgress.child;
                    workInProgress.child = null;
                } else {
                    // Disconnect the tail rows after the content row.
                    // We're going to render them separately later.
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                }
                initSuspenseListRenderState(workInProgress, false, tail, lastContentRow, tailMode, workInProgress.lastEffect);
                break;
            case 'backwards':
                // We're going to find the first row that has existing content.
                // At the same time we're going to reverse the list of everything
                // we pass in the meantime. That's going to be our tail in reverse
                // order.
                var _tail = null;
                var row = workInProgress.child;
                workInProgress.child = null;
                while(row !== null){
                    var currentRow = row.alternate; // New rows can't be content rows.
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                        // This is the beginning of the main content.
                        workInProgress.child = row;
                        break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                } // TODO: If workInProgress.child is null, we can continue on the tail immediately.
                initSuspenseListRenderState(workInProgress, true, _tail, null, tailMode, workInProgress.lastEffect);
                break;
            case 'together':
                initSuspenseListRenderState(workInProgress, false, null, null, undefined, workInProgress.lastEffect);
                break;
            default:
                // The default reveal order is the same as not having
                // a boundary.
                workInProgress.memoizedState = null;
        }
        return workInProgress.child;
    }
    function updatePortalComponent(current4, workInProgress, renderLanes1) {
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        var nextChildren = workInProgress.pendingProps;
        if (current4 === null) // Portals are special because we don't append the children during mount
        // but at commit. Therefore we need to track insertions which the normal
        // flow doesn't do during mount. This doesn't happen at the root because
        // the root always starts with a "current" with a null child.
        // TODO: Consider unifying this with how the root works.
        workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes1);
        else reconcileChildren(current4, workInProgress, nextChildren, renderLanes1);
        return workInProgress.child;
    }
    var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
    function updateContextProvider(current4, workInProgress, renderLanes1) {
        var providerType = workInProgress.type;
        var context = providerType._context;
        var newProps = workInProgress.pendingProps;
        var oldProps = workInProgress.memoizedProps;
        var newValue = newProps.value;
        if (!('value' in newProps)) {
            if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');
            }
        }
        var providerPropTypes = workInProgress.type.propTypes;
        if (providerPropTypes) checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');
        pushProvider(workInProgress, newValue);
        if (oldProps !== null) {
            var oldValue = oldProps.value;
            var changedBits = calculateChangedBits(context, newValue, oldValue);
            if (changedBits === 0) {
                // No change. Bailout early if children are the same.
                if (oldProps.children === newProps.children && !hasContextChanged()) return bailoutOnAlreadyFinishedWork(current4, workInProgress, renderLanes1);
            } else // The context value changed. Search for matching consumers and schedule
            // them to update.
            propagateContextChange(workInProgress, context, changedBits, renderLanes1);
        }
        var newChildren = newProps.children;
        reconcileChildren(current4, workInProgress, newChildren, renderLanes1);
        return workInProgress.child;
    }
    var hasWarnedAboutUsingContextAsConsumer = false;
    function updateContextConsumer(current4, workInProgress, renderLanes1) {
        var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In
        if (context._context === undefined) {
            // This may be because it's a Context (rather than a Consumer).
            // Or it may be because it's older React where they're the same thing.
            // We only want to warn if we're sure it's a new React.
            if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
            }
        } else context = context._context;
        var newProps = workInProgress.pendingProps;
        var render = newProps.children;
        if (typeof render !== 'function') error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
        prepareToReadContext(workInProgress, renderLanes1);
        var newValue = readContext(context, newProps.unstable_observedBits);
        var newChildren;
        ReactCurrentOwner$1.current = workInProgress;
        setIsRendering(true);
        newChildren = render(newValue);
        setIsRendering(false);
        workInProgress.flags |= PerformedWork;
        reconcileChildren(current4, workInProgress, newChildren, renderLanes1);
        return workInProgress.child;
    }
    function markWorkInProgressReceivedUpdate() {
        didReceiveUpdate = true;
    }
    function bailoutOnAlreadyFinishedWork(current4, workInProgress, renderLanes1) {
        if (current4 !== null) // Reuse previous dependencies
        workInProgress.dependencies = current4.dependencies;
        // Don't update "base" render times for bailouts.
        stopProfilerTimerIfRunning();
        markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.
        if (!includesSomeLane(renderLanes1, workInProgress.childLanes)) // The children don't have any work either. We can skip them.
        // TODO: Once we add back resuming, we should check if the children are
        // a work-in-progress set. If so, we need to transfer their effects.
        return null;
        else {
            // This fiber doesn't have work, but its subtree does. Clone the child
            // fibers and continue.
            cloneChildFibers(current4, workInProgress);
            return workInProgress.child;
        }
    }
    function remountFiber(current4, oldWorkInProgress, newWorkInProgress) {
        var returnFiber = oldWorkInProgress.return;
        if (returnFiber === null) throw new Error('Cannot swap the root fiber.');
         // Disconnect from the old current.
        // It will get deleted.
        current4.alternate = null;
        oldWorkInProgress.alternate = null; // Connect to the new tree.
        newWorkInProgress.index = oldWorkInProgress.index;
        newWorkInProgress.sibling = oldWorkInProgress.sibling;
        newWorkInProgress.return = oldWorkInProgress.return;
        newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.
        if (oldWorkInProgress === returnFiber.child) returnFiber.child = newWorkInProgress;
        else {
            var prevSibling = returnFiber.child;
            if (prevSibling === null) throw new Error('Expected parent to have a child.');
            while(prevSibling.sibling !== oldWorkInProgress){
                prevSibling = prevSibling.sibling;
                if (prevSibling === null) throw new Error('Expected to find the previous sibling.');
            }
            prevSibling.sibling = newWorkInProgress;
        } // Delete the old fiber and place the new one.
        // Since the old fiber is disconnected, we have to schedule it manually.
        var last = returnFiber.lastEffect;
        if (last !== null) {
            last.nextEffect = current4;
            returnFiber.lastEffect = current4;
        } else returnFiber.firstEffect = returnFiber.lastEffect = current4;
        current4.nextEffect = null;
        current4.flags = Deletion;
        newWorkInProgress.flags |= Placement; // Restart work from the new fiber.
        return newWorkInProgress;
    }
    function beginWork(current4, workInProgress, renderLanes1) {
        var updateLanes = workInProgress.lanes;
        if (workInProgress._debugNeedsRemount && current4 !== null) // This will restart the begin phase with a new fiber.
        return remountFiber(current4, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));
        if (current4 !== null) {
            var oldProps = current4.memoizedProps;
            var newProps = workInProgress.pendingProps;
            if (oldProps !== newProps || hasContextChanged() || workInProgress.type !== current4.type) // If props or context changed, mark the fiber as having performed work.
            // This may be unset if the props are determined to be equal later (memo).
            didReceiveUpdate = true;
            else if (!includesSomeLane(renderLanes1, updateLanes)) {
                didReceiveUpdate = false; // This fiber does not have any pending work. Bailout without entering
                // the begin phase. There's still some bookkeeping we that needs to be done
                // in this optimized path, mostly pushing stuff onto the stack.
                switch(workInProgress.tag){
                    case HostRoot:
                        pushHostRootContext(workInProgress);
                        resetHydrationState();
                        break;
                    case HostComponent:
                        pushHostContext(workInProgress);
                        break;
                    case ClassComponent:
                        var Component = workInProgress.type;
                        if (isContextProvider(Component)) pushContextProvider(workInProgress);
                        break;
                    case HostPortal:
                        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                        break;
                    case ContextProvider:
                        var newValue = workInProgress.memoizedProps.value;
                        pushProvider(workInProgress, newValue);
                        break;
                    case Profiler:
                        // Profiler should only call onRender when one of its descendants actually rendered.
                        var hasChildWork = includesSomeLane(renderLanes1, workInProgress.childLanes);
                        if (hasChildWork) workInProgress.flags |= Update;
                         // Reset effect durations for the next eventual effect phase.
                        // These are reset during render to allow the DevTools commit hook a chance to read them,
                        var stateNode = workInProgress.stateNode;
                        stateNode.effectDuration = 0;
                        stateNode.passiveEffectDuration = 0;
                        break;
                    case SuspenseComponent:
                        var state = workInProgress.memoizedState;
                        if (state !== null) {
                            // whether to retry the primary children, or to skip over it and
                            // go straight to the fallback. Check the priority of the primary
                            // child fragment.
                            var primaryChildFragment = workInProgress.child;
                            var primaryChildLanes = primaryChildFragment.childLanes;
                            if (includesSomeLane(renderLanes1, primaryChildLanes)) // The primary children have pending work. Use the normal path
                            // to attempt to render the primary children again.
                            return updateSuspenseComponent(current4, workInProgress, renderLanes1);
                            else {
                                // The primary child fragment does not have pending work marked
                                // on it
                                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient
                                // priority. Bailout.
                                var child = bailoutOnAlreadyFinishedWork(current4, workInProgress, renderLanes1);
                                if (child !== null) // The fallback children have pending work. Skip over the
                                // primary children and work on the fallback.
                                return child.sibling;
                                else return null;
                            }
                        } else pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                        break;
                    case SuspenseListComponent:
                        var didSuspendBefore = (current4.flags & DidCapture) !== NoFlags;
                        var _hasChildWork = includesSomeLane(renderLanes1, workInProgress.childLanes);
                        if (didSuspendBefore) {
                            if (_hasChildWork) // If something was in fallback state last time, and we have all the
                            // same children then we're still in progressive loading state.
                            // Something might get unblocked by state updates or retries in the
                            // tree which will affect the tail. So we need to use the normal
                            // path to compute the correct tail.
                            return updateSuspenseListComponent(current4, workInProgress, renderLanes1);
                             // If none of the children had any work, that means that none of
                            // them got retried so they'll still be blocked in the same way
                            // as before. We can fast bail out.
                            workInProgress.flags |= DidCapture;
                        } // If nothing suspended before and we're rendering the same children,
                        // then the tail doesn't matter. Anything new that suspends will work
                        // in the "together" mode, so we can continue from the state we had.
                        var renderState = workInProgress.memoizedState;
                        if (renderState !== null) {
                            // Reset to the "together" mode in case we've started a different
                            // update in the past but didn't complete it.
                            renderState.rendering = null;
                            renderState.tail = null;
                            renderState.lastEffect = null;
                        }
                        pushSuspenseContext(workInProgress, suspenseStackCursor.current);
                        if (_hasChildWork) break;
                        else // If none of the children had any work, that means that none of
                        // them got retried so they'll still be blocked in the same way
                        // as before. We can fast bail out.
                        return null;
                    case OffscreenComponent:
                    case LegacyHiddenComponent:
                        // Need to check if the tree still needs to be deferred. This is
                        // almost identical to the logic used in the normal update path,
                        // so we'll just enter that. The only difference is we'll bail out
                        // at the next level instead of this one, because the child props
                        // have not changed. Which is fine.
                        // TODO: Probably should refactor `beginWork` to split the bailout
                        // path from the normal path. I'm tempted to do a labeled break here
                        // but I won't :)
                        workInProgress.lanes = NoLanes;
                        return updateOffscreenComponent(current4, workInProgress, renderLanes1);
                }
                return bailoutOnAlreadyFinishedWork(current4, workInProgress, renderLanes1);
            } else if ((current4.flags & ForceUpdateForLegacySuspense) !== NoFlags) // This is a special case that only exists for legacy mode.
            // See https://github.com/facebook/react/pull/19216.
            didReceiveUpdate = true;
            else // An update was scheduled on this fiber, but there are no new props
            // nor legacy context. Set this to false. If an update queue or context
            // consumer produces a changed value, it will set this to true. Otherwise,
            // the component will assume the children have not changed and bail out.
            didReceiveUpdate = false;
        } else didReceiveUpdate = false;
         // Before entering the begin phase, clear pending update priority.
        // TODO: This assumes that we're about to evaluate the component and process
        // the update queue. However, there's an exception: SimpleMemoComponent
        // sometimes bails out later in the begin phase. This indicates that we should
        // move this assignment out of the common path and into each branch.
        workInProgress.lanes = NoLanes;
        switch(workInProgress.tag){
            case IndeterminateComponent:
                return mountIndeterminateComponent(current4, workInProgress, workInProgress.type, renderLanes1);
            case LazyComponent:
                var elementType = workInProgress.elementType;
                return mountLazyComponent(current4, workInProgress, elementType, updateLanes, renderLanes1);
            case FunctionComponent:
                var _Component = workInProgress.type;
                var unresolvedProps = workInProgress.pendingProps;
                var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
                return updateFunctionComponent(current4, workInProgress, _Component, resolvedProps, renderLanes1);
            case ClassComponent:
                var _Component2 = workInProgress.type;
                var _unresolvedProps = workInProgress.pendingProps;
                var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);
                return updateClassComponent(current4, workInProgress, _Component2, _resolvedProps, renderLanes1);
            case HostRoot:
                return updateHostRoot(current4, workInProgress, renderLanes1);
            case HostComponent:
                return updateHostComponent(current4, workInProgress, renderLanes1);
            case HostText:
                return updateHostText(current4, workInProgress);
            case SuspenseComponent:
                return updateSuspenseComponent(current4, workInProgress, renderLanes1);
            case HostPortal:
                return updatePortalComponent(current4, workInProgress, renderLanes1);
            case ForwardRef:
                var type = workInProgress.type;
                var _unresolvedProps2 = workInProgress.pendingProps;
                var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current4, workInProgress, type, _resolvedProps2, renderLanes1);
            case Fragment:
                return updateFragment(current4, workInProgress, renderLanes1);
            case Mode:
                return updateMode(current4, workInProgress, renderLanes1);
            case Profiler:
                return updateProfiler(current4, workInProgress, renderLanes1);
            case ContextProvider:
                return updateContextProvider(current4, workInProgress, renderLanes1);
            case ContextConsumer:
                return updateContextConsumer(current4, workInProgress, renderLanes1);
            case MemoComponent:
                var _type2 = workInProgress.type;
                var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                if (workInProgress.type !== workInProgress.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) checkPropTypes(outerPropTypes, _resolvedProps3, 'prop', getComponentName(_type2));
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current4, workInProgress, _type2, _resolvedProps3, updateLanes, renderLanes1);
            case SimpleMemoComponent:
                return updateSimpleMemoComponent(current4, workInProgress, workInProgress.type, workInProgress.pendingProps, updateLanes, renderLanes1);
            case IncompleteClassComponent:
                var _Component3 = workInProgress.type;
                var _unresolvedProps4 = workInProgress.pendingProps;
                var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);
                return mountIncompleteClassComponent(current4, workInProgress, _Component3, _resolvedProps4, renderLanes1);
            case SuspenseListComponent:
                return updateSuspenseListComponent(current4, workInProgress, renderLanes1);
            case FundamentalComponent:
                break;
            case ScopeComponent:
                break;
            case Block:
                break;
            case OffscreenComponent:
                return updateOffscreenComponent(current4, workInProgress, renderLanes1);
            case LegacyHiddenComponent:
                return updateLegacyHiddenComponent(current4, workInProgress, renderLanes1);
        }
        throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function markUpdate(workInProgress) {
        // Tag the fiber with an update effect. This turns a Placement into
        // a PlacementAndUpdate.
        workInProgress.flags |= Update;
    }
    function markRef$1(workInProgress) {
        workInProgress.flags |= Ref;
    }
    var appendAllChildren;
    var updateHostContainer;
    var updateHostComponent$1;
    var updateHostText$1;
    // Mutation mode
    appendAllChildren = function(parent, workInProgress, needsVisibilityToggle, isHidden) {
        // We only have the top Fiber that was created but we need recurse down its
        // children to find all the terminal nodes.
        var node = workInProgress.child;
        while(node !== null){
            if (node.tag === HostComponent || node.tag === HostText) appendInitialChild(parent, node.stateNode);
            else if (node.tag === HostPortal) ;
            else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === workInProgress) return;
            while(node.sibling === null){
                if (node.return === null || node.return === workInProgress) return;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    };
    updateHostContainer = function(workInProgress) {
    };
    updateHostComponent$1 = function(current4, workInProgress, type, newProps, rootContainerInstance) {
        // If we have an alternate, that means this is an update and we need to
        // schedule a side-effect to do the updates.
        var oldProps = current4.memoizedProps;
        if (oldProps === newProps) // In mutation mode, this is sufficient for a bailout because
        // we won't touch this node even if children changed.
        return;
         // If we get updated because one of our children updated, we don't
        // have newProps so we'll have to reuse them.
        // TODO: Split the update API as separate for the props vs. children.
        // Even better would be if children weren't special cased at all tho.
        var instance = workInProgress.stateNode;
        var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host
        // component is hitting the resume path. Figure out why. Possibly
        // related to `hidden`.
        var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.
        workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
        // is a new ref we mark this as an update. All the work is done in commitWork.
        if (updatePayload) markUpdate(workInProgress);
    };
    updateHostText$1 = function(current4, workInProgress, oldText, newText) {
        // If the text differs, mark it as an update. All the work in done in commitWork.
        if (oldText !== newText) markUpdate(workInProgress);
    };
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (getIsHydrating()) // If we're hydrating, we should consume as many items as we can
        // so we don't leave any behind.
        return;
        switch(renderState.tailMode){
            case 'hidden':
                // Any insertions at the end of the tail list after this point
                // should be invisible. If there are already mounted boundaries
                // anything before them are not considered for collapsing.
                // Therefore we need to go through the whole tail to find if
                // there are any.
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while(tailNode !== null){
                    if (tailNode.alternate !== null) lastTailNode = tailNode;
                    tailNode = tailNode.sibling;
                } // Next we're simply going to delete all insertions after the
                // last rendered item.
                if (lastTailNode === null) // All remaining items in the tail are insertions.
                renderState.tail = null;
                else // Detach the insertion after the last node that was already
                // inserted.
                lastTailNode.sibling = null;
                break;
            case 'collapsed':
                // Any insertions at the end of the tail list after this point
                // should be invisible. If there are already mounted boundaries
                // anything before them are not considered for collapsing.
                // Therefore we need to go through the whole tail to find if
                // there are any.
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while(_tailNode !== null){
                    if (_tailNode.alternate !== null) _lastTailNode = _tailNode;
                    _tailNode = _tailNode.sibling;
                } // Next we're simply going to delete all insertions after the
                // last rendered item.
                if (_lastTailNode === null) {
                    // All remaining items in the tail are insertions.
                    if (!hasRenderedATailFallback && renderState.tail !== null) // We suspended during the head. We want to show at least one
                    // row at the tail. So we'll keep on and cut off the rest.
                    renderState.tail.sibling = null;
                    else renderState.tail = null;
                } else // Detach the insertion after the last node that was already
                // inserted.
                _lastTailNode.sibling = null;
                break;
        }
    }
    function completeWork(current4, workInProgress, renderLanes1) {
        var newProps = workInProgress.pendingProps;
        switch(workInProgress.tag){
            case IndeterminateComponent:
            case LazyComponent:
            case SimpleMemoComponent:
            case FunctionComponent:
            case ForwardRef:
            case Fragment:
            case Mode:
            case Profiler:
            case ContextConsumer:
            case MemoComponent:
                return null;
            case ClassComponent:
                var Component = workInProgress.type;
                if (isContextProvider(Component)) popContext(workInProgress);
                return null;
            case HostRoot:
                popHostContainer(workInProgress);
                popTopLevelContextObject(workInProgress);
                resetWorkInProgressVersions();
                var fiberRoot = workInProgress.stateNode;
                if (fiberRoot.pendingContext) {
                    fiberRoot.context = fiberRoot.pendingContext;
                    fiberRoot.pendingContext = null;
                }
                if (current4 === null || current4.child === null) {
                    // If we hydrated, pop so that we can delete any remaining children
                    // that weren't hydrated.
                    var wasHydrated = popHydrationState(workInProgress);
                    if (wasHydrated) // If we hydrated, then we'll need to schedule an update for
                    // the commit side-effects on the root.
                    markUpdate(workInProgress);
                    else if (!fiberRoot.hydrate) // Schedule an effect to clear this container at the start of the next commit.
                    // This handles the case of React rendering into a container with previous children.
                    // It's also safe to do for updates too, because current.child would only be null
                    // if the previous render was null (so the the container would already be empty).
                    workInProgress.flags |= Snapshot;
                }
                updateHostContainer(workInProgress);
                return null;
            case HostComponent:
                popHostContext(workInProgress);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress.type;
                if (current4 !== null && workInProgress.stateNode != null) {
                    updateHostComponent$1(current4, workInProgress, type, newProps, rootContainerInstance);
                    if (current4.ref !== workInProgress.ref) markRef$1(workInProgress);
                } else {
                    if (!newProps) {
                        if (!(workInProgress.stateNode !== null)) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                         // This can happen when we abort work.
                        return null;
                    }
                    var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context
                    // "stack" as the parent. Then append children as we go in beginWork
                    // or completeWork depending on whether we want to add them top->down or
                    // bottom->up. Top->down is faster in IE11.
                    var _wasHydrated = popHydrationState(workInProgress);
                    if (_wasHydrated) // TODO: Move this and createInstance step into the beginPhase
                    // to consolidate.
                    {
                        if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) // If changes to the hydrated node need to be applied at the
                        // commit-phase we mark this as such.
                        markUpdate(workInProgress);
                    } else {
                        var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);
                        appendAllChildren(instance, workInProgress, false, false);
                        workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.
                        // (eg DOM renderer supports auto-focus for certain elements).
                        // Make sure such renderers get scheduled for later work.
                        if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) markUpdate(workInProgress);
                    }
                    if (workInProgress.ref !== null) // If there is a ref on a host node we need to schedule a callback
                    markRef$1(workInProgress);
                }
                return null;
            case HostText:
                var newText = newProps;
                if (current4 && workInProgress.stateNode != null) {
                    var oldText = current4.memoizedProps; // If we have an alternate, that means this is an update and we need
                    // to schedule a side-effect to do the updates.
                    updateHostText$1(current4, workInProgress, oldText, newText);
                } else {
                    if (typeof newText !== 'string') {
                        if (!(workInProgress.stateNode !== null)) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                         // This can happen when we abort work.
                    }
                    var _rootContainerInstance = getRootHostContainer();
                    var _currentHostContext = getHostContext();
                    var _wasHydrated2 = popHydrationState(workInProgress);
                    if (_wasHydrated2) {
                        if (prepareToHydrateHostTextInstance(workInProgress)) markUpdate(workInProgress);
                    } else workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
                }
                return null;
            case SuspenseComponent:
                popSuspenseContext(workInProgress);
                var nextState = workInProgress.memoizedState;
                if ((workInProgress.flags & DidCapture) !== NoFlags) {
                    // Something suspended. Re-render with the fallback children.
                    workInProgress.lanes = renderLanes1; // Do not reset the effect list.
                    if ((workInProgress.mode & ProfileMode) !== NoMode) transferActualDuration(workInProgress);
                    return workInProgress;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = false;
                if (current4 === null) {
                    if (workInProgress.memoizedProps.fallback !== undefined) popHydrationState(workInProgress);
                } else {
                    var prevState = current4.memoizedState;
                    prevDidTimeout = prevState !== null;
                }
                if (nextDidTimeout && !prevDidTimeout) // If this subtreee is running in blocking mode we can suspend,
                // otherwise we won't suspend.
                // TODO: This will still suspend a synchronous tree if anything
                // in the concurrent tree already suspended during this render.
                // This is a known bug.
                {
                    if ((workInProgress.mode & BlockingMode) !== NoMode) {
                        // TODO: Move this back to throwException because this is too late
                        // if this is a large tree which is common for initial loads. We
                        // don't know if we should restart a render or not until we get
                        // this marker, and this is too late.
                        // If this render already had a ping or lower pri updates,
                        // and this is the first time we know we're going to suspend we
                        // should be able to immediately restart from within throwException.
                        var hasInvisibleChildContext = current4 === null && workInProgress.memoizedProps.unstable_avoidThisFallback !== true;
                        if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) // If this was in an invisible tree or a new render, then showing
                        // this boundary is ok.
                        renderDidSuspend();
                        else // Otherwise, we're going to have to hide content so we should
                        // suspend for longer if possible.
                        renderDidSuspendDelayIfPossible();
                    }
                }
                // TODO: Only schedule updates if these values are non equal, i.e. it changed.
                if (nextDidTimeout || prevDidTimeout) // If this boundary just timed out, schedule an effect to attach a
                // retry listener to the promise. This flag is also used to hide the
                // primary children. In mutation mode, we also need the flag to
                // *unhide* children that were previously hidden, so check if this
                // is currently timed out, too.
                workInProgress.flags |= Update;
                return null;
            case HostPortal:
                popHostContainer(workInProgress);
                updateHostContainer(workInProgress);
                if (current4 === null) preparePortalMount(workInProgress.stateNode.containerInfo);
                return null;
            case ContextProvider:
                // Pop provider fiber
                popProvider(workInProgress);
                return null;
            case IncompleteClassComponent:
                // Same as class component case. I put it down here so that the tags are
                // sequential to ensure this switch is compiled to a jump table.
                var _Component = workInProgress.type;
                if (isContextProvider(_Component)) popContext(workInProgress);
                return null;
            case SuspenseListComponent:
                popSuspenseContext(workInProgress);
                var renderState = workInProgress.memoizedState;
                if (renderState === null) // We're running in the default, "independent" mode.
                // We don't do anything in this mode.
                return null;
                var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                    // We just rendered the head.
                    if (!didSuspendAlready) {
                        // This is the first pass. We need to figure out if anything is still
                        // suspended in the rendered set.
                        // If new content unsuspended, but there's still some content that
                        // didn't. Then we need to do a second pass that forces everything
                        // to keep showing their fallbacks.
                        // We might be suspended if something in this render pass suspended, or
                        // something in the previous committed pass suspended. Otherwise,
                        // there's no chance so we can skip the expensive call to
                        // findFirstSuspended.
                        var cannotBeSuspended = renderHasNotSuspendedYet() && (current4 === null || (current4.flags & DidCapture) === NoFlags);
                        if (!cannotBeSuspended) {
                            var row = workInProgress.child;
                            while(row !== null){
                                var suspended = findFirstSuspended(row);
                                if (suspended !== null) {
                                    didSuspendAlready = true;
                                    workInProgress.flags |= DidCapture;
                                    cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as
                                    // part of the second pass. In that case nothing will subscribe to
                                    // its thennables. Instead, we'll transfer its thennables to the
                                    // SuspenseList so that it can retry if they resolve.
                                    // There might be multiple of these in the list but since we're
                                    // going to wait for all of them anyway, it doesn't really matter
                                    // which ones gets to ping. In theory we could get clever and keep
                                    // track of how many dependencies remain but it gets tricky because
                                    // in the meantime, we can add/remove/change items and dependencies.
                                    // We might bail out of the loop before finding any but that
                                    // doesn't matter since that means that the other boundaries that
                                    // we did find already has their listeners attached.
                                    var newThennables = suspended.updateQueue;
                                    if (newThennables !== null) {
                                        workInProgress.updateQueue = newThennables;
                                        workInProgress.flags |= Update;
                                    } // Rerender the whole list, but this time, we'll force fallbacks
                                    // to stay in place.
                                    // Reset the effect list before doing the second pass since that's now invalid.
                                    if (renderState.lastEffect === null) workInProgress.firstEffect = null;
                                    workInProgress.lastEffect = renderState.lastEffect; // Reset the child fibers to their original state.
                                    resetChildFibers(workInProgress, renderLanes1); // Set up the Suspense Context to force suspense and immediately
                                    // rerender the children.
                                    pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                                    return workInProgress.child;
                                }
                                row = row.sibling;
                            }
                        }
                        if (renderState.tail !== null && now() > getRenderTargetTime()) {
                            // We have already passed our CPU deadline but we still have rows
                            // left in the tail. We'll just give up further attempts to render
                            // the main content and only render fallbacks.
                            workInProgress.flags |= DidCapture;
                            didSuspendAlready = true;
                            cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
                            // to get it started back up to attempt the next item. While in terms
                            // of priority this work has the same priority as this current render,
                            // it's not part of the same transition once the transition has
                            // committed. If it's sync, we still want to yield so that it can be
                            // painted. Conceptually, this is really the same as pinging.
                            // We can use any RetryLane even if it's the one currently rendering
                            // since we're leaving it behind on this node.
                            workInProgress.lanes = SomeRetryLane;
                            markSpawnedWork(SomeRetryLane);
                        }
                    } else cutOffTailIfNeeded(renderState, false);
                     // Next we're going to render the tail.
                } else {
                    // Append the rendered row to the child list.
                    if (!didSuspendAlready) {
                        var _suspended = findFirstSuspended(renderedTail);
                        if (_suspended !== null) {
                            workInProgress.flags |= DidCapture;
                            didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't
                            // get lost if this row ends up dropped during a second pass.
                            var _newThennables = _suspended.updateQueue;
                            if (_newThennables !== null) {
                                workInProgress.updateQueue = _newThennables;
                                workInProgress.flags |= Update;
                            }
                            cutOffTailIfNeeded(renderState, true); // This might have been modified.
                            if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.
                            ) {
                                // We need to delete the row we just rendered.
                                // Reset the effect list to what it was before we rendered this
                                // child. The nested children have already appended themselves.
                                var lastEffect = workInProgress.lastEffect = renderState.lastEffect; // Remove any effects that were appended after this point.
                                if (lastEffect !== null) lastEffect.nextEffect = null;
                                 // We're done.
                                return null;
                            }
                        } else if (// time we have to render. So rendering one more row would likely
                        // exceed it.
                        now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes1 !== OffscreenLane) {
                            // We have now passed our CPU deadline and we'll just give up further
                            // attempts to render the main content and only render fallbacks.
                            // The assumption is that this is usually faster.
                            workInProgress.flags |= DidCapture;
                            didSuspendAlready = true;
                            cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
                            // to get it started back up to attempt the next item. While in terms
                            // of priority this work has the same priority as this current render,
                            // it's not part of the same transition once the transition has
                            // committed. If it's sync, we still want to yield so that it can be
                            // painted. Conceptually, this is really the same as pinging.
                            // We can use any RetryLane even if it's the one currently rendering
                            // since we're leaving it behind on this node.
                            workInProgress.lanes = SomeRetryLane;
                            markSpawnedWork(SomeRetryLane);
                        }
                    }
                    if (renderState.isBackwards) {
                        // The effect list of the backwards tail will have been added
                        // to the end. This breaks the guarantee that life-cycles fire in
                        // sibling order but that isn't a strong guarantee promised by React.
                        // Especially since these might also just pop in during future commits.
                        // Append to the beginning of the list.
                        renderedTail.sibling = workInProgress.child;
                        workInProgress.child = renderedTail;
                    } else {
                        var previousSibling = renderState.last;
                        if (previousSibling !== null) previousSibling.sibling = renderedTail;
                        else workInProgress.child = renderedTail;
                        renderState.last = renderedTail;
                    }
                }
                if (renderState.tail !== null) {
                    // We still have tail rows to render.
                    // Pop a row.
                    var next = renderState.tail;
                    renderState.rendering = next;
                    renderState.tail = next.sibling;
                    renderState.lastEffect = workInProgress.lastEffect;
                    renderState.renderingStartTime = now();
                    next.sibling = null; // Restore the context.
                    // TODO: We can probably just avoid popping it instead and only
                    // setting it the first time we go from not suspended to suspended.
                    var suspenseContext = suspenseStackCursor.current;
                    if (didSuspendAlready) suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                    else suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                    pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.
                    return next;
                }
                return null;
            case FundamentalComponent:
                break;
            case ScopeComponent:
                break;
            case Block:
                break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
                popRenderLanes(workInProgress);
                if (current4 !== null) {
                    var _nextState = workInProgress.memoizedState;
                    var _prevState = current4.memoizedState;
                    var prevIsHidden = _prevState !== null;
                    var nextIsHidden = _nextState !== null;
                    if (prevIsHidden !== nextIsHidden && newProps.mode !== 'unstable-defer-without-hiding') workInProgress.flags |= Update;
                }
                return null;
        }
        throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function unwindWork(workInProgress, renderLanes1) {
        switch(workInProgress.tag){
            case ClassComponent:
                var Component = workInProgress.type;
                if (isContextProvider(Component)) popContext(workInProgress);
                var flags = workInProgress.flags;
                if (flags & ShouldCapture) {
                    workInProgress.flags = flags & ~ShouldCapture | DidCapture;
                    if ((workInProgress.mode & ProfileMode) !== NoMode) transferActualDuration(workInProgress);
                    return workInProgress;
                }
                return null;
            case HostRoot:
                popHostContainer(workInProgress);
                popTopLevelContextObject(workInProgress);
                resetWorkInProgressVersions();
                var _flags = workInProgress.flags;
                if (!((_flags & DidCapture) === NoFlags)) throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");
                workInProgress.flags = _flags & ~ShouldCapture | DidCapture;
                return workInProgress;
            case HostComponent:
                // TODO: popHydrationState
                popHostContext(workInProgress);
                return null;
            case SuspenseComponent:
                popSuspenseContext(workInProgress);
                var _flags2 = workInProgress.flags;
                if (_flags2 & ShouldCapture) {
                    workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.
                    if ((workInProgress.mode & ProfileMode) !== NoMode) transferActualDuration(workInProgress);
                    return workInProgress;
                }
                return null;
            case SuspenseListComponent:
                popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been
                // caught by a nested boundary. If not, it should bubble through.
                return null;
            case HostPortal:
                popHostContainer(workInProgress);
                return null;
            case ContextProvider:
                popProvider(workInProgress);
                return null;
            case OffscreenComponent:
            case LegacyHiddenComponent:
                popRenderLanes(workInProgress);
                return null;
            default:
                return null;
        }
    }
    function unwindInterruptedWork(interruptedWork) {
        switch(interruptedWork.tag){
            case ClassComponent:
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== undefined) popContext(interruptedWork);
                break;
            case HostRoot:
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
            case HostComponent:
                popHostContext(interruptedWork);
                break;
            case HostPortal:
                popHostContainer(interruptedWork);
                break;
            case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
            case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
            case ContextProvider:
                popProvider(interruptedWork);
                break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
        }
    }
    function createCapturedValue(value, source) {
        // If the value is an error, call this function immediately after it is thrown
        // so the stack is accurate.
        return {
            value: value,
            source: source,
            stack: getStackByFiberInDevAndProd(source)
        };
    }
    // This module is forked in different environments.
    // By default, return `true` to log errors to the console.
    // Forks can return `false` if this isn't desirable.
    function showErrorDialog(boundary, errorInfo) {
        return true;
    }
    function logCapturedError(boundary, errorInfo) {
        try {
            var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.
            // This enables renderers like ReactNative to better manage redbox behavior.
            if (logError === false) return;
            var error4 = errorInfo.value;
            var source = errorInfo.source;
            var stack = errorInfo.stack;
            var componentStack = stack !== null ? stack : ''; // Browsers support silencing uncaught errors by calling
            // `preventDefault()` in window `error` handler.
            // We record this information as an expando on the error.
            if (error4 != null && error4._suppressLogging) {
                if (boundary.tag === ClassComponent) // The error is recoverable and was silenced.
                // Ignore it and don't print the stack addendum.
                // This is handy for testing error boundaries without noise.
                return;
                 // The error is fatal. Since the silencing might have
                // been accidental, we'll surface it anyway.
                // However, the browser would have silenced the original error
                // so we'll print it first, and then print the stack addendum.
                console['error'](error4); // Don't transform to our wrapper
            // For a more detailed description of this block, see:
            // https://github.com/facebook/react/pull/13384
            }
            var componentName = source ? getComponentName(source.type) : null;
            var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : 'The above error occurred in one of your React components:';
            var errorBoundaryMessage;
            var errorBoundaryName = getComponentName(boundary.type);
            if (errorBoundaryName) errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
            else errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
            var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
            // We don't include the original error message and JS stack because the browser
            // has already printed it. Even if the application swallows the error, it is still
            // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
            console['error'](combinedMessage); // Don't transform to our wrapper
        } catch (e) {
            // This method must not throw, or React internal state will get messed up.
            // If console.error is overridden, or logCapturedError() shows a dialog that throws,
            // we want to report this error outside of the normal stack as a last resort.
            // https://github.com/facebook/react/issues/13188
            setTimeout(function() {
                throw e;
            });
        }
    }
    var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;
    function createRootErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.
        update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property
        // being called "element".
        update.payload = {
            element: null
        };
        var error4 = errorInfo.value;
        update.callback = function() {
            onUncaughtError(error4);
            logCapturedError(fiber, errorInfo);
        };
        return update;
    }
    function createClassErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate;
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if (typeof getDerivedStateFromError === 'function') {
            var error$1 = errorInfo.value;
            update.payload = function() {
                logCapturedError(fiber, errorInfo);
                return getDerivedStateFromError(error$1);
            };
        }
        var inst = fiber.stateNode;
        if (inst !== null && typeof inst.componentDidCatch === 'function') update.callback = function callback() {
            markFailedErrorBoundaryForHotReloading(fiber);
            if (typeof getDerivedStateFromError !== 'function') {
                // To preserve the preexisting retry behavior of error boundaries,
                // we keep track of which ones already failed during this batch.
                // This gets reset before we yield back to the browser.
                // TODO: Warn in strict mode if getDerivedStateFromError is
                // not defined.
                markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined
                logCapturedError(fiber, errorInfo);
            }
            var error$1 = errorInfo.value;
            var stack = errorInfo.stack;
            this.componentDidCatch(error$1, {
                componentStack: stack !== null ? stack : ''
            });
            if (typeof getDerivedStateFromError !== 'function') // If componentDidCatch is the only error boundary method defined,
            // then it needs to call setState to recover from errors.
            // If no state update is scheduled then the boundary will swallow the error.
            {
                if (!includesSomeLane(fiber.lanes, SyncLane)) error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || 'Unknown');
            }
        };
        else update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
        };
        return update;
    }
    function attachPingListener(root1, wakeable, lanes) {
        // Attach a listener to the promise to "ping" the root and retry. But only if
        // one does not already exist for the lanes we're currently rendering (which
        // acts like a "thread ID" here).
        var pingCache = root1.pingCache;
        var threadIDs;
        if (pingCache === null) {
            pingCache = root1.pingCache = new PossiblyWeakMap$1();
            threadIDs = new Set();
            pingCache.set(wakeable, threadIDs);
        } else {
            threadIDs = pingCache.get(wakeable);
            if (threadIDs === undefined) {
                threadIDs = new Set();
                pingCache.set(wakeable, threadIDs);
            }
        }
        if (!threadIDs.has(lanes)) {
            // Memoize using the thread ID to prevent redundant listeners.
            threadIDs.add(lanes);
            var ping = pingSuspendedRoot.bind(null, root1, wakeable, lanes);
            wakeable.then(ping, ping);
        }
    }
    function throwException(root1, returnFiber, sourceFiber, value, rootRenderLanes) {
        // The source fiber did not complete.
        sourceFiber.flags |= Incomplete; // Its effect list is no longer valid.
        sourceFiber.firstEffect = sourceFiber.lastEffect = null;
        if (value !== null && typeof value === 'object' && typeof value.then === 'function') {
            // This is a wakeable.
            var wakeable = value;
            if ((sourceFiber.mode & BlockingMode) === NoMode) {
                // Reset the memoizedState to what it was before we attempted
                // to render it.
                var currentSource = sourceFiber.alternate;
                if (currentSource) {
                    sourceFiber.updateQueue = currentSource.updateQueue;
                    sourceFiber.memoizedState = currentSource.memoizedState;
                    sourceFiber.lanes = currentSource.lanes;
                } else {
                    sourceFiber.updateQueue = null;
                    sourceFiber.memoizedState = null;
                }
            }
            var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext); // Schedule the nearest Suspense to re-render the timed out view.
            var _workInProgress = returnFiber;
            do {
                if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
                    // Found the nearest boundary.
                    // Stash the promise on the boundary fiber. If the boundary times out, we'll
                    // attach another listener to flip the boundary back to its normal state.
                    var wakeables = _workInProgress.updateQueue;
                    if (wakeables === null) {
                        var updateQueue = new Set();
                        updateQueue.add(wakeable);
                        _workInProgress.updateQueue = updateQueue;
                    } else wakeables.add(wakeable);
                     // If the boundary is outside of blocking mode, we should *not*
                    // suspend the commit. Pretend as if the suspended component rendered
                    // null and keep rendering. In the commit phase, we'll schedule a
                    // subsequent synchronous update to re-render the Suspense.
                    //
                    // Note: It doesn't matter whether the component that suspended was
                    // inside a blocking mode tree. If the Suspense is outside of it, we
                    // should *not* suspend the commit.
                    if ((_workInProgress.mode & BlockingMode) === NoMode) {
                        _workInProgress.flags |= DidCapture;
                        sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.
                        // But we shouldn't call any lifecycle methods or callbacks. Remove
                        // all lifecycle effect tags.
                        sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                        if (sourceFiber.tag === ClassComponent) {
                            var currentSourceFiber = sourceFiber.alternate;
                            if (currentSourceFiber === null) // This is a new mount. Change the tag so it's not mistaken for a
                            // completed class component. For example, we should not call
                            // componentWillUnmount if it is deleted.
                            sourceFiber.tag = IncompleteClassComponent;
                            else {
                                // When we try rendering again, we should not reuse the current fiber,
                                // since it's known to be in an inconsistent state. Use a force update to
                                // prevent a bail out.
                                var update = createUpdate(NoTimestamp, SyncLane);
                                update.tag = ForceUpdate;
                                enqueueUpdate(sourceFiber, update);
                            }
                        } // The source fiber did not complete. Mark it with Sync priority to
                        // indicate that it still has pending work.
                        sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane); // Exit without suspending.
                        return;
                    } // Confirmed that the boundary is in a concurrent mode tree. Continue
                    // with the normal suspend path.
                    //
                    // After this we'll use a set of heuristics to determine whether this
                    // render pass will run to completion or restart or "suspend" the commit.
                    // The actual logic for this is spread out in different places.
                    //
                    // This first principle is that if we're going to suspend when we complete
                    // a root, then we should also restart if we get an update or ping that
                    // might unsuspend it, and vice versa. The only reason to suspend is
                    // because you think you might want to restart before committing. However,
                    // it doesn't make sense to restart only while in the period we're suspended.
                    //
                    // Restarting too aggressively is also not good because it starves out any
                    // intermediate loading state. So we use heuristics to determine when.
                    // Suspense Heuristics
                    //
                    // If nothing threw a Promise or all the same fallbacks are already showing,
                    // then don't suspend/restart.
                    //
                    // If this is an initial render of a new tree of Suspense boundaries and
                    // those trigger a fallback, then don't suspend/restart. We want to ensure
                    // that we can show the initial loading state as quickly as possible.
                    //
                    // If we hit a "Delayed" case, such as when we'd switch from content back into
                    // a fallback, then we should always suspend/restart. Transitions apply
                    // to this case. If none is defined, JND is used instead.
                    //
                    // If we're already showing a fallback and it gets "retried", allowing us to show
                    // another level, but there's still an inner boundary that would show a fallback,
                    // then we suspend/restart for 500ms since the last time we showed a fallback
                    // anywhere in the tree. This effectively throttles progressive loading into a
                    // consistent train of commits. This also gives us an opportunity to restart to
                    // get to the completed state slightly earlier.
                    //
                    // If there's ambiguity due to batching it's resolved in preference of:
                    // 1) "delayed", 2) "initial render", 3) "retry".
                    //
                    // We want to ensure that a "busy" state doesn't get force committed. We want to
                    // ensure that new initial loading states can commit as soon as possible.
                    attachPingListener(root1, wakeable, rootRenderLanes);
                    _workInProgress.flags |= ShouldCapture;
                    _workInProgress.lanes = rootRenderLanes;
                    return;
                } // This boundary already captured during this render. Continue to the next
                // boundary.
                _workInProgress = _workInProgress.return;
            }while (_workInProgress !== null) // No boundary was found. Fallthrough to error mode.
            // TODO: Use invariant so the message is stripped in prod?
            value = new Error((getComponentName(sourceFiber.type) || 'A React component') + ' suspended while rendering, but no fallback UI was specified.\n' + '\n' + 'Add a <Suspense fallback=...> component higher in the tree to ' + 'provide a loading indicator or placeholder to display.');
        } // We didn't find a boundary that could handle this type of exception. Start
        // over and traverse parent path again, this time treating the exception
        // as an error.
        renderDidError();
        value = createCapturedValue(value, sourceFiber);
        var workInProgress = returnFiber;
        do {
            switch(workInProgress.tag){
                case HostRoot:
                    var _errorInfo = value;
                    workInProgress.flags |= ShouldCapture;
                    var lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);
                    var _update = createRootErrorUpdate(workInProgress, _errorInfo, lane);
                    enqueueCapturedUpdate(workInProgress, _update);
                    return;
                case ClassComponent:
                    // Capture and retry
                    var errorInfo = value;
                    var ctor = workInProgress.type;
                    var instance = workInProgress.stateNode;
                    if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                        workInProgress.flags |= ShouldCapture;
                        var _lane = pickArbitraryLane(rootRenderLanes);
                        workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state
                        var _update2 = createClassErrorUpdate(workInProgress, errorInfo, _lane);
                        enqueueCapturedUpdate(workInProgress, _update2);
                        return;
                    }
                    break;
            }
            workInProgress = workInProgress.return;
        }while (workInProgress !== null)
    }
    var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
    var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;
    var callComponentWillUnmountWithTimer = function(current4, instance) {
        instance.props = current4.memoizedProps;
        instance.state = current4.memoizedState;
        instance.componentWillUnmount();
    }; // Capture errors so they don't interrupt unmounting.
    function safelyCallComponentWillUnmount(current4, instance) {
        invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current4, instance);
        if (hasCaughtError()) {
            var unmountError = clearCaughtError();
            captureCommitPhaseError(current4, unmountError);
        }
    }
    function safelyDetachRef(current4) {
        var ref = current4.ref;
        if (ref !== null) {
            if (typeof ref === 'function') {
                invokeGuardedCallback(null, ref, null, null);
                if (hasCaughtError()) {
                    var refError = clearCaughtError();
                    captureCommitPhaseError(current4, refError);
                }
            } else ref.current = null;
        }
    }
    function safelyCallDestroy(current4, destroy) {
        invokeGuardedCallback(null, destroy, null);
        if (hasCaughtError()) {
            var error4 = clearCaughtError();
            captureCommitPhaseError(current4, error4);
        }
    }
    function commitBeforeMutationLifeCycles(current4, finishedWork) {
        switch(finishedWork.tag){
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent:
            case Block:
                return;
            case ClassComponent:
                if (finishedWork.flags & Snapshot) {
                    if (current4 !== null) {
                        var prevProps = current4.memoizedProps;
                        var prevState = current4.memoizedState;
                        var instance = finishedWork.stateNode; // We could update instance props and state here,
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                            if (instance.state !== finishedWork.memoizedState) error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                        }
                        var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                        var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                        if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                            didWarnSet.add(finishedWork.type);
                            error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentName(finishedWork.type));
                        }
                        instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                    }
                }
                return;
            case HostRoot:
                if (finishedWork.flags & Snapshot) {
                    var root1 = finishedWork.stateNode;
                    clearContainer(root1.containerInfo);
                }
                return;
            case HostComponent:
            case HostText:
            case HostPortal:
            case IncompleteClassComponent:
                // Nothing to do for these component types
                return;
        }
        throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function commitHookEffectListUnmount(tag, finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
                if ((effect.tag & tag) === tag) {
                    // Unmount
                    var destroy = effect.destroy;
                    effect.destroy = undefined;
                    if (destroy !== undefined) destroy();
                }
                effect = effect.next;
            }while (effect !== firstEffect)
        }
    }
    function commitHookEffectListMount(tag, finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
                if ((effect.tag & tag) === tag) {
                    // Mount
                    var create = effect.create;
                    effect.destroy = create();
                    var destroy = effect.destroy;
                    if (destroy !== undefined && typeof destroy !== 'function') {
                        var addendum = void 0;
                        if (destroy === null) addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                        else if (typeof destroy.then === 'function') addendum = "\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                        else addendum = ' You returned: ' + destroy;
                        error("An effect function must not return anything besides a function, which is used for clean-up.%s", addendum);
                    }
                }
                effect = effect.next;
            }while (effect !== firstEffect)
        }
    }
    function schedulePassiveEffects(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
                var _effect = effect, next = _effect.next, tag = _effect.tag;
                if ((tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1) {
                    enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
                    enqueuePendingPassiveHookEffectMount(finishedWork, effect);
                }
                effect = next;
            }while (effect !== firstEffect)
        }
    }
    function commitLifeCycles(finishedRoot, current4, finishedWork, committedLanes) {
        switch(finishedWork.tag){
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent:
            case Block:
                commitHookEffectListMount(Layout | HasEffect, finishedWork);
                schedulePassiveEffects(finishedWork);
                return;
            case ClassComponent:
                var instance = finishedWork.stateNode;
                if (finishedWork.flags & Update) {
                    if (current4 === null) {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                            if (instance.state !== finishedWork.memoizedState) error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                        }
                        instance.componentDidMount();
                    } else {
                        var prevProps = finishedWork.elementType === finishedWork.type ? current4.memoizedProps : resolveDefaultProps(finishedWork.type, current4.memoizedProps);
                        var prevState = current4.memoizedState; // We could update instance props and state here,
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                            if (instance.state !== finishedWork.memoizedState) error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                        }
                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                    }
                } // TODO: I think this is now always non-null by the time it reaches the
                // commit phase. Consider removing the type check.
                var updateQueue = finishedWork.updateQueue;
                if (updateQueue !== null) {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                        if (instance.state !== finishedWork.memoizedState) error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || 'instance');
                    }
                    // but instead we rely on them being set during last render.
                    // TODO: revisit this when we implement resuming.
                    commitUpdateQueue(finishedWork, updateQueue, instance);
                }
                return;
            case HostRoot:
                // TODO: I think this is now always non-null by the time it reaches the
                // commit phase. Consider removing the type check.
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                    var _instance = null;
                    if (finishedWork.child !== null) switch(finishedWork.child.tag){
                        case HostComponent:
                            _instance = getPublicInstance(finishedWork.child.stateNode);
                            break;
                        case ClassComponent:
                            _instance = finishedWork.child.stateNode;
                            break;
                    }
                    commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                return;
            case HostComponent:
                var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted
                // (eg DOM renderer may schedule auto-focus for inputs and form controls).
                // These effects should only be committed when components are first mounted,
                // aka when there is no current/alternate.
                if (current4 === null && finishedWork.flags & Update) {
                    var type = finishedWork.type;
                    var props = finishedWork.memoizedProps;
                    commitMount(_instance2, type, props);
                }
                return;
            case HostText:
                // We have no life-cycles associated with text.
                return;
            case HostPortal:
                // We have no life-cycles associated with portals.
                return;
            case Profiler:
                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                var effectDuration = finishedWork.stateNode.effectDuration;
                var commitTime1 = getCommitTime();
                if (typeof onRender === 'function') onRender(finishedWork.memoizedProps.id, current4 === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime1, finishedRoot.memoizedInteractions);
                return;
            case SuspenseComponent:
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                return;
            case SuspenseListComponent:
            case IncompleteClassComponent:
            case FundamentalComponent:
            case ScopeComponent:
            case OffscreenComponent:
            case LegacyHiddenComponent:
                return;
        }
        throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function hideOrUnhideAllChildren(finishedWork, isHidden) {
        // We only have the top Fiber that was inserted but we need to recurse down its
        // children to find all the terminal nodes.
        var node = finishedWork;
        while(true){
            if (node.tag === HostComponent) {
                var instance = node.stateNode;
                if (isHidden) hideInstance(instance);
                else unhideInstance(node.stateNode, node.memoizedProps);
            } else if (node.tag === HostText) {
                var _instance3 = node.stateNode;
                if (isHidden) hideTextInstance(_instance3);
                else unhideTextInstance(_instance3, node.memoizedProps);
            } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;
            else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === finishedWork) return;
            while(node.sibling === null){
                if (node.return === null || node.return === finishedWork) return;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;
        if (ref !== null) {
            var instance = finishedWork.stateNode;
            var instanceToUse;
            switch(finishedWork.tag){
                case HostComponent:
                    instanceToUse = getPublicInstance(instance);
                    break;
                default:
                    instanceToUse = instance;
            } // Moved outside to ensure DCE works with this flag
            if (typeof ref === 'function') ref(instanceToUse);
            else {
                if (!ref.hasOwnProperty('current')) error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentName(finishedWork.type));
                ref.current = instanceToUse;
            }
        }
    }
    function commitDetachRef(current4) {
        var currentRef = current4.ref;
        if (currentRef !== null) {
            if (typeof currentRef === 'function') currentRef(null);
            else currentRef.current = null;
        }
    } // User-originating errors (lifecycles and refs) should not interrupt
    // deletion, so don't let them throw. Host-originating errors should
    // interrupt deletion, so it's okay
    function commitUnmount(finishedRoot, current4, renderPriorityLevel) {
        onCommitUnmount(current4);
        switch(current4.tag){
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent:
            case Block:
                var updateQueue = current4.updateQueue;
                if (updateQueue !== null) {
                    var lastEffect = updateQueue.lastEffect;
                    if (lastEffect !== null) {
                        var firstEffect = lastEffect.next;
                        var effect = firstEffect;
                        do {
                            var _effect2 = effect, destroy = _effect2.destroy, tag = _effect2.tag;
                            if (destroy !== undefined) {
                                if ((tag & Passive$1) !== NoFlags$1) enqueuePendingPassiveHookEffectUnmount(current4, effect);
                                else safelyCallDestroy(current4, destroy);
                            }
                            effect = effect.next;
                        }while (effect !== firstEffect)
                    }
                }
                return;
            case ClassComponent:
                safelyDetachRef(current4);
                var instance = current4.stateNode;
                if (typeof instance.componentWillUnmount === 'function') safelyCallComponentWillUnmount(current4, instance);
                return;
            case HostComponent:
                safelyDetachRef(current4);
                return;
            case HostPortal:
                unmountHostComponents(finishedRoot, current4);
                return;
            case FundamentalComponent:
                return;
            case DehydratedFragment:
                return;
            case ScopeComponent:
                return;
        }
    }
    function commitNestedUnmounts(finishedRoot, root2, renderPriorityLevel) {
        // While we're inside a removed host node we don't want to call
        // removeChild on the inner nodes because they're removed by the top
        // call anyway. We also want to call componentWillUnmount on all
        // composites before this host node is removed from the tree. Therefore
        // we do an inner loop while we're still inside the host node.
        var node = root2;
        while(true){
            commitUnmount(finishedRoot, node); // Visit children because they may contain more composite or host nodes.
            // Skip portals because commitUnmount() currently visits them recursively.
            if (node.child !== null && // If we don't use mutation we drill down into portals here instead.
            node.tag !== HostPortal) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === root2) return;
            while(node.sibling === null){
                if (node.return === null || node.return === root2) return;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    function detachFiberMutation(fiber) {
        // Cut off the return pointers to disconnect it from the tree. Ideally, we
        // should clear the child pointer of the parent alternate to let this
        // get GC:ed but we don't know which for sure which parent is the current
        // one so we'll settle for GC:ing the subtree of this child. This child
        // itself will be GC:ed when the parent updates the next time.
        // Note: we cannot null out sibling here, otherwise it can cause issues
        // with findDOMNode and how it requires the sibling field to carry out
        // traversal in a later effect. See PR #16820. We now clear the sibling
        // field after effects, see: detachFiberAfterEffects.
        //
        // Don't disconnect stateNode now; it will be detached in detachFiberAfterEffects.
        // It may be required if the current component is an error boundary,
        // and one of its descendants throws while unmounting a passive effect.
        fiber.alternate = null;
        fiber.child = null;
        fiber.dependencies = null;
        fiber.firstEffect = null;
        fiber.lastEffect = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.return = null;
        fiber.updateQueue = null;
        fiber._debugOwner = null;
    }
    function getHostParentFiber(fiber) {
        var parent = fiber.return;
        while(parent !== null){
            if (isHostParent(parent)) return parent;
            parent = parent.return;
        }
        throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
    }
    function getHostSibling(fiber) {
        // We're going to search forward into the tree until we find a sibling host
        // node. Unfortunately, if multiple insertions are done in a row we have to
        // search past them. This leads to exponential search for the next sibling.
        // TODO: Find a more efficient way to do this.
        var node = fiber;
        siblings: while(true){
            // If we didn't find anything, let's try the next sibling.
            while(node.sibling === null){
                if (node.return === null || isHostParent(node.return)) // If we pop out of the root or hit the parent the fiber we are the
                // last sibling.
                return null;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
            while(node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment){
                // If it is not host node and, we might have a host node inside it.
                // Try to search down until we find one.
                if (node.flags & Placement) continue siblings;
                 // If we don't have a child, try the siblings instead.
                // We also skip portals because they are not part of this host tree.
                if (node.child === null || node.tag === HostPortal) continue siblings;
                else {
                    node.child.return = node;
                    node = node.child;
                }
            } // Check if this host node is stable or about to be placed.
            if (!(node.flags & Placement)) // Found it!
            return node.stateNode;
        }
    }
    function commitPlacement(finishedWork) {
        var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.
        var parent;
        var isContainer;
        var parentStateNode = parentFiber.stateNode;
        switch(parentFiber.tag){
            case HostComponent:
                parent = parentStateNode;
                isContainer = false;
                break;
            case HostRoot:
                parent = parentStateNode.containerInfo;
                isContainer = true;
                break;
            case HostPortal:
                parent = parentStateNode.containerInfo;
                isContainer = true;
                break;
            case FundamentalComponent:
            // eslint-disable-next-line-no-fallthrough
            default:
                throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
        if (parentFiber.flags & ContentReset) {
            // Reset the text content of the parent before doing any insertions
            resetTextContent(parent); // Clear ContentReset from the effect tag
            parentFiber.flags &= ~ContentReset;
        }
        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its
        // children to find all the terminal nodes.
        if (isContainer) insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
        else insertOrAppendPlacementNode(finishedWork, before, parent);
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        var isHost = tag === HostComponent || tag === HostText;
        if (isHost || enableFundamentalAPI) {
            var stateNode = isHost ? node.stateNode : node.stateNode.instance;
            if (before) insertInContainerBefore(parent, stateNode, before);
            else appendChildToContainer(parent, stateNode);
        } else if (tag === HostPortal) ;
        else {
            var child = node.child;
            if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while(sibling !== null){
                    insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                    sibling = sibling.sibling;
                }
            }
        }
    }
    function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        var isHost = tag === HostComponent || tag === HostText;
        if (isHost || enableFundamentalAPI) {
            var stateNode = isHost ? node.stateNode : node.stateNode.instance;
            if (before) insertBefore(parent, stateNode, before);
            else appendChild(parent, stateNode);
        } else if (tag === HostPortal) ;
        else {
            var child = node.child;
            if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while(sibling !== null){
                    insertOrAppendPlacementNode(sibling, before, parent);
                    sibling = sibling.sibling;
                }
            }
        }
    }
    function unmountHostComponents(finishedRoot, current4, renderPriorityLevel) {
        // We only have the top Fiber that was deleted but we need to recurse down its
        // children to find all the terminal nodes.
        var node = current4; // Each iteration, currentParent is populated with node's host parent if not
        // currentParentIsValid.
        var currentParentIsValid = false; // Note: these two variables *must* always be updated together.
        var currentParent;
        var currentParentIsContainer;
        while(true){
            if (!currentParentIsValid) {
                var parent = node.return;
                findParent: while(true){
                    if (!(parent !== null)) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
                    var parentStateNode = parent.stateNode;
                    switch(parent.tag){
                        case HostComponent:
                            currentParent = parentStateNode;
                            currentParentIsContainer = false;
                            break findParent;
                        case HostRoot:
                            currentParent = parentStateNode.containerInfo;
                            currentParentIsContainer = true;
                            break findParent;
                        case HostPortal:
                            currentParent = parentStateNode.containerInfo;
                            currentParentIsContainer = true;
                            break findParent;
                    }
                    parent = parent.return;
                }
                currentParentIsValid = true;
            }
            if (node.tag === HostComponent || node.tag === HostText) {
                commitNestedUnmounts(finishedRoot, node); // After all the children have unmounted, it is now safe to remove the
                // node from the tree.
                if (currentParentIsContainer) removeChildFromContainer(currentParent, node.stateNode);
                else removeChild(currentParent, node.stateNode);
                 // Don't visit children because we already visited them.
            } else if (node.tag === HostPortal) {
                if (node.child !== null) {
                    // When we go into a portal, it becomes the parent to remove from.
                    // We will reassign it back when we pop the portal on the way up.
                    currentParent = node.stateNode.containerInfo;
                    currentParentIsContainer = true; // Visit children because portals might contain host components.
                    node.child.return = node;
                    node = node.child;
                    continue;
                }
            } else {
                commitUnmount(finishedRoot, node); // Visit children because we may find more host components below.
                if (node.child !== null) {
                    node.child.return = node;
                    node = node.child;
                    continue;
                }
            }
            if (node === current4) return;
            while(node.sibling === null){
                if (node.return === null || node.return === current4) return;
                node = node.return;
                if (node.tag === HostPortal) // When we go out of the portal, we need to restore the parent.
                // Since we don't keep a stack of them, we will search for it.
                currentParentIsValid = false;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    function commitDeletion(finishedRoot, current4, renderPriorityLevel) {
        // Recursively delete all host nodes from the parent.
        // Detach refs and call componentWillUnmount() on the whole subtree.
        unmountHostComponents(finishedRoot, current4);
        var alternate = current4.alternate;
        detachFiberMutation(current4);
        if (alternate !== null) detachFiberMutation(alternate);
    }
    function commitWork(current4, finishedWork) {
        switch(finishedWork.tag){
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent:
            case Block:
                commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
                return;
            case ClassComponent:
                return;
            case HostComponent:
                var instance = finishedWork.stateNode;
                if (instance != null) {
                    // Commit the work prepared earlier.
                    var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
                    // as the newProps. The updatePayload will contain the real change in
                    // this case.
                    var oldProps = current4 !== null ? current4.memoizedProps : newProps;
                    var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.
                    var updatePayload = finishedWork.updateQueue;
                    finishedWork.updateQueue = null;
                    if (updatePayload !== null) commitUpdate(instance, updatePayload, type, oldProps, newProps);
                }
                return;
            case HostText:
                if (!(finishedWork.stateNode !== null)) throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                var textInstance = finishedWork.stateNode;
                var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
                // as the newProps. The updatePayload will contain the real change in
                // this case.
                var oldText = current4 !== null ? current4.memoizedProps : newText;
                commitTextUpdate(textInstance, oldText, newText);
                return;
            case HostRoot:
                var _root = finishedWork.stateNode;
                if (_root.hydrate) {
                    // We've just hydrated. No need to hydrate again.
                    _root.hydrate = false;
                    commitHydratedContainer(_root.containerInfo);
                }
                return;
            case Profiler:
                return;
            case SuspenseComponent:
                commitSuspenseComponent(finishedWork);
                attachSuspenseRetryListeners(finishedWork);
                return;
            case SuspenseListComponent:
                attachSuspenseRetryListeners(finishedWork);
                return;
            case IncompleteClassComponent:
                return;
            case FundamentalComponent:
                break;
            case ScopeComponent:
                break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
                var newState = finishedWork.memoizedState;
                var isHidden = newState !== null;
                hideOrUnhideAllChildren(finishedWork, isHidden);
                return;
        }
        throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function commitSuspenseComponent(finishedWork) {
        var newState = finishedWork.memoizedState;
        if (newState !== null) {
            markCommitTimeOfFallback();
            // Hide the Offscreen component that contains the primary children. TODO:
            // Ideally, this effect would have been scheduled on the Offscreen fiber
            // itself. That's how unhiding works: the Offscreen component schedules an
            // effect on itself. However, in this case, the component didn't complete,
            // so the fiber was never added to the effect list in the normal path. We
            // could have appended it to the effect list in the Suspense component's
            // second pass, but doing it this way is less complicated. This would be
            // simpler if we got rid of the effect list and traversed the tree, like
            // we're planning to do.
            var primaryChildParent = finishedWork.child;
            hideOrUnhideAllChildren(primaryChildParent, true);
        }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        var newState = finishedWork.memoizedState;
        if (newState === null) {
            var current4 = finishedWork.alternate;
            if (current4 !== null) {
                var prevState = current4.memoizedState;
                if (prevState !== null) {
                    var suspenseInstance = prevState.dehydrated;
                    if (suspenseInstance !== null) commitHydratedSuspenseInstance(suspenseInstance);
                }
            }
        }
    }
    function attachSuspenseRetryListeners(finishedWork) {
        // If this boundary just timed out, then it will have a set of wakeables.
        // For each wakeable, attach a listener so that when it resolves, React
        // attempts to re-render the boundary in the primary (pre-timeout) state.
        var wakeables = finishedWork.updateQueue;
        if (wakeables !== null) {
            finishedWork.updateQueue = null;
            var retryCache = finishedWork.stateNode;
            if (retryCache === null) retryCache = finishedWork.stateNode = new PossiblyWeakSet();
            wakeables.forEach(function(wakeable) {
                // Memoize using the boundary fiber to prevent redundant listeners.
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                    if (wakeable.__reactDoNotTraceInteractions !== true) retry = tracing.unstable_wrap(retry);
                    retryCache.add(wakeable);
                    wakeable.then(retry, retry);
                }
            });
        }
    } // This function detects when a Suspense boundary goes from visible to hidden.
    // It returns false if the boundary is already hidden.
    // TODO: Use an effect tag.
    function isSuspenseBoundaryBeingHidden(current5, finishedWork) {
        if (current5 !== null) {
            var oldState = current5.memoizedState;
            if (oldState === null || oldState.dehydrated !== null) {
                var newState = finishedWork.memoizedState;
                return newState !== null && newState.dehydrated === null;
            }
        }
        return false;
    }
    function commitResetTextContent(current5) {
        resetTextContent(current5.stateNode);
    }
    var COMPONENT_TYPE = 0;
    var HAS_PSEUDO_CLASS_TYPE = 1;
    var ROLE_TYPE = 2;
    var TEST_NAME_TYPE = 3;
    var TEXT_TYPE = 4;
    if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor$1 = Symbol.for;
        COMPONENT_TYPE = symbolFor$1('selector.component');
        HAS_PSEUDO_CLASS_TYPE = symbolFor$1('selector.has_pseudo_class');
        ROLE_TYPE = symbolFor$1('selector.role');
        TEST_NAME_TYPE = symbolFor$1('selector.test_id');
        TEXT_TYPE = symbolFor$1('selector.text');
    }
    var commitHooks = [];
    function onCommitRoot$1() {
        commitHooks.forEach(function(commitHook) {
            return commitHook();
        });
    }
    var ceil = Math.ceil;
    var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
    var NoContext = /*             */ 0;
    var BatchedContext = /*               */ 1;
    var EventContext = /*                 */ 2;
    var DiscreteEventContext = /*         */ 4;
    var LegacyUnbatchedContext = /*       */ 8;
    var RenderContext = /*                */ 16;
    var CommitContext = /*                */ 32;
    var RetryAfterError = /*       */ 64;
    var RootIncomplete = 0;
    var RootFatalErrored = 1;
    var RootErrored = 2;
    var RootSuspended = 3;
    var RootSuspendedWithDelay = 4;
    var RootCompleted = 5; // Describes where we are in the React execution stack
    var executionContext = NoContext; // The root we're working on
    var workInProgressRoot = null; // The fiber we're working on
    var workInProgress = null; // The lanes we're rendering
    var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree
    // This is a superset of the lanes we started working on at the root. The only
    // case where it's different from `workInProgressRootRenderLanes` is when we
    // enter a subtree that is hidden and needs to be unhidden: Suspense and
    // Offscreen component.
    //
    // Most things in the work loop should deal with workInProgressRootRenderLanes.
    // Most things in begin/complete phases should deal with subtreeRenderLanes.
    var subtreeRenderLanes = NoLanes;
    var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.
    var workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown
    var workInProgressRootFatalError = null; // "Included" lanes refer to lanes that were worked on during this render. It's
    // slightly different than `renderLanes` because `renderLanes` can change as you
    // enter and exit an Offscreen tree. This value is the combination of all render
    // lanes for the entire render phase.
    var workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only
    // includes unprocessed updates, not work in bailed out children.
    var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.
    var workInProgressRootUpdatedLanes = NoLanes; // Lanes that were pinged (in an interleaved event) during this render.
    var workInProgressRootPingedLanes = NoLanes;
    var mostRecentlyUpdatedRoot = null; // The most recent time we committed a fallback. This lets us ensure a train
    // model where we don't commit new loading states in too quick succession.
    var globalMostRecentFallbackTime = 0;
    var FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering
    // more and prefer CPU suspense heuristics instead.
    var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU
    // suspense heuristics and opt out of rendering more content.
    var RENDER_TIMEOUT_MS = 500;
    function resetRenderTimer() {
        workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
    }
    function getRenderTargetTime() {
        return workInProgressRootRenderTargetTime;
    }
    var nextEffect = null;
    var hasUncaughtError = false;
    var firstUncaughtError = null;
    var legacyErrorBoundariesThatAlreadyFailed = null;
    var rootDoesHavePassiveEffects = false;
    var rootWithPendingPassiveEffects = null;
    var pendingPassiveEffectsRenderPriority = NoPriority$1;
    var pendingPassiveEffectsLanes = NoLanes;
    var pendingPassiveHookEffectsMount = [];
    var pendingPassiveHookEffectsUnmount = [];
    var rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates
    var NESTED_UPDATE_LIMIT = 50;
    var nestedUpdateCount = 0;
    var rootWithNestedUpdates = null;
    var NESTED_PASSIVE_UPDATE_LIMIT = 50;
    var nestedPassiveUpdateCount = 0; // Marks the need to reschedule pending interactions at these lanes
    // during the commit phase. This enables them to be traced across components
    // that spawn new work during render. E.g. hidden boundaries, suspended SSR
    // hydration or SuspenseList.
    // TODO: Can use a bitmask instead of an array
    var spawnedWorkDuringRender = null; // If two updates are scheduled within the same event, we should treat their
    // event times as simultaneous, even if the actual clock time has advanced
    // between the first and second call.
    var currentEventTime = NoTimestamp;
    var currentEventWipLanes = NoLanes;
    var currentEventPendingLanes = NoLanes; // Dev only flag that tracks if passive effects are currently being flushed.
    // We warn about state updates for unmounted components differently in this case.
    var isFlushingPassiveEffects = false;
    var focusedInstanceHandle = null;
    var shouldFireAfterActiveInstanceBlur = false;
    function getWorkInProgressRoot() {
        return workInProgressRoot;
    }
    function requestEventTime() {
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) // We're inside React, so it's fine to read the actual time.
        return now();
         // We're not inside React, so we may be in the middle of a browser event.
        if (currentEventTime !== NoTimestamp) // Use the same start time for all updates until we enter React again.
        return currentEventTime;
         // This is the first update since React yielded. Compute a new start time.
        currentEventTime = now();
        return currentEventTime;
    }
    function requestUpdateLane(fiber) {
        // Special cases
        var mode = fiber.mode;
        if ((mode & BlockingMode) === NoMode) return SyncLane;
        else if ((mode & ConcurrentMode) === NoMode) return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
         // The algorithm for assigning an update to a lane should be stable for all
        // updates at the same priority within the same event. To do this, the inputs
        // to the algorithm must be the same. For example, we use the `renderLanes`
        // to avoid choosing a lane that is already in the middle of rendering.
        //
        // However, the "included" lanes could be mutated in between updates in the
        // same event, like if you perform an update inside `flushSync`. Or any other
        // code path that might call `prepareFreshStack`.
        //
        // The trick we use is to cache the first of each of these inputs within an
        // event. Then reset the cached values once we can be sure the event is over.
        // Our heuristic for that is whenever we enter a concurrent work loop.
        //
        // We'll do the same for `currentEventPendingLanes` below.
        if (currentEventWipLanes === NoLanes) currentEventWipLanes = workInProgressRootIncludedLanes;
        var isTransition = requestCurrentTransition() !== NoTransition;
        if (isTransition) {
            if (currentEventPendingLanes !== NoLanes) currentEventPendingLanes = mostRecentlyUpdatedRoot !== null ? mostRecentlyUpdatedRoot.pendingLanes : NoLanes;
            return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);
        } // TODO: Remove this dependency on the Scheduler priority.
        // To do that, we're replacing it with an update lane priority.
        var schedulerPriority = getCurrentPriorityLevel(); // The old behavior was using the priority level of the Scheduler.
        // This couples React to the Scheduler internals, so we're replacing it
        // with the currentUpdateLanePriority above. As an example of how this
        // could be problematic, if we're not inside `Scheduler.runWithPriority`,
        // then we'll get the priority of the current running Scheduler task,
        // which is probably not what we want.
        var lane;
        if ((executionContext & DiscreteEventContext) !== NoContext && schedulerPriority === UserBlockingPriority$2) lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
        else {
            var schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);
            lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
        }
        return lane;
    }
    function requestRetryLane(fiber) {
        // This is a fork of `requestUpdateLane` designed specifically for Suspense
        // "retries" — a special update that attempts to flip a Suspense boundary
        // from its placeholder state to its primary/resolved state.
        // Special cases
        var mode = fiber.mode;
        if ((mode & BlockingMode) === NoMode) return SyncLane;
        else if ((mode & ConcurrentMode) === NoMode) return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
         // See `requestUpdateLane` for explanation of `currentEventWipLanes`
        if (currentEventWipLanes === NoLanes) currentEventWipLanes = workInProgressRootIncludedLanes;
        return findRetryLane(currentEventWipLanes);
    }
    function scheduleUpdateOnFiber(fiber, lane, eventTime) {
        checkForNestedUpdates();
        warnAboutRenderPhaseUpdatesInDEV(fiber);
        var root2 = markUpdateLaneFromFiberToRoot(fiber, lane);
        if (root2 === null) {
            warnAboutUpdateOnUnmountedFiberInDEV(fiber);
            return null;
        } // Mark that the root has a pending update.
        markRootUpdated(root2, lane, eventTime);
        if (root2 === workInProgressRoot) {
            workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);
            if (workInProgressRootExitStatus === RootSuspendedWithDelay) // The root already suspended with a delay, which means this render
            // definitely won't finish. Since we have a new update, let's mark it as
            // suspended now, right before marking the incoming update. This has the
            // effect of interrupting the current render and switching to the update.
            // TODO: Make sure this doesn't override pings that happen while we've
            // already started rendering.
            markRootSuspended$1(root2, workInProgressRootRenderLanes);
        } // TODO: requestUpdateLanePriority also reads the priority. Pass the
        // priority as an argument to that function and this one.
        var priorityLevel = getCurrentPriorityLevel();
        if (lane === SyncLane) {
            if ((executionContext & LegacyUnbatchedContext) !== NoContext && (executionContext & (RenderContext | CommitContext)) === NoContext) {
                // Register pending interactions on the root to avoid losing traced interaction data.
                schedulePendingInteractions(root2, lane); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
                // root inside of batchedUpdates should be synchronous, but layout updates
                // should be deferred until the end of the batch.
                performSyncWorkOnRoot(root2);
            } else {
                ensureRootIsScheduled(root2, eventTime);
                schedulePendingInteractions(root2, lane);
                if (executionContext === NoContext) {
                    // Flush the synchronous work now, unless we're already working or inside
                    // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
                    // scheduleCallbackForFiber to preserve the ability to schedule a callback
                    // without immediately flushing it. We only do this for user-initiated
                    // updates, to preserve historical behavior of legacy mode.
                    resetRenderTimer();
                    flushSyncCallbackQueue();
                }
            }
        } else {
            // Schedule a discrete update but only if it's not Sync.
            if ((executionContext & DiscreteEventContext) !== NoContext && // discrete, even inside a discrete event.
            (priorityLevel === UserBlockingPriority$2 || priorityLevel === ImmediatePriority$1)) {
                // This is the result of a discrete event. Track the lowest priority
                // discrete update per root so we can flush them early, if needed.
                if (rootsWithPendingDiscreteUpdates === null) rootsWithPendingDiscreteUpdates = new Set([
                    root2
                ]);
                else rootsWithPendingDiscreteUpdates.add(root2);
            } // Schedule other updates after in case the callback is sync.
            ensureRootIsScheduled(root2, eventTime);
            schedulePendingInteractions(root2, lane);
        } // We use this when assigning a lane for a transition inside
        // `requestUpdateLane`. We assume it's the same as the root being updated,
        // since in the common case of a single root app it probably is. If it's not
        // the same root, then it's not a huge deal, we just might batch more stuff
        // together more than necessary.
        mostRecentlyUpdatedRoot = root2;
    } // This is split into a separate function so we can mark a fiber with pending
    // work without treating it as a typical update that originates from an event;
    // e.g. retrying a Suspense boundary isn't an update, but it does schedule work
    // on a fiber.
    function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
        // Update the source fiber's lanes
        sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
        var alternate = sourceFiber.alternate;
        if (alternate !== null) alternate.lanes = mergeLanes(alternate.lanes, lane);
        if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
        var node = sourceFiber;
        var parent = sourceFiber.return;
        while(parent !== null){
            parent.childLanes = mergeLanes(parent.childLanes, lane);
            alternate = parent.alternate;
            if (alternate !== null) alternate.childLanes = mergeLanes(alternate.childLanes, lane);
            else if ((parent.flags & (Placement | Hydrating)) !== NoFlags) warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
            node = parent;
            parent = parent.return;
        }
        if (node.tag === HostRoot) {
            var root2 = node.stateNode;
            return root2;
        } else return null;
    } // Use this function to schedule a task for a root. There's only one task per
    // root; if a task was already scheduled, we'll check to make sure the priority
    // of the existing task is the same as the priority of the next level that the
    // root has work on. This function is called on every update, and right before
    // exiting a task.
    function ensureRootIsScheduled(root3, currentTime) {
        var existingCallbackNode = root3.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as
        // expired so we know to work on those next.
        markStarvedLanesAsExpired(root3, currentTime); // Determine the next lanes to work on, and their priority.
        var nextLanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); // This returns the priority level computed during the `getNextLanes` call.
        var newCallbackPriority = returnNextLanesPriority();
        if (nextLanes === NoLanes) {
            // Special case: There's nothing to work on.
            if (existingCallbackNode !== null) {
                cancelCallback(existingCallbackNode);
                root3.callbackNode = null;
                root3.callbackPriority = NoLanePriority;
            }
            return;
        } // Check if there's an existing task. We may be able to reuse it.
        if (existingCallbackNode !== null) {
            var existingCallbackPriority = root3.callbackPriority;
            if (existingCallbackPriority === newCallbackPriority) // The priority hasn't changed. We can reuse the existing task. Exit.
            return;
             // The priority changed. Cancel the existing callback. We'll schedule a new
            // one below.
            cancelCallback(existingCallbackNode);
        } // Schedule a new callback.
        var newCallbackNode;
        if (newCallbackPriority === SyncLanePriority) // Special case: Sync React callbacks are scheduled on a special
        // internal queue
        newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root3));
        else if (newCallbackPriority === SyncBatchedLanePriority) newCallbackNode = scheduleCallback(ImmediatePriority$1, performSyncWorkOnRoot.bind(null, root3));
        else {
            var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
            newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root3));
        }
        root3.callbackPriority = newCallbackPriority;
        root3.callbackNode = newCallbackNode;
    } // This is the entry point for every concurrent task, i.e. anything that
    // goes through Scheduler.
    function performConcurrentWorkOnRoot(root3) {
        // Since we know we're in a React event, we can clear the current
        // event time. The next update will compute a new event time.
        currentEventTime = NoTimestamp;
        currentEventWipLanes = NoLanes;
        currentEventPendingLanes = NoLanes;
        if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) throw Error("Should not already be working.");
         // Flush any pending passive effects before deciding which lanes to work on,
        // in case they schedule additional work.
        var originalCallbackNode = root3.callbackNode;
        var didFlushPassiveEffects = flushPassiveEffects();
        if (didFlushPassiveEffects) {
            // Something in the passive effect phase may have canceled the current task.
            // Check if the task node for this root was changed.
            if (root3.callbackNode !== originalCallbackNode) // The current task was canceled. Exit. We don't need to call
            // `ensureRootIsScheduled` because the check above implies either that
            // there's a new task, or that there's no remaining work on this root.
            return null;
        } // Determine the next expiration time to work on, using the fields stored
        // on the root.
        var lanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (lanes === NoLanes) // Defensive coding. This is never expected to happen.
        return null;
        var exitStatus = renderRootConcurrent(root3, lanes);
        if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) // The render included lanes that were updated during the render phase.
        // For example, when unhiding a hidden tree, we include all the lanes
        // that were previously skipped when the tree was hidden. That set of
        // lanes is a superset of the lanes we started rendering with.
        //
        // So we'll throw out the current work and restart.
        prepareFreshStack(root3, NoLanes);
        else if (exitStatus !== RootIncomplete) {
            if (exitStatus === RootErrored) {
                executionContext |= RetryAfterError; // If an error occurred during hydration,
                // discard server response and fall back to client side render.
                if (root3.hydrate) {
                    root3.hydrate = false;
                    clearContainer(root3.containerInfo);
                } // If something threw an error, try rendering one more time. We'll render
                // synchronously to block concurrent data mutations, and we'll includes
                // all pending updates are included. If it still fails after the second
                // attempt, we'll give up and commit the resulting tree.
                lanes = getLanesToRetrySynchronouslyOnError(root3);
                if (lanes !== NoLanes) exitStatus = renderRootSync(root3, lanes);
            }
            if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root3, NoLanes);
                markRootSuspended$1(root3, lanes);
                ensureRootIsScheduled(root3, now());
                throw fatalError;
            } // We now have a consistent tree. The next step is either to commit it,
            // or, if something suspended, wait to commit it after a timeout.
            var finishedWork = root3.current.alternate;
            root3.finishedWork = finishedWork;
            root3.finishedLanes = lanes;
            finishConcurrentRender(root3, exitStatus, lanes);
        }
        ensureRootIsScheduled(root3, now());
        if (root3.callbackNode === originalCallbackNode) // The task node scheduled for this root is the same one that's
        // currently executed. Need to return a continuation.
        return performConcurrentWorkOnRoot.bind(null, root3);
        return null;
    }
    function finishConcurrentRender(root3, exitStatus, lanes) {
        switch(exitStatus){
            case RootIncomplete:
            case RootFatalErrored:
                throw Error("Root did not complete. This is a bug in React.");
            // Flow knows about invariant, so it complains if I add a break
            // statement, but eslint doesn't know about invariant, so it complains
            // if I do. eslint-disable-next-line no-fallthrough
            case RootErrored:
                // We should have already attempted to retry this tree. If we reached
                // this point, it errored again. Commit it.
                commitRoot(root3);
                break;
            case RootSuspended:
                markRootSuspended$1(root3, lanes); // We have an acceptable loading state. We need to figure out if we
                // should immediately commit it or wait a bit.
                if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
                    // This render only included retries, no updates. Throttle committing
                    // retries so that we don't show too many loading states too quickly.
                    var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.
                    if (msUntilTimeout > 10) {
                        var nextLanes = getNextLanes(root3, NoLanes);
                        if (nextLanes !== NoLanes) break;
                        var suspendedLanes = root3.suspendedLanes;
                        if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                            // We should prefer to render the fallback of at the last
                            // suspended level. Ping the last suspended level to try
                            // rendering it again.
                            // FIXME: What if the suspended lanes are Idle? Should not restart.
                            var eventTime = requestEventTime();
                            markRootPinged(root3, suspendedLanes);
                            break;
                        } // The render is suspended, it hasn't timed out, and there's no
                        // lower priority work to do. Instead of committing the fallback
                        // immediately, wait for more data to arrive.
                        root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3), msUntilTimeout);
                        break;
                    }
                } // The work expired. Commit immediately.
                commitRoot(root3);
                break;
            case RootSuspendedWithDelay:
                markRootSuspended$1(root3, lanes);
                if (includesOnlyTransitions(lanes)) break;
                if (!shouldForceFlushFallbacksInDEV()) {
                    // This is not a transition, but we did trigger an avoided state.
                    // Schedule a placeholder to display after a short delay, using the Just
                    // Noticeable Difference.
                    // TODO: Is the JND optimization worth the added complexity? If this is
                    // the only reason we track the event time, then probably not.
                    // Consider removing.
                    var mostRecentEventTime = getMostRecentEventTime(root3, lanes);
                    var eventTimeMs = mostRecentEventTime;
                    var timeElapsedMs = now() - eventTimeMs;
                    var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.
                    if (_msUntilTimeout > 10) {
                        // Instead of committing the fallback immediately, wait for more data
                        // to arrive.
                        root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3), _msUntilTimeout);
                        break;
                    }
                } // Commit the placeholder.
                commitRoot(root3);
                break;
            case RootCompleted:
                // The work completed. Ready to commit.
                commitRoot(root3);
                break;
            default:
                throw Error("Unknown root exit status.");
        }
    }
    function markRootSuspended$1(root3, suspendedLanes) {
        // When suspending, we should always exclude lanes that were pinged or (more
        // rarely, since we try to avoid it) updated during the render phase.
        // TODO: Lol maybe there's a better way to factor this besides this
        // obnoxiously named function :)
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);
        markRootSuspended(root3, suspendedLanes);
    } // This is the entry point for synchronous tasks that don't go
    // through Scheduler
    function performSyncWorkOnRoot(root3) {
        if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) throw Error("Should not already be working.");
        flushPassiveEffects();
        var lanes;
        var exitStatus;
        if (root3 === workInProgressRoot && includesSomeLane(root3.expiredLanes, workInProgressRootRenderLanes)) {
            // There's a partial tree, and at least one of its lanes has expired. Finish
            // rendering it before rendering the rest of the expired work.
            lanes = workInProgressRootRenderLanes;
            exitStatus = renderRootSync(root3, lanes);
            if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
                // The render included lanes that were updated during the render phase.
                // For example, when unhiding a hidden tree, we include all the lanes
                // that were previously skipped when the tree was hidden. That set of
                // lanes is a superset of the lanes we started rendering with.
                //
                // Note that this only happens when part of the tree is rendered
                // concurrently. If the whole tree is rendered synchronously, then there
                // are no interleaved events.
                lanes = getNextLanes(root3, lanes);
                exitStatus = renderRootSync(root3, lanes);
            }
        } else {
            lanes = getNextLanes(root3, NoLanes);
            exitStatus = renderRootSync(root3, lanes);
        }
        if (root3.tag !== LegacyRoot && exitStatus === RootErrored) {
            executionContext |= RetryAfterError; // If an error occurred during hydration,
            // discard server response and fall back to client side render.
            if (root3.hydrate) {
                root3.hydrate = false;
                clearContainer(root3.containerInfo);
            } // If something threw an error, try rendering one more time. We'll render
            // synchronously to block concurrent data mutations, and we'll includes
            // all pending updates are included. If it still fails after the second
            // attempt, we'll give up and commit the resulting tree.
            lanes = getLanesToRetrySynchronouslyOnError(root3);
            if (lanes !== NoLanes) exitStatus = renderRootSync(root3, lanes);
        }
        if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root3, NoLanes);
            markRootSuspended$1(root3, lanes);
            ensureRootIsScheduled(root3, now());
            throw fatalError;
        } // We now have a consistent tree. Because this is a sync render, we
        // will commit it even if something suspended.
        var finishedWork = root3.current.alternate;
        root3.finishedWork = finishedWork;
        root3.finishedLanes = lanes;
        commitRoot(root3); // Before exiting, make sure there's a callback scheduled for the next
        // pending level.
        ensureRootIsScheduled(root3, now());
        return null;
    }
    function flushDiscreteUpdates() {
        // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.
        // However, `act` uses `batchedUpdates`, so there's no way to distinguish
        // those two cases. Need to fix this before exposing flushDiscreteUpdates
        // as a public API.
        if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
            if ((executionContext & RenderContext) !== NoContext) error("unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.");
            // This is probably a nested event dispatch triggered by a lifecycle/effect,
            // like `el.focus()`. Exit.
            return;
        }
        flushPendingDiscreteUpdates(); // If the discrete updates scheduled passive effects, flush them now so that
        // they fire before the next serial event.
        flushPassiveEffects();
    }
    function flushPendingDiscreteUpdates() {
        if (rootsWithPendingDiscreteUpdates !== null) {
            // For each root with pending discrete updates, schedule a callback to
            // immediately flush them.
            var roots = rootsWithPendingDiscreteUpdates;
            rootsWithPendingDiscreteUpdates = null;
            roots.forEach(function(root3) {
                markDiscreteUpdatesExpired(root3);
                ensureRootIsScheduled(root3, now());
            });
        } // Now flush the immediate queue.
        flushSyncCallbackQueue();
    }
    function batchedUpdates$1(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        try {
            return fn(a);
        } finally{
            executionContext = prevExecutionContext;
            if (executionContext === NoContext) {
                // Flush the immediate callbacks that were scheduled during this batch
                resetRenderTimer();
                flushSyncCallbackQueue();
            }
        }
    }
    function batchedEventUpdates$1(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext |= EventContext;
        try {
            return fn(a);
        } finally{
            executionContext = prevExecutionContext;
            if (executionContext === NoContext) {
                // Flush the immediate callbacks that were scheduled during this batch
                resetRenderTimer();
                flushSyncCallbackQueue();
            }
        }
    }
    function discreteUpdates$1(fn, a, b, c, d) {
        var prevExecutionContext = executionContext;
        executionContext |= DiscreteEventContext;
        try {
            return runWithPriority$1(UserBlockingPriority$2, fn.bind(null, a, b, c, d));
        } finally{
            executionContext = prevExecutionContext;
            if (executionContext === NoContext) {
                // Flush the immediate callbacks that were scheduled during this batch
                resetRenderTimer();
                flushSyncCallbackQueue();
            }
        }
    }
    function unbatchedUpdates(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext &= ~BatchedContext;
        executionContext |= LegacyUnbatchedContext;
        try {
            return fn(a);
        } finally{
            executionContext = prevExecutionContext;
            if (executionContext === NoContext) {
                // Flush the immediate callbacks that were scheduled during this batch
                resetRenderTimer();
                flushSyncCallbackQueue();
            }
        }
    }
    function flushSync(fn, a) {
        var prevExecutionContext = executionContext;
        if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {
            error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
            return fn(a);
        }
        executionContext |= BatchedContext;
        try {
            if (fn) return runWithPriority$1(ImmediatePriority$1, fn.bind(null, a));
            else return undefined;
        } finally{
            executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.
            // Note that this will happen even if batchedUpdates is higher up
            // the stack.
            flushSyncCallbackQueue();
        }
    }
    function pushRenderLanes(fiber, lanes) {
        push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
        subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
        workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
    }
    function popRenderLanes(fiber) {
        subtreeRenderLanes = subtreeRenderLanesCursor.current;
        pop(subtreeRenderLanesCursor, fiber);
    }
    function prepareFreshStack(root3, lanes) {
        root3.finishedWork = null;
        root3.finishedLanes = NoLanes;
        var timeoutHandle = root3.timeoutHandle;
        if (timeoutHandle !== noTimeout) {
            // The root previous suspended and scheduled a timeout to commit a fallback
            // state. Now that we have additional work, cancel the timeout.
            root3.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
            cancelTimeout(timeoutHandle);
        }
        if (workInProgress !== null) {
            var interruptedWork = workInProgress.return;
            while(interruptedWork !== null){
                unwindInterruptedWork(interruptedWork);
                interruptedWork = interruptedWork.return;
            }
        }
        workInProgressRoot = root3;
        workInProgress = createWorkInProgress(root3.current, null);
        workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
        workInProgressRootExitStatus = RootIncomplete;
        workInProgressRootFatalError = null;
        workInProgressRootSkippedLanes = NoLanes;
        workInProgressRootUpdatedLanes = NoLanes;
        workInProgressRootPingedLanes = NoLanes;
        spawnedWorkDuringRender = null;
        ReactStrictModeWarnings.discardPendingWarnings();
    }
    function handleError(root3, thrownValue) {
        do {
            var erroredWork = workInProgress;
            try {
                // Reset module-level state that was set during the render phase.
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber(); // TODO: I found and added this missing line while investigating a
                // separate issue. Write a regression test using string refs.
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                    // Expected to be working on a non-root fiber. This is a fatal error
                    // because there's no ancestor that can handle it; the root is
                    // supposed to capture all errors that weren't caught by an error
                    // boundary.
                    workInProgressRootExitStatus = RootFatalErrored;
                    workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next
                    // sibling, or the parent if there are no siblings. But since the root
                    // has no siblings nor a parent, we set it to null. Usually this is
                    // handled by `completeUnitOfWork` or `unwindWork`, but since we're
                    // intentionally not calling those, we need set it here.
                    // TODO: Consider calling `unwindWork` to pop the contexts.
                    workInProgress = null;
                    return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) // Record the time spent rendering before an error was thrown. This
                // avoids inaccurate Profiler durations in the case of a
                // suspended render.
                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                throwException(root3, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
            } catch (yetAnotherThrownValue) {
                // Something in the return path also threw.
                thrownValue = yetAnotherThrownValue;
                if (workInProgress === erroredWork && erroredWork !== null) {
                    // If this boundary has already errored, then we had trouble processing
                    // the error. Bubble it to the next boundary.
                    erroredWork = erroredWork.return;
                    workInProgress = erroredWork;
                } else erroredWork = workInProgress;
                continue;
            } // Return to the normal work loop.
            return;
        }while (true)
    }
    function pushDispatcher() {
        var prevDispatcher = ReactCurrentDispatcher$2.current;
        ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
        if (prevDispatcher === null) // The React isomorphic package does not include a default dispatcher.
        // Instead the first renderer will lazily attach one, in order to give
        // nicer error messages.
        return ContextOnlyDispatcher;
        else return prevDispatcher;
    }
    function popDispatcher(prevDispatcher) {
        ReactCurrentDispatcher$2.current = prevDispatcher;
    }
    function pushInteractions(root3) {
        var prevInteractions = tracing.__interactionsRef.current;
        tracing.__interactionsRef.current = root3.memoizedInteractions;
        return prevInteractions;
    }
    function popInteractions(prevInteractions) {
        tracing.__interactionsRef.current = prevInteractions;
    }
    function markCommitTimeOfFallback() {
        globalMostRecentFallbackTime = now();
    }
    function markSkippedUpdateLanes(lane) {
        workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
    }
    function renderDidSuspend() {
        if (workInProgressRootExitStatus === RootIncomplete) workInProgressRootExitStatus = RootSuspended;
    }
    function renderDidSuspendDelayIfPossible() {
        if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) workInProgressRootExitStatus = RootSuspendedWithDelay;
         // Check if there are updates that we skipped tree that might have unblocked
        // this render.
        if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootUpdatedLanes))) // Mark the current render as suspended so that we switch to working on
        // the updates that were skipped. Usually we only suspend at the end of
        // the render phase.
        // TODO: We should probably always mark the root as suspended immediately
        // (inside this function), since by suspending at the end of the render
        // phase introduces a potential mistake where we suspend lanes that were
        // pinged or updated while we were rendering.
        markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
    }
    function renderDidError() {
        if (workInProgressRootExitStatus !== RootCompleted) workInProgressRootExitStatus = RootErrored;
    } // Called during render to determine if anything has suspended.
    // Returns false if we're not sure.
    function renderHasNotSuspendedYet() {
        // If something errored or completed, we can't really be sure,
        // so those are false.
        return workInProgressRootExitStatus === RootIncomplete;
    }
    function renderRootSync(root3, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
        // and prepare a fresh one. Otherwise we'll continue where we left off.
        if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
            prepareFreshStack(root3, lanes);
            startWorkOnPendingInteractions(root3, lanes);
        }
        var prevInteractions = pushInteractions(root3);
        for(;;)try {
            workLoopSync();
            break;
        } catch (thrownValue) {
            handleError(root3, thrownValue);
        }
        resetContextDependencies();
        popInteractions(prevInteractions);
        executionContext = prevExecutionContext;
        popDispatcher(prevDispatcher);
        if (workInProgress !== null) throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
        workInProgressRoot = null;
        workInProgressRootRenderLanes = NoLanes;
        return workInProgressRootExitStatus;
    } // The work loop is an extremely hot path. Tell Closure not to inline it.
    /** @noinline */ function workLoopSync() {
        // Already timed out, so perform work without checking if we need to yield.
        while(workInProgress !== null)performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root3, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
        // and prepare a fresh one. Otherwise we'll continue where we left off.
        if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
            resetRenderTimer();
            prepareFreshStack(root3, lanes);
            startWorkOnPendingInteractions(root3, lanes);
        }
        var prevInteractions = pushInteractions(root3);
        for(;;)try {
            workLoopConcurrent();
            break;
        } catch (thrownValue) {
            handleError(root3, thrownValue);
        }
        resetContextDependencies();
        popInteractions(prevInteractions);
        popDispatcher(prevDispatcher);
        executionContext = prevExecutionContext;
        if (workInProgress !== null) return RootIncomplete;
        else {
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes; // Return the final exit status.
            return workInProgressRootExitStatus;
        }
    }
    /** @noinline */ function workLoopConcurrent() {
        // Perform work until Scheduler asks us to yield
        while(workInProgress !== null && !shouldYield())performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
        // The current, flushed, state of this fiber is the alternate. Ideally
        // nothing should rely on this, but relying on it here means that we don't
        // need an additional field on the work in progress.
        var current5 = unitOfWork.alternate;
        setCurrentFiber(unitOfWork);
        var next;
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
            startProfilerTimer(unitOfWork);
            next = beginWork$1(current5, unitOfWork, subtreeRenderLanes);
            stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
        } else next = beginWork$1(current5, unitOfWork, subtreeRenderLanes);
        resetCurrentFiber();
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        if (next === null) // If this doesn't spawn new work, complete the current work.
        completeUnitOfWork(unitOfWork);
        else workInProgress = next;
        ReactCurrentOwner$2.current = null;
    }
    function completeUnitOfWork(unitOfWork) {
        // Attempt to complete the current unit of work, then move to the next
        // sibling. If there are no more siblings, return to the parent fiber.
        var completedWork = unitOfWork;
        do {
            // The current, flushed, state of this fiber is the alternate. Ideally
            // nothing should rely on this, but relying on it here means that we don't
            // need an additional field on the work in progress.
            var current5 = completedWork.alternate;
            var returnFiber = completedWork.return; // Check if the work completed or if something threw.
            if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) next = completeWork(current5, completedWork, subtreeRenderLanes);
                else {
                    startProfilerTimer(completedWork);
                    next = completeWork(current5, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.
                    stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next !== null) {
                    // Completing this fiber spawned new work. Work on that next.
                    workInProgress = next;
                    return;
                }
                resetChildLanes(completedWork);
                if (returnFiber !== null && (returnFiber.flags & Incomplete) === NoFlags) {
                    // Append all the effects of the subtree and this fiber onto the effect
                    // list of the parent. The completion order of the children affects the
                    // side-effect order.
                    if (returnFiber.firstEffect === null) returnFiber.firstEffect = completedWork.firstEffect;
                    if (completedWork.lastEffect !== null) {
                        if (returnFiber.lastEffect !== null) returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
                        returnFiber.lastEffect = completedWork.lastEffect;
                    } // If this fiber had side-effects, we append it AFTER the children's
                    // side-effects. We can perform certain side-effects earlier if needed,
                    // by doing multiple passes over the effect list. We don't want to
                    // schedule our own side-effect on our own list because if end up
                    // reusing children we'll schedule this effect onto itself since we're
                    // at the end.
                    var flags = completedWork.flags; // Skip both NoWork and PerformedWork tags when creating the effect
                    // list. PerformedWork effect is read by React DevTools but shouldn't be
                    // committed.
                    if (flags > PerformedWork) {
                        if (returnFiber.lastEffect !== null) returnFiber.lastEffect.nextEffect = completedWork;
                        else returnFiber.firstEffect = completedWork;
                        returnFiber.lastEffect = completedWork;
                    }
                }
            } else {
                // This fiber did not complete because something threw. Pop values off
                // the stack without entering the complete phase. If this is a boundary,
                // capture values if possible.
                var _next = unwindWork(completedWork); // Because this fiber did not complete, don't reset its expiration time.
                if (_next !== null) {
                    // If completing this work spawned new work, do that next. We'll come
                    // back here again.
                    // Since we're restarting, remove anything that is not a host effect
                    // from the effect tag.
                    _next.flags &= HostEffectMask;
                    workInProgress = _next;
                    return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                    // Record the render duration for the fiber that errored.
                    stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.
                    var actualDuration = completedWork.actualDuration;
                    var child = completedWork.child;
                    while(child !== null){
                        actualDuration += child.actualDuration;
                        child = child.sibling;
                    }
                    completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                    // Mark the parent fiber as incomplete and clear its effect list.
                    returnFiber.firstEffect = returnFiber.lastEffect = null;
                    returnFiber.flags |= Incomplete;
                }
            }
            var siblingFiber = completedWork.sibling;
            if (siblingFiber !== null) {
                // If there is more work to do in this returnFiber, do that next.
                workInProgress = siblingFiber;
                return;
            } // Otherwise, return to the parent
            completedWork = returnFiber; // Update the next thing we're working on in case something throws.
            workInProgress = completedWork;
        }while (completedWork !== null) // We've reached the root.
        if (workInProgressRootExitStatus === RootIncomplete) workInProgressRootExitStatus = RootCompleted;
    }
    function resetChildLanes(completedWork) {
        if (// to switch statement in `completeWork`.
        (completedWork.tag === LegacyHiddenComponent || completedWork.tag === OffscreenComponent) && completedWork.memoizedState !== null && !includesSomeLane(subtreeRenderLanes, OffscreenLane) && (completedWork.mode & ConcurrentMode) !== NoLanes) // The children of this component are hidden. Don't bubble their
        // expiration times.
        return;
        var newChildLanes = NoLanes; // Bubble up the earliest expiration time.
        if ((completedWork.mode & ProfileMode) !== NoMode) {
            // In profiling mode, resetChildExpirationTime is also used to reset
            // profiler durations.
            var actualDuration = completedWork.actualDuration;
            var treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will
            // only be updated if work is done on the fiber (i.e. it doesn't bailout).
            // When work is done, it should bubble to the parent's actualDuration. If
            // the fiber has not been cloned though, (meaning no work was done), then
            // this value will reflect the amount of time spent working on a previous
            // render. In that case it should not bubble. We determine whether it was
            // cloned by comparing the child pointer.
            var shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;
            var child = completedWork.child;
            while(child !== null){
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                if (shouldBubbleActualDurations) actualDuration += child.actualDuration;
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
            }
            var isTimedOutSuspense = completedWork.tag === SuspenseComponent && completedWork.memoizedState !== null;
            if (isTimedOutSuspense) {
                // Don't count time spent in a timed out Suspense subtree as part of the base duration.
                var primaryChildFragment = completedWork.child;
                if (primaryChildFragment !== null) treeBaseDuration -= primaryChildFragment.treeBaseDuration;
            }
            completedWork.actualDuration = actualDuration;
            completedWork.treeBaseDuration = treeBaseDuration;
        } else {
            var _child = completedWork.child;
            while(_child !== null){
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                _child = _child.sibling;
            }
        }
        completedWork.childLanes = newChildLanes;
    }
    function commitRoot(root3) {
        var renderPriorityLevel = getCurrentPriorityLevel();
        runWithPriority$1(ImmediatePriority$1, commitRootImpl.bind(null, root3, renderPriorityLevel));
        return null;
    }
    function commitRootImpl(root3, renderPriorityLevel) {
        do // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
        // means `flushPassiveEffects` will sometimes result in additional
        // passive effects. So we need to keep flushing in a loop until there are
        // no more pending effects.
        // TODO: Might be better if `flushPassiveEffects` did not automatically
        // flush synchronous work at the end, to avoid factoring hazards like this.
        flushPassiveEffects();
        while (rootWithPendingPassiveEffects !== null)
        flushRenderPhaseStrictModeWarningsInDEV();
        if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) throw Error("Should not already be working.");
        var finishedWork = root3.finishedWork;
        var lanes = root3.finishedLanes;
        if (finishedWork === null) return null;
        root3.finishedWork = null;
        root3.finishedLanes = NoLanes;
        if (!(finishedWork !== root3.current)) throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
         // commitRoot never returns a continuation; it always finishes synchronously.
        // So we can clear these now to allow a new callback to be scheduled.
        root3.callbackNode = null; // Update the first and last pending times on this root. The new first
        // pending time is whatever is left on the root fiber.
        var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
        markRootFinished(root3, remainingLanes); // Clear already finished discrete updates in case that a later call of
        // `flushDiscreteUpdates` starts a useless render pass which may cancels
        // a scheduled timeout.
        if (rootsWithPendingDiscreteUpdates !== null) {
            if (!hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root3)) rootsWithPendingDiscreteUpdates.delete(root3);
        }
        if (root3 === workInProgressRoot) {
            // We can reset these now that they are finished.
            workInProgressRoot = null;
            workInProgress = null;
            workInProgressRootRenderLanes = NoLanes;
        } // Get the list of effects.
        var firstEffect;
        if (finishedWork.flags > PerformedWork) {
            // A fiber's effect list consists only of its children, not itself. So if
            // the root has an effect, we need to add it to the end of the list. The
            // resulting list is the set that would belong to the root's parent, if it
            // had one; that is, all the effects in the tree including the root.
            if (finishedWork.lastEffect !== null) {
                finishedWork.lastEffect.nextEffect = finishedWork;
                firstEffect = finishedWork.firstEffect;
            } else firstEffect = finishedWork;
        } else // There is no effect on the root.
        firstEffect = finishedWork.firstEffect;
        if (firstEffect !== null) {
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            var prevInteractions = pushInteractions(root3); // Reset this to null before calling lifecycles
            ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass
            // of the effect list for each phase: all mutation effects come before all
            // layout effects, and so on.
            // The first phase a "before mutation" phase. We use this phase to read the
            // state of the host tree right before we mutate it. This is where
            // getSnapshotBeforeUpdate is called.
            focusedInstanceHandle = prepareForCommit(root3.containerInfo);
            shouldFireAfterActiveInstanceBlur = false;
            nextEffect = firstEffect;
            do {
                invokeGuardedCallback(null, commitBeforeMutationEffects, null);
                if (hasCaughtError()) {
                    if (!(nextEffect !== null)) throw Error("Should be working on an effect.");
                    var error5 = clearCaughtError();
                    captureCommitPhaseError(nextEffect, error5);
                    nextEffect = nextEffect.nextEffect;
                }
            }while (nextEffect !== null) // We no longer need to track the active instance fiber
            focusedInstanceHandle = null;
            // Mark the current commit time to be shared by all Profilers in this
            // batch. This enables them to be grouped later.
            recordCommitTime();
            nextEffect = firstEffect;
            do {
                invokeGuardedCallback(null, commitMutationEffects, null, root3, renderPriorityLevel);
                if (hasCaughtError()) {
                    if (!(nextEffect !== null)) throw Error("Should be working on an effect.");
                    var _error = clearCaughtError();
                    captureCommitPhaseError(nextEffect, _error);
                    nextEffect = nextEffect.nextEffect;
                }
            }while (nextEffect !== null)
            resetAfterCommit(root3.containerInfo); // The work-in-progress tree is now the current tree. This must come after
            // the mutation phase, so that the previous tree is still current during
            // componentWillUnmount, but before the layout phase, so that the finished
            // work is current during componentDidMount/Update.
            root3.current = finishedWork; // The next phase is the layout phase, where we call effects that read
            // the host tree after it's been mutated. The idiomatic use case for this is
            // layout, but class component lifecycles also fire here for legacy reasons.
            nextEffect = firstEffect;
            do {
                invokeGuardedCallback(null, commitLayoutEffects, null, root3, lanes);
                if (hasCaughtError()) {
                    if (!(nextEffect !== null)) throw Error("Should be working on an effect.");
                    var _error2 = clearCaughtError();
                    captureCommitPhaseError(nextEffect, _error2);
                    nextEffect = nextEffect.nextEffect;
                }
            }while (nextEffect !== null)
            nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an
            // opportunity to paint.
            requestPaint();
            popInteractions(prevInteractions);
            executionContext = prevExecutionContext;
        } else {
            // No effects.
            root3.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were
            recordCommitTime();
        }
        var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
        if (rootDoesHavePassiveEffects) {
            // This commit has passive effects. Stash a reference to them. But don't
            // schedule a callback until after flushing layout work.
            rootDoesHavePassiveEffects = false;
            rootWithPendingPassiveEffects = root3;
            pendingPassiveEffectsLanes = lanes;
            pendingPassiveEffectsRenderPriority = renderPriorityLevel;
        } else {
            // We are done with the effect chain at this point so let's clear the
            // nextEffect pointers to assist with GC. If we have passive effects, we'll
            // clear this in flushPassiveEffects.
            nextEffect = firstEffect;
            while(nextEffect !== null){
                var nextNextEffect = nextEffect.nextEffect;
                nextEffect.nextEffect = null;
                if (nextEffect.flags & Deletion) detachFiberAfterEffects(nextEffect);
                nextEffect = nextNextEffect;
            }
        } // Read this again, since an effect might have updated it
        remainingLanes = root3.pendingLanes; // Check if there's remaining work on this root
        if (remainingLanes !== NoLanes) {
            if (spawnedWorkDuringRender !== null) {
                var expirationTimes = spawnedWorkDuringRender;
                spawnedWorkDuringRender = null;
                for(var i = 0; i < expirationTimes.length; i++)scheduleInteractions(root3, expirationTimes[i], root3.memoizedInteractions);
            }
            schedulePendingInteractions(root3, remainingLanes);
        } else // If there's no remaining work, we can clear the set of already failed
        // error boundaries.
        legacyErrorBoundariesThatAlreadyFailed = null;
        if (!rootDidHavePassiveEffects) // If there are no passive effects, then we can complete the pending interactions.
        // Otherwise, we'll wait until after the passive effects are flushed.
        // Wait to do this until after remaining work has been scheduled,
        // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
        finishPendingInteractions(root3, lanes);
        if (remainingLanes === SyncLane) {
            // Count the number of times the root synchronously re-renders without
            // finishing. If there are too many, it indicates an infinite update loop.
            if (root3 === rootWithNestedUpdates) nestedUpdateCount++;
            else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root3;
            }
        } else nestedUpdateCount = 0;
        onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
        onCommitRoot$1();
        // additional work on this root is scheduled.
        ensureRootIsScheduled(root3, now());
        if (hasUncaughtError) {
            hasUncaughtError = false;
            var _error3 = firstUncaughtError;
            firstUncaughtError = null;
            throw _error3;
        }
        if ((executionContext & LegacyUnbatchedContext) !== NoContext) // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
        // synchronously, but layout updates should be deferred until the end
        // of the batch.
        return null;
         // If layout work was scheduled, flush it now.
        flushSyncCallbackQueue();
        return null;
    }
    function commitBeforeMutationEffects() {
        while(nextEffect !== null){
            var current6 = nextEffect.alternate;
            if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
                if ((nextEffect.flags & Deletion) !== NoFlags) {
                    if (doesFiberContain(nextEffect, focusedInstanceHandle)) shouldFireAfterActiveInstanceBlur = true;
                } else // TODO: Move this out of the hot path using a dedicated effect tag.
                if (nextEffect.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current6, nextEffect) && doesFiberContain(nextEffect, focusedInstanceHandle)) shouldFireAfterActiveInstanceBlur = true;
            }
            var flags = nextEffect.flags;
            if ((flags & Snapshot) !== NoFlags) {
                setCurrentFiber(nextEffect);
                commitBeforeMutationLifeCycles(current6, nextEffect);
                resetCurrentFiber();
            }
            if ((flags & Passive) !== NoFlags) // If there are passive effects, schedule a callback to flush at
            // the earliest opportunity.
            {
                if (!rootDoesHavePassiveEffects) {
                    rootDoesHavePassiveEffects = true;
                    scheduleCallback(NormalPriority$1, function() {
                        flushPassiveEffects();
                        return null;
                    });
                }
            }
            nextEffect = nextEffect.nextEffect;
        }
    }
    function commitMutationEffects(root3, renderPriorityLevel) {
        // TODO: Should probably move the bulk of this function to commitWork.
        while(nextEffect !== null){
            setCurrentFiber(nextEffect);
            var flags = nextEffect.flags;
            if (flags & ContentReset) commitResetTextContent(nextEffect);
            if (flags & Ref) {
                var current7 = nextEffect.alternate;
                if (current7 !== null) commitDetachRef(current7);
            } // The following switch statement is only concerned about placement,
            // updates, and deletions. To avoid needing to add a case for every possible
            // bitmap value, we remove the secondary effects from the effect tag and
            // switch on that value.
            var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);
            switch(primaryFlags){
                case Placement:
                    commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
                    // inserted, before any life-cycles like componentDidMount gets called.
                    // TODO: findDOMNode doesn't rely on this any more but isMounted does
                    // and isMounted is deprecated anyway so we should be able to kill this.
                    nextEffect.flags &= ~Placement;
                    break;
                case PlacementAndUpdate:
                    // Placement
                    commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
                    // inserted, before any life-cycles like componentDidMount gets called.
                    nextEffect.flags &= ~Placement; // Update
                    var _current = nextEffect.alternate;
                    commitWork(_current, nextEffect);
                    break;
                case Hydrating:
                    nextEffect.flags &= ~Hydrating;
                    break;
                case HydratingAndUpdate:
                    nextEffect.flags &= ~Hydrating; // Update
                    var _current2 = nextEffect.alternate;
                    commitWork(_current2, nextEffect);
                    break;
                case Update:
                    var _current3 = nextEffect.alternate;
                    commitWork(_current3, nextEffect);
                    break;
                case Deletion:
                    commitDeletion(root3, nextEffect);
                    break;
            }
            resetCurrentFiber();
            nextEffect = nextEffect.nextEffect;
        }
    }
    function commitLayoutEffects(root3, committedLanes) {
        while(nextEffect !== null){
            setCurrentFiber(nextEffect);
            var flags = nextEffect.flags;
            if (flags & (Update | Callback)) {
                var current8 = nextEffect.alternate;
                commitLifeCycles(root3, current8, nextEffect);
            }
            if (flags & Ref) commitAttachRef(nextEffect);
            resetCurrentFiber();
            nextEffect = nextEffect.nextEffect;
        }
    }
    function flushPassiveEffects() {
        // Returns whether passive effects were flushed.
        if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
            var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority$1 ? NormalPriority$1 : pendingPassiveEffectsRenderPriority;
            pendingPassiveEffectsRenderPriority = NoPriority$1;
            return runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);
        }
        return false;
    }
    function enqueuePendingPassiveHookEffectMount(fiber, effect) {
        pendingPassiveHookEffectsMount.push(effect, fiber);
        if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            scheduleCallback(NormalPriority$1, function() {
                flushPassiveEffects();
                return null;
            });
        }
    }
    function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
        pendingPassiveHookEffectsUnmount.push(effect, fiber);
        fiber.flags |= PassiveUnmountPendingDev;
        var alternate = fiber.alternate;
        if (alternate !== null) alternate.flags |= PassiveUnmountPendingDev;
        if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            scheduleCallback(NormalPriority$1, function() {
                flushPassiveEffects();
                return null;
            });
        }
    }
    function invokePassiveEffectCreate(effect) {
        var create = effect.create;
        effect.destroy = create();
    }
    function flushPassiveEffectsImpl() {
        if (rootWithPendingPassiveEffects === null) return false;
        var root3 = rootWithPendingPassiveEffects;
        var lanes = pendingPassiveEffectsLanes;
        rootWithPendingPassiveEffects = null;
        pendingPassiveEffectsLanes = NoLanes;
        if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) throw Error("Cannot flush passive effects while already rendering.");
        isFlushingPassiveEffects = true;
        var prevExecutionContext = executionContext;
        executionContext |= CommitContext;
        var prevInteractions = pushInteractions(root3); // It's important that ALL pending passive effect destroy functions are called
        // before ANY passive effect create functions are called.
        // Otherwise effects in sibling components might interfere with each other.
        // e.g. a destroy function in one component may unintentionally override a ref
        // value set by a create function in another component.
        // Layout effects have the same constraint.
        // First pass: Destroy stale passive effects.
        var unmountEffects = pendingPassiveHookEffectsUnmount;
        pendingPassiveHookEffectsUnmount = [];
        for(var i = 0; i < unmountEffects.length; i += 2){
            var _effect = unmountEffects[i];
            var fiber = unmountEffects[i + 1];
            var destroy = _effect.destroy;
            _effect.destroy = undefined;
            fiber.flags &= ~PassiveUnmountPendingDev;
            var alternate = fiber.alternate;
            if (alternate !== null) alternate.flags &= ~PassiveUnmountPendingDev;
            if (typeof destroy === 'function') {
                setCurrentFiber(fiber);
                invokeGuardedCallback(null, destroy, null);
                if (hasCaughtError()) {
                    if (!(fiber !== null)) throw Error("Should be working on an effect.");
                    var error6 = clearCaughtError();
                    captureCommitPhaseError(fiber, error6);
                }
                resetCurrentFiber();
            }
        } // Second pass: Create new passive effects.
        var mountEffects = pendingPassiveHookEffectsMount;
        pendingPassiveHookEffectsMount = [];
        for(var _i = 0; _i < mountEffects.length; _i += 2){
            var _effect2 = mountEffects[_i];
            var _fiber = mountEffects[_i + 1];
            setCurrentFiber(_fiber);
            invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);
            if (hasCaughtError()) {
                if (!(_fiber !== null)) throw Error("Should be working on an effect.");
                var _error4 = clearCaughtError();
                captureCommitPhaseError(_fiber, _error4);
            }
            resetCurrentFiber();
        } // Note: This currently assumes there are no passive effects on the root fiber
        // because the root is not part of its own effect list.
        // This could change in the future.
        var effect = root3.current.firstEffect;
        while(effect !== null){
            var nextNextEffect = effect.nextEffect; // Remove nextEffect pointer to assist GC
            effect.nextEffect = null;
            if (effect.flags & Deletion) detachFiberAfterEffects(effect);
            effect = nextNextEffect;
        }
        popInteractions(prevInteractions);
        finishPendingInteractions(root3, lanes);
        isFlushingPassiveEffects = false;
        executionContext = prevExecutionContext;
        flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this
        // exceeds the limit, we'll fire a warning.
        nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
        return true;
    }
    function isAlreadyFailedLegacyErrorBoundary(instance) {
        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
    }
    function markLegacyErrorBoundaryAsFailed(instance) {
        if (legacyErrorBoundariesThatAlreadyFailed === null) legacyErrorBoundariesThatAlreadyFailed = new Set([
            instance
        ]);
        else legacyErrorBoundariesThatAlreadyFailed.add(instance);
    }
    function prepareToThrowUncaughtError(error7) {
        if (!hasUncaughtError) {
            hasUncaughtError = true;
            firstUncaughtError = error7;
        }
    }
    var onUncaughtError = prepareToThrowUncaughtError;
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error7) {
        var errorInfo = createCapturedValue(error7, sourceFiber);
        var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
        enqueueUpdate(rootFiber, update);
        var eventTime = requestEventTime();
        var root3 = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);
        if (root3 !== null) {
            markRootUpdated(root3, SyncLane, eventTime);
            ensureRootIsScheduled(root3, eventTime);
            schedulePendingInteractions(root3, SyncLane);
        }
    }
    function captureCommitPhaseError(sourceFiber, error7) {
        if (sourceFiber.tag === HostRoot) {
            // Error was thrown at the root. There is no parent, so the root
            // itself should capture it.
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error7);
            return;
        }
        var fiber = sourceFiber.return;
        while(fiber !== null){
            if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error7);
                return;
            } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                    var errorInfo = createCapturedValue(error7, sourceFiber);
                    var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                    enqueueUpdate(fiber, update);
                    var eventTime = requestEventTime();
                    var root3 = markUpdateLaneFromFiberToRoot(fiber, SyncLane);
                    if (root3 !== null) {
                        markRootUpdated(root3, SyncLane, eventTime);
                        ensureRootIsScheduled(root3, eventTime);
                        schedulePendingInteractions(root3, SyncLane);
                    } else {
                        // This component has already been unmounted.
                        // We can't schedule any follow up work for the root because the fiber is already unmounted,
                        // but we can still call the log-only boundary so the error isn't swallowed.
                        //
                        // TODO This is only a temporary bandaid for the old reconciler fork.
                        // We can delete this special case once the new fork is merged.
                        if (typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) try {
                            instance.componentDidCatch(error7, errorInfo);
                        } catch (errorToIgnore) {
                        // This is kind of an edge case.
                        }
                    }
                    return;
                }
            }
            fiber = fiber.return;
        }
    }
    function pingSuspendedRoot(root4, wakeable, pingedLanes) {
        var pingCache = root4.pingCache;
        if (pingCache !== null) // The wakeable resolved, so we no longer need to memoize, because it will
        // never be thrown again.
        pingCache.delete(wakeable);
        var eventTime = requestEventTime();
        markRootPinged(root4, pingedLanes);
        if (workInProgressRoot === root4 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
            // Received a ping at the same priority level at which we're currently
            // rendering. We might want to restart this render. This should mirror
            // the logic of whether or not a root suspends once it completes.
            // TODO: If we're rendering sync either due to Sync, Batched or expired,
            // we should probably never restart.
            // If we're suspended with delay, or if it's a retry, we'll always suspend
            // so we can always restart.
            if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) // Restart from the root.
            prepareFreshStack(root4, NoLanes);
            else // Even though we can't restart right now, we might get an
            // opportunity later. So we mark this render as having a ping.
            workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
        }
        ensureRootIsScheduled(root4, eventTime);
        schedulePendingInteractions(root4, pingedLanes);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
        // The boundary fiber (a Suspense component or SuspenseList component)
        // previously was rendered in its fallback state. One of the promises that
        // suspended it has resolved, which means at least part of the tree was
        // likely unblocked. Try rendering again, at a new expiration time.
        if (retryLane === NoLane) retryLane = requestRetryLane(boundaryFiber);
         // TODO: Special case idle priority?
        var eventTime = requestEventTime();
        var root4 = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);
        if (root4 !== null) {
            markRootUpdated(root4, retryLane, eventTime);
            ensureRootIsScheduled(root4, eventTime);
            schedulePendingInteractions(root4, retryLane);
        }
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = NoLane; // Default
        var retryCache;
        retryCache = boundaryFiber.stateNode;
        if (retryCache !== null) // The wakeable resolved, so we no longer need to memoize, because it will
        // never be thrown again.
        retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
    } // Computes the next Just Noticeable Difference (JND) boundary.
    // The theory is that a person can't tell the difference between small differences in time.
    // Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
    // difference in the experience. However, waiting for longer might mean that we can avoid
    // showing an intermediate loading state. The longer we have already waited, the harder it
    // is to tell small differences in time. Therefore, the longer we've already waited,
    // the longer we can wait additionally. At some point we have to give up though.
    // We pick a train model where the next boundary commits at a consistent schedule.
    // These particular numbers are vague estimates. We expect to adjust them based on research.
    function jnd(timeElapsed) {
        return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
    }
    function checkForNestedUpdates() {
        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = null;
            throw Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
        }
        if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
            nestedPassiveUpdateCount = 0;
            error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
        }
    }
    function flushRenderPhaseStrictModeWarningsInDEV() {
        ReactStrictModeWarnings.flushLegacyContextWarning();
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
    }
    var didWarnStateUpdateForNotYetMountedComponent = null;
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
        if ((executionContext & RenderContext) !== NoContext) // We let the other warning about render phase updates deal with this one.
        return;
        if (!(fiber.mode & (BlockingMode | ConcurrentMode))) return;
        var tag = fiber.tag;
        if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) // Only warn for user-defined components, not internal ones like Suspense.
        return;
         // We show the whole stack but dedupe on the top component's name because
        // the problematic code almost always lies inside that component.
        var componentName = getComponentName(fiber.type) || 'ReactComponent';
        if (didWarnStateUpdateForNotYetMountedComponent !== null) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) return;
            didWarnStateUpdateForNotYetMountedComponent.add(componentName);
        } else didWarnStateUpdateForNotYetMountedComponent = new Set([
            componentName
        ]);
        var previousFiber = current;
        try {
            setCurrentFiber(fiber);
            error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally{
            if (previousFiber) setCurrentFiber(fiber);
            else resetCurrentFiber();
        }
    }
    var didWarnStateUpdateForUnmountedComponent = null;
    function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
        var tag = fiber.tag;
        if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) // Only warn for user-defined components, not internal ones like Suspense.
        return;
         // If there are pending passive effects unmounts for this Fiber,
        // we can assume that they would have prevented this update.
        if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) return;
         // We show the whole stack but dedupe on the top component's name because
        // the problematic code almost always lies inside that component.
        var componentName = getComponentName(fiber.type) || 'ReactComponent';
        if (didWarnStateUpdateForUnmountedComponent !== null) {
            if (didWarnStateUpdateForUnmountedComponent.has(componentName)) return;
            didWarnStateUpdateForUnmountedComponent.add(componentName);
        } else didWarnStateUpdateForUnmountedComponent = new Set([
            componentName
        ]);
        if (isFlushingPassiveEffects) ;
        else {
            var previousFiber = current;
            try {
                setCurrentFiber(fiber);
                error("Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in %s.", tag === ClassComponent ? 'the componentWillUnmount method' : 'a useEffect cleanup function');
            } finally{
                if (previousFiber) setCurrentFiber(fiber);
                else resetCurrentFiber();
            }
        }
    }
    var beginWork$1;
    var dummyFiber = null;
    beginWork$1 = function(current9, unitOfWork, lanes) {
        // If a component throws an error, we replay it again in a synchronously
        // dispatched event, so that the debugger will treat it as an uncaught
        // error See ReactErrorUtils for more information.
        // Before entering the begin phase, copy the work-in-progress onto a dummy
        // fiber. If beginWork throws, we'll use this to reset the state.
        var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
        try {
            return beginWork(current9, unitOfWork, lanes);
        } catch (originalError) {
            if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') // Don't replay promises. Treat everything else like an error.
            throw originalError;
             // Keep this code in sync with handleError; any changes here must have
            // corresponding changes there.
            resetContextDependencies();
            resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the
            // same fiber again.
            // Unwind the failed stack frame
            unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.
            assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
            if (unitOfWork.mode & ProfileMode) // Reset the profiler timer.
            startProfilerTimer(unitOfWork);
             // Run beginWork again.
            invokeGuardedCallback(null, beginWork, null, current9, unitOfWork, lanes);
            if (hasCaughtError()) {
                var replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
                // Rethrow this error instead of the original one.
                throw replayError;
            } else // This branch is reachable if the render phase is impure.
            throw originalError;
        }
    };
    var didWarnAboutUpdateInRender = false;
    var didWarnAboutUpdateInRenderForAnotherComponent;
    didWarnAboutUpdateInRenderForAnotherComponent = new Set();
    function warnAboutRenderPhaseUpdatesInDEV(fiber) {
        if (isRendering && (executionContext & RenderContext) !== NoContext && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) switch(fiber.tag){
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent:
                var renderingComponentName = workInProgress && getComponentName(workInProgress.type) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.
                var dedupeKey = renderingComponentName;
                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                    var setStateComponentName = getComponentName(fiber.type) || 'Unknown';
                    error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                }
                break;
            case ClassComponent:
                if (!didWarnAboutUpdateInRender) {
                    error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                    didWarnAboutUpdateInRender = true;
                }
                break;
        }
    } // a 'shared' variable that changes when act() opens/closes in tests.
    var IsThisRendererActing = {
        current: false
    };
    function warnIfNotScopedWithMatchingAct(fiber) {
        if (IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {
            var previousFiber = current;
            try {
                setCurrentFiber(fiber);
                error("It looks like you're using the wrong act() around your test interactions.\nBe sure to use the matching version of act() corresponding to your renderer:\n\n// for react-dom:\nimport {act} from 'react-dom/test-utils';\n// ...\nact(() => ...);\n\n// for react-test-renderer:\nimport TestRenderer from react-test-renderer';\nconst {act} = TestRenderer;\n// ...\nact(() => ...);");
            } finally{
                if (previousFiber) setCurrentFiber(fiber);
                else resetCurrentFiber();
            }
        }
    }
    function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
        if ((fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) error("An update to %s ran an effect, but was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentName(fiber.type));
    }
    function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
        if (executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
            var previousFiber = current;
            try {
                setCurrentFiber(fiber);
                error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentName(fiber.type));
            } finally{
                if (previousFiber) setCurrentFiber(fiber);
                else resetCurrentFiber();
            }
        }
    }
    var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.
    var didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked
    // scheduler is the actual recommendation. The alternative could be a testing build,
    // a new lib, or whatever; we dunno just yet. This message is for early adopters
    // to get their tests right.
    function warnIfUnmockedScheduler(fiber) {
        if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === undefined) {
            if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
                didWarnAboutUnmockedScheduler = true;
                error("In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked to guarantee consistent behaviour across tests and browsers. For example, with jest: \njest.mock('scheduler', () => require('scheduler/unstable_mock'));\n\nFor more info, visit https://reactjs.org/link/mock-scheduler");
            }
        }
    }
    function computeThreadID(root4, lane) {
        // Interaction threads are unique per root and expiration time.
        // NOTE: Intentionally unsound cast. All that matters is that it's a number
        // and it represents a batch of work. Could make a helper function instead,
        // but meh this is fine for now.
        return lane * 1000 + root4.interactionThreadID;
    }
    function markSpawnedWork(lane) {
        if (spawnedWorkDuringRender === null) spawnedWorkDuringRender = [
            lane
        ];
        else spawnedWorkDuringRender.push(lane);
    }
    function scheduleInteractions(root4, lane, interactions) {
        if (interactions.size > 0) {
            var pendingInteractionMap = root4.pendingInteractionMap;
            var pendingInteractions = pendingInteractionMap.get(lane);
            if (pendingInteractions != null) interactions.forEach(function(interaction) {
                if (!pendingInteractions.has(interaction)) // Update the pending async work count for previously unscheduled interaction.
                interaction.__count++;
                pendingInteractions.add(interaction);
            });
            else {
                pendingInteractionMap.set(lane, new Set(interactions)); // Update the pending async work count for the current interactions.
                interactions.forEach(function(interaction) {
                    interaction.__count++;
                });
            }
            var subscriber = tracing.__subscriberRef.current;
            if (subscriber !== null) {
                var threadID = computeThreadID(root4, lane);
                subscriber.onWorkScheduled(interactions, threadID);
            }
        }
    }
    function schedulePendingInteractions(root4, lane) {
        scheduleInteractions(root4, lane, tracing.__interactionsRef.current);
    }
    function startWorkOnPendingInteractions(root4, lanes) {
        // we can accurately attribute time spent working on it, And so that cascading
        // work triggered during the render phase will be associated with it.
        var interactions = new Set();
        root4.pendingInteractionMap.forEach(function(scheduledInteractions, scheduledLane) {
            if (includesSomeLane(lanes, scheduledLane)) scheduledInteractions.forEach(function(interaction) {
                return interactions.add(interaction);
            });
        }); // Store the current set of interactions on the FiberRoot for a few reasons:
        // We can re-use it in hot functions like performConcurrentWorkOnRoot()
        // without having to recalculate it. We will also use it in commitWork() to
        // pass to any Profiler onRender() hooks. This also provides DevTools with a
        // way to access it when the onCommitRoot() hook is called.
        root4.memoizedInteractions = interactions;
        if (interactions.size > 0) {
            var subscriber = tracing.__subscriberRef.current;
            if (subscriber !== null) {
                var threadID = computeThreadID(root4, lanes);
                try {
                    subscriber.onWorkStarted(interactions, threadID);
                } catch (error7) {
                    // If the subscriber throws, rethrow it in a separate task
                    scheduleCallback(ImmediatePriority$1, function() {
                        throw error7;
                    });
                }
            }
        }
    }
    function finishPendingInteractions(root4, committedLanes) {
        var remainingLanesAfterCommit = root4.pendingLanes;
        var subscriber;
        try {
            subscriber = tracing.__subscriberRef.current;
            if (subscriber !== null && root4.memoizedInteractions.size > 0) {
                // FIXME: More than one lane can finish in a single commit.
                var threadID = computeThreadID(root4, committedLanes);
                subscriber.onWorkStopped(root4.memoizedInteractions, threadID);
            }
        } catch (error7) {
            // If the subscriber throws, rethrow it in a separate task
            scheduleCallback(ImmediatePriority$1, function() {
                throw error7;
            });
        } finally{
            // Clear completed interactions from the pending Map.
            // Unless the render was suspended or cascading work was scheduled,
            // In which case– leave pending interactions until the subsequent render.
            var pendingInteractionMap = root4.pendingInteractionMap;
            pendingInteractionMap.forEach(function(scheduledInteractions, lane) {
                // Only decrement the pending interaction count if we're done.
                // If there's still work at the current priority,
                // That indicates that we are waiting for suspense data.
                if (!includesSomeLane(remainingLanesAfterCommit, lane)) {
                    pendingInteractionMap.delete(lane);
                    scheduledInteractions.forEach(function(interaction) {
                        interaction.__count--;
                        if (subscriber !== null && interaction.__count === 0) try {
                            subscriber.onInteractionScheduledWorkCompleted(interaction);
                        } catch (error7) {
                            // If the subscriber throws, rethrow it in a separate task
                            scheduleCallback(ImmediatePriority$1, function() {
                                throw error7;
                            });
                        }
                    });
                }
            });
        }
    } // `act` testing API
    function shouldForceFlushFallbacksInDEV() {
        // Never force flush in production. This function should get stripped out.
        return actingUpdatesScopeDepth > 0;
    }
    // so we can tell if any async act() calls try to run in parallel.
    var actingUpdatesScopeDepth = 0;
    function detachFiberAfterEffects(fiber) {
        fiber.sibling = null;
        fiber.stateNode = null;
    }
    var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.
    var failedBoundaries = null;
    var setRefreshHandler = function(handler) {
        resolveFamily = handler;
    };
    function resolveFunctionForHotReloading(type) {
        if (resolveFamily === null) // Hot reloading is disabled.
        return type;
        var family = resolveFamily(type);
        if (family === undefined) return type;
         // Use the latest known implementation.
        return family.current;
    }
    function resolveClassForHotReloading(type) {
        // No implementation differences.
        return resolveFunctionForHotReloading(type);
    }
    function resolveForwardRefForHotReloading(type) {
        if (resolveFamily === null) // Hot reloading is disabled.
        return type;
        var family = resolveFamily(type);
        if (family === undefined) {
            // Check if we're dealing with a real forwardRef. Don't want to crash early.
            if (type !== null && type !== undefined && typeof type.render === 'function') {
                // ForwardRef is special because its resolved .type is an object,
                // but it's possible that we only have its inner render function in the map.
                // If that inner render function is different, we'll build a new forwardRef type.
                var currentRender = resolveFunctionForHotReloading(type.render);
                if (type.render !== currentRender) {
                    var syntheticType = {
                        $$typeof: REACT_FORWARD_REF_TYPE,
                        render: currentRender
                    };
                    if (type.displayName !== undefined) syntheticType.displayName = type.displayName;
                    return syntheticType;
                }
            }
            return type;
        } // Use the latest known implementation.
        return family.current;
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
        if (resolveFamily === null) // Hot reloading is disabled.
        return false;
        var prevType = fiber.elementType;
        var nextType = element.type; // If we got here, we know types aren't === equal.
        var needsCompareFamilies = false;
        var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;
        switch(fiber.tag){
            case ClassComponent:
                if (typeof nextType === 'function') needsCompareFamilies = true;
                break;
            case FunctionComponent:
                if (typeof nextType === 'function') needsCompareFamilies = true;
                else if ($$typeofNextType === REACT_LAZY_TYPE) // We don't know the inner type yet.
                // We're going to assume that the lazy inner type is stable,
                // and so it is sufficient to avoid reconciling it away.
                // We're not going to unwrap or actually use the new lazy type.
                needsCompareFamilies = true;
                break;
            case ForwardRef:
                if ($$typeofNextType === REACT_FORWARD_REF_TYPE) needsCompareFamilies = true;
                else if ($$typeofNextType === REACT_LAZY_TYPE) needsCompareFamilies = true;
                break;
            case MemoComponent:
            case SimpleMemoComponent:
                if ($$typeofNextType === REACT_MEMO_TYPE) // TODO: if it was but can no longer be simple,
                // we shouldn't set this.
                needsCompareFamilies = true;
                else if ($$typeofNextType === REACT_LAZY_TYPE) needsCompareFamilies = true;
                break;
            default:
                return false;
        } // Check if both types have a family and it's the same one.
        if (needsCompareFamilies) {
            // Note: memo() and forwardRef() we'll compare outer rather than inner type.
            // This means both of them need to be registered to preserve state.
            // If we unwrapped and compared the inner types for wrappers instead,
            // then we would risk falsely saying two separate memo(Foo)
            // calls are equivalent because they wrap the same Foo function.
            var prevFamily = resolveFamily(prevType);
            if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) return true;
        }
        return false;
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
        if (resolveFamily === null) // Hot reloading is disabled.
        return;
        if (typeof WeakSet !== 'function') return;
        if (failedBoundaries === null) failedBoundaries = new WeakSet();
        failedBoundaries.add(fiber);
    }
    var scheduleRefresh = function(root4, update) {
        if (resolveFamily === null) // Hot reloading is disabled.
        return;
        var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
        flushPassiveEffects();
        flushSync(function() {
            scheduleFibersWithFamiliesRecursively(root4.current, updatedFamilies, staleFamilies);
        });
    };
    var scheduleRoot = function(root4, element) {
        if (root4.context !== emptyContextObject) // Super edge case: root has a legacy _renderSubtree context
        // but we don't know the parentComponent so we can't pass it.
        // Just ignore. We'll delete this with _renderSubtree code path later.
        return;
        flushPassiveEffects();
        flushSync(function() {
            updateContainer(element, root4, null, null);
        });
    };
    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
        var candidateType = null;
        switch(tag){
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
                candidateType = type;
                break;
            case ForwardRef:
                candidateType = type.render;
                break;
        }
        if (resolveFamily === null) throw new Error('Expected resolveFamily to be set during hot reload.');
        var needsRender = false;
        var needsRemount = false;
        if (candidateType !== null) {
            var family = resolveFamily(candidateType);
            if (family !== undefined) {
                if (staleFamilies.has(family)) needsRemount = true;
                else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) needsRemount = true;
                    else needsRender = true;
                }
            }
        }
        if (failedBoundaries !== null) {
            if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) needsRemount = true;
        }
        if (needsRemount) fiber._debugNeedsRemount = true;
        if (needsRemount || needsRender) scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
        if (child !== null && !needsRemount) scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
        if (sibling !== null) scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
    }
    var findHostInstancesForRefresh = function(root4, families) {
        var hostInstances = new Set();
        var types = new Set(families.map(function(family) {
            return family.current;
        }));
        findHostInstancesForMatchingFibersRecursively(root4.current, types, hostInstances);
        return hostInstances;
    };
    function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
        var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
        var candidateType = null;
        switch(tag){
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
                candidateType = type;
                break;
            case ForwardRef:
                candidateType = type.render;
                break;
        }
        var didMatch = false;
        if (candidateType !== null) {
            if (types.has(candidateType)) didMatch = true;
        }
        if (didMatch) // We have a match. This only drills down to the closest host components.
        // There's no need to search deeper because for the purpose of giving
        // visual feedback, "flashing" outermost parent rectangles is sufficient.
        findHostInstancesForFiberShallowly(fiber, hostInstances);
        else // If there's no match, maybe there will be one further down in the child tree.
        if (child !== null) findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
        if (sibling !== null) findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
    }
    function findHostInstancesForFiberShallowly(fiber, hostInstances) {
        var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
        if (foundHostInstances) return;
         // If we didn't find any host children, fallback to closest host parent.
        var node = fiber;
        while(true){
            switch(node.tag){
                case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
            }
            if (node.return === null) throw new Error('Expected to reach root first.');
            node = node.return;
        }
    }
    function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
        var node = fiber;
        var foundHostInstances = false;
        while(true){
            if (node.tag === HostComponent) {
                // We got a match.
                foundHostInstances = true;
                hostInstances.add(node.stateNode); // There may still be more, so keep searching.
            } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === fiber) return foundHostInstances;
            while(node.sibling === null){
                if (node.return === null || node.return === fiber) return foundHostInstances;
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
        return false;
    }
    var hasBadMapPolyfill;
    hasBadMapPolyfill = false;
    try {
        var nonExtensibleObject = Object.preventExtensions({
        });
        /* eslint-disable no-new */ new Map([
            [
                nonExtensibleObject,
                null
            ]
        ]);
        new Set([
            nonExtensibleObject
        ]);
    /* eslint-enable no-new */ } catch (e) {
        // TODO: Consider warning about bad polyfills
        hasBadMapPolyfill = true;
    }
    var debugCounter = 1;
    function FiberNode(tag, pendingProps, key, mode) {
        // Instance
        this.tag = tag;
        this.key = key;
        this.elementType = null;
        this.type = null;
        this.stateNode = null; // Fiber
        this.return = null;
        this.child = null;
        this.sibling = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = pendingProps;
        this.memoizedProps = null;
        this.updateQueue = null;
        this.memoizedState = null;
        this.dependencies = null;
        this.mode = mode; // Effects
        this.flags = NoFlags;
        this.nextEffect = null;
        this.firstEffect = null;
        this.lastEffect = null;
        this.lanes = NoLanes;
        this.childLanes = NoLanes;
        this.alternate = null;
        // Note: The following is done to avoid a v8 performance cliff.
        //
        // Initializing the fields below to smis and later updating them with
        // double values will cause Fibers to end up having separate shapes.
        // This behavior/bug has something to do with Object.preventExtension().
        // Fortunately this only impacts DEV builds.
        // Unfortunately it makes React unusably slow for some applications.
        // To work around this, initialize the fields below with doubles.
        //
        // Learn more about this here:
        // https://github.com/facebook/react/issues/14365
        // https://bugs.chromium.org/p/v8/issues/detail?id=8538
        this.actualDuration = Number.NaN;
        this.actualStartTime = Number.NaN;
        this.selfBaseDuration = Number.NaN;
        this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.
        // This won't trigger the performance cliff mentioned above,
        // and it simplifies other profiler code (including DevTools).
        this.actualDuration = 0;
        this.actualStartTime = -1;
        this.selfBaseDuration = 0;
        this.treeBaseDuration = 0;
        // This isn't directly used but is handy for debugging internals:
        this._debugID = debugCounter++;
        this._debugSource = null;
        this._debugOwner = null;
        this._debugNeedsRemount = false;
        this._debugHookTypes = null;
        if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') Object.preventExtensions(this);
    } // This is a constructor function, rather than a POJO constructor, still
    // please ensure we do the following:
    // 1) Nobody should add any instance methods on this. Instance methods can be
    //    more difficult to predict when they get optimized and they are almost
    //    never inlined properly in static compilers.
    // 2) Nobody should rely on `instanceof Fiber` for type testing. We should
    //    always know when it is a fiber.
    // 3) We might want to experiment with using numeric keys since they are easier
    //    to optimize in a non-JIT environment.
    // 4) We can easily go from a constructor to a createFiber object literal if that
    //    is faster.
    // 5) It should be easy to port this to a C struct and keep a C implementation
    //    compatible.
    var createFiber = function(tag, pendingProps, key, mode) {
        // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
        return new FiberNode(tag, pendingProps, key, mode);
    };
    function shouldConstruct$1(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
    }
    function isSimpleFunctionComponent(type) {
        return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;
    }
    function resolveLazyComponentTag(Component) {
        if (typeof Component === 'function') return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
        else if (Component !== undefined && Component !== null) {
            var $$typeof = Component.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE) return ForwardRef;
            if ($$typeof === REACT_MEMO_TYPE) return MemoComponent;
        }
        return IndeterminateComponent;
    } // This is used to create an alternate fiber to do work on.
    function createWorkInProgress(current9, pendingProps) {
        var workInProgress1 = current9.alternate;
        if (workInProgress1 === null) {
            // We use a double buffering pooling technique because we know that we'll
            // only ever need at most two versions of a tree. We pool the "other" unused
            // node that we're free to reuse. This is lazily created to avoid allocating
            // extra objects for things that are never updated. It also allow us to
            // reclaim the extra memory if needed.
            workInProgress1 = createFiber(current9.tag, pendingProps, current9.key, current9.mode);
            workInProgress1.elementType = current9.elementType;
            workInProgress1.type = current9.type;
            workInProgress1.stateNode = current9.stateNode;
            // DEV-only fields
            workInProgress1._debugID = current9._debugID;
            workInProgress1._debugSource = current9._debugSource;
            workInProgress1._debugOwner = current9._debugOwner;
            workInProgress1._debugHookTypes = current9._debugHookTypes;
            workInProgress1.alternate = current9;
            current9.alternate = workInProgress1;
        } else {
            workInProgress1.pendingProps = pendingProps; // Needed because Blocks store data on type.
            workInProgress1.type = current9.type; // We already have an alternate.
            // Reset the effect tag.
            workInProgress1.flags = NoFlags; // The effect list is no longer valid.
            workInProgress1.nextEffect = null;
            workInProgress1.firstEffect = null;
            workInProgress1.lastEffect = null;
            // We intentionally reset, rather than copy, actualDuration & actualStartTime.
            // This prevents time from endlessly accumulating in new commits.
            // This has the downside of resetting values for different priority renders,
            // But works for yielding (the common case) and should support resuming.
            workInProgress1.actualDuration = 0;
            workInProgress1.actualStartTime = -1;
        }
        workInProgress1.childLanes = current9.childLanes;
        workInProgress1.lanes = current9.lanes;
        workInProgress1.child = current9.child;
        workInProgress1.memoizedProps = current9.memoizedProps;
        workInProgress1.memoizedState = current9.memoizedState;
        workInProgress1.updateQueue = current9.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so
        // it cannot be shared with the current fiber.
        var currentDependencies = current9.dependencies;
        workInProgress1.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
        }; // These will be overridden during the parent's reconciliation
        workInProgress1.sibling = current9.sibling;
        workInProgress1.index = current9.index;
        workInProgress1.ref = current9.ref;
        workInProgress1.selfBaseDuration = current9.selfBaseDuration;
        workInProgress1.treeBaseDuration = current9.treeBaseDuration;
        workInProgress1._debugNeedsRemount = current9._debugNeedsRemount;
        switch(workInProgress1.tag){
            case IndeterminateComponent:
            case FunctionComponent:
            case SimpleMemoComponent:
                workInProgress1.type = resolveFunctionForHotReloading(current9.type);
                break;
            case ClassComponent:
                workInProgress1.type = resolveClassForHotReloading(current9.type);
                break;
            case ForwardRef:
                workInProgress1.type = resolveForwardRefForHotReloading(current9.type);
                break;
        }
        return workInProgress1;
    } // Used to reuse a Fiber for a second pass.
    function resetWorkInProgress(workInProgress1, renderLanes1) {
        // This resets the Fiber to what createFiber or createWorkInProgress would
        // have set the values to before during the first pass. Ideally this wouldn't
        // be necessary but unfortunately many code paths reads from the workInProgress
        // when they should be reading from current and writing to workInProgress.
        // We assume pendingProps, index, key, ref, return are still untouched to
        // avoid doing another reconciliation.
        // Reset the effect tag but keep any Placement tags, since that's something
        // that child fiber is setting, not the reconciliation.
        workInProgress1.flags &= Placement; // The effect list is no longer valid.
        workInProgress1.nextEffect = null;
        workInProgress1.firstEffect = null;
        workInProgress1.lastEffect = null;
        var current9 = workInProgress1.alternate;
        if (current9 === null) {
            // Reset to createFiber's initial values.
            workInProgress1.childLanes = NoLanes;
            workInProgress1.lanes = renderLanes1;
            workInProgress1.child = null;
            workInProgress1.memoizedProps = null;
            workInProgress1.memoizedState = null;
            workInProgress1.updateQueue = null;
            workInProgress1.dependencies = null;
            workInProgress1.stateNode = null;
            // Note: We don't reset the actualTime counts. It's useful to accumulate
            // actual time across multiple render passes.
            workInProgress1.selfBaseDuration = 0;
            workInProgress1.treeBaseDuration = 0;
        } else {
            // Reset to the cloned values that createWorkInProgress would've.
            workInProgress1.childLanes = current9.childLanes;
            workInProgress1.lanes = current9.lanes;
            workInProgress1.child = current9.child;
            workInProgress1.memoizedProps = current9.memoizedProps;
            workInProgress1.memoizedState = current9.memoizedState;
            workInProgress1.updateQueue = current9.updateQueue; // Needed because Blocks store data on type.
            workInProgress1.type = current9.type; // Clone the dependencies object. This is mutated during the render phase, so
            // it cannot be shared with the current fiber.
            var currentDependencies = current9.dependencies;
            workInProgress1.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
            };
            // Note: We don't reset the actualTime counts. It's useful to accumulate
            // actual time across multiple render passes.
            workInProgress1.selfBaseDuration = current9.selfBaseDuration;
            workInProgress1.treeBaseDuration = current9.treeBaseDuration;
        }
        return workInProgress1;
    }
    function createHostRootFiber(tag) {
        var mode;
        if (tag === ConcurrentRoot) mode = ConcurrentMode | BlockingMode | StrictMode;
        else if (tag === BlockingRoot) mode = BlockingMode | StrictMode;
        else mode = NoMode;
        if (isDevToolsPresent) // Always collect profile timings when DevTools are present.
        // This enables DevTools to start capturing timing at any point–
        // Without some nodes in the tree having empty base times.
        mode |= ProfileMode;
        return createFiber(HostRoot, null, null, mode);
    }
    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
        var resolvedType = type;
        if (typeof type === 'function') {
            if (shouldConstruct$1(type)) {
                fiberTag = ClassComponent;
                resolvedType = resolveClassForHotReloading(resolvedType);
            } else resolvedType = resolveFunctionForHotReloading(resolvedType);
        } else if (typeof type === 'string') fiberTag = HostComponent;
        else getTag: switch(type){
            case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_DEBUG_TRACING_MODE_TYPE:
                fiberTag = Mode;
                mode |= DebugTracingMode;
                break;
            case REACT_STRICT_MODE_TYPE:
                fiberTag = Mode;
                mode |= StrictMode;
                break;
            case REACT_PROFILER_TYPE:
                return createFiberFromProfiler(pendingProps, mode, lanes, key);
            case REACT_SUSPENSE_TYPE:
                return createFiberFromSuspense(pendingProps, mode, lanes, key);
            case REACT_SUSPENSE_LIST_TYPE:
                return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
            case REACT_OFFSCREEN_TYPE:
                return createFiberFromOffscreen(pendingProps, mode, lanes, key);
            case REACT_LEGACY_HIDDEN_TYPE:
                return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);
            case REACT_SCOPE_TYPE:
            // eslint-disable-next-line no-fallthrough
            default:
                if (typeof type === 'object' && type !== null) switch(type.$$typeof){
                    case REACT_PROVIDER_TYPE:
                        fiberTag = ContextProvider;
                        break getTag;
                    case REACT_CONTEXT_TYPE:
                        // This is a consumer
                        fiberTag = ContextConsumer;
                        break getTag;
                    case REACT_FORWARD_REF_TYPE:
                        fiberTag = ForwardRef;
                        resolvedType = resolveForwardRefForHotReloading(resolvedType);
                        break getTag;
                    case REACT_MEMO_TYPE:
                        fiberTag = MemoComponent;
                        break getTag;
                    case REACT_LAZY_TYPE:
                        fiberTag = LazyComponent;
                        resolvedType = null;
                        break getTag;
                    case REACT_BLOCK_TYPE:
                        fiberTag = Block;
                        break getTag;
                }
                var info = '';
                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                var ownerName = owner ? getComponentName(owner.type) : null;
                if (ownerName) info += '\n\nCheck the render method of `' + ownerName + '`.';
                throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (type == null ? type : typeof type) + "." + info);
        }
        var fiber = createFiber(fiberTag, pendingProps, key, mode);
        fiber.elementType = type;
        fiber.type = resolvedType;
        fiber.lanes = lanes;
        fiber._debugOwner = owner;
        return fiber;
    }
    function createFiberFromElement(element, mode, lanes) {
        var owner = null;
        owner = element._owner;
        var type = element.type;
        var key = element.key;
        var pendingProps = element.props;
        var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
        fiber._debugSource = element._source;
        fiber._debugOwner = element._owner;
        return fiber;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
        var fiber = createFiber(Fragment, elements, key, mode);
        fiber.lanes = lanes;
        return fiber;
    }
    function createFiberFromProfiler(pendingProps, mode, lanes, key) {
        if (typeof pendingProps.id !== 'string') error('Profiler must specify an "id" as a prop');
        var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode); // TODO: The Profiler fiber shouldn't have a type. It has a tag.
        fiber.elementType = REACT_PROFILER_TYPE;
        fiber.type = REACT_PROFILER_TYPE;
        fiber.lanes = lanes;
        fiber.stateNode = {
            effectDuration: 0,
            passiveEffectDuration: 0
        };
        return fiber;
    }
    function createFiberFromSuspense(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseComponent, pendingProps, key, mode); // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
        // This needs to be fixed in getComponentName so that it relies on the tag
        // instead.
        fiber.type = REACT_SUSPENSE_TYPE;
        fiber.elementType = REACT_SUSPENSE_TYPE;
        fiber.lanes = lanes;
        return fiber;
    }
    function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
        // TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.
        // This needs to be fixed in getComponentName so that it relies on the tag
        // instead.
        fiber.type = REACT_SUSPENSE_LIST_TYPE;
        fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
        fiber.lanes = lanes;
        return fiber;
    }
    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
        var fiber = createFiber(OffscreenComponent, pendingProps, key, mode); // TODO: The OffscreenComponent fiber shouldn't have a type. It has a tag.
        fiber.type = REACT_OFFSCREEN_TYPE;
        fiber.elementType = REACT_OFFSCREEN_TYPE;
        fiber.lanes = lanes;
        return fiber;
    }
    function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
        var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode); // TODO: The LegacyHidden fiber shouldn't have a type. It has a tag.
        fiber.type = REACT_LEGACY_HIDDEN_TYPE;
        fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
        fiber.lanes = lanes;
        return fiber;
    }
    function createFiberFromText(content, mode, lanes) {
        var fiber = createFiber(HostText, content, null, mode);
        fiber.lanes = lanes;
        return fiber;
    }
    function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoMode); // TODO: These should not need a type.
        fiber.elementType = 'DELETED';
        fiber.type = 'DELETED';
        return fiber;
    }
    function createFiberFromPortal(portal, mode, lanes) {
        var pendingProps = portal.children !== null ? portal.children : [];
        var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
        fiber.lanes = lanes;
        fiber.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            // Used by persistent updates
            implementation: portal.implementation
        };
        return fiber;
    } // Used for stashing WIP properties to replay failed work in DEV.
    function assignFiberPropertiesInDEV(target, source) {
        if (target === null) // This Fiber's initial properties will always be overwritten.
        // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
        target = createFiber(IndeterminateComponent, null, null, NoMode);
         // This is intentionally written as a list of all properties.
        // We tried to use Object.assign() instead but this is called in
        // the hottest path, and Object.assign() was too slow:
        // https://github.com/facebook/react/issues/12502
        // This code is DEV-only so size is not a concern.
        target.tag = source.tag;
        target.key = source.key;
        target.elementType = source.elementType;
        target.type = source.type;
        target.stateNode = source.stateNode;
        target.return = source.return;
        target.child = source.child;
        target.sibling = source.sibling;
        target.index = source.index;
        target.ref = source.ref;
        target.pendingProps = source.pendingProps;
        target.memoizedProps = source.memoizedProps;
        target.updateQueue = source.updateQueue;
        target.memoizedState = source.memoizedState;
        target.dependencies = source.dependencies;
        target.mode = source.mode;
        target.flags = source.flags;
        target.nextEffect = source.nextEffect;
        target.firstEffect = source.firstEffect;
        target.lastEffect = source.lastEffect;
        target.lanes = source.lanes;
        target.childLanes = source.childLanes;
        target.alternate = source.alternate;
        target.actualDuration = source.actualDuration;
        target.actualStartTime = source.actualStartTime;
        target.selfBaseDuration = source.selfBaseDuration;
        target.treeBaseDuration = source.treeBaseDuration;
        target._debugID = source._debugID;
        target._debugSource = source._debugSource;
        target._debugOwner = source._debugOwner;
        target._debugNeedsRemount = source._debugNeedsRemount;
        target._debugHookTypes = source._debugHookTypes;
        return target;
    }
    function FiberRootNode(containerInfo, tag, hydrate) {
        this.tag = tag;
        this.containerInfo = containerInfo;
        this.pendingChildren = null;
        this.current = null;
        this.pingCache = null;
        this.finishedWork = null;
        this.timeoutHandle = noTimeout;
        this.context = null;
        this.pendingContext = null;
        this.hydrate = hydrate;
        this.callbackNode = null;
        this.callbackPriority = NoLanePriority;
        this.eventTimes = createLaneMap(NoLanes);
        this.expirationTimes = createLaneMap(NoTimestamp);
        this.pendingLanes = NoLanes;
        this.suspendedLanes = NoLanes;
        this.pingedLanes = NoLanes;
        this.expiredLanes = NoLanes;
        this.mutableReadLanes = NoLanes;
        this.finishedLanes = NoLanes;
        this.entangledLanes = NoLanes;
        this.entanglements = createLaneMap(NoLanes);
        this.mutableSourceEagerHydrationData = null;
        this.interactionThreadID = tracing.unstable_getThreadID();
        this.memoizedInteractions = new Set();
        this.pendingInteractionMap = new Map();
        switch(tag){
            case BlockingRoot:
                this._debugRootType = 'createBlockingRoot()';
                break;
            case ConcurrentRoot:
                this._debugRootType = 'createRoot()';
                break;
            case LegacyRoot:
                this._debugRootType = 'createLegacyRoot()';
                break;
        }
    }
    function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
        var root4 = new FiberRootNode(containerInfo, tag, hydrate);
        // stateNode is any.
        var uninitializedFiber = createHostRootFiber(tag);
        root4.current = uninitializedFiber;
        uninitializedFiber.stateNode = root4;
        initializeUpdateQueue(uninitializedFiber);
        return root4;
    }
    // This ensures that the version used for server rendering matches the one
    // that is eventually read during hydration.
    // If they don't match there's a potential tear and a full deopt render is required.
    function registerMutableSourceForHydration(root4, mutableSource) {
        var getVersion = mutableSource._getVersion;
        var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.
        // Retaining it forever may interfere with GC.
        if (root4.mutableSourceEagerHydrationData == null) root4.mutableSourceEagerHydrationData = [
            mutableSource,
            version
        ];
        else root4.mutableSourceEagerHydrationData.push(mutableSource, version);
    }
    function createPortal(children, containerInfo, implementation) {
        var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        return {
            // This tag allow us to uniquely identify this as a React Portal
            $$typeof: REACT_PORTAL_TYPE,
            key: key == null ? null : '' + key,
            children: children,
            containerInfo: containerInfo,
            implementation: implementation
        };
    }
    var didWarnAboutNestedUpdates;
    var didWarnAboutFindNodeInStrictMode;
    didWarnAboutNestedUpdates = false;
    didWarnAboutFindNodeInStrictMode = {
    };
    function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        var fiber = get(parentComponent);
        var parentContext = findCurrentUnmaskedContext(fiber);
        if (fiber.tag === ClassComponent) {
            var Component = fiber.type;
            if (isContextProvider(Component)) return processChildContext(fiber, Component, parentContext);
        }
        return parentContext;
    }
    function findHostInstanceWithWarning(component, methodName) {
        var fiber = get(component);
        if (fiber === undefined) {
            if (typeof component.render === 'function') throw Error("Unable to find node on an unmounted component.");
            else throw Error("Argument appears to not be a ReactComponent. Keys: " + Object.keys(component));
        }
        var hostFiber = findCurrentHostFiber(fiber);
        if (hostFiber === null) return null;
        if (hostFiber.mode & StrictMode) {
            var componentName = getComponentName(fiber.type) || 'Component';
            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                didWarnAboutFindNodeInStrictMode[componentName] = true;
                var previousFiber = current;
                try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictMode) error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    else error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                } finally{
                    // Ideally this should reset to previous but this shouldn't be called in
                    // render and there's another warning for that anyway.
                    if (previousFiber) setCurrentFiber(previousFiber);
                    else resetCurrentFiber();
                }
            }
        }
        return hostFiber.stateNode;
    }
    function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) {
        return createFiberRoot(containerInfo, tag, hydrate);
    }
    function updateContainer(element, container, parentComponent, callback) {
        onScheduleRoot(container, element);
        var current$1 = container.current;
        var eventTime = requestEventTime();
        // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
        if ('undefined' !== typeof jest) {
            warnIfUnmockedScheduler(current$1);
            warnIfNotScopedWithMatchingAct(current$1);
        }
        var lane = requestUpdateLane(current$1);
        var context = getContextForSubtree(parentComponent);
        if (container.context === null) container.context = context;
        else container.pendingContext = context;
        if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
            didWarnAboutNestedUpdates = true;
            error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentName(current.type) || 'Unknown');
        }
        var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property
        // being called "element".
        update.payload = {
            element: element
        };
        callback = callback === undefined ? null : callback;
        if (callback !== null) {
            if (typeof callback !== 'function') error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
            update.callback = callback;
        }
        enqueueUpdate(current$1, update);
        scheduleUpdateOnFiber(current$1, lane, eventTime);
        return lane;
    }
    function getPublicRootInstance(container) {
        var containerFiber = container.current;
        if (!containerFiber.child) return null;
        switch(containerFiber.child.tag){
            case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
            default:
                return containerFiber.child.stateNode;
        }
    }
    function markRetryLaneImpl(fiber, retryLane) {
        var suspenseState = fiber.memoizedState;
        if (suspenseState !== null && suspenseState.dehydrated !== null) suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
    } // Increases the priority of thennables when they resolve within this boundary.
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        var alternate = fiber.alternate;
        if (alternate) markRetryLaneImpl(alternate, retryLane);
    }
    function attemptUserBlockingHydration$1(fiber) {
        if (fiber.tag !== SuspenseComponent) // We ignore HostRoots here because we can't increase
        // their priority and they should not suspend on I/O,
        // since you have to wrap anything that might suspend in
        // Suspense.
        return;
        var eventTime = requestEventTime();
        var lane = InputDiscreteHydrationLane;
        scheduleUpdateOnFiber(fiber, lane, eventTime);
        markRetryLaneIfNotHydrated(fiber, lane);
    }
    function attemptContinuousHydration$1(fiber) {
        if (fiber.tag !== SuspenseComponent) // We ignore HostRoots here because we can't increase
        // their priority and they should not suspend on I/O,
        // since you have to wrap anything that might suspend in
        // Suspense.
        return;
        var eventTime = requestEventTime();
        var lane = SelectiveHydrationLane;
        scheduleUpdateOnFiber(fiber, lane, eventTime);
        markRetryLaneIfNotHydrated(fiber, lane);
    }
    function attemptHydrationAtCurrentPriority$1(fiber) {
        if (fiber.tag !== SuspenseComponent) // We ignore HostRoots here because we can't increase
        // their priority other than synchronously flush it.
        return;
        var eventTime = requestEventTime();
        var lane = requestUpdateLane(fiber);
        scheduleUpdateOnFiber(fiber, lane, eventTime);
        markRetryLaneIfNotHydrated(fiber, lane);
    }
    function runWithPriority$2(priority, fn) {
        setCurrentUpdateLanePriority(priority);
        return fn();
    }
    function findHostInstanceWithNoPortals(fiber) {
        var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
        if (hostFiber === null) return null;
        if (hostFiber.tag === FundamentalComponent) return hostFiber.stateNode.instance;
        return hostFiber.stateNode;
    }
    var shouldSuspendImpl = function(fiber) {
        return false;
    };
    function shouldSuspend(fiber) {
        return shouldSuspendImpl(fiber);
    }
    var overrideHookState = null;
    var overrideHookStateDeletePath = null;
    var overrideHookStateRenamePath = null;
    var overrideProps = null;
    var overridePropsDeletePath = null;
    var overridePropsRenamePath = null;
    var scheduleUpdate = null;
    var setSuspenseHandler = null;
    var copyWithDeleteImpl = function(obj, path, index1) {
        var key = path[index1];
        var updated = Array.isArray(obj) ? obj.slice() : _assign({
        }, obj);
        if (index1 + 1 === path.length) {
            if (Array.isArray(updated)) updated.splice(key, 1);
            else delete updated[key];
            return updated;
        } // $FlowFixMe number or string is fine here
        updated[key] = copyWithDeleteImpl(obj[key], path, index1 + 1);
        return updated;
    };
    var copyWithDelete = function(obj, path) {
        return copyWithDeleteImpl(obj, path, 0);
    };
    var copyWithRenameImpl = function(obj, oldPath, newPath, index1) {
        var oldKey = oldPath[index1];
        var updated = Array.isArray(obj) ? obj.slice() : _assign({
        }, obj);
        if (index1 + 1 === oldPath.length) {
            var newKey = newPath[index1]; // $FlowFixMe number or string is fine here
            updated[newKey] = updated[oldKey];
            if (Array.isArray(updated)) updated.splice(oldKey, 1);
            else delete updated[oldKey];
        } else // $FlowFixMe number or string is fine here
        updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index1 + 1);
        return updated;
    };
    var copyWithRename = function(obj, oldPath, newPath) {
        if (oldPath.length !== newPath.length) {
            warn('copyWithRename() expects paths of the same length');
            return;
        } else {
            for(var i = 0; i < newPath.length - 1; i++)if (oldPath[i] !== newPath[i]) {
                warn('copyWithRename() expects paths to be the same except for the deepest key');
                return;
            }
        }
        return copyWithRenameImpl(obj, oldPath, newPath, 0);
    };
    var copyWithSetImpl = function(obj, path, index1, value) {
        if (index1 >= path.length) return value;
        var key = path[index1];
        var updated = Array.isArray(obj) ? obj.slice() : _assign({
        }, obj); // $FlowFixMe number or string is fine here
        updated[key] = copyWithSetImpl(obj[key], path, index1 + 1, value);
        return updated;
    };
    var copyWithSet = function(obj, path, value) {
        return copyWithSetImpl(obj, path, 0, value);
    };
    var findHook = function(fiber, id) {
        // For now, the "id" of stateful hooks is just the stateful hook index.
        // This may change in the future with e.g. nested hooks.
        var currentHook1 = fiber.memoizedState;
        while(currentHook1 !== null && id > 0){
            currentHook1 = currentHook1.next;
            id--;
        }
        return currentHook1;
    }; // Support DevTools editable values for useState and useReducer.
    overrideHookState = function(fiber, id, path, value) {
        var hook = findHook(fiber, id);
        if (hook !== null) {
            var newState = copyWithSet(hook.memoizedState, path, value);
            hook.memoizedState = newState;
            hook.baseState = newState; // We aren't actually adding an update to the queue,
            // because there is no update we can add for useReducer hooks that won't trigger an error.
            // (There's no appropriate action type for DevTools overrides.)
            // As a result though, React will see the scheduled update as a noop and bailout.
            // Shallow cloning props works as a workaround for now to bypass the bailout check.
            fiber.memoizedProps = _assign({
            }, fiber.memoizedProps);
            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
        }
    };
    overrideHookStateDeletePath = function(fiber, id, path) {
        var hook = findHook(fiber, id);
        if (hook !== null) {
            var newState = copyWithDelete(hook.memoizedState, path);
            hook.memoizedState = newState;
            hook.baseState = newState; // We aren't actually adding an update to the queue,
            // because there is no update we can add for useReducer hooks that won't trigger an error.
            // (There's no appropriate action type for DevTools overrides.)
            // As a result though, React will see the scheduled update as a noop and bailout.
            // Shallow cloning props works as a workaround for now to bypass the bailout check.
            fiber.memoizedProps = _assign({
            }, fiber.memoizedProps);
            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
        }
    };
    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
        var hook = findHook(fiber, id);
        if (hook !== null) {
            var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
            hook.memoizedState = newState;
            hook.baseState = newState; // We aren't actually adding an update to the queue,
            // because there is no update we can add for useReducer hooks that won't trigger an error.
            // (There's no appropriate action type for DevTools overrides.)
            // As a result though, React will see the scheduled update as a noop and bailout.
            // Shallow cloning props works as a workaround for now to bypass the bailout check.
            fiber.memoizedProps = _assign({
            }, fiber.memoizedProps);
            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
        }
    }; // Support DevTools props for function components, forwardRef, memo, host components, etc.
    overrideProps = function(fiber, path, value) {
        fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
        if (fiber.alternate) fiber.alternate.pendingProps = fiber.pendingProps;
        scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    };
    overridePropsDeletePath = function(fiber, path) {
        fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
        if (fiber.alternate) fiber.alternate.pendingProps = fiber.pendingProps;
        scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    };
    overridePropsRenamePath = function(fiber, oldPath, newPath) {
        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
        if (fiber.alternate) fiber.alternate.pendingProps = fiber.pendingProps;
        scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    };
    scheduleUpdate = function(fiber) {
        scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    };
    setSuspenseHandler = function(newShouldSuspendImpl) {
        shouldSuspendImpl = newShouldSuspendImpl;
    };
    function findHostInstanceByFiber(fiber) {
        var hostFiber = findCurrentHostFiber(fiber);
        if (hostFiber === null) return null;
        return hostFiber.stateNode;
    }
    function emptyFindFiberByHostInstance(instance) {
        return null;
    }
    function getCurrentFiberForDevTools() {
        return current;
    }
    function injectIntoDevTools(devToolsConfig) {
        var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
        var ReactCurrentDispatcher1 = ReactSharedInternals.ReactCurrentDispatcher;
        return injectInternals({
            bundleType: devToolsConfig.bundleType,
            version: devToolsConfig.version,
            rendererPackageName: devToolsConfig.rendererPackageName,
            rendererConfig: devToolsConfig.rendererConfig,
            overrideHookState: overrideHookState,
            overrideHookStateDeletePath: overrideHookStateDeletePath,
            overrideHookStateRenamePath: overrideHookStateRenamePath,
            overrideProps: overrideProps,
            overridePropsDeletePath: overridePropsDeletePath,
            overridePropsRenamePath: overridePropsRenamePath,
            setSuspenseHandler: setSuspenseHandler,
            scheduleUpdate: scheduleUpdate,
            currentDispatcherRef: ReactCurrentDispatcher1,
            findHostInstanceByFiber: findHostInstanceByFiber,
            findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
            // React Refresh
            findHostInstancesForRefresh: findHostInstancesForRefresh,
            scheduleRefresh: scheduleRefresh,
            scheduleRoot: scheduleRoot,
            setRefreshHandler: setRefreshHandler,
            // Enables DevTools to append owner stacks to error messages in DEV mode.
            getCurrentFiber: getCurrentFiberForDevTools
        });
    }
    function ReactDOMRoot(container, options1) {
        this._internalRoot = createRootImpl(container, ConcurrentRoot, options1);
    }
    function ReactDOMBlockingRoot(container, tag, options1) {
        this._internalRoot = createRootImpl(container, tag, options1);
    }
    ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(children) {
        var root4 = this._internalRoot;
        if (typeof arguments[1] === 'function') error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
        var container = root4.containerInfo;
        if (container.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(root4.current);
            if (hostInstance) {
                if (hostInstance.parentNode !== container) error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
            }
        }
        updateContainer(children, root4, null, null);
    };
    ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function() {
        if (typeof arguments[0] === 'function') error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
        var root4 = this._internalRoot;
        var container = root4.containerInfo;
        updateContainer(null, root4, null, function() {
            unmarkContainerAsRoot(container);
        });
    };
    function createRootImpl(container, tag, options1) {
        // Tag is either LegacyRoot or Concurrent Root
        var hydrate = options1 != null && options1.hydrate === true;
        var hydrationCallbacks = options1 != null && options1.hydrationOptions || null;
        var mutableSources = options1 != null && options1.hydrationOptions != null && options1.hydrationOptions.mutableSources || null;
        var root4 = createContainer(container, tag, hydrate);
        markContainerAsRoot(root4.current, container);
        var containerNodeType = container.nodeType;
        var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
        listenToAllSupportedEvents(rootContainerElement);
        if (mutableSources) for(var i = 0; i < mutableSources.length; i++){
            var mutableSource = mutableSources[i];
            registerMutableSourceForHydration(root4, mutableSource);
        }
        return root4;
    }
    function createLegacyRoot(container, options1) {
        return new ReactDOMBlockingRoot(container, LegacyRoot, options1);
    }
    function isValidContainer(node) {
        return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
    }
    var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
    var topLevelUpdateWarnings;
    var warnedAboutHydrateAPI = false;
    topLevelUpdateWarnings = function(container) {
        if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);
            if (hostInstance) {
                if (hostInstance.parentNode !== container) error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
            }
        }
        var isRootRenderedBySomeReact = !!container._reactRootContainer;
        var rootEl = getReactRootElementInContainer(container);
        var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
        if (hasNonRootReactChild && !isRootRenderedBySomeReact) error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
        if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === 'BODY') error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function getReactRootElementInContainer(container) {
        if (!container) return null;
        if (container.nodeType === DOCUMENT_NODE) return container.documentElement;
        else return container.firstChild;
    }
    function shouldHydrateDueToLegacyHeuristic(container) {
        var rootElement = getReactRootElementInContainer(container);
        return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
    }
    function legacyCreateRootFromDOMContainer(container, forceHydrate) {
        var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.
        if (!shouldHydrate) {
            var warned = false;
            var rootSibling;
            while(rootSibling = container.lastChild){
                if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
                    warned = true;
                    error("render(): Target node has markup rendered by React, but there are unrelated nodes as well. This is most commonly caused by white-space inserted around server-rendered markup.");
                }
                container.removeChild(rootSibling);
            }
        }
        if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
            warnedAboutHydrateAPI = true;
            warn("render(): Calling ReactDOM.render() to hydrate server-rendered markup will stop working in React v18. Replace the ReactDOM.render() call with ReactDOM.hydrate() if you want React to attach to the server HTML.");
        }
        return createLegacyRoot(container, shouldHydrate ? {
            hydrate: true
        } : undefined);
    }
    function warnOnInvalidCallback$1(callback, callerName) {
        if (callback !== null && typeof callback !== 'function') error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
    }
    function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
        topLevelUpdateWarnings(container);
        warnOnInvalidCallback$1(callback === undefined ? null : callback, 'render');
        // member of intersection type." Whyyyyyy.
        var root4 = container._reactRootContainer;
        var fiberRoot;
        if (!root4) {
            // Initial mount
            root4 = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
            fiberRoot = root4._internalRoot;
            if (typeof callback === 'function') {
                var originalCallback = callback;
                callback = function() {
                    var instance = getPublicRootInstance(fiberRoot);
                    originalCallback.call(instance);
                };
            } // Initial mount should not be batched.
            unbatchedUpdates(function() {
                updateContainer(children, fiberRoot, parentComponent, callback);
            });
        } else {
            fiberRoot = root4._internalRoot;
            if (typeof callback === 'function') {
                var _originalCallback = callback;
                callback = function() {
                    var instance = getPublicRootInstance(fiberRoot);
                    _originalCallback.call(instance);
                };
            } // Update
            updateContainer(children, fiberRoot, parentComponent, callback);
        }
        return getPublicRootInstance(fiberRoot);
    }
    function findDOMNode(componentOrElement) {
        var owner = ReactCurrentOwner$3.current;
        if (owner !== null && owner.stateNode !== null) {
            var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
            if (!warnedAboutRefsInRender) error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(owner.type) || 'A component');
            owner.stateNode._warnedAboutRefsInRender = true;
        }
        if (componentOrElement == null) return null;
        if (componentOrElement.nodeType === ELEMENT_NODE) return componentOrElement;
        return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');
    }
    function hydrate(element, container, callback) {
        if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
        var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;
        if (isModernRoot) error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call createRoot(container, {hydrate: true}).render(element)?");
        return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
    }
    function render(element, container, callback) {
        if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
        var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;
        if (isModernRoot) error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.render(element)?");
        return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
    }
    function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        if (!isValidContainer(containerNode)) throw Error("Target container is not a DOM element.");
        if (!(parentComponent != null && has(parentComponent))) throw Error("parentComponent must be a valid React Component");
        return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
    }
    function unmountComponentAtNode(container) {
        if (!isValidContainer(container)) throw Error("unmountComponentAtNode(...): Target container is not a DOM element.");
        var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;
        if (isModernRoot) error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?");
        if (container._reactRootContainer) {
            var rootEl = getReactRootElementInContainer(container);
            var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
            if (renderedByDifferentReact) error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
            unbatchedUpdates(function() {
                legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                    // $FlowFixMe This should probably use `delete container._reactRootContainer`
                    container._reactRootContainer = null;
                    unmarkContainerAsRoot(container);
                });
            }); // If you call unmountComponentAtNode twice in quick succession, you'll
            // get `true` twice. That's probably fine?
            return true;
        } else {
            var _rootEl = getReactRootElementInContainer(container);
            var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl)); // Check if the container itself is a React root node.
            var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;
            if (hasNonRootReactChild) error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
            return false;
        }
    }
    setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);
    setAttemptContinuousHydration(attemptContinuousHydration$1);
    setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
    setAttemptHydrationAtPriority(runWithPriority$2);
    var didWarnAboutUnstableCreatePortal = false;
    if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    setRestoreImplementation(restoreControlledState$3);
    setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);
    function createPortal$1(children, container) {
        var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
         // TODO: pass ReactDOM portal implementation as third argument
        // $FlowFixMe The Flow type is opaque but there's no way to actually create it.
        return createPortal(children, container, null, key);
    }
    function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
    }
    function unstable_createPortal(children, container) {
        var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        if (!didWarnAboutUnstableCreatePortal) {
            didWarnAboutUnstableCreatePortal = true;
            warn("The ReactDOM.unstable_createPortal() alias has been deprecated, and will be removed in React 18+. Update your code to use ReactDOM.createPortal() instead. It has the exact same API, but without the \"unstable_\" prefix.");
        }
        return createPortal$1(children, container, key);
    }
    var Internals = {
        // Keep in sync with ReactTestUtils.js, and ReactTestUtilsAct.js.
        // This is an array for better minification.
        Events: [
            getInstanceFromNode,
            getNodeFromInstance,
            getFiberCurrentPropsFromNode,
            enqueueStateRestore,
            restoreStateIfNeeded,
            flushPassiveEffects,
            IsThisRendererActing
        ]
    };
    var foundDevTools = injectIntoDevTools({
        findFiberByHostInstance: getClosestInstanceFromNode,
        bundleType: 1,
        version: ReactVersion,
        rendererPackageName: 'react-dom'
    });
    if (!foundDevTools && canUseDOM && window.top === window.self) // If we're in Chrome or Firefox, provide a download link if not installed.
    {
        if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
            var protocol = window.location.protocol; // Don't warn in exotic cases like chrome-extension://.
            if (/^(https?|file):$/.test(protocol)) // eslint-disable-next-line react-internal/no-production-logging
            console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === 'file:' ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ''), 'font-weight:bold');
        }
    }
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
    exports.createPortal = createPortal$1;
    exports.findDOMNode = findDOMNode;
    exports.flushSync = flushSync;
    exports.hydrate = hydrate;
    exports.render = render;
    exports.unmountComponentAtNode = unmountComponentAtNode;
    exports.unstable_batchedUpdates = batchedUpdates$1;
    exports.unstable_createPortal = unstable_createPortal;
    exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
    exports.version = ReactVersion;
})();

},{"react":"cKM0D","object-assign":"dkHwz","scheduler":"a0WwH","scheduler/tracing":"5lM8P"}],"a0WwH":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/scheduler.development.js');

},{"./cjs/scheduler.development.js":"hlst1"}],"hlst1":[function(require,module,exports) {
/** @license React v0.20.2
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    var enableSchedulerDebugging = false;
    var enableProfiling = false;
    var requestHostCallback;
    var requestHostTimeout;
    var cancelHostTimeout;
    var requestPaint;
    var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';
    if (hasPerformanceNow) {
        var localPerformance = performance;
        exports.unstable_now = function() {
            return localPerformance.now();
        };
    } else {
        var localDate = Date;
        var initialTime = localDate.now();
        exports.unstable_now = function() {
            return localDate.now() - initialTime;
        };
    }
    if (// implementation using setTimeout.
    typeof window === 'undefined' || typeof MessageChannel !== 'function') {
        // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
        // fallback to a naive implementation.
        var _callback = null;
        var _timeoutID = null;
        var _flushCallback = function() {
            if (_callback !== null) try {
                var currentTime = exports.unstable_now();
                var hasRemainingTime = true;
                _callback(hasRemainingTime, currentTime);
                _callback = null;
            } catch (e) {
                setTimeout(_flushCallback, 0);
                throw e;
            }
        };
        requestHostCallback = function(cb) {
            if (_callback !== null) // Protect against re-entrancy.
            setTimeout(requestHostCallback, 0, cb);
            else {
                _callback = cb;
                setTimeout(_flushCallback, 0);
            }
        };
        requestHostTimeout = function(cb, ms) {
            _timeoutID = setTimeout(cb, ms);
        };
        cancelHostTimeout = function() {
            clearTimeout(_timeoutID);
        };
        exports.unstable_shouldYield = function() {
            return false;
        };
        requestPaint = exports.unstable_forceFrameRate = function() {
        };
    } else {
        // Capture local references to native APIs, in case a polyfill overrides them.
        var _setTimeout = window.setTimeout;
        var _clearTimeout = window.clearTimeout;
        if (typeof console !== 'undefined') {
            // TODO: Scheduler no longer requires these methods to be polyfilled. But
            // maybe we want to continue warning if they don't exist, to preserve the
            // option to rely on it in the future?
            var requestAnimationFrame = window.requestAnimationFrame;
            var cancelAnimationFrame = window.cancelAnimationFrame;
            if (typeof requestAnimationFrame !== 'function') // Using console['error'] to evade Babel and ESLint
            console['error']("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            if (typeof cancelAnimationFrame !== 'function') // Using console['error'] to evade Babel and ESLint
            console['error']("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
        // thread, like user events. By default, it yields multiple times per frame.
        // It does not attempt to align with frame boundaries, since most tasks don't
        // need to be frame aligned; for those that do, use requestAnimationFrame.
        var yieldInterval = 5;
        var deadline = 0; // TODO: Make this configurable
        // `isInputPending` is not available. Since we have no way of knowing if
        // there's pending input, always yield at the end of the frame.
        exports.unstable_shouldYield = function() {
            return exports.unstable_now() >= deadline;
        }; // Since we yield every frame regardless, `requestPaint` has no effect.
        requestPaint = function() {
        };
        exports.unstable_forceFrameRate = function(fps) {
            if (fps < 0 || fps > 125) {
                // Using console['error'] to evade Babel and ESLint
                console['error']("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
                return;
            }
            if (fps > 0) yieldInterval = Math.floor(1000 / fps);
            else // reset the framerate
            yieldInterval = 5;
        };
        var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
                var currentTime = exports.unstable_now(); // Yield after `yieldInterval` ms, regardless of where we are in the vsync
                // cycle. This means there's always time remaining at the beginning of
                // the message event.
                deadline = currentTime + yieldInterval;
                var hasTimeRemaining = true;
                try {
                    var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                    if (!hasMoreWork) {
                        isMessageLoopRunning = false;
                        scheduledHostCallback = null;
                    } else // If there's more work, schedule the next message event at the end
                    // of the preceding one.
                    port.postMessage(null);
                } catch (error) {
                    // If a scheduler task throws, exit the current browser task so the
                    // error can be observed.
                    port.postMessage(null);
                    throw error;
                }
            } else isMessageLoopRunning = false;
             // Yielding to the browser will give it a chance to paint, so we can
        };
        var channel = new MessageChannel();
        var port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        requestHostCallback = function(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
                isMessageLoopRunning = true;
                port.postMessage(null);
            }
        };
        requestHostTimeout = function(callback, ms) {
            taskTimeoutID = _setTimeout(function() {
                callback(exports.unstable_now());
            }, ms);
        };
        cancelHostTimeout = function() {
            _clearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
        };
    }
    function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        siftUp(heap, node, index);
    }
    function peek(heap) {
        var first = heap[0];
        return first === undefined ? null : first;
    }
    function pop(heap) {
        var first = heap[0];
        if (first !== undefined) {
            var last = heap.pop();
            if (last !== first) {
                heap[0] = last;
                siftDown(heap, last, 0);
            }
            return first;
        } else return null;
    }
    function siftUp(heap, node, i) {
        var index = i;
        while(true){
            var parentIndex = index - 1 >>> 1;
            var parent = heap[parentIndex];
            if (parent !== undefined && compare(parent, node) > 0) {
                // The parent is larger. Swap positions.
                heap[parentIndex] = node;
                heap[index] = parent;
                index = parentIndex;
            } else // The parent is smaller. Exit.
            return;
        }
    }
    function siftDown(heap, node, i) {
        var index = i;
        var length = heap.length;
        while(index < length){
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.
            if (left !== undefined && compare(left, node) < 0) {
                if (right !== undefined && compare(right, left) < 0) {
                    heap[index] = right;
                    heap[rightIndex] = node;
                    index = rightIndex;
                } else {
                    heap[index] = left;
                    heap[leftIndex] = node;
                    index = leftIndex;
                }
            } else if (right !== undefined && compare(right, node) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
            } else // Neither child is smaller. Exit.
            return;
        }
    }
    function compare(a, b) {
        // Compare sort index first, then task id.
        var diff = a.sortIndex - b.sortIndex;
        return diff !== 0 ? diff : a.id - b.id;
    }
    // TODO: Use symbols?
    var ImmediatePriority = 1;
    var UserBlockingPriority = 2;
    var NormalPriority = 3;
    var LowPriority = 4;
    var IdlePriority = 5;
    function markTaskErrored(task, ms) {
    }
    /* eslint-disable no-var */ // Math.pow(2, 30) - 1
    // 0b111111111111111111111111111111
    var maxSigned31BitInt = 1073741823; // Times out immediately
    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out
    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
    var NORMAL_PRIORITY_TIMEOUT = 5000;
    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out
    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap
    var taskQueue = [];
    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.
    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
    var currentTask = null;
    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.
    var isPerformingWork = false;
    var isHostCallbackScheduled = false;
    var isHostTimeoutScheduled = false;
    function advanceTimers(currentTime) {
        // Check for tasks that are no longer delayed and add them to the queue.
        var timer = peek(timerQueue);
        while(timer !== null){
            if (timer.callback === null) // Timer was cancelled.
            pop(timerQueue);
            else if (timer.startTime <= currentTime) {
                // Timer fired. Transfer to the task queue.
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push(taskQueue, timer);
            } else // Remaining timers are pending.
            return;
            timer = peek(timerQueue);
        }
    }
    function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
            } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
        }
    }
    function flushWork(hasTimeRemaining, initialTime) {
        isHostCallbackScheduled = false;
        if (isHostTimeoutScheduled) {
            // We scheduled a timeout but it's no longer needed. Cancel it.
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
        }
        isPerformingWork = true;
        var previousPriorityLevel = currentPriorityLevel;
        try {
            if (enableProfiling) try {
                return workLoop(hasTimeRemaining, initialTime);
            } catch (error) {
                if (currentTask !== null) {
                    var currentTime = exports.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                }
                throw error;
            }
            else // No catch in prod code path.
            return workLoop(hasTimeRemaining, initialTime);
        } finally{
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
        }
    }
    function workLoop(hasTimeRemaining, initialTime) {
        var currentTime = initialTime;
        advanceTimers(currentTime);
        currentTask = peek(taskQueue);
        while(currentTask !== null && !enableSchedulerDebugging){
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())) break;
            var callback = currentTask.callback;
            if (typeof callback === 'function') {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime = exports.unstable_now();
                if (typeof continuationCallback === 'function') currentTask.callback = continuationCallback;
                else if (currentTask === peek(taskQueue)) pop(taskQueue);
                advanceTimers(currentTime);
            } else pop(taskQueue);
            currentTask = peek(taskQueue);
        } // Return whether there's additional work
        if (currentTask !== null) return true;
        else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            return false;
        }
    }
    function unstable_runWithPriority(priorityLevel, eventHandler) {
        switch(priorityLevel){
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
                break;
            default:
                priorityLevel = NormalPriority;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    }
    function unstable_next(eventHandler) {
        var priorityLevel;
        switch(currentPriorityLevel){
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
                // Shift down to normal priority
                priorityLevel = NormalPriority;
                break;
            default:
                // Anything lower than normal priority should remain at the current level.
                priorityLevel = currentPriorityLevel;
                break;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    }
    function unstable_wrapCallback(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
            // This is a fork of runWithPriority, inlined for performance.
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
                return callback.apply(this, arguments);
            } finally{
                currentPriorityLevel = previousPriorityLevel;
            }
        };
    }
    function unstable_scheduleCallback(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        var startTime;
        if (typeof options === 'object' && options !== null) {
            var delay = options.delay;
            if (typeof delay === 'number' && delay > 0) startTime = currentTime + delay;
            else startTime = currentTime;
        } else startTime = currentTime;
        var timeout;
        switch(priorityLevel){
            case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
            case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
            case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
            case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
            case NormalPriority:
            default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
        }
        var expirationTime = startTime + timeout;
        var newTask = {
            id: taskIdCounter++,
            callback: callback,
            priorityLevel: priorityLevel,
            startTime: startTime,
            expirationTime: expirationTime,
            sortIndex: -1
        };
        if (startTime > currentTime) {
            // This is a delayed task.
            newTask.sortIndex = startTime;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                // All tasks are delayed, and this is the task with the earliest delay.
                if (isHostTimeoutScheduled) // Cancel an existing timeout.
                cancelHostTimeout();
                else isHostTimeoutScheduled = true;
                 // Schedule a timeout.
                requestHostTimeout(handleTimeout, startTime - currentTime);
            }
        } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            // wait until the next time we yield.
            if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
            }
        }
        return newTask;
    }
    function unstable_pauseExecution() {
    }
    function unstable_continueExecution() {
        if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
        }
    }
    function unstable_getFirstCallbackNode() {
        return peek(taskQueue);
    }
    function unstable_cancelCallback(task) {
        // remove from the queue because you can't remove arbitrary nodes from an
        // array based heap, only the first one.)
        task.callback = null;
    }
    function unstable_getCurrentPriorityLevel() {
        return currentPriorityLevel;
    }
    var unstable_requestPaint = requestPaint;
    var unstable_Profiling = null;
    exports.unstable_IdlePriority = IdlePriority;
    exports.unstable_ImmediatePriority = ImmediatePriority;
    exports.unstable_LowPriority = LowPriority;
    exports.unstable_NormalPriority = NormalPriority;
    exports.unstable_Profiling = unstable_Profiling;
    exports.unstable_UserBlockingPriority = UserBlockingPriority;
    exports.unstable_cancelCallback = unstable_cancelCallback;
    exports.unstable_continueExecution = unstable_continueExecution;
    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
    exports.unstable_next = unstable_next;
    exports.unstable_pauseExecution = unstable_pauseExecution;
    exports.unstable_requestPaint = unstable_requestPaint;
    exports.unstable_runWithPriority = unstable_runWithPriority;
    exports.unstable_scheduleCallback = unstable_scheduleCallback;
    exports.unstable_wrapCallback = unstable_wrapCallback;
})();

},{}],"5lM8P":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/scheduler-tracing.development.js');

},{"./cjs/scheduler-tracing.development.js":"857Gp"}],"857Gp":[function(require,module,exports) {
/** @license React v0.20.2
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    var DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.
    var interactionIDCounter = 0;
    var threadIDCounter = 0; // Set of currently traced interactions.
    // Interactions "stack"–
    // Meaning that newly traced interactions are appended to the previously active set.
    // When an interaction goes out of scope, the previous set (if any) is restored.
    exports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.
    exports.__subscriberRef = null;
    exports.__interactionsRef = {
        current: new Set()
    };
    exports.__subscriberRef = {
        current: null
    };
    function unstable_clear(callback) {
        var prevInteractions = exports.__interactionsRef.current;
        exports.__interactionsRef.current = new Set();
        try {
            return callback();
        } finally{
            exports.__interactionsRef.current = prevInteractions;
        }
    }
    function unstable_getCurrent() {
        return exports.__interactionsRef.current;
    }
    function unstable_getThreadID() {
        return ++threadIDCounter;
    }
    function unstable_trace(name, timestamp, callback) {
        var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;
        var interaction = {
            __count: 1,
            id: interactionIDCounter++,
            name: name,
            timestamp: timestamp
        };
        var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.
        // To do that, clone the current interactions.
        // The previous set will be restored upon completion.
        var interactions = new Set(prevInteractions);
        interactions.add(interaction);
        exports.__interactionsRef.current = interactions;
        var subscriber = exports.__subscriberRef.current;
        var returnValue;
        try {
            if (subscriber !== null) subscriber.onInteractionTraced(interaction);
        } finally{
            try {
                if (subscriber !== null) subscriber.onWorkStarted(interactions, threadID);
            } finally{
                try {
                    returnValue = callback();
                } finally{
                    exports.__interactionsRef.current = prevInteractions;
                    try {
                        if (subscriber !== null) subscriber.onWorkStopped(interactions, threadID);
                    } finally{
                        interaction.__count--; // If no async work was scheduled for this interaction,
                        // Notify subscribers that it's completed.
                        if (subscriber !== null && interaction.__count === 0) subscriber.onInteractionScheduledWorkCompleted(interaction);
                    }
                }
            }
        }
        return returnValue;
    }
    function unstable_wrap(callback) {
        var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;
        var wrappedInteractions = exports.__interactionsRef.current;
        var subscriber = exports.__subscriberRef.current;
        if (subscriber !== null) subscriber.onWorkScheduled(wrappedInteractions, threadID);
         // Update the pending async work count for the current interactions.
        // Update after calling subscribers in case of error.
        wrappedInteractions.forEach(function(interaction) {
            interaction.__count++;
        });
        var hasRun = false;
        function wrapped() {
            var prevInteractions = exports.__interactionsRef.current;
            exports.__interactionsRef.current = wrappedInteractions;
            subscriber = exports.__subscriberRef.current;
            try {
                var returnValue;
                try {
                    if (subscriber !== null) subscriber.onWorkStarted(wrappedInteractions, threadID);
                } finally{
                    try {
                        returnValue = callback.apply(undefined, arguments);
                    } finally{
                        exports.__interactionsRef.current = prevInteractions;
                        if (subscriber !== null) subscriber.onWorkStopped(wrappedInteractions, threadID);
                    }
                }
                return returnValue;
            } finally{
                if (!hasRun) {
                    // We only expect a wrapped function to be executed once,
                    // But in the event that it's executed more than once–
                    // Only decrement the outstanding interaction counts once.
                    hasRun = true; // Update pending async counts for all wrapped interactions.
                    // If this was the last scheduled async work for any of them,
                    // Mark them as completed.
                    wrappedInteractions.forEach(function(interaction) {
                        interaction.__count--;
                        if (subscriber !== null && interaction.__count === 0) subscriber.onInteractionScheduledWorkCompleted(interaction);
                    });
                }
            }
        }
        wrapped.cancel = function cancel() {
            subscriber = exports.__subscriberRef.current;
            try {
                if (subscriber !== null) subscriber.onWorkCanceled(wrappedInteractions, threadID);
            } finally{
                // Update pending async counts for all wrapped interactions.
                // If this was the last scheduled async work for any of them,
                // Mark them as completed.
                wrappedInteractions.forEach(function(interaction) {
                    interaction.__count--;
                    if (subscriber && interaction.__count === 0) subscriber.onInteractionScheduledWorkCompleted(interaction);
                });
            }
        };
        return wrapped;
    }
    var subscribers = null;
    subscribers = new Set();
    function unstable_subscribe(subscriber) {
        subscribers.add(subscriber);
        if (subscribers.size === 1) exports.__subscriberRef.current = {
            onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
            onInteractionTraced: onInteractionTraced,
            onWorkCanceled: onWorkCanceled,
            onWorkScheduled: onWorkScheduled,
            onWorkStarted: onWorkStarted,
            onWorkStopped: onWorkStopped
        };
    }
    function unstable_unsubscribe(subscriber) {
        subscribers.delete(subscriber);
        if (subscribers.size === 0) exports.__subscriberRef.current = null;
    }
    function onInteractionTraced(interaction) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function(subscriber) {
            try {
                subscriber.onInteractionTraced(interaction);
            } catch (error) {
                if (!didCatchError) {
                    didCatchError = true;
                    caughtError = error;
                }
            }
        });
        if (didCatchError) throw caughtError;
    }
    function onInteractionScheduledWorkCompleted(interaction) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function(subscriber) {
            try {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
            } catch (error) {
                if (!didCatchError) {
                    didCatchError = true;
                    caughtError = error;
                }
            }
        });
        if (didCatchError) throw caughtError;
    }
    function onWorkScheduled(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function(subscriber) {
            try {
                subscriber.onWorkScheduled(interactions, threadID);
            } catch (error) {
                if (!didCatchError) {
                    didCatchError = true;
                    caughtError = error;
                }
            }
        });
        if (didCatchError) throw caughtError;
    }
    function onWorkStarted(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function(subscriber) {
            try {
                subscriber.onWorkStarted(interactions, threadID);
            } catch (error) {
                if (!didCatchError) {
                    didCatchError = true;
                    caughtError = error;
                }
            }
        });
        if (didCatchError) throw caughtError;
    }
    function onWorkStopped(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function(subscriber) {
            try {
                subscriber.onWorkStopped(interactions, threadID);
            } catch (error) {
                if (!didCatchError) {
                    didCatchError = true;
                    caughtError = error;
                }
            }
        });
        if (didCatchError) throw caughtError;
    }
    function onWorkCanceled(interactions, threadID) {
        var didCatchError = false;
        var caughtError = null;
        subscribers.forEach(function(subscriber) {
            try {
                subscriber.onWorkCanceled(interactions, threadID);
            } catch (error) {
                if (!didCatchError) {
                    didCatchError = true;
                    caughtError = error;
                }
            }
        });
        if (didCatchError) throw caughtError;
    }
    exports.unstable_clear = unstable_clear;
    exports.unstable_getCurrent = unstable_getCurrent;
    exports.unstable_getThreadID = unstable_getThreadID;
    exports.unstable_subscribe = unstable_subscribe;
    exports.unstable_trace = unstable_trace;
    exports.unstable_unsubscribe = unstable_unsubscribe;
    exports.unstable_wrap = unstable_wrap;
})();

},{}],"4TaF2":[function() {},{}],"hBKJs":[function() {},{}],"kMyqb":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$27fb = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$27fb.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxRuntime = require("react/jsx-runtime");
var _react = require("react");
var _main = require("./main");
var _appCss = require("./App.css");
var _uiname = require("./ui-components/UIName");
var _uinameDefault = parcelHelpers.interopDefault(_uiname);
var _uigameMode = require("./ui-components/UIGameMode");
var _uigameModeDefault = parcelHelpers.interopDefault(_uigameMode);
var _uichat = require("./ui-components/UIChat");
var _uichatDefault = parcelHelpers.interopDefault(_uichat);
var _bridge = require("./game/bridge");
var _startParams = require("./game/StartParams");
var _netCommunicator = require("./game/NetCommunicator");
var _netCommunicatorDefault = parcelHelpers.interopDefault(_netCommunicator);
var _s = $RefreshSig$();
var startParams = new _startParams.StartParams();
function App() {
    _s();
    const [step, setStep] = _react.useState(_main.SubmitMode.PlayerName);
    const submitPlayerName = (playerName)=>{
        startParams.playerName = playerName;
        setStep(_main.SubmitMode.GameMode);
    };
    const submitGameMode = (mode, host)=>{
        if (mode === _main.GameMode.singleplayer) {
            setStep(_main.SubmitMode.StartGame);
            startParams.gameMode = _main.GameMode.singleplayer;
            _bridge.startGame(startParams);
        } else {
            startParams.gameMode = _main.GameMode.multiplayer;
            startParams.host = host;
            startParams.netCommunicator = new _netCommunicatorDefault.default(startParams.playerName, startParams.host);
            startParams.netCommunicator.onOpponentConnected = onOpponentConnected;
            setStep(_main.SubmitMode.ChatMode);
        }
    };
    const onOpponentConnected = ()=>{
        setStep(_main.SubmitMode.StartGame);
        _bridge.startGame(startParams);
    };
    return step !== _main.SubmitMode.StartGame ? /*#__PURE__*/ _jsxRuntime.jsxs("div", {
        __source: {
            fileName: "src/App.tsx",
            lineNumber: 45
        },
        __self: this,
        children: [
            /*#__PURE__*/ _jsxRuntime.jsx("div", {
                className: "w3-card w3-center",
                __source: {
                    fileName: "src/App.tsx",
                    lineNumber: 46
                },
                __self: this,
                children: /*#__PURE__*/ _jsxRuntime.jsx("span", {
                    className: "game-title",
                    __source: {
                        fileName: "src/App.tsx",
                        lineNumber: 47
                    },
                    __self: this,
                    children: "Commander Kektus"
                })
            }),
            /*#__PURE__*/ _jsxRuntime.jsxs("div", {
                className: "w3-content w3-center w3-padding-top-24",
                __source: {
                    fileName: "src/App.tsx",
                    lineNumber: 49
                },
                __self: this,
                children: [
                    step === _main.SubmitMode.PlayerName && /*#__PURE__*/ _jsxRuntime.jsx(_uinameDefault.default, {
                        submit: submitPlayerName,
                        __source: {
                            fileName: "src/App.tsx",
                            lineNumber: 50
                        },
                        __self: this
                    }),
                    step === _main.SubmitMode.GameMode && /*#__PURE__*/ _jsxRuntime.jsx(_uigameModeDefault.default, {
                        submit: submitGameMode,
                        __source: {
                            fileName: "src/App.tsx",
                            lineNumber: 51
                        },
                        __self: this
                    }),
                    step === _main.SubmitMode.ChatMode && /*#__PURE__*/ _jsxRuntime.jsx(_uichatDefault.default, {
                        netCom: startParams.netCommunicator,
                        playerName: startParams.playerName,
                        __source: {
                            fileName: "src/App.tsx",
                            lineNumber: 52
                        },
                        __self: this
                    })
                ]
            })
        ]
    }) : null;
}
_s(App, "LMczrX8C9g9bBQA8Et3uqpR+4j8=");
_c = App;
exports.default = App;
var _c;
$RefreshReg$(_c, "App");

  $parcel$ReactRefreshHelpers$27fb.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-runtime":"5F5p8","react":"cKM0D","./main":"bo1Qm","./App.css":"7C62m","./ui-components/UIName":"iuSSc","./ui-components/UIGameMode":"2MRVa","./ui-components/UIChat":"iF6Xe","./game/bridge":"c4E5M","./game/StartParams":"bUdck","./game/NetCommunicator":"7pzfP","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"jOwmj"}],"bo1Qm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SubmitMode", ()=>SubmitMode
);
parcelHelpers.export(exports, "GameMode", ()=>GameMode
);
var SubmitMode;
(function(SubmitMode1) {
    SubmitMode1[SubmitMode1["PlayerName"] = 0] = "PlayerName";
    SubmitMode1[SubmitMode1["GameMode"] = 1] = "GameMode";
    SubmitMode1[SubmitMode1["StartGame"] = 2] = "StartGame";
    SubmitMode1[SubmitMode1["ChatMode"] = 3] = "ChatMode";
})(SubmitMode || (SubmitMode = {
}));
var GameMode;
(function(GameMode1) {
    GameMode1[GameMode1["singleplayer"] = 0] = "singleplayer";
    GameMode1[GameMode1["multiplayer"] = 1] = "multiplayer";
})(GameMode || (GameMode = {
}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"4N8i7":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule') return;
        // Skip duplicate re-exports when they have the same value.
        if (key in dest && dest[key] === source[key]) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"7C62m":[function() {},{}],"iuSSc":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$1012 = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$1012.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxRuntime = require("react/jsx-runtime");
var _react = require("react");
var _textField = require("@material-ui/core/TextField");
var _textFieldDefault = parcelHelpers.interopDefault(_textField);
var _button = require("@material-ui/core/Button");
var _buttonDefault = parcelHelpers.interopDefault(_button);
var _s = $RefreshSig$();
function UIName(props) {
    _s();
    const [validInput, setValidInput] = _react.useState(true);
    const submit = ()=>{
        const playerName = document.getElementById('playerName').value;
        if (playerName !== '') props.submit(playerName);
        else setValidInput(false);
    };
    return(/*#__PURE__*/ _jsxRuntime.jsxs("div", {
        className: "w3-row-padding",
        __source: {
            fileName: "src/ui-components/UIName.tsx",
            lineNumber: 19
        },
        __self: this,
        children: [
            /*#__PURE__*/ _jsxRuntime.jsx("span", {
                className: "game-ui-title",
                __source: {
                    fileName: "src/ui-components/UIName.tsx",
                    lineNumber: 20
                },
                __self: this,
                children: "What's your name son?"
            }),
            /*#__PURE__*/ _jsxRuntime.jsx("div", {
                className: "w3-row w3-padding",
                __source: {
                    fileName: "src/ui-components/UIName.tsx",
                    lineNumber: 21
                },
                __self: this,
                children: validInput ? /*#__PURE__*/ _jsxRuntime.jsx(_textFieldDefault.default, {
                    id: "playerName",
                    variant: "outlined",
                    __source: {
                        fileName: "src/ui-components/UIName.tsx",
                        lineNumber: 23
                    },
                    __self: this
                }) : /*#__PURE__*/ _jsxRuntime.jsx(_textFieldDefault.default, {
                    error: true,
                    id: "playerName",
                    helperText: "Tell us who you are.",
                    variant: "outlined",
                    __source: {
                        fileName: "src/ui-components/UIName.tsx",
                        lineNumber: 25
                    },
                    __self: this
                })
            }),
            /*#__PURE__*/ _jsxRuntime.jsx("div", {
                className: "w3-row w3-padding",
                __source: {
                    fileName: "src/ui-components/UIName.tsx",
                    lineNumber: 33
                },
                __self: this,
                children: /*#__PURE__*/ _jsxRuntime.jsx(_buttonDefault.default, {
                    variant: "contained",
                    color: "primary",
                    onClick: submit,
                    __source: {
                        fileName: "src/ui-components/UIName.tsx",
                        lineNumber: 34
                    },
                    __self: this,
                    children: "enroll for battle"
                })
            })
        ]
    }));
}
exports.default = UIName;
_s(UIName, "l8VEt4OHz/dtHQ18rp8GdVknO10=");
_c = UIName;
var _c;
$RefreshReg$(_c, "UIName");

  $parcel$ReactRefreshHelpers$1012.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-runtime":"5F5p8","react":"cKM0D","@material-ui/core/TextField":"khQAh","@material-ui/core/Button":"lEQJw","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"jOwmj"}],"khQAh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_textFieldDefault.default
);
var _textField = require("./TextField");
var _textFieldDefault = parcelHelpers.interopDefault(_textField);

},{"./TextField":"9S86F","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"9S86F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _input = require("../Input");
var _inputDefault = parcelHelpers.interopDefault(_input);
var _filledInput = require("../FilledInput");
var _filledInputDefault = parcelHelpers.interopDefault(_filledInput);
var _outlinedInput = require("../OutlinedInput");
var _outlinedInputDefault = parcelHelpers.interopDefault(_outlinedInput);
var _inputLabel = require("../InputLabel");
var _inputLabelDefault = parcelHelpers.interopDefault(_inputLabel);
var _formControl = require("../FormControl");
var _formControlDefault = parcelHelpers.interopDefault(_formControl);
var _formHelperText = require("../FormHelperText");
var _formHelperTextDefault = parcelHelpers.interopDefault(_formHelperText);
var _select = require("../Select");
var _selectDefault = parcelHelpers.interopDefault(_select);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var variantComponent = {
    standard: _inputDefault.default,
    filled: _filledInputDefault.default,
    outlined: _outlinedInputDefault.default
};
var styles = {
    /* Styles applied to the root element. */ root: {
    }
};
/**
 * The `TextField` is a convenience wrapper for the most common cases (80%).
 * It cannot be all things to all people, otherwise the API would grow out of control.
 *
 * ## Advanced Configuration
 *
 * It's important to understand that the text field is a simple abstraction
 * on top of the following components:
 *
 * - [FormControl](/api/form-control/)
 * - [InputLabel](/api/input-label/)
 * - [FilledInput](/api/filled-input/)
 * - [OutlinedInput](/api/outlined-input/)
 * - [Input](/api/input/)
 * - [FormHelperText](/api/form-helper-text/)
 *
 * If you wish to alter the props applied to the `input` element, you can do so as follows:
 *
 * ```jsx
 * const inputProps = {
 *   step: 300,
 * };
 *
 * return <TextField id="time" type="time" inputProps={inputProps} />;
 * ```
 *
 * For advanced cases, please look at the source of TextField by clicking on the
 * "Edit this page" button above. Consider either:
 *
 * - using the upper case props for passing values directly to the components
 * - using the underlying components directly as shown in the demos
 */ var TextField = /*#__PURE__*/ _react.forwardRef(function TextField1(props, ref) {
    var autoComplete = props.autoComplete, _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus, children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? 'primary' : _props$color, defaultValue = props.defaultValue, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$error = props.error, error = _props$error === void 0 ? false : _props$error, FormHelperTextProps = props.FormHelperTextProps, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, helperText = props.helperText, hiddenLabel = props.hiddenLabel, id = props.id, InputLabelProps = props.InputLabelProps, inputProps = props.inputProps, InputProps = props.InputProps, inputRef = props.inputRef, label = props.label, _props$multiline = props.multiline, multiline = _props$multiline === void 0 ? false : _props$multiline, name = props.name, onBlur = props.onBlur, onChange = props.onChange, onFocus = props.onFocus, placeholder = props.placeholder, _props$required = props.required, required = _props$required === void 0 ? false : _props$required, rows = props.rows, rowsMax = props.rowsMax, maxRows = props.maxRows, minRows = props.minRows, _props$select = props.select, select = _props$select === void 0 ? false : _props$select, SelectProps = props.SelectProps, type = props.type, value = props.value, _props$variant = props.variant, variant = _props$variant === void 0 ? 'standard' : _props$variant, other = _objectWithoutPropertiesDefault.default(props, [
        "autoComplete",
        "autoFocus",
        "children",
        "classes",
        "className",
        "color",
        "defaultValue",
        "disabled",
        "error",
        "FormHelperTextProps",
        "fullWidth",
        "helperText",
        "hiddenLabel",
        "id",
        "InputLabelProps",
        "inputProps",
        "InputProps",
        "inputRef",
        "label",
        "multiline",
        "name",
        "onBlur",
        "onChange",
        "onFocus",
        "placeholder",
        "required",
        "rows",
        "rowsMax",
        "maxRows",
        "minRows",
        "select",
        "SelectProps",
        "type",
        "value",
        "variant"
    ]);
    if (select && !children) console.error('Material-UI: `children` must be passed when using the `TextField` component with `select`.');
    var InputMore = {
    };
    if (variant === 'outlined') {
        if (InputLabelProps && typeof InputLabelProps.shrink !== 'undefined') InputMore.notched = InputLabelProps.shrink;
        if (label) {
            var _InputLabelProps$requ;
            var displayRequired = (_InputLabelProps$requ = InputLabelProps === null || InputLabelProps === void 0 ? void 0 : InputLabelProps.required) !== null && _InputLabelProps$requ !== void 0 ? _InputLabelProps$requ : required;
            InputMore.label = /*#__PURE__*/ _react.createElement(_react.Fragment, null, label, displayRequired && "\xA0*");
        }
    }
    if (select) {
        // unset defaults from textbox inputs
        if (!SelectProps || !SelectProps.native) InputMore.id = undefined;
        InputMore['aria-describedby'] = undefined;
    }
    var helperTextId = helperText && id ? "".concat(id, "-helper-text") : undefined;
    var inputLabelId = label && id ? "".concat(id, "-label") : undefined;
    var InputComponent = variantComponent[variant];
    var InputElement = /*#__PURE__*/ _react.createElement(InputComponent, _extendsDefault.default({
        "aria-describedby": helperTextId,
        autoComplete: autoComplete,
        autoFocus: autoFocus,
        defaultValue: defaultValue,
        fullWidth: fullWidth,
        multiline: multiline,
        name: name,
        rows: rows,
        rowsMax: rowsMax,
        maxRows: maxRows,
        minRows: minRows,
        type: type,
        value: value,
        id: id,
        inputRef: inputRef,
        onBlur: onBlur,
        onChange: onChange,
        onFocus: onFocus,
        placeholder: placeholder,
        inputProps: inputProps
    }, InputMore, InputProps));
    return(/*#__PURE__*/ _react.createElement(_formControlDefault.default, _extendsDefault.default({
        className: _clsxDefault.default(classes.root, className),
        disabled: disabled,
        error: error,
        fullWidth: fullWidth,
        hiddenLabel: hiddenLabel,
        ref: ref,
        required: required,
        color: color,
        variant: variant
    }, other), label && /*#__PURE__*/ _react.createElement(_inputLabelDefault.default, _extendsDefault.default({
        htmlFor: id,
        id: inputLabelId
    }, InputLabelProps), label), select ? /*#__PURE__*/ _react.createElement(_selectDefault.default, _extendsDefault.default({
        "aria-describedby": helperTextId,
        id: id,
        labelId: inputLabelId,
        value: value,
        input: InputElement
    }, SelectProps), children) : InputElement, helperText && /*#__PURE__*/ _react.createElement(_formHelperTextDefault.default, _extendsDefault.default({
        id: helperTextId
    }, FormHelperTextProps), helperText)));
});
TextField.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */ autoComplete: _propTypesDefault.default.string,
    /**
   * If `true`, the `input` element will be focused during the first mount.
   */ autoFocus: _propTypesDefault.default.bool,
    /**
   * @ignore
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */ color: _propTypesDefault.default.oneOf([
        'primary',
        'secondary'
    ]),
    /**
   * The default value of the `input` element.
   */ defaultValue: _propTypesDefault.default.any,
    /**
   * If `true`, the `input` element will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * If `true`, the label will be displayed in an error state.
   */ error: _propTypesDefault.default.bool,
    /**
   * Props applied to the [`FormHelperText`](/api/form-helper-text/) element.
   */ FormHelperTextProps: _propTypesDefault.default.object,
    /**
   * If `true`, the input will take up the full width of its container.
   */ fullWidth: _propTypesDefault.default.bool,
    /**
   * The helper text content.
   */ helperText: _propTypesDefault.default.node,
    /**
   * @ignore
   */ hiddenLabel: _propTypesDefault.default.bool,
    /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */ id: _propTypesDefault.default.string,
    /**
   * Props applied to the [`InputLabel`](/api/input-label/) element.
   */ InputLabelProps: _propTypesDefault.default.object,
    /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */ inputProps: _propTypesDefault.default.object,
    /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/api/filled-input/),
   * [`OutlinedInput`](/api/outlined-input/) or [`Input`](/api/input/)
   * component depending on the `variant` prop value.
   */ InputProps: _propTypesDefault.default.object,
    /**
   * Pass a ref to the `input` element.
   */ inputRef: _utils.refType,
    /**
   * The label content.
   */ label: _propTypesDefault.default.node,
    /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   */ margin: _propTypesDefault.default.oneOf([
        'dense',
        'none',
        'normal'
    ]),
    /**
   * Maximum number of rows to display when multiline option is set to true.
   */ maxRows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * Minimum number of rows to display.
   */ minRows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * If `true`, a textarea element will be rendered instead of an input.
   */ multiline: _propTypesDefault.default.bool,
    /**
   * Name attribute of the `input` element.
   */ name: _propTypesDefault.default.string,
    /**
   * @ignore
   */ onBlur: _propTypesDefault.default.func,
    /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */ onChange: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onFocus: _propTypesDefault.default.func,
    /**
   * The short hint displayed in the input before the user enters a value.
   */ placeholder: _propTypesDefault.default.string,
    /**
   * If `true`, the label is displayed as required and the `input` element` will be required.
   */ required: _propTypesDefault.default.bool,
    /**
   * Number of rows to display when multiline option is set to true.
   * @deprecated Use `minRows` instead.
   */ rows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * Maximum number of rows to display.
   * @deprecated Use `maxRows` instead.
   */ rowsMax: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * Render a [`Select`](/api/select/) element while passing the Input element to `Select` as `input` parameter.
   * If this option is set you must pass the options of the select as children.
   */ select: _propTypesDefault.default.bool,
    /**
   * Props applied to the [`Select`](/api/select/) element.
   */ SelectProps: _propTypesDefault.default.object,
    /**
   * The size of the text field.
   */ size: _propTypesDefault.default.oneOf([
        'medium',
        'small'
    ]),
    /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */ type: _propTypesDefault.default.string,
    /**
   * The value of the `input` element, required for a controlled component.
   */ value: _propTypesDefault.default.any,
    /**
   * The variant to use.
   */ variant: _propTypesDefault.default.oneOf([
        'filled',
        'outlined',
        'standard'
    ])
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiTextField'
})(TextField);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","@material-ui/utils":"Uumnw","../Input":"1b3pY","../FilledInput":"XFeMl","../OutlinedInput":"lvlVJ","../InputLabel":"4k6Kc","../FormControl":"8200A","../FormHelperText":"iLeKI","../Select":"1kFm7","../styles/withStyles":"3pIr2","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"esrVD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
exports.default = _extends;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"kasvP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectWithoutPropertiesLooseJs = require("./objectWithoutPropertiesLoose.js");
var _objectWithoutPropertiesLooseJsDefault = parcelHelpers.interopDefault(_objectWithoutPropertiesLooseJs);
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {
    };
    var target = _objectWithoutPropertiesLooseJsDefault.default(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
exports.default = _objectWithoutProperties;

},{"./objectWithoutPropertiesLoose.js":"5cFhH","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5cFhH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {
    };
    var target = {
    };
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
exports.default = _objectWithoutPropertiesLoose;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"lYCp3":[function(require,module,exports) {
var ReactIs = require('react-is');
// By explicitly using `prop-types` you are opting into new development behavior.
// http://fb.me/prop-types-in-prod
var throwOnDirectAccess = true;
module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);

},{"react-is":"1fpDl","./factoryWithTypeCheckers":"f041i"}],"1fpDl":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/react-is.development.js');

},{"./cjs/react-is.development.js":"cetar"}],"cetar":[function(require,module,exports) {
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var hasSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 60103;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 60106;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 60107;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 60108;
    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 60114;
    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 60109;
    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 60110; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
    // (unstable) APIs that have been removed. Can we remove the symbols?
    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 60111;
    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 60111;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 60112;
    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 60113;
    var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 60120;
    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 60115;
    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 60116;
    var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 60121;
    var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 60117;
    var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 60118;
    var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 60119;
    function isValidElementType(type) {
        return typeof type === 'string' || typeof type === 'function' || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
    }
    function typeOf(object) {
        if (typeof object === 'object' && object !== null) {
            var $$typeof = object.$$typeof;
            switch($$typeof){
                case REACT_ELEMENT_TYPE:
                    var type = object.type;
                    switch(type){
                        case REACT_ASYNC_MODE_TYPE:
                        case REACT_CONCURRENT_MODE_TYPE:
                        case REACT_FRAGMENT_TYPE:
                        case REACT_PROFILER_TYPE:
                        case REACT_STRICT_MODE_TYPE:
                        case REACT_SUSPENSE_TYPE:
                            return type;
                        default:
                            var $$typeofType = type && type.$$typeof;
                            switch($$typeofType){
                                case REACT_CONTEXT_TYPE:
                                case REACT_FORWARD_REF_TYPE:
                                case REACT_LAZY_TYPE:
                                case REACT_MEMO_TYPE:
                                case REACT_PROVIDER_TYPE:
                                    return $$typeofType;
                                default:
                                    return $$typeof;
                            }
                    }
                case REACT_PORTAL_TYPE:
                    return $$typeof;
            }
        }
        return undefined;
    } // AsyncMode is deprecated along with isAsyncMode
    var AsyncMode = REACT_ASYNC_MODE_TYPE;
    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
    var ContextConsumer = REACT_CONTEXT_TYPE;
    var ContextProvider = REACT_PROVIDER_TYPE;
    var Element1 = REACT_ELEMENT_TYPE;
    var ForwardRef = REACT_FORWARD_REF_TYPE;
    var Fragment = REACT_FRAGMENT_TYPE;
    var Lazy = REACT_LAZY_TYPE;
    var Memo = REACT_MEMO_TYPE;
    var Portal = REACT_PORTAL_TYPE;
    var Profiler = REACT_PROFILER_TYPE;
    var StrictMode = REACT_STRICT_MODE_TYPE;
    var Suspense = REACT_SUSPENSE_TYPE;
    var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated
    function isAsyncMode(object) {
        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint
            console['warn']("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
    }
    function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
    }
    function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
    }
    function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
    }
    function isElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }
    function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
    }
    function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
    }
    function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
    }
    function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
    }
    function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
    }
    function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }
    function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
    }
    exports.AsyncMode = AsyncMode;
    exports.ConcurrentMode = ConcurrentMode;
    exports.ContextConsumer = ContextConsumer;
    exports.ContextProvider = ContextProvider;
    exports.Element = Element1;
    exports.ForwardRef = ForwardRef;
    exports.Fragment = Fragment;
    exports.Lazy = Lazy;
    exports.Memo = Memo;
    exports.Portal = Portal;
    exports.Profiler = Profiler;
    exports.StrictMode = StrictMode;
    exports.Suspense = Suspense;
    exports.isAsyncMode = isAsyncMode;
    exports.isConcurrentMode = isConcurrentMode;
    exports.isContextConsumer = isContextConsumer;
    exports.isContextProvider = isContextProvider;
    exports.isElement = isElement;
    exports.isForwardRef = isForwardRef;
    exports.isFragment = isFragment;
    exports.isLazy = isLazy;
    exports.isMemo = isMemo;
    exports.isPortal = isPortal;
    exports.isProfiler = isProfiler;
    exports.isStrictMode = isStrictMode;
    exports.isSuspense = isSuspense;
    exports.isValidElementType = isValidElementType;
    exports.typeOf = typeOf;
})();

},{}],"f041i":[function(require,module,exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
var ReactIs = require('react-is');
var assign = require('object-assign');
var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
var checkPropTypes = require('./checkPropTypes');
var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {
};
printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') console.error(message);
    try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
    } catch (x) {
    }
};
function emptyFunctionThatReturnsNull() {
    return null;
}
module.exports = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
    /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */ function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === 'function') return iteratorFn;
    }
    /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */ var ANONYMOUS = '<<anonymous>>';
    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
        array: createPrimitiveTypeChecker('array'),
        bool: createPrimitiveTypeChecker('boolean'),
        func: createPrimitiveTypeChecker('function'),
        number: createPrimitiveTypeChecker('number'),
        object: createPrimitiveTypeChecker('object'),
        string: createPrimitiveTypeChecker('string'),
        symbol: createPrimitiveTypeChecker('symbol'),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
    };
    /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */ /*eslint-disable no-self-compare*/ function is(x, y) {
        // SameValue algorithm
        if (x === y) // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
        else // Step 6.a: NaN == NaN
        return x !== x && y !== y;
    }
    /*eslint-enable no-self-compare*/ /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */ function PropTypeError(message) {
        this.message = message;
        this.stack = '';
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
        var manualPropTypeCallCache = {
        };
        var manualPropTypeWarningCount = 0;
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
                if (throwOnDirectAccess) {
                    // New behavior only for users of `prop-types` package
                    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
                    err.name = 'Invariant Violation';
                    throw err;
                } else if (typeof console !== 'undefined') {
                    // Old behavior for people using React.PropTypes
                    var cacheKey = componentName + ':' + propName;
                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                    manualPropTypeWarningCount < 3) {
                        printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
                        manualPropTypeCallCache[cacheKey] = true;
                        manualPropTypeWarningCount++;
                    }
                }
            }
            if (props[propName] == null) {
                if (isRequired) {
                    if (props[propName] === null) return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
                    return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
                }
                return null;
            } else return validate(props, propName, componentName, location, propFullName);
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
                // `propValue` being instance of, say, date/regexp, pass the 'object'
                // check, but we can offer a more precise error message here rather than
                // 'of type `object`'.
                var preciseType = getPreciseType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
            }
            for(var i = 0; i < propValue.length; i++){
                var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
                if (error instanceof Error) return error;
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
                var expectedClassName = expectedClass.name || ANONYMOUS;
                var actualClassName = getClassName(props[propName]);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
            {
                if (arguments.length > 1) printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
                else printWarning('Invalid argument supplied to oneOf, expected an array.');
            }
            return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for(var i = 0; i < expectedValues.length; i++){
                if (is(propValue, expectedValues[i])) return null;
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
                var type = getPreciseType(value);
                if (type === 'symbol') return String(value);
                return value;
            });
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
        }
        return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
            for(var key in propValue)if (has(propValue, key)) {
                var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error instanceof Error) return error;
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
            printWarning('Invalid argument supplied to oneOfType, expected an instance of array.');
            return emptyFunctionThatReturnsNull;
        }
        for(var i = 0; i < arrayOfTypeCheckers.length; i++){
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== 'function') {
                printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
                return emptyFunctionThatReturnsNull;
            }
        }
        function validate(props, propName, componentName, location, propFullName) {
            for(var i1 = 0; i1 < arrayOfTypeCheckers.length; i1++){
                var checker = arrayOfTypeCheckers[i1];
                if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) return null;
            }
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
        }
        return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            for(var key in shapeTypes){
                var checker = shapeTypes[key];
                if (!checker) continue;
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error) return error;
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            // We need to check all keys in case some are required but missing from
            // props.
            var allKeys = assign({
            }, props[propName], shapeTypes);
            for(var key in allKeys){
                var checker = shapeTypes[key];
                if (!checker) return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error) return error;
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
        switch(typeof propValue){
            case 'number':
            case 'string':
            case 'undefined':
                return true;
            case 'boolean':
                return !propValue;
            case 'object':
                if (Array.isArray(propValue)) return propValue.every(isNode);
                if (propValue === null || isValidElement(propValue)) return true;
                var iteratorFn = getIteratorFn(propValue);
                if (iteratorFn) {
                    var iterator = iteratorFn.call(propValue);
                    var step;
                    if (iteratorFn !== propValue.entries) while(!(step = iterator.next()).done){
                        if (!isNode(step.value)) return false;
                    }
                    else // Iterator will provide entry [k,v] tuples rather than values.
                    while(!(step = iterator.next()).done){
                        var entry = step.value;
                        if (entry) {
                            if (!isNode(entry[1])) return false;
                        }
                    }
                } else return false;
                return true;
            default:
                return false;
        }
    }
    function isSymbol(propType, propValue) {
        // Native Symbol.
        if (propType === 'symbol') return true;
        // falsy value can't be a Symbol
        if (!propValue) return false;
        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
        if (propValue['@@toStringTag'] === 'Symbol') return true;
        // Fallback for non-spec compliant Symbols which are polyfilled.
        if (typeof Symbol === 'function' && propValue instanceof Symbol) return true;
        return false;
    }
    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) return 'array';
        if (propValue instanceof RegExp) // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return 'object';
        if (isSymbol(propType, propValue)) return 'symbol';
        return propType;
    }
    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
        if (typeof propValue === 'undefined' || propValue === null) return '' + propValue;
        var propType = getPropType(propValue);
        if (propType === 'object') {
            if (propValue instanceof Date) return 'date';
            else if (propValue instanceof RegExp) return 'regexp';
        }
        return propType;
    }
    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch(type){
            case 'array':
            case 'object':
                return 'an ' + type;
            case 'boolean':
            case 'date':
            case 'regexp':
                return 'a ' + type;
            default:
                return type;
        }
    }
    // Returns class name of the object, if any.
    function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) return ANONYMOUS;
        return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
};

},{"react-is":"1fpDl","object-assign":"dkHwz","./lib/ReactPropTypesSecret":"jGtsG","./checkPropTypes":"b0hSy"}],"jGtsG":[function(require,module,exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
module.exports = ReactPropTypesSecret;

},{}],"b0hSy":[function(require,module,exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
var printWarning = function() {
};
var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
var loggedTypeFailures = {
};
var has = Function.call.bind(Object.prototype.hasOwnProperty);
printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') console.error(message);
    try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
    } catch (x) {
    }
};
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    for(var typeSpecName in typeSpecs)if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            if (typeof typeSpecs[typeSpecName] !== 'function') {
                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.');
                err.name = 'Invariant Violation';
                throw err;
            }
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
            error = ex;
        }
        if (error && !(error instanceof Error)) printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : '';
            printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
        }
    }
}
/**
 * Resets warning cache when testing.
 *
 * @private
 */ checkPropTypes.resetWarningCache = function() {
    loggedTypeFailures = {
    };
};
module.exports = checkPropTypes;

},{"./lib/ReactPropTypesSecret":"jGtsG"}],"cS959":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function toVal(mix) {
    var k, y, str = '';
    if (typeof mix === 'string' || typeof mix === 'number') str += mix;
    else if (typeof mix === 'object') {
        if (Array.isArray(mix)) for(k = 0; k < mix.length; k++){
            if (mix[k]) {
                if (y = toVal(mix[k])) {
                    str && (str += ' ');
                    str += y;
                }
            }
        }
        else {
            for(k in mix)if (mix[k]) {
                str && (str += ' ');
                str += k;
            }
        }
    }
    return str;
}
exports.default = function() {
    var i = 0, tmp, x, str = '';
    while(i < arguments.length){
        if (tmp = arguments[i++]) {
            if (x = toVal(tmp)) {
                str && (str += ' ');
                str += x;
            }
        }
    }
    return str;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"Uumnw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @license Material-UI v4.11.2
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ parcelHelpers.export(exports, "chainPropTypes", ()=>_chainPropTypesDefault.default
);
parcelHelpers.export(exports, "deepmerge", ()=>_deepmergeDefault.default
);
parcelHelpers.export(exports, "elementAcceptingRef", ()=>_elementAcceptingRefDefault.default
);
parcelHelpers.export(exports, "elementTypeAcceptingRef", ()=>_elementTypeAcceptingRefDefault.default
);
parcelHelpers.export(exports, "exactProp", ()=>_exactPropDefault.default
);
parcelHelpers.export(exports, "formatMuiErrorMessage", ()=>_formatMuiErrorMessageDefault.default
);
parcelHelpers.export(exports, "getDisplayName", ()=>_getDisplayNameDefault.default
);
parcelHelpers.export(exports, "HTMLElementType", ()=>_htmlelementTypeDefault.default
);
parcelHelpers.export(exports, "ponyfillGlobal", ()=>_ponyfillGlobalDefault.default
);
parcelHelpers.export(exports, "refType", ()=>_refTypeDefault.default
);
var _chainPropTypes = require("./chainPropTypes");
var _chainPropTypesDefault = parcelHelpers.interopDefault(_chainPropTypes);
var _deepmerge = require("./deepmerge");
var _deepmergeDefault = parcelHelpers.interopDefault(_deepmerge);
var _elementAcceptingRef = require("./elementAcceptingRef");
var _elementAcceptingRefDefault = parcelHelpers.interopDefault(_elementAcceptingRef);
var _elementTypeAcceptingRef = require("./elementTypeAcceptingRef");
var _elementTypeAcceptingRefDefault = parcelHelpers.interopDefault(_elementTypeAcceptingRef);
var _exactProp = require("./exactProp");
var _exactPropDefault = parcelHelpers.interopDefault(_exactProp);
var _formatMuiErrorMessage = require("./formatMuiErrorMessage");
var _formatMuiErrorMessageDefault = parcelHelpers.interopDefault(_formatMuiErrorMessage);
var _getDisplayName = require("./getDisplayName");
var _getDisplayNameDefault = parcelHelpers.interopDefault(_getDisplayName);
var _htmlelementType = require("./HTMLElementType");
var _htmlelementTypeDefault = parcelHelpers.interopDefault(_htmlelementType);
var _ponyfillGlobal = require("./ponyfillGlobal");
var _ponyfillGlobalDefault = parcelHelpers.interopDefault(_ponyfillGlobal);
var _refType = require("./refType");
var _refTypeDefault = parcelHelpers.interopDefault(_refType);

},{"./chainPropTypes":"cHAx1","./deepmerge":"845fv","./elementAcceptingRef":"lv9JU","./elementTypeAcceptingRef":"4ehHe","./exactProp":"2rDI3","./formatMuiErrorMessage":"agsOS","./getDisplayName":"hT7gA","./HTMLElementType":"aIIXn","./ponyfillGlobal":"fre7E","./refType":"jvG4R","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"cHAx1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function chainPropTypes(propType1, propType2) {
    return function validate() {
        return propType1.apply(void 0, arguments) || propType2.apply(void 0, arguments);
    };
}
exports.default = chainPropTypes;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"845fv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _typeof = require("@babel/runtime/helpers/esm/typeof");
var _typeofDefault = parcelHelpers.interopDefault(_typeof);
function isPlainObject(item) {
    return item && _typeofDefault.default(item) === 'object' && item.constructor === Object;
}
function deepmerge(target, source) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        clone: true
    };
    var output = options.clone ? _extendsDefault.default({
    }, target) : target;
    if (isPlainObject(target) && isPlainObject(source)) Object.keys(source).forEach(function(key) {
        // Avoid prototype pollution
        if (key === '__proto__') return;
        if (isPlainObject(source[key]) && key in target) output[key] = deepmerge(target[key], source[key], options);
        else output[key] = source[key];
    });
    return output;
}
exports.default = deepmerge;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/typeof":"sHS2O","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"sHS2O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof1(obj1) {
        return typeof obj1;
    };
    else _typeof = function _typeof2(obj1) {
        return obj1 && typeof Symbol === "function" && obj1.constructor === Symbol && obj1 !== Symbol.prototype ? "symbol" : typeof obj1;
    };
    return _typeof(obj);
}
exports.default = _typeof;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"lv9JU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _chainPropTypes = require("./chainPropTypes");
var _chainPropTypesDefault = parcelHelpers.interopDefault(_chainPropTypes);
function isClassComponent(elementType) {
    // elementType.prototype?.isReactComponent
    var _elementType$prototyp = elementType.prototype, prototype = _elementType$prototyp === void 0 ? {
    } : _elementType$prototyp;
    return Boolean(prototype.isReactComponent);
}
function acceptingRef(props, propName, componentName, location, propFullName) {
    var element = props[propName];
    var safePropName = propFullName || propName;
    if (element == null) return null;
    var warningHint;
    var elementType = element.type;
    /**
   * Blacklisting instead of whitelisting
   *
   * Blacklisting will miss some components, such as React.Fragment. Those will at least
   * trigger a warning in React.
   * We can't whitelist because there is no safe way to detect React.forwardRef
   * or class components. "Safe" means there's no public API.
   *
   */ if (typeof elementType === 'function' && !isClassComponent(elementType)) warningHint = 'Did you accidentally use a plain function component for an element instead?';
    if (warningHint !== undefined) return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an element that can hold a ref. ".concat(warningHint, " ") + 'For more information see https://material-ui.com/r/caveat-with-refs-guide');
    return null;
}
var elementAcceptingRef = _chainPropTypesDefault.default(_propTypesDefault.default.element, acceptingRef);
elementAcceptingRef.isRequired = _chainPropTypesDefault.default(_propTypesDefault.default.element.isRequired, acceptingRef);
exports.default = elementAcceptingRef;

},{"prop-types":"lYCp3","./chainPropTypes":"cHAx1","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"4ehHe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _propTypes = require("prop-types");
var _chainPropTypes = require("./chainPropTypes");
var _chainPropTypesDefault = parcelHelpers.interopDefault(_chainPropTypes);
function isClassComponent(elementType) {
    // elementType.prototype?.isReactComponent
    var _elementType$prototyp = elementType.prototype, prototype = _elementType$prototyp === void 0 ? {
    } : _elementType$prototyp;
    return Boolean(prototype.isReactComponent);
}
function elementTypeAcceptingRef(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var safePropName = propFullName || propName;
    if (propValue == null) return null;
    var warningHint;
    /**
   * Blacklisting instead of whitelisting
   *
   * Blacklisting will miss some components, such as React.Fragment. Those will at least
   * trigger a warning in React.
   * We can't whitelist because there is no safe way to detect React.forwardRef
   * or class components. "Safe" means there's no public API.
   *
   */ if (typeof propValue === 'function' && !isClassComponent(propValue)) warningHint = 'Did you accidentally provide a plain function component instead?';
    if (warningHint !== undefined) return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an element type that can hold a ref. ".concat(warningHint, " ") + 'For more information see https://material-ui.com/r/caveat-with-refs-guide');
    return null;
}
exports.default = _chainPropTypesDefault.default(_propTypes.elementType, elementTypeAcceptingRef);

},{"prop-types":"lYCp3","./chainPropTypes":"cHAx1","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"2rDI3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "specialProperty", ()=>specialProperty
);
var _defineProperty = require("@babel/runtime/helpers/esm/defineProperty");
var _definePropertyDefault = parcelHelpers.interopDefault(_defineProperty);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var specialProperty = "exact-prop: \u200B";
function exactProp(propTypes) {
    return _extendsDefault.default({
    }, propTypes, _definePropertyDefault.default({
    }, specialProperty, function(props) {
        var unsupportedProps = Object.keys(props).filter(function(prop) {
            return !propTypes.hasOwnProperty(prop);
        });
        if (unsupportedProps.length > 0) return new Error("The following props are not supported: ".concat(unsupportedProps.map(function(prop) {
            return "`".concat(prop, "`");
        }).join(', '), ". Please remove them."));
        return null;
    }));
}
exports.default = exactProp;

},{"@babel/runtime/helpers/esm/defineProperty":"c51LI","@babel/runtime/helpers/esm/extends":"esrVD","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"c51LI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
exports.default = _defineProperty;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"agsOS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function formatMuiErrorMessage(code) {
    // Apply babel-plugin-transform-template-literals in loose mode
    // loose mode is safe iff we're concatenating primitives
    // see https://babeljs.io/docs/en/babel-plugin-transform-template-literals#loose
    /* eslint-disable prefer-template */ var url = 'https://material-ui.com/production-error/?code=' + code;
    for(var i = 1; i < arguments.length; i += 1)// rest params over-transpile for this case
    // eslint-disable-next-line prefer-rest-params
    url += '&args[]=' + encodeURIComponent(arguments[i]);
    return 'Minified Material-UI error #' + code + '; visit ' + url + ' for the full message.';
/* eslint-enable prefer-template */ }
exports.default = formatMuiErrorMessage;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hT7gA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getFunctionName", ()=>getFunctionName
);
var _typeof = require("@babel/runtime/helpers/esm/typeof");
var _typeofDefault = parcelHelpers.interopDefault(_typeof);
var _reactIs = require("react-is"); // Simplified polyfill for IE 11 support
// https://github.com/JamesMGreene/Function.name/blob/58b314d4a983110c3682f1228f845d39ccca1817/Function.name.js#L3
var fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function getFunctionName(fn) {
    var match = "".concat(fn).match(fnNameMatchRegex);
    var name = match && match[1];
    return name || '';
}
/**
 * @param {function} Component
 * @param {string} fallback
 * @returns {string | undefined}
 */ function getFunctionComponentName(Component) {
    var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    return Component.displayName || Component.name || getFunctionName(Component) || fallback;
}
function getWrappedName(outerType, innerType, wrapperName) {
    var functionName = getFunctionComponentName(innerType);
    return outerType.displayName || (functionName !== '' ? "".concat(wrapperName, "(").concat(functionName, ")") : wrapperName);
}
function getDisplayName(Component) {
    if (Component == null) return undefined;
    if (typeof Component === 'string') return Component;
    if (typeof Component === 'function') return getFunctionComponentName(Component, 'Component');
    if (_typeofDefault.default(Component) === 'object') switch(Component.$$typeof){
        case _reactIs.ForwardRef:
            return getWrappedName(Component, Component.render, 'ForwardRef');
        case _reactIs.Memo:
            return getWrappedName(Component, Component.type, 'memo');
        default:
            return undefined;
    }
    return undefined;
}
exports.default = getDisplayName;

},{"@babel/runtime/helpers/esm/typeof":"sHS2O","react-is":"gtJo0","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"gtJo0":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/react-is.development.js');

},{"./cjs/react-is.development.js":"ej4nK"}],"ej4nK":[function(require,module,exports) {
/** @license React v17.0.2
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 60103;
    var REACT_PORTAL_TYPE = 60106;
    var REACT_FRAGMENT_TYPE = 60107;
    var REACT_STRICT_MODE_TYPE = 60108;
    var REACT_PROFILER_TYPE = 60114;
    var REACT_PROVIDER_TYPE = 60109;
    var REACT_CONTEXT_TYPE = 60110;
    var REACT_FORWARD_REF_TYPE = 60112;
    var REACT_SUSPENSE_TYPE = 60113;
    var REACT_SUSPENSE_LIST_TYPE = 60120;
    var REACT_MEMO_TYPE = 60115;
    var REACT_LAZY_TYPE = 60116;
    var REACT_BLOCK_TYPE = 60121;
    var REACT_SERVER_BLOCK_TYPE = 60122;
    var REACT_FUNDAMENTAL_TYPE = 60117;
    var REACT_SCOPE_TYPE = 60119;
    var REACT_OPAQUE_ID_TYPE = 60128;
    var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
    var REACT_OFFSCREEN_TYPE = 60130;
    var REACT_LEGACY_HIDDEN_TYPE = 60131;
    if (typeof Symbol === 'function' && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor('react.element');
        REACT_PORTAL_TYPE = symbolFor('react.portal');
        REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
        REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
        REACT_PROFILER_TYPE = symbolFor('react.profiler');
        REACT_PROVIDER_TYPE = symbolFor('react.provider');
        REACT_CONTEXT_TYPE = symbolFor('react.context');
        REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
        REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
        REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
        REACT_MEMO_TYPE = symbolFor('react.memo');
        REACT_LAZY_TYPE = symbolFor('react.lazy');
        REACT_BLOCK_TYPE = symbolFor('react.block');
        REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
        REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
        REACT_SCOPE_TYPE = symbolFor('react.scope');
        REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
        REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
        REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
        REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
    }
    // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.
    var enableScopeAPI = false; // Experimental Create Event Handle API.
    function isValidElementType(type) {
        if (typeof type === 'string' || typeof type === 'function') return true;
         // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) return true;
        if (typeof type === 'object' && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) return true;
        }
        return false;
    }
    function typeOf(object) {
        if (typeof object === 'object' && object !== null) {
            var $$typeof = object.$$typeof;
            switch($$typeof){
                case REACT_ELEMENT_TYPE:
                    var type = object.type;
                    switch(type){
                        case REACT_FRAGMENT_TYPE:
                        case REACT_PROFILER_TYPE:
                        case REACT_STRICT_MODE_TYPE:
                        case REACT_SUSPENSE_TYPE:
                        case REACT_SUSPENSE_LIST_TYPE:
                            return type;
                        default:
                            var $$typeofType = type && type.$$typeof;
                            switch($$typeofType){
                                case REACT_CONTEXT_TYPE:
                                case REACT_FORWARD_REF_TYPE:
                                case REACT_LAZY_TYPE:
                                case REACT_MEMO_TYPE:
                                case REACT_PROVIDER_TYPE:
                                    return $$typeofType;
                                default:
                                    return $$typeof;
                            }
                    }
                case REACT_PORTAL_TYPE:
                    return $$typeof;
            }
        }
        return undefined;
    }
    var ContextConsumer = REACT_CONTEXT_TYPE;
    var ContextProvider = REACT_PROVIDER_TYPE;
    var Element1 = REACT_ELEMENT_TYPE;
    var ForwardRef = REACT_FORWARD_REF_TYPE;
    var Fragment = REACT_FRAGMENT_TYPE;
    var Lazy = REACT_LAZY_TYPE;
    var Memo = REACT_MEMO_TYPE;
    var Portal = REACT_PORTAL_TYPE;
    var Profiler = REACT_PROFILER_TYPE;
    var StrictMode = REACT_STRICT_MODE_TYPE;
    var Suspense = REACT_SUSPENSE_TYPE;
    var hasWarnedAboutDeprecatedIsAsyncMode = false;
    var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated
    function isAsyncMode(object) {
        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint
            console['warn']("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
        }
        return false;
    }
    function isConcurrentMode(object) {
        if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
            hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint
            console['warn']("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
        }
        return false;
    }
    function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
    }
    function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
    }
    function isElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }
    function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
    }
    function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
    }
    function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
    }
    function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
    }
    function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
    }
    function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }
    function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
    }
    exports.ContextConsumer = ContextConsumer;
    exports.ContextProvider = ContextProvider;
    exports.Element = Element1;
    exports.ForwardRef = ForwardRef;
    exports.Fragment = Fragment;
    exports.Lazy = Lazy;
    exports.Memo = Memo;
    exports.Portal = Portal;
    exports.Profiler = Profiler;
    exports.StrictMode = StrictMode;
    exports.Suspense = Suspense;
    exports.isAsyncMode = isAsyncMode;
    exports.isConcurrentMode = isConcurrentMode;
    exports.isContextConsumer = isContextConsumer;
    exports.isContextProvider = isContextProvider;
    exports.isElement = isElement;
    exports.isForwardRef = isForwardRef;
    exports.isFragment = isFragment;
    exports.isLazy = isLazy;
    exports.isMemo = isMemo;
    exports.isPortal = isPortal;
    exports.isProfiler = isProfiler;
    exports.isStrictMode = isStrictMode;
    exports.isSuspense = isSuspense;
    exports.isValidElementType = isValidElementType;
    exports.typeOf = typeOf;
})();

},{}],"aIIXn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function HTMLElementType(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var safePropName = propFullName || propName;
    if (propValue == null) return null;
    if (propValue && propValue.nodeType !== 1) return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an HTMLElement.");
    return null;
}
exports.default = HTMLElementType;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"fre7E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"jvG4R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var refType = _propTypesDefault.default.oneOfType([
    _propTypesDefault.default.func,
    _propTypesDefault.default.object
]);
exports.default = refType;

},{"prop-types":"lYCp3","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"1b3pY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_inputDefault.default
);
var _input = require("./Input");
var _inputDefault = parcelHelpers.interopDefault(_input);

},{"./Input":"dp691","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"dp691":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _inputBase = require("../InputBase");
var _inputBaseDefault = parcelHelpers.interopDefault(_inputBase);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var styles = function styles1(theme) {
    var light = theme.palette.type === 'light';
    var bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
    return {
        /* Styles applied to the root element. */ root: {
            position: 'relative'
        },
        /* Styles applied to the root element if the component is a descendant of `FormControl`. */ formControl: {
            'label + &': {
                marginTop: 16
            }
        },
        /* Styles applied to the root element if the component is focused. */ focused: {
        },
        /* Styles applied to the root element if `disabled={true}`. */ disabled: {
        },
        /* Styles applied to the root element if color secondary. */ colorSecondary: {
            '&$underline:after': {
                borderBottomColor: theme.palette.secondary.main
            }
        },
        /* Styles applied to the root element if `disableUnderline={false}`. */ underline: {
            '&:after': {
                borderBottom: "2px solid ".concat(theme.palette.primary.main),
                left: 0,
                bottom: 0,
                // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
                content: '""',
                position: 'absolute',
                right: 0,
                transform: 'scaleX(0)',
                transition: theme.transitions.create('transform', {
                    duration: theme.transitions.duration.shorter,
                    easing: theme.transitions.easing.easeOut
                }),
                pointerEvents: 'none' // Transparent to the hover style.
            },
            '&$focused:after': {
                transform: 'scaleX(1)'
            },
            '&$error:after': {
                borderBottomColor: theme.palette.error.main,
                transform: 'scaleX(1)' // error is always underlined in red
            },
            '&:before': {
                borderBottom: "1px solid ".concat(bottomLineColor),
                left: 0,
                bottom: 0,
                // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
                content: '"\\00a0"',
                position: 'absolute',
                right: 0,
                transition: theme.transitions.create('border-bottom-color', {
                    duration: theme.transitions.duration.shorter
                }),
                pointerEvents: 'none' // Transparent to the hover style.
            },
            '&:hover:not($disabled):before': {
                borderBottom: "2px solid ".concat(theme.palette.text.primary),
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    borderBottom: "1px solid ".concat(bottomLineColor)
                }
            },
            '&$disabled:before': {
                borderBottomStyle: 'dotted'
            }
        },
        /* Pseudo-class applied to the root element if `error={true}`. */ error: {
        },
        /* Styles applied to the `input` element if `margin="dense"`. */ marginDense: {
        },
        /* Styles applied to the root element if `multiline={true}`. */ multiline: {
        },
        /* Styles applied to the root element if `fullWidth={true}`. */ fullWidth: {
        },
        /* Styles applied to the `input` element. */ input: {
        },
        /* Styles applied to the `input` element if `margin="dense"`. */ inputMarginDense: {
        },
        /* Styles applied to the `input` element if `multiline={true}`. */ inputMultiline: {
        },
        /* Styles applied to the `input` element if `type="search"`. */ inputTypeSearch: {
        }
    };
};
var Input = /*#__PURE__*/ _react.forwardRef(function Input1(props, ref) {
    var disableUnderline = props.disableUnderline, classes = props.classes, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$inputComponent = props.inputComponent, inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent, _props$multiline = props.multiline, multiline = _props$multiline === void 0 ? false : _props$multiline, _props$type = props.type, type = _props$type === void 0 ? 'text' : _props$type, other = _objectWithoutPropertiesDefault.default(props, [
        "disableUnderline",
        "classes",
        "fullWidth",
        "inputComponent",
        "multiline",
        "type"
    ]);
    return(/*#__PURE__*/ _react.createElement(_inputBaseDefault.default, _extendsDefault.default({
        classes: _extendsDefault.default({
        }, classes, {
            root: _clsxDefault.default(classes.root, !disableUnderline && classes.underline),
            underline: null
        }),
        fullWidth: fullWidth,
        inputComponent: inputComponent,
        multiline: multiline,
        ref: ref,
        type: type
    }, other)));
});
Input.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */ autoComplete: _propTypesDefault.default.string,
    /**
   * If `true`, the `input` element will be focused during the first mount.
   */ autoFocus: _propTypesDefault.default.bool,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */ color: _propTypesDefault.default.oneOf([
        'primary',
        'secondary'
    ]),
    /**
   * The default `input` element value. Use when the component is not controlled.
   */ defaultValue: _propTypesDefault.default.any,
    /**
   * If `true`, the `input` element will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * If `true`, the input will not have an underline.
   */ disableUnderline: _propTypesDefault.default.bool,
    /**
   * End `InputAdornment` for this component.
   */ endAdornment: _propTypesDefault.default.node,
    /**
   * If `true`, the input will indicate an error. This is normally obtained via context from
   * FormControl.
   */ error: _propTypesDefault.default.bool,
    /**
   * If `true`, the input will take up the full width of its container.
   */ fullWidth: _propTypesDefault.default.bool,
    /**
   * The id of the `input` element.
   */ id: _propTypesDefault.default.string,
    /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   */ inputComponent: _propTypesDefault.default.elementType,
    /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */ inputProps: _propTypesDefault.default.object,
    /**
   * Pass a ref to the `input` element.
   */ inputRef: _utils.refType,
    /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */ margin: _propTypesDefault.default.oneOf([
        'dense',
        'none'
    ]),
    /**
   * Maximum number of rows to display when multiline option is set to true.
   */ maxRows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * If `true`, a textarea element will be rendered.
   */ multiline: _propTypesDefault.default.bool,
    /**
   * Name attribute of the `input` element.
   */ name: _propTypesDefault.default.string,
    /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */ onChange: _propTypesDefault.default.func,
    /**
   * The short hint displayed in the input before the user enters a value.
   */ placeholder: _propTypesDefault.default.string,
    /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */ readOnly: _propTypesDefault.default.bool,
    /**
   * If `true`, the `input` element will be required.
   */ required: _propTypesDefault.default.bool,
    /**
   * Number of rows to display when multiline option is set to true.
   */ rows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * Start `InputAdornment` for this component.
   */ startAdornment: _propTypesDefault.default.node,
    /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */ type: _propTypesDefault.default.string,
    /**
   * The value of the `input` element, required for a controlled component.
   */ value: _propTypesDefault.default.any
};
Input.muiName = 'Input';
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiInput'
})(Input);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","@material-ui/utils":"Uumnw","../InputBase":"43mUM","../styles/withStyles":"3pIr2","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"43mUM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_inputBaseDefault.default
);
var _inputBase = require("./InputBase");
var _inputBaseDefault = parcelHelpers.interopDefault(_inputBase);

},{"./InputBase":"byHwr","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"byHwr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _utils = require("@material-ui/utils");
/* eslint-disable jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions */ var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _formControlState = require("../FormControl/formControlState");
var _formControlStateDefault = parcelHelpers.interopDefault(_formControlState);
var _formControlContext = require("../FormControl/FormControlContext");
var _formControlContextDefault = parcelHelpers.interopDefault(_formControlContext);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _capitalize = require("../utils/capitalize");
var _capitalizeDefault = parcelHelpers.interopDefault(_capitalize);
var _useForkRef = require("../utils/useForkRef");
var _useForkRefDefault = parcelHelpers.interopDefault(_useForkRef);
var _textareaAutosize = require("../TextareaAutosize");
var _textareaAutosizeDefault = parcelHelpers.interopDefault(_textareaAutosize);
var _utils1 = require("./utils");
var styles = function styles1(theme) {
    var light = theme.palette.type === 'light';
    var placeholder = {
        color: 'currentColor',
        opacity: light ? 0.42 : 0.5,
        transition: theme.transitions.create('opacity', {
            duration: theme.transitions.duration.shorter
        })
    };
    var placeholderHidden = {
        opacity: '0 !important'
    };
    var placeholderVisible = {
        opacity: light ? 0.42 : 0.5
    };
    return {
        '@global': {
            '@keyframes mui-auto-fill': {
            },
            '@keyframes mui-auto-fill-cancel': {
            }
        },
        /* Styles applied to the root element. */ root: _extendsDefault.default({
        }, theme.typography.body1, {
            color: theme.palette.text.primary,
            lineHeight: '1.1876em',
            // Reset (19px), match the native input line-height
            boxSizing: 'border-box',
            // Prevent padding issue with fullWidth.
            position: 'relative',
            cursor: 'text',
            display: 'inline-flex',
            alignItems: 'center',
            '&$disabled': {
                color: theme.palette.text.disabled,
                cursor: 'default'
            }
        }),
        /* Styles applied to the root element if the component is a descendant of `FormControl`. */ formControl: {
        },
        /* Styles applied to the root element if the component is focused. */ focused: {
        },
        /* Styles applied to the root element if `disabled={true}`. */ disabled: {
        },
        /* Styles applied to the root element if `startAdornment` is provided. */ adornedStart: {
        },
        /* Styles applied to the root element if `endAdornment` is provided. */ adornedEnd: {
        },
        /* Pseudo-class applied to the root element if `error={true}`. */ error: {
        },
        /* Styles applied to the `input` element if `margin="dense"`. */ marginDense: {
        },
        /* Styles applied to the root element if `multiline={true}`. */ multiline: {
            padding: "".concat(6, "px 0 ").concat(7, "px"),
            '&$marginDense': {
                paddingTop: 3
            }
        },
        /* Styles applied to the root element if the color is secondary. */ colorSecondary: {
        },
        /* Styles applied to the root element if `fullWidth={true}`. */ fullWidth: {
            width: '100%'
        },
        /* Styles applied to the `input` element. */ input: {
            font: 'inherit',
            letterSpacing: 'inherit',
            color: 'currentColor',
            padding: "".concat(6, "px 0 ").concat(7, "px"),
            border: 0,
            boxSizing: 'content-box',
            background: 'none',
            height: '1.1876em',
            // Reset (19px), match the native input line-height
            margin: 0,
            // Reset for Safari
            WebkitTapHighlightColor: 'transparent',
            display: 'block',
            // Make the flex item shrink with Firefox
            minWidth: 0,
            width: '100%',
            // Fix IE 11 width issue
            animationName: 'mui-auto-fill-cancel',
            animationDuration: '10ms',
            '&::-webkit-input-placeholder': placeholder,
            '&::-moz-placeholder': placeholder,
            // Firefox 19+
            '&:-ms-input-placeholder': placeholder,
            // IE 11
            '&::-ms-input-placeholder': placeholder,
            // Edge
            '&:focus': {
                outline: 0
            },
            // Reset Firefox invalid required input style
            '&:invalid': {
                boxShadow: 'none'
            },
            '&::-webkit-search-decoration': {
                // Remove the padding when type=search.
                '-webkit-appearance': 'none'
            },
            // Show and hide the placeholder logic
            'label[data-shrink=false] + $formControl &': {
                '&::-webkit-input-placeholder': placeholderHidden,
                '&::-moz-placeholder': placeholderHidden,
                // Firefox 19+
                '&:-ms-input-placeholder': placeholderHidden,
                // IE 11
                '&::-ms-input-placeholder': placeholderHidden,
                // Edge
                '&:focus::-webkit-input-placeholder': placeholderVisible,
                '&:focus::-moz-placeholder': placeholderVisible,
                // Firefox 19+
                '&:focus:-ms-input-placeholder': placeholderVisible,
                // IE 11
                '&:focus::-ms-input-placeholder': placeholderVisible // Edge
            },
            '&$disabled': {
                opacity: 1 // Reset iOS opacity
            },
            '&:-webkit-autofill': {
                animationDuration: '5000s',
                animationName: 'mui-auto-fill'
            }
        },
        /* Styles applied to the `input` element if `margin="dense"`. */ inputMarginDense: {
            paddingTop: 3
        },
        /* Styles applied to the `input` element if `multiline={true}`. */ inputMultiline: {
            height: 'auto',
            resize: 'none',
            padding: 0
        },
        /* Styles applied to the `input` element if `type="search"`. */ inputTypeSearch: {
            // Improve type search style.
            '-moz-appearance': 'textfield',
            '-webkit-appearance': 'textfield'
        },
        /* Styles applied to the `input` element if `startAdornment` is provided. */ inputAdornedStart: {
        },
        /* Styles applied to the `input` element if `endAdornment` is provided. */ inputAdornedEnd: {
        },
        /* Styles applied to the `input` element if `hiddenLabel={true}`. */ inputHiddenLabel: {
        }
    };
};
var useEnhancedEffect = typeof window === 'undefined' ? _react.useEffect : _react.useLayoutEffect;
/**
 * `InputBase` contains as few styles as possible.
 * It aims to be a simple building block for creating an input.
 * It contains a load of style reset and some state logic.
 */ var InputBase = /*#__PURE__*/ _react.forwardRef(function InputBase1(props, ref) {
    var ariaDescribedby = props['aria-describedby'], autoComplete = props.autoComplete, autoFocus = props.autoFocus, classes = props.classes, className = props.className, color = props.color, defaultValue = props.defaultValue, disabled = props.disabled, endAdornment = props.endAdornment, error = props.error, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, id = props.id, _props$inputComponent = props.inputComponent, inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent, _props$inputProps = props.inputProps, inputPropsProp = _props$inputProps === void 0 ? {
    } : _props$inputProps, inputRefProp = props.inputRef, margin = props.margin, _props$multiline = props.multiline, multiline = _props$multiline === void 0 ? false : _props$multiline, name = props.name, onBlur = props.onBlur, onChange = props.onChange, onClick = props.onClick, onFocus = props.onFocus, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, placeholder = props.placeholder, readOnly = props.readOnly, renderSuffix = props.renderSuffix, rows = props.rows, rowsMax = props.rowsMax, rowsMin = props.rowsMin, maxRows = props.maxRows, minRows = props.minRows, startAdornment = props.startAdornment, _props$type = props.type, type = _props$type === void 0 ? 'text' : _props$type, valueProp = props.value, other = _objectWithoutPropertiesDefault.default(props, [
        "aria-describedby",
        "autoComplete",
        "autoFocus",
        "classes",
        "className",
        "color",
        "defaultValue",
        "disabled",
        "endAdornment",
        "error",
        "fullWidth",
        "id",
        "inputComponent",
        "inputProps",
        "inputRef",
        "margin",
        "multiline",
        "name",
        "onBlur",
        "onChange",
        "onClick",
        "onFocus",
        "onKeyDown",
        "onKeyUp",
        "placeholder",
        "readOnly",
        "renderSuffix",
        "rows",
        "rowsMax",
        "rowsMin",
        "maxRows",
        "minRows",
        "startAdornment",
        "type",
        "value"
    ]);
    var value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
    var _React$useRef = _react.useRef(value != null), isControlled = _React$useRef.current;
    var inputRef = _react.useRef();
    var handleInputRefWarning = _react.useCallback(function(instance) {
        if (instance && instance.nodeName !== 'INPUT' && !instance.focus) console.error([
            'Material-UI: You have provided a `inputComponent` to the input component',
            'that does not correctly handle the `inputRef` prop.',
            'Make sure the `inputRef` prop is called with a HTMLInputElement.'
        ].join('\n'));
    }, []);
    var handleInputPropsRefProp = _useForkRefDefault.default(inputPropsProp.ref, handleInputRefWarning);
    var handleInputRefProp = _useForkRefDefault.default(inputRefProp, handleInputPropsRefProp);
    var handleInputRef = _useForkRefDefault.default(inputRef, handleInputRefProp);
    var _React$useState = _react.useState(false), focused = _React$useState[0], setFocused = _React$useState[1];
    var muiFormControl = _formControlContext.useFormControl();
    // eslint-disable-next-line react-hooks/rules-of-hooks
    _react.useEffect(function() {
        if (muiFormControl) return muiFormControl.registerEffect();
        return undefined;
    }, [
        muiFormControl
    ]);
    var fcs = _formControlStateDefault.default({
        props: props,
        muiFormControl: muiFormControl,
        states: [
            'color',
            'disabled',
            'error',
            'hiddenLabel',
            'margin',
            'required',
            'filled'
        ]
    });
    fcs.focused = muiFormControl ? muiFormControl.focused : focused; // The blur won't fire when the disabled state is set on a focused input.
    // We need to book keep the focused state manually.
    _react.useEffect(function() {
        if (!muiFormControl && disabled && focused) {
            setFocused(false);
            if (onBlur) onBlur();
        }
    }, [
        muiFormControl,
        disabled,
        focused,
        onBlur
    ]);
    var onFilled = muiFormControl && muiFormControl.onFilled;
    var onEmpty = muiFormControl && muiFormControl.onEmpty;
    var checkDirty = _react.useCallback(function(obj) {
        if (_utils1.isFilled(obj)) {
            if (onFilled) onFilled();
        } else if (onEmpty) onEmpty();
    }, [
        onFilled,
        onEmpty
    ]);
    useEnhancedEffect(function() {
        if (isControlled) checkDirty({
            value: value
        });
    }, [
        value,
        checkDirty,
        isControlled
    ]);
    var handleFocus = function handleFocus1(event) {
        // Fix a bug with IE 11 where the focus/blur events are triggered
        // while the input is disabled.
        if (fcs.disabled) {
            event.stopPropagation();
            return;
        }
        if (onFocus) onFocus(event);
        if (inputPropsProp.onFocus) inputPropsProp.onFocus(event);
        if (muiFormControl && muiFormControl.onFocus) muiFormControl.onFocus(event);
        else setFocused(true);
    };
    var handleBlur = function handleBlur1(event) {
        if (onBlur) onBlur(event);
        if (inputPropsProp.onBlur) inputPropsProp.onBlur(event);
        if (muiFormControl && muiFormControl.onBlur) muiFormControl.onBlur(event);
        else setFocused(false);
    };
    var handleChange = function handleChange1(event) {
        if (!isControlled) {
            var element = event.target || inputRef.current;
            if (element == null) throw new Error("Material-UI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://material-ui.com/r/input-component-ref-interface for more info.");
            checkDirty({
                value: element.value
            });
        }
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
        if (inputPropsProp.onChange) inputPropsProp.onChange.apply(inputPropsProp, [
            event
        ].concat(args));
         // Perform in the willUpdate
        if (onChange) onChange.apply(void 0, [
            event
        ].concat(args));
    }; // Check the input state on mount, in case it was filled by the user
    // or auto filled by the browser before the hydration (for SSR).
    _react.useEffect(function() {
        checkDirty(inputRef.current);
    }, []); // eslint-disable-line react-hooks/exhaustive-deps
    var handleClick = function handleClick1(event) {
        if (inputRef.current && event.currentTarget === event.target) inputRef.current.focus();
        if (onClick) onClick(event);
    };
    var InputComponent = inputComponent;
    var inputProps = _extendsDefault.default({
    }, inputPropsProp, {
        ref: handleInputRef
    });
    if (typeof InputComponent !== 'string') inputProps = _extendsDefault.default({
        // Rename ref to inputRef as we don't know the
        // provided `inputComponent` structure.
        inputRef: handleInputRef,
        type: type
    }, inputProps, {
        ref: null
    });
    else if (multiline) {
        if (rows && !maxRows && !minRows && !rowsMax && !rowsMin) InputComponent = 'textarea';
        else {
            inputProps = _extendsDefault.default({
                minRows: rows || minRows,
                rowsMax: rowsMax,
                maxRows: maxRows
            }, inputProps);
            InputComponent = _textareaAutosizeDefault.default;
        }
    } else inputProps = _extendsDefault.default({
        type: type
    }, inputProps);
    var handleAutoFill = function handleAutoFill1(event) {
        // Provide a fake value as Chrome might not let you access it for security reasons.
        checkDirty(event.animationName === 'mui-auto-fill-cancel' ? inputRef.current : {
            value: 'x'
        });
    };
    _react.useEffect(function() {
        if (muiFormControl) muiFormControl.setAdornedStart(Boolean(startAdornment));
    }, [
        muiFormControl,
        startAdornment
    ]);
    return(/*#__PURE__*/ _react.createElement("div", _extendsDefault.default({
        className: _clsxDefault.default(classes.root, classes["color".concat(_capitalizeDefault.default(fcs.color || 'primary'))], className, fcs.disabled && classes.disabled, fcs.error && classes.error, fullWidth && classes.fullWidth, fcs.focused && classes.focused, muiFormControl && classes.formControl, multiline && classes.multiline, startAdornment && classes.adornedStart, endAdornment && classes.adornedEnd, fcs.margin === 'dense' && classes.marginDense),
        onClick: handleClick,
        ref: ref
    }, other), startAdornment, /*#__PURE__*/ _react.createElement(_formControlContextDefault.default.Provider, {
        value: null
    }, /*#__PURE__*/ _react.createElement(InputComponent, _extendsDefault.default({
        "aria-invalid": fcs.error,
        "aria-describedby": ariaDescribedby,
        autoComplete: autoComplete,
        autoFocus: autoFocus,
        defaultValue: defaultValue,
        disabled: fcs.disabled,
        id: id,
        onAnimationStart: handleAutoFill,
        name: name,
        placeholder: placeholder,
        readOnly: readOnly,
        required: fcs.required,
        rows: rows,
        value: value,
        onKeyDown: onKeyDown,
        onKeyUp: onKeyUp
    }, inputProps, {
        className: _clsxDefault.default(classes.input, inputPropsProp.className, fcs.disabled && classes.disabled, multiline && classes.inputMultiline, fcs.hiddenLabel && classes.inputHiddenLabel, startAdornment && classes.inputAdornedStart, endAdornment && classes.inputAdornedEnd, type === 'search' && classes.inputTypeSearch, fcs.margin === 'dense' && classes.inputMarginDense),
        onBlur: handleBlur,
        onChange: handleChange,
        onFocus: handleFocus
    }))), endAdornment, renderSuffix ? renderSuffix(_extendsDefault.default({
    }, fcs, {
        startAdornment: startAdornment
    })) : null));
});
InputBase.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * @ignore
   */ 'aria-describedby': _propTypesDefault.default.string,
    /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */ autoComplete: _propTypesDefault.default.string,
    /**
   * If `true`, the `input` element will be focused during the first mount.
   */ autoFocus: _propTypesDefault.default.bool,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */ color: _propTypesDefault.default.oneOf([
        'primary',
        'secondary'
    ]),
    /**
   * The default `input` element value. Use when the component is not controlled.
   */ defaultValue: _propTypesDefault.default.any,
    /**
   * If `true`, the `input` element will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * End `InputAdornment` for this component.
   */ endAdornment: _propTypesDefault.default.node,
    /**
   * If `true`, the input will indicate an error. This is normally obtained via context from
   * FormControl.
   */ error: _propTypesDefault.default.bool,
    /**
   * If `true`, the input will take up the full width of its container.
   */ fullWidth: _propTypesDefault.default.bool,
    /**
   * The id of the `input` element.
   */ id: _propTypesDefault.default.string,
    /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   */ inputComponent: _propTypesDefault.default.elementType,
    /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */ inputProps: _propTypesDefault.default.object,
    /**
   * Pass a ref to the `input` element.
   */ inputRef: _utils.refType,
    /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */ margin: _propTypesDefault.default.oneOf([
        'dense',
        'none'
    ]),
    /**
   * Maximum number of rows to display when multiline option is set to true.
   */ maxRows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * Minimum number of rows to display when multiline option is set to true.
   */ minRows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * If `true`, a textarea element will be rendered.
   */ multiline: _propTypesDefault.default.bool,
    /**
   * Name attribute of the `input` element.
   */ name: _propTypesDefault.default.string,
    /**
   * Callback fired when the input is blurred.
   *
   * Notice that the first argument (event) might be undefined.
   */ onBlur: _propTypesDefault.default.func,
    /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */ onChange: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onClick: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onFocus: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onKeyDown: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onKeyUp: _propTypesDefault.default.func,
    /**
   * The short hint displayed in the input before the user enters a value.
   */ placeholder: _propTypesDefault.default.string,
    /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */ readOnly: _propTypesDefault.default.bool,
    /**
   * @ignore
   */ renderSuffix: _propTypesDefault.default.func,
    /**
   * If `true`, the `input` element will be required.
   */ required: _propTypesDefault.default.bool,
    /**
   * Number of rows to display when multiline option is set to true.
   */ rows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * Maximum number of rows to display.
   * @deprecated Use `maxRows` instead.
   */ rowsMax: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * Minimum number of rows to display.
   * @deprecated Use `minRows` instead.
   */ rowsMin: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * Start `InputAdornment` for this component.
   */ startAdornment: _propTypesDefault.default.node,
    /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */ type: _propTypesDefault.default.string,
    /**
   * The value of the `input` element, required for a controlled component.
   */ value: _propTypesDefault.default.any
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiInputBase'
})(InputBase);

},{"@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@babel/runtime/helpers/esm/extends":"esrVD","@material-ui/utils":"Uumnw","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","../FormControl/formControlState":"hHO4w","../FormControl/FormControlContext":"k2RBZ","../styles/withStyles":"3pIr2","../utils/capitalize":"4RyDE","../utils/useForkRef":"bLpHM","../TextareaAutosize":"5gMaw","./utils":"4cvQH","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hHO4w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function formControlState(_ref) {
    var props = _ref.props, states = _ref.states, muiFormControl = _ref.muiFormControl;
    return states.reduce(function(acc, state) {
        acc[state] = props[state];
        if (muiFormControl) {
            if (typeof props[state] === 'undefined') acc[state] = muiFormControl[state];
        }
        return acc;
    }, {
    });
}
exports.default = formControlState;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"k2RBZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useFormControl", ()=>useFormControl
);
var _react = require("react");
/**
 * @ignore - internal component.
 */ var FormControlContext = _react.createContext();
FormControlContext.displayName = 'FormControlContext';
function useFormControl() {
    return _react.useContext(FormControlContext);
}
exports.default = FormControlContext;

},{"react":"cKM0D","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"3pIr2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _styles = require("@material-ui/styles");
var _defaultTheme = require("./defaultTheme");
var _defaultThemeDefault = parcelHelpers.interopDefault(_defaultTheme);
function withStyles(stylesOrCreator, options) {
    return _styles.withStyles(stylesOrCreator, _extendsDefault.default({
        defaultTheme: _defaultThemeDefault.default
    }, options));
}
exports.default = withStyles;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@material-ui/styles":"lPqjv","./defaultTheme":"l1m84","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"lPqjv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createGenerateClassName", ()=>_createGenerateClassNameDefault.default
);
parcelHelpers.export(exports, "createStyles", ()=>_createStylesDefault.default
);
parcelHelpers.export(exports, "getThemeProps", ()=>_getThemePropsDefault.default
);
parcelHelpers.export(exports, "jssPreset", ()=>_jssPresetDefault.default
);
parcelHelpers.export(exports, "makeStyles", ()=>_makeStylesDefault.default
);
parcelHelpers.export(exports, "mergeClasses", ()=>_mergeClassesDefault.default
);
parcelHelpers.export(exports, "ServerStyleSheets", ()=>_serverStyleSheetsDefault.default
);
parcelHelpers.export(exports, "styled", ()=>_styledDefault.default
);
parcelHelpers.export(exports, "StylesProvider", ()=>_stylesProviderDefault.default
);
parcelHelpers.export(exports, "ThemeProvider", ()=>_themeProviderDefault.default
);
parcelHelpers.export(exports, "useTheme", ()=>_useThemeDefault.default
);
parcelHelpers.export(exports, "withStyles", ()=>_withStylesDefault.default
);
parcelHelpers.export(exports, "withTheme", ()=>_withThemeDefault.default
);
/** @license Material-UI v4.11.4
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /* eslint-disable import/export */ var _utils = require("@material-ui/utils");
var _createGenerateClassName = require("./createGenerateClassName");
var _createGenerateClassNameDefault = parcelHelpers.interopDefault(_createGenerateClassName);
parcelHelpers.exportAll(_createGenerateClassName, exports);
var _createStyles = require("./createStyles");
var _createStylesDefault = parcelHelpers.interopDefault(_createStyles);
parcelHelpers.exportAll(_createStyles, exports);
var _getThemeProps = require("./getThemeProps");
var _getThemePropsDefault = parcelHelpers.interopDefault(_getThemeProps);
parcelHelpers.exportAll(_getThemeProps, exports);
var _jssPreset = require("./jssPreset");
var _jssPresetDefault = parcelHelpers.interopDefault(_jssPreset);
parcelHelpers.exportAll(_jssPreset, exports);
var _makeStyles = require("./makeStyles");
var _makeStylesDefault = parcelHelpers.interopDefault(_makeStyles);
parcelHelpers.exportAll(_makeStyles, exports);
var _mergeClasses = require("./mergeClasses");
var _mergeClassesDefault = parcelHelpers.interopDefault(_mergeClasses);
parcelHelpers.exportAll(_mergeClasses, exports);
var _serverStyleSheets = require("./ServerStyleSheets");
var _serverStyleSheetsDefault = parcelHelpers.interopDefault(_serverStyleSheets);
parcelHelpers.exportAll(_serverStyleSheets, exports);
var _styled = require("./styled");
var _styledDefault = parcelHelpers.interopDefault(_styled);
parcelHelpers.exportAll(_styled, exports);
var _stylesProvider = require("./StylesProvider");
var _stylesProviderDefault = parcelHelpers.interopDefault(_stylesProvider);
parcelHelpers.exportAll(_stylesProvider, exports);
var _themeProvider = require("./ThemeProvider");
var _themeProviderDefault = parcelHelpers.interopDefault(_themeProvider);
parcelHelpers.exportAll(_themeProvider, exports);
var _useTheme = require("./useTheme");
var _useThemeDefault = parcelHelpers.interopDefault(_useTheme);
parcelHelpers.exportAll(_useTheme, exports);
var _withStyles = require("./withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
parcelHelpers.exportAll(_withStyles, exports);
var _withTheme = require("./withTheme");
var _withThemeDefault = parcelHelpers.interopDefault(_withTheme);
parcelHelpers.exportAll(_withTheme, exports);
/* Warning if there are several instances of @material-ui/styles */ if (typeof window !== 'undefined') {
    _utils.ponyfillGlobal['__@material-ui/styles-init__'] = _utils.ponyfillGlobal['__@material-ui/styles-init__'] || 0;
    if (_utils.ponyfillGlobal['__@material-ui/styles-init__'] === 1) console.warn([
        'It looks like there are several instances of `@material-ui/styles` initialized in this application.',
        "This may cause theme propagation issues, broken class names, specificity issues, and makes your application bigger without a good reason.",
        '',
        'See https://material-ui.com/r/styles-instance-warning for more info.'
    ].join('\n'));
    _utils.ponyfillGlobal['__@material-ui/styles-init__'] += 1;
}

},{"@material-ui/utils":"Uumnw","./createGenerateClassName":"eGtjv","./createStyles":"3ybzt","./getThemeProps":"iGlkZ","./jssPreset":"hyu7L","./makeStyles":"8KWuW","./mergeClasses":"bj8Xo","./ServerStyleSheets":"hIR08","./styled":"75v2p","./StylesProvider":"6XQfg","./ThemeProvider":"gfkCJ","./useTheme":"1dQw3","./withStyles":"4C5Hz","./withTheme":"4Nh79","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"eGtjv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_createGenerateClassNameDefault.default
);
var _createGenerateClassName = require("./createGenerateClassName");
var _createGenerateClassNameDefault = parcelHelpers.interopDefault(_createGenerateClassName);

},{"./createGenerateClassName":"kelcP","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"kelcP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nested = require("../ThemeProvider/nested");
var _nestedDefault = parcelHelpers.interopDefault(_nested);
/**
 * This is the list of the style rule name we use as drop in replacement for the built-in
 * pseudo classes (:checked, :disabled, :focused, etc.).
 *
 * Why do they exist in the first place?
 * These classes are used at a specificity of 2.
 * It allows them to override previously definied styles as well as
 * being untouched by simple user overrides.
 */ var pseudoClasses = [
    'checked',
    'disabled',
    'error',
    'focused',
    'focusVisible',
    'required',
    'expanded',
    'selected'
]; // Returns a function which generates unique class names based on counters.
function createGenerateClassName() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    };
    var _options$disableGloba = options.disableGlobal, disableGlobal = _options$disableGloba === void 0 ? false : _options$disableGloba, _options$productionPr = options.productionPrefix, productionPrefix = _options$productionPr === void 0 ? 'jss' : _options$productionPr, _options$seed = options.seed, seed = _options$seed === void 0 ? '' : _options$seed;
    var seedPrefix = seed === '' ? '' : "".concat(seed, "-");
    var ruleCounter = 0;
    var getNextCounterId = function getNextCounterId1() {
        ruleCounter += 1;
        if (ruleCounter >= 10000000000) console.warn([
            'Material-UI: You might have a memory leak.',
            'The ruleCounter is not supposed to grow that much.'
        ].join(''));
        return ruleCounter;
    };
    return function(rule, styleSheet) {
        var name = styleSheet.options.name; // Is a global static MUI style?
        if (name && name.indexOf('Mui') === 0 && !styleSheet.options.link && !disableGlobal) {
            // We can use a shorthand class name, we never use the keys to style the components.
            if (pseudoClasses.indexOf(rule.key) !== -1) return "Mui-".concat(rule.key);
            var prefix = "".concat(seedPrefix).concat(name, "-").concat(rule.key);
            if (!styleSheet.options.theme[_nestedDefault.default] || seed !== '') return prefix;
            return "".concat(prefix, "-").concat(getNextCounterId());
        }
        var suffix = "".concat(rule.key, "-").concat(getNextCounterId()); // Help with debuggability.
        if (styleSheet.options.classNamePrefix) return "".concat(seedPrefix).concat(styleSheet.options.classNamePrefix, "-").concat(suffix);
        return "".concat(seedPrefix).concat(suffix);
    };
}
exports.default = createGenerateClassName;

},{"../ThemeProvider/nested":"5t4Fq","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5t4Fq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
exports.default = hasSymbol ? Symbol.for('mui.nested') : '__THEME_NESTED__';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"3ybzt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_createStylesDefault.default
);
var _createStyles = require("./createStyles");
var _createStylesDefault = parcelHelpers.interopDefault(_createStyles);

},{"./createStyles":"dmUmx","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"dmUmx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function createStyles(styles) {
    return styles;
}
exports.default = createStyles;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"iGlkZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_getThemePropsDefault.default
);
var _getThemeProps = require("./getThemeProps");
var _getThemePropsDefault = parcelHelpers.interopDefault(_getThemeProps);

},{"./getThemeProps":"aKMkS","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"aKMkS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getThemeProps(params) {
    var theme = params.theme, name = params.name, props = params.props;
    if (!theme || !theme.props || !theme.props[name]) return props;
     // Resolve default props, code borrow from React source.
    // https://github.com/facebook/react/blob/15a8f031838a553e41c0b66eb1bcf1da8448104d/packages/react/src/ReactElement.js#L221
    var defaultProps = theme.props[name];
    var propName;
    for(propName in defaultProps)if (props[propName] === undefined) props[propName] = defaultProps[propName];
    return props;
}
exports.default = getThemeProps;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hyu7L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_jssPresetDefault.default
);
var _jssPreset = require("./jssPreset");
var _jssPresetDefault = parcelHelpers.interopDefault(_jssPreset);

},{"./jssPreset":"51zqe","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"51zqe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jssPluginRuleValueFunction = require("jss-plugin-rule-value-function");
var _jssPluginRuleValueFunctionDefault = parcelHelpers.interopDefault(_jssPluginRuleValueFunction);
var _jssPluginGlobal = require("jss-plugin-global");
var _jssPluginGlobalDefault = parcelHelpers.interopDefault(_jssPluginGlobal);
var _jssPluginNested = require("jss-plugin-nested");
var _jssPluginNestedDefault = parcelHelpers.interopDefault(_jssPluginNested);
var _jssPluginCamelCase = require("jss-plugin-camel-case");
var _jssPluginCamelCaseDefault = parcelHelpers.interopDefault(_jssPluginCamelCase);
var _jssPluginDefaultUnit = require("jss-plugin-default-unit");
var _jssPluginDefaultUnitDefault = parcelHelpers.interopDefault(_jssPluginDefaultUnit);
var _jssPluginVendorPrefixer = require("jss-plugin-vendor-prefixer");
var _jssPluginVendorPrefixerDefault = parcelHelpers.interopDefault(_jssPluginVendorPrefixer);
var _jssPluginPropsSort = require("jss-plugin-props-sort"); // Subset of jss-preset-default with only the plugins the Material-UI components are using.
var _jssPluginPropsSortDefault = parcelHelpers.interopDefault(_jssPluginPropsSort);
function jssPreset() {
    return {
        plugins: [
            _jssPluginRuleValueFunctionDefault.default(),
            _jssPluginGlobalDefault.default(),
            _jssPluginNestedDefault.default(),
            _jssPluginCamelCaseDefault.default(),
            _jssPluginDefaultUnitDefault.default(),
            // This way, we can get a performance boost.
            // In the documentation, we are using `autoprefixer` to solve this problem.
            typeof window === 'undefined' ? null : _jssPluginVendorPrefixerDefault.default(),
            _jssPluginPropsSortDefault.default()
        ]
    };
}
exports.default = jssPreset;

},{"jss-plugin-rule-value-function":"8wHRh","jss-plugin-global":"b1IM2","jss-plugin-nested":"5ScGL","jss-plugin-camel-case":"hk5qj","jss-plugin-default-unit":"9T4i1","jss-plugin-vendor-prefixer":"7X7VV","jss-plugin-props-sort":"e7RN0","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8wHRh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tinyWarning = require("tiny-warning");
var _tinyWarningDefault = parcelHelpers.interopDefault(_tinyWarning);
var _jss = require("jss");
var now = Date.now();
var fnValuesNs = "fnValues" + now;
var fnRuleNs = "fnStyle" + ++now;
var functionPlugin = function functionPlugin1() {
    return {
        onCreateRule: function onCreateRule(name, decl, options) {
            if (typeof decl !== 'function') return null;
            var rule = _jss.createRule(name, {
            }, options);
            rule[fnRuleNs] = decl;
            return rule;
        },
        onProcessStyle: function onProcessStyle(style, rule) {
            // We need to extract function values from the declaration, so that we can keep core unaware of them.
            // We need to do that only once.
            // We don't need to extract functions on each style update, since this can happen only once.
            // We don't support function values inside of function rules.
            if (fnValuesNs in rule || fnRuleNs in rule) return style;
            var fnValues = {
            };
            for(var prop in style){
                var value = style[prop];
                if (typeof value !== 'function') continue;
                delete style[prop];
                fnValues[prop] = value;
            } // $FlowFixMe[prop-missing]
            rule[fnValuesNs] = fnValues;
            return style;
        },
        onUpdate: function onUpdate(data, rule, sheet, options) {
            var styleRule = rule; // $FlowFixMe[prop-missing]
            var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object
            // will be returned from that function.
            if (fnRule) {
                // Empty object will remove all currently defined props
                // in case function rule returns a falsy value.
                styleRule.style = fnRule(data) || {
                };
                for(var prop in styleRule.style)if (typeof styleRule.style[prop] === 'function') {
                    _tinyWarningDefault.default(false, '[JSS] Function values inside function rules are not supported.');
                    break;
                }
            } // $FlowFixMe[prop-missing]
            var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.
            if (fnValues) for(var _prop in fnValues)styleRule.prop(_prop, fnValues[_prop](data), options);
        }
    };
};
exports.default = functionPlugin;

},{"tiny-warning":"aQcGE","jss":"bJs7q","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"aQcGE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var isProduction = false;
function warning(condition, message) {
    if (!isProduction) {
        if (condition) return;
        var text = "Warning: " + message;
        if (typeof console !== 'undefined') console.warn(text);
        try {
            throw Error(text);
        } catch (x) {
        }
    }
}
exports.default = warning;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"bJs7q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RuleList", ()=>RuleList
);
parcelHelpers.export(exports, "SheetsManager", ()=>SheetsManager
);
parcelHelpers.export(exports, "SheetsRegistry", ()=>SheetsRegistry
);
parcelHelpers.export(exports, "create", ()=>create
);
parcelHelpers.export(exports, "createGenerateId", ()=>createGenerateId
);
parcelHelpers.export(exports, "createRule", ()=>createRule
);
parcelHelpers.export(exports, "getDynamicStyles", ()=>getDynamicStyles
);
parcelHelpers.export(exports, "hasCSSTOMSupport", ()=>hasCSSTOMSupport
);
parcelHelpers.export(exports, "sheets", ()=>registry
);
parcelHelpers.export(exports, "toCssValue", ()=>toCssValue
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _isInBrowser = require("is-in-browser");
var _isInBrowserDefault = parcelHelpers.interopDefault(_isInBrowser);
var _tinyWarning = require("tiny-warning");
var _tinyWarningDefault = parcelHelpers.interopDefault(_tinyWarning);
var _createClass = require("@babel/runtime/helpers/esm/createClass");
var _createClassDefault = parcelHelpers.interopDefault(_createClass);
var _inheritsLoose = require("@babel/runtime/helpers/esm/inheritsLoose");
var _inheritsLooseDefault = parcelHelpers.interopDefault(_inheritsLoose);
var _assertThisInitialized = require("@babel/runtime/helpers/esm/assertThisInitialized");
var _assertThisInitializedDefault = parcelHelpers.interopDefault(_assertThisInitialized);
var _objectWithoutPropertiesLoose = require("@babel/runtime/helpers/esm/objectWithoutPropertiesLoose");
var _objectWithoutPropertiesLooseDefault = parcelHelpers.interopDefault(_objectWithoutPropertiesLoose);
var plainObjectConstrurctor = {
}.constructor;
function cloneStyle(style) {
    if (style == null || typeof style !== 'object') return style;
    if (Array.isArray(style)) return style.map(cloneStyle);
    if (style.constructor !== plainObjectConstrurctor) return style;
    var newStyle = {
    };
    for(var name in style)newStyle[name] = cloneStyle(style[name]);
    return newStyle;
}
/**
 * Create a rule instance.
 */ function createRule(name, decl, options) {
    if (name === void 0) name = 'unnamed';
    var jss = options.jss;
    var declCopy = cloneStyle(decl);
    var rule = jss.plugins.onCreateRule(name, declCopy, options);
    if (rule) return rule; // It is an at-rule and it has no instance.
    if (name[0] === '@') _tinyWarningDefault.default(false, "[JSS] Unknown rule " + name);
    return null;
}
var join = function join1(value, by) {
    var result = '';
    for(var i = 0; i < value.length; i++){
        // Remove !important from the value, it will be readded later.
        if (value[i] === '!important') break;
        if (result) result += by;
        result += value[i];
    }
    return result;
};
/**
 * Converts array values to string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */ var toCssValue = function toCssValue1(value, ignoreImportant) {
    if (ignoreImportant === void 0) ignoreImportant = false;
    if (!Array.isArray(value)) return value;
    var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.
    if (Array.isArray(value[0])) for(var i = 0; i < value.length; i++){
        if (value[i] === '!important') break;
        if (cssValue) cssValue += ', ';
        cssValue += join(value[i], ' ');
    }
    else cssValue = join(value, ', '); // Add !important, because it was ignored.
    if (!ignoreImportant && value[value.length - 1] === '!important') cssValue += ' !important';
    return cssValue;
};
/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */ function indentStr(str, indent) {
    var result = '';
    for(var index = 0; index < indent; index++)result += '  ';
    return result + str;
}
/**
 * Converts a Rule to CSS string.
 */ function toCss(selector, style, options) {
    if (options === void 0) options = {
    };
    var result = '';
    if (!style) return result;
    var _options = options, _options$indent = _options.indent, indent = _options$indent === void 0 ? 0 : _options$indent;
    var fallbacks = style.fallbacks;
    if (selector) indent++; // Apply fallbacks first.
    if (fallbacks) {
        // Array syntax {fallbacks: [{prop: value}]}
        if (Array.isArray(fallbacks)) for(var index = 0; index < fallbacks.length; index++){
            var fallback = fallbacks[index];
            for(var prop in fallback){
                var value = fallback[prop];
                if (value != null) {
                    if (result) result += '\n';
                    result += indentStr(prop + ": " + toCssValue(value) + ";", indent);
                }
            }
        }
        else // Object syntax {fallbacks: {prop: value}}
        for(var _prop in fallbacks){
            var _value = fallbacks[_prop];
            if (_value != null) {
                if (result) result += '\n';
                result += indentStr(_prop + ": " + toCssValue(_value) + ";", indent);
            }
        }
    }
    for(var _prop2 in style){
        var _value2 = style[_prop2];
        if (_value2 != null && _prop2 !== 'fallbacks') {
            if (result) result += '\n';
            result += indentStr(_prop2 + ": " + toCssValue(_value2) + ";", indent);
        }
    } // Allow empty style in this case, because properties will be added dynamically.
    if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.
    if (!selector) return result;
    indent--;
    if (result) result = "\n" + result + "\n";
    return indentStr(selector + " {" + result, indent) + indentStr('}', indent);
}
var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
var escape = function(str) {
    return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
};
var BaseStyleRule = /*#__PURE__*/ function() {
    function BaseStyleRule1(key, style, options) {
        this.type = 'style';
        this.key = void 0;
        this.isProcessed = false;
        this.style = void 0;
        this.renderer = void 0;
        this.renderable = void 0;
        this.options = void 0;
        var sheet = options.sheet, Renderer = options.Renderer;
        this.key = key;
        this.options = options;
        this.style = style;
        if (sheet) this.renderer = sheet.renderer;
        else if (Renderer) this.renderer = new Renderer();
    }
    /**
   * Get or set a style property.
   */ var _proto = BaseStyleRule1.prototype;
    _proto.prop = function prop(name, value, options) {
        // It's a getter.
        if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.
        var force = options ? options.force : false;
        if (!force && this.style[name] === value) return this;
        var newValue = value;
        if (!options || options.process !== false) newValue = this.options.jss.plugins.onChangeValue(value, name, this);
        var isEmpty = newValue == null || newValue === false;
        var isDefined = name in this.style; // Value is empty and wasn't defined before.
        if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.
        var remove = isEmpty && isDefined;
        if (remove) delete this.style[name];
        else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.
        if (this.renderable && this.renderer) {
            if (remove) this.renderer.removeProperty(this.renderable, name);
            else this.renderer.setProperty(this.renderable, name, newValue);
            return this;
        }
        var sheet = this.options.sheet;
        if (sheet && sheet.attached) _tinyWarningDefault.default(false, '[JSS] Rule is not linked. Missing sheet option "link: true".');
        return this;
    };
    return BaseStyleRule1;
}();
var StyleRule1 = /*#__PURE__*/ function(_BaseStyleRule) {
    _inheritsLooseDefault.default(StyleRule2, _BaseStyleRule);
    function StyleRule2(key, style, options) {
        var _this;
        _this = _BaseStyleRule.call(this, key, style, options) || this;
        _this.selectorText = void 0;
        _this.id = void 0;
        _this.renderable = void 0;
        var selector = options.selector, scoped = options.scoped, sheet = options.sheet, generateId = options.generateId;
        if (selector) _this.selectorText = selector;
        else if (scoped !== false) {
            _this.id = generateId(_assertThisInitializedDefault.default(_assertThisInitializedDefault.default(_this)), sheet);
            _this.selectorText = "." + escape(_this.id);
        }
        return _this;
    }
    /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */ var _proto2 = StyleRule2.prototype;
    /**
   * Apply rule to an element inline.
   */ _proto2.applyTo = function applyTo(renderable) {
        var renderer = this.renderer;
        if (renderer) {
            var json = this.toJSON();
            for(var prop in json)renderer.setProperty(renderable, prop, json[prop]);
        }
        return this;
    };
    _proto2.toJSON = function toJSON() {
        var json = {
        };
        for(var prop in this.style){
            var value = this.style[prop];
            if (typeof value !== 'object') json[prop] = value;
            else if (Array.isArray(value)) json[prop] = toCssValue(value);
        }
        return json;
    };
    _proto2.toString = function toString(options) {
        var sheet = this.options.sheet;
        var link = sheet ? sheet.options.link : false;
        var opts = link ? _extendsDefault.default({
        }, options, {
            allowEmpty: true
        }) : options;
        return toCss(this.selectorText, this.style, opts);
    };
    _createClassDefault.default(StyleRule2, [
        {
            key: "selector",
            set: function set(selector) {
                if (selector === this.selectorText) return;
                this.selectorText = selector;
                var renderer = this.renderer, renderable = this.renderable;
                if (!renderable || !renderer) return;
                var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.
                if (!hasChanged) renderer.replaceRule(renderable, this);
            },
            get: function get() {
                return this.selectorText;
            }
        }
    ]);
    return StyleRule2;
}(BaseStyleRule);
var pluginStyleRule = {
    onCreateRule: function onCreateRule(name, style, options) {
        if (name[0] === '@' || options.parent && options.parent.type === 'keyframes') return null;
        return new StyleRule1(name, style, options);
    }
};
var defaultToStringOptions = {
    indent: 1,
    children: true
};
var atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */ var ConditionalRule = /*#__PURE__*/ function() {
    function ConditionalRule1(key, styles, options) {
        this.type = 'conditional';
        this.at = void 0;
        this.key = void 0;
        this.query = void 0;
        this.rules = void 0;
        this.options = void 0;
        this.isProcessed = false;
        this.renderable = void 0;
        this.key = key;
        var atMatch = key.match(atRegExp);
        this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.
        this.query = options.name || "@" + this.at;
        this.options = options;
        this.rules = new RuleList(_extendsDefault.default({
        }, options, {
            parent: this
        }));
        for(var name in styles)this.rules.add(name, styles[name]);
        this.rules.process();
    }
    /**
   * Get a rule.
   */ var _proto = ConditionalRule1.prototype;
    _proto.getRule = function getRule(name) {
        return this.rules.get(name);
    };
    _proto.indexOf = function indexOf(rule) {
        return this.rules.indexOf(rule);
    };
    _proto.addRule = function addRule(name, style, options) {
        var rule = this.rules.add(name, style, options);
        if (!rule) return null;
        this.options.jss.plugins.onProcessRule(rule);
        return rule;
    };
    _proto.toString = function toString(options) {
        if (options === void 0) options = defaultToStringOptions;
        if (options.indent == null) options.indent = defaultToStringOptions.indent;
        if (options.children == null) options.children = defaultToStringOptions.children;
        if (options.children === false) return this.query + " {}";
        var children = this.rules.toString(options);
        return children ? this.query + " {\n" + children + "\n}" : '';
    };
    return ConditionalRule1;
}();
var keyRegExp = /@media|@supports\s+/;
var pluginConditionalRule = {
    onCreateRule: function onCreateRule(key, styles, options) {
        return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
    }
};
var defaultToStringOptions$1 = {
    indent: 1,
    children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */ var KeyframesRule = /*#__PURE__*/ function() {
    function KeyframesRule1(key, frames, options) {
        this.type = 'keyframes';
        this.at = '@keyframes';
        this.key = void 0;
        this.name = void 0;
        this.id = void 0;
        this.rules = void 0;
        this.options = void 0;
        this.isProcessed = false;
        this.renderable = void 0;
        var nameMatch = key.match(nameRegExp);
        if (nameMatch && nameMatch[1]) this.name = nameMatch[1];
        else {
            this.name = 'noname';
            _tinyWarningDefault.default(false, "[JSS] Bad keyframes name " + key);
        }
        this.key = this.type + "-" + this.name;
        this.options = options;
        var scoped = options.scoped, sheet = options.sheet, generateId = options.generateId;
        this.id = scoped === false ? this.name : escape(generateId(this, sheet));
        this.rules = new RuleList(_extendsDefault.default({
        }, options, {
            parent: this
        }));
        for(var name in frames)this.rules.add(name, frames[name], _extendsDefault.default({
        }, options, {
            parent: this
        }));
        this.rules.process();
    }
    /**
   * Generates a CSS string.
   */ var _proto = KeyframesRule1.prototype;
    _proto.toString = function toString(options) {
        if (options === void 0) options = defaultToStringOptions$1;
        if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
        if (options.children == null) options.children = defaultToStringOptions$1.children;
        if (options.children === false) return this.at + " " + this.id + " {}";
        var children = this.rules.toString(options);
        if (children) children = "\n" + children + "\n";
        return this.at + " " + this.id + " {" + children + "}";
    };
    return KeyframesRule1;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp = /\$([\w-]+)/g;
var findReferencedKeyframe = function findReferencedKeyframe1(val, keyframes) {
    if (typeof val === 'string') return val.replace(refRegExp, function(match, name) {
        if (name in keyframes) return keyframes[name];
        _tinyWarningDefault.default(false, "[JSS] Referenced keyframes rule \"" + name + "\" is not defined.");
        return match;
    });
    return val;
};
/**
 * Replace the reference for a animation name.
 */ var replaceRef = function replaceRef1(style, prop, keyframes) {
    var value = style[prop];
    var refKeyframe = findReferencedKeyframe(value, keyframes);
    if (refKeyframe !== value) style[prop] = refKeyframe;
};
var plugin = {
    onCreateRule: function onCreateRule(key, frames, options) {
        return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
    },
    // Animation name ref replacer.
    onProcessStyle: function onProcessStyle(style, rule, sheet) {
        if (rule.type !== 'style' || !sheet) return style;
        if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
        if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
        return style;
    },
    onChangeValue: function onChangeValue(val, prop, rule) {
        var sheet = rule.options.sheet;
        if (!sheet) return val;
        switch(prop){
            case 'animation':
                return findReferencedKeyframe(val, sheet.keyframes);
            case 'animation-name':
                return findReferencedKeyframe(val, sheet.keyframes);
            default:
                return val;
        }
    }
};
var KeyframeRule1 = /*#__PURE__*/ function(_BaseStyleRule) {
    _inheritsLooseDefault.default(KeyframeRule2, _BaseStyleRule);
    function KeyframeRule2() {
        var _this;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _BaseStyleRule.call.apply(_BaseStyleRule, [
            this
        ].concat(args)) || this;
        _this.renderable = void 0;
        return _this;
    }
    var _proto = KeyframeRule2.prototype;
    /**
   * Generates a CSS string.
   */ _proto.toString = function toString(options) {
        var sheet = this.options.sheet;
        var link = sheet ? sheet.options.link : false;
        var opts = link ? _extendsDefault.default({
        }, options, {
            allowEmpty: true
        }) : options;
        return toCss(this.key, this.style, opts);
    };
    return KeyframeRule2;
}(BaseStyleRule);
var pluginKeyframeRule = {
    onCreateRule: function onCreateRule(key, style, options) {
        if (options.parent && options.parent.type === 'keyframes') return new KeyframeRule1(key, style, options);
        return null;
    }
};
var FontFaceRule = /*#__PURE__*/ function() {
    function FontFaceRule1(key, style, options) {
        this.type = 'font-face';
        this.at = '@font-face';
        this.key = void 0;
        this.style = void 0;
        this.options = void 0;
        this.isProcessed = false;
        this.renderable = void 0;
        this.key = key;
        this.style = style;
        this.options = options;
    }
    /**
   * Generates a CSS string.
   */ var _proto = FontFaceRule1.prototype;
    _proto.toString = function toString(options) {
        if (Array.isArray(this.style)) {
            var str = '';
            for(var index = 0; index < this.style.length; index++){
                str += toCss(this.at, this.style[index]);
                if (this.style[index + 1]) str += '\n';
            }
            return str;
        }
        return toCss(this.at, this.style, options);
    };
    return FontFaceRule1;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
    onCreateRule: function onCreateRule(key, style, options) {
        return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
    }
};
var ViewportRule = /*#__PURE__*/ function() {
    function ViewportRule1(key, style, options) {
        this.type = 'viewport';
        this.at = '@viewport';
        this.key = void 0;
        this.style = void 0;
        this.options = void 0;
        this.isProcessed = false;
        this.renderable = void 0;
        this.key = key;
        this.style = style;
        this.options = options;
    }
    /**
   * Generates a CSS string.
   */ var _proto = ViewportRule1.prototype;
    _proto.toString = function toString(options) {
        return toCss(this.key, this.style, options);
    };
    return ViewportRule1;
}();
var pluginViewportRule = {
    onCreateRule: function onCreateRule(key, style, options) {
        return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
    }
};
var SimpleRule = /*#__PURE__*/ function() {
    function SimpleRule1(key, value, options) {
        this.type = 'simple';
        this.key = void 0;
        this.value = void 0;
        this.options = void 0;
        this.isProcessed = false;
        this.renderable = void 0;
        this.key = key;
        this.value = value;
        this.options = options;
    }
    /**
   * Generates a CSS string.
   */ // eslint-disable-next-line no-unused-vars
    var _proto = SimpleRule1.prototype;
    _proto.toString = function toString(options) {
        if (Array.isArray(this.value)) {
            var str = '';
            for(var index = 0; index < this.value.length; index++){
                str += this.key + " " + this.value[index] + ";";
                if (this.value[index + 1]) str += '\n';
            }
            return str;
        }
        return this.key + " " + this.value + ";";
    };
    return SimpleRule1;
}();
var keysMap = {
    '@charset': true,
    '@import': true,
    '@namespace': true
};
var pluginSimpleRule = {
    onCreateRule: function onCreateRule(key, value, options) {
        return key in keysMap ? new SimpleRule(key, value, options) : null;
    }
};
var plugins = [
    pluginStyleRule,
    pluginConditionalRule,
    plugin,
    pluginKeyframeRule,
    pluginFontFaceRule,
    pluginViewportRule,
    pluginSimpleRule
];
var defaultUpdateOptions = {
    process: true
};
var forceUpdateOptions = {
    force: true,
    process: true
};
var RuleList = /*#__PURE__*/ function() {
    // Rules registry for access by .get() method.
    // It contains the same rule registered by name and by selector.
    // Original styles object.
    // Used to ensure correct rules order.
    function RuleList1(options) {
        this.map = {
        };
        this.raw = {
        };
        this.index = [];
        this.counter = 0;
        this.options = void 0;
        this.classes = void 0;
        this.keyframes = void 0;
        this.options = options;
        this.classes = options.classes;
        this.keyframes = options.keyframes;
    }
    /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */ var _proto = RuleList1.prototype;
    _proto.add = function add(name, decl, ruleOptions) {
        var _this$options = this.options, parent = _this$options.parent, sheet = _this$options.sheet, jss = _this$options.jss, Renderer = _this$options.Renderer, generateId = _this$options.generateId, scoped = _this$options.scoped;
        var options = _extendsDefault.default({
            classes: this.classes,
            parent: parent,
            sheet: sheet,
            jss: jss,
            Renderer: Renderer,
            generateId: generateId,
            scoped: scoped,
            name: name,
            keyframes: this.keyframes,
            selector: undefined
        }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
        // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
        // we need to make the key unique within this RuleList instance scope.
        var key = name;
        if (name in this.raw) key = name + "-d" + this.counter++;
         // We need to save the original decl before creating the rule
        // because cache plugin needs to use it as a key to return a cached rule.
        this.raw[key] = decl;
        if (key in this.classes) // E.g. rules inside of @media container
        options.selector = "." + escape(this.classes[key]);
        var rule = createRule(key, decl, options);
        if (!rule) return null;
        this.register(rule);
        var index = options.index === undefined ? this.index.length : options.index;
        this.index.splice(index, 0, rule);
        return rule;
    };
    _proto.get = function get(name) {
        return this.map[name];
    };
    _proto.remove = function remove(rule) {
        this.unregister(rule);
        delete this.raw[rule.key];
        this.index.splice(this.index.indexOf(rule), 1);
    };
    _proto.indexOf = function indexOf(rule) {
        return this.index.indexOf(rule);
    };
    _proto.process = function process() {
        var plugins1 = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
        // we end up with very hard-to-track-down side effects.
        this.index.slice(0).forEach(plugins1.onProcessRule, plugins1);
    };
    _proto.register = function register(rule) {
        this.map[rule.key] = rule;
        if (rule instanceof StyleRule1) {
            this.map[rule.selector] = rule;
            if (rule.id) this.classes[rule.key] = rule.id;
        } else if (rule instanceof KeyframesRule && this.keyframes) this.keyframes[rule.name] = rule.id;
    };
    _proto.unregister = function unregister(rule) {
        delete this.map[rule.key];
        if (rule instanceof StyleRule1) {
            delete this.map[rule.selector];
            delete this.classes[rule.key];
        } else if (rule instanceof KeyframesRule) delete this.keyframes[rule.name];
    };
    _proto.update = function update() {
        var name;
        var data;
        var options;
        if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
            name = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe[invalid-tuple-index]
            data = arguments.length <= 1 ? undefined : arguments[1]; // $FlowFixMe[invalid-tuple-index]
            options = arguments.length <= 2 ? undefined : arguments[2];
        } else {
            data = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe[invalid-tuple-index]
            options = arguments.length <= 1 ? undefined : arguments[1];
            name = null;
        }
        if (name) this.updateOne(this.map[name], data, options);
        else for(var index = 0; index < this.index.length; index++)this.updateOne(this.index[index], data, options);
    };
    _proto.updateOne = function updateOne(rule, data, options) {
        if (options === void 0) options = defaultUpdateOptions;
        var _this$options2 = this.options, plugins1 = _this$options2.jss.plugins, sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.
        if (rule.rules instanceof RuleList1) {
            rule.rules.update(data, options);
            return;
        }
        var styleRule = rule;
        var style = styleRule.style;
        plugins1.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.
        if (options.process && style && style !== styleRule.style) {
            // We need to run the plugins in case new `style` relies on syntax plugins.
            plugins1.onProcessStyle(styleRule.style, styleRule, sheet); // Update and add props.
            for(var prop in styleRule.style){
                var nextValue = styleRule.style[prop];
                var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
                // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.
                if (nextValue !== prevValue) styleRule.prop(prop, nextValue, forceUpdateOptions);
            } // Remove props.
            for(var _prop in style){
                var _nextValue = styleRule.style[_prop];
                var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
                // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.
                if (_nextValue == null && _nextValue !== _prevValue) styleRule.prop(_prop, null, forceUpdateOptions);
            }
        }
    };
    _proto.toString = function toString(options) {
        var str = '';
        var sheet = this.options.sheet;
        var link = sheet ? sheet.options.link : false;
        for(var index = 0; index < this.index.length; index++){
            var rule = this.index[index];
            var css = rule.toString(options); // No need to render an empty rule.
            if (!css && !link) continue;
            if (str) str += '\n';
            str += css;
        }
        return str;
    };
    return RuleList1;
}();
var StyleSheet1 = /*#__PURE__*/ function() {
    function StyleSheet2(styles, options) {
        this.options = void 0;
        this.deployed = void 0;
        this.attached = void 0;
        this.rules = void 0;
        this.renderer = void 0;
        this.classes = void 0;
        this.keyframes = void 0;
        this.queue = void 0;
        this.attached = false;
        this.deployed = false;
        this.classes = {
        };
        this.keyframes = {
        };
        this.options = _extendsDefault.default({
        }, options, {
            sheet: this,
            parent: this,
            classes: this.classes,
            keyframes: this.keyframes
        });
        if (options.Renderer) this.renderer = new options.Renderer(this);
        this.rules = new RuleList(this.options);
        for(var name in styles)this.rules.add(name, styles[name]);
        this.rules.process();
    }
    /**
   * Attach renderable to the render tree.
   */ var _proto = StyleSheet2.prototype;
    _proto.attach = function attach() {
        if (this.attached) return this;
        if (this.renderer) this.renderer.attach();
        this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.
        if (!this.deployed) this.deploy();
        return this;
    };
    _proto.detach = function detach() {
        if (!this.attached) return this;
        if (this.renderer) this.renderer.detach();
        this.attached = false;
        return this;
    };
    _proto.addRule = function addRule(name, decl, options) {
        var queue = this.queue; // Plugins can create rules.
        // In order to preserve the right order, we need to queue all `.addRule` calls,
        // which happen after the first `rules.add()` call.
        if (this.attached && !queue) this.queue = [];
        var rule = this.rules.add(name, decl, options);
        if (!rule) return null;
        this.options.jss.plugins.onProcessRule(rule);
        if (this.attached) {
            if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
            // It will be inserted all together when .attach is called.
            if (queue) queue.push(rule);
            else {
                this.insertRule(rule);
                if (this.queue) {
                    this.queue.forEach(this.insertRule, this);
                    this.queue = undefined;
                }
            }
            return rule;
        } // We can't add rules to a detached style node.
        // We will redeploy the sheet once user will attach it.
        this.deployed = false;
        return rule;
    };
    _proto.insertRule = function insertRule(rule) {
        if (this.renderer) this.renderer.insertRule(rule);
    };
    _proto.addRules = function addRules(styles, options) {
        var added = [];
        for(var name in styles){
            var rule = this.addRule(name, styles[name], options);
            if (rule) added.push(rule);
        }
        return added;
    };
    _proto.getRule = function getRule(name) {
        return this.rules.get(name);
    };
    _proto.deleteRule = function deleteRule(name) {
        var rule = typeof name === 'object' ? name : this.rules.get(name);
        if (!rule || // won't be able to remove the CSS rule from the DOM.
        this.attached && !rule.renderable) return false;
        this.rules.remove(rule);
        if (this.attached && rule.renderable && this.renderer) return this.renderer.deleteRule(rule.renderable);
        return true;
    };
    _proto.indexOf = function indexOf(rule) {
        return this.rules.indexOf(rule);
    };
    _proto.deploy = function deploy() {
        if (this.renderer) this.renderer.deploy();
        this.deployed = true;
        return this;
    };
    _proto.update = function update() {
        var _this$rules;
        (_this$rules = this.rules).update.apply(_this$rules, arguments);
        return this;
    };
    _proto.updateOne = function updateOne(rule, data, options) {
        this.rules.updateOne(rule, data, options);
        return this;
    };
    _proto.toString = function toString(options) {
        return this.rules.toString(options);
    };
    return StyleSheet2;
}();
var PluginsRegistry = /*#__PURE__*/ function() {
    function PluginsRegistry1() {
        this.plugins = {
            internal: [],
            external: []
        };
        this.registry = void 0;
    }
    var _proto = PluginsRegistry1.prototype;
    /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */ _proto.onCreateRule = function onCreateRule(name, decl, options) {
        for(var i = 0; i < this.registry.onCreateRule.length; i++){
            var rule = this.registry.onCreateRule[i](name, decl, options);
            if (rule) return rule;
        }
        return null;
    };
    _proto.onProcessRule = function onProcessRule(rule) {
        if (rule.isProcessed) return;
        var sheet = rule.options.sheet;
        for(var i = 0; i < this.registry.onProcessRule.length; i++)this.registry.onProcessRule[i](rule, sheet);
        if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
        rule.isProcessed = true;
    };
    _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
        for(var i = 0; i < this.registry.onProcessStyle.length; i++)// $FlowFixMe[prop-missing]
        rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    };
    _proto.onProcessSheet = function onProcessSheet(sheet) {
        for(var i = 0; i < this.registry.onProcessSheet.length; i++)this.registry.onProcessSheet[i](sheet);
    };
    _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
        for(var i = 0; i < this.registry.onUpdate.length; i++)this.registry.onUpdate[i](data, rule, sheet, options);
    };
    _proto.onChangeValue = function onChangeValue(value, prop, rule) {
        var processedValue = value;
        for(var i = 0; i < this.registry.onChangeValue.length; i++)processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
        return processedValue;
    };
    _proto.use = function use(newPlugin, options) {
        if (options === void 0) options = {
            queue: 'external'
        };
        var plugins1 = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.
        if (plugins1.indexOf(newPlugin) !== -1) return;
        plugins1.push(newPlugin);
        this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(registry, plugin1) {
            for(var name in plugin1)if (name in registry) registry[name].push(plugin1[name]);
            else _tinyWarningDefault.default(false, "[JSS] Unknown hook \"" + name + "\".");
            return registry;
        }, {
            onCreateRule: [],
            onProcessRule: [],
            onProcessStyle: [],
            onProcessSheet: [],
            onChangeValue: [],
            onUpdate: []
        });
    };
    return PluginsRegistry1;
}();
/**
 * Sheets registry to access them all at one place.
 */ var SheetsRegistry = /*#__PURE__*/ function() {
    function SheetsRegistry1() {
        this.registry = [];
    }
    var _proto = SheetsRegistry1.prototype;
    /**
   * Register a Style Sheet.
   */ _proto.add = function add(sheet) {
        var registry = this.registry;
        var index = sheet.options.index;
        if (registry.indexOf(sheet) !== -1) return;
        if (registry.length === 0 || index >= this.index) {
            registry.push(sheet);
            return;
        } // Find a position.
        for(var i = 0; i < registry.length; i++)if (registry[i].options.index > index) {
            registry.splice(i, 0, sheet);
            return;
        }
    };
    _proto.reset = function reset() {
        this.registry = [];
    };
    _proto.remove = function remove(sheet) {
        var index = this.registry.indexOf(sheet);
        this.registry.splice(index, 1);
    };
    _proto.toString = function toString(_temp) {
        var _ref = _temp === void 0 ? {
        } : _temp, attached = _ref.attached, options = _objectWithoutPropertiesLooseDefault.default(_ref, [
            "attached"
        ]);
        var css = '';
        for(var i = 0; i < this.registry.length; i++){
            var sheet = this.registry[i];
            if (attached != null && sheet.attached !== attached) continue;
            if (css) css += '\n';
            css += sheet.toString(options);
        }
        return css;
    };
    _createClassDefault.default(SheetsRegistry1, [
        {
            key: "index",
            /**
     * Current highest index number.
     */ get: function get() {
                return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
            }
        }
    ]);
    return SheetsRegistry1;
}();
/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */ var registry = new SheetsRegistry();
/* eslint-disable */ /**
 * Now that `globalThis` is available on most platforms
 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
 * we check for `globalThis` first. `globalThis` is necessary for jss
 * to run in Agoric's secure version of JavaScript (SES). Under SES,
 * `globalThis` exists, but `window`, `self`, and `Function('return
 * this')()` are all undefined for security reasons.
 *
 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
 */ var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();
var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.
var moduleId = globalThis$1[ns]++;
var maxRules = 10000000000;
/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */ var createGenerateId = function createGenerateId1(options) {
    if (options === void 0) options = {
    };
    var ruleCounter = 0;
    var generateId = function generateId1(rule, sheet) {
        ruleCounter += 1;
        if (ruleCounter > maxRules) _tinyWarningDefault.default(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".");
        var jssId = '';
        var prefix = '';
        if (sheet) {
            if (sheet.options.classNamePrefix) prefix = sheet.options.classNamePrefix;
            if (sheet.options.jss.id != null) jssId = String(sheet.options.jss.id);
        }
        if (options.minify) // Using "c" because a number can't be the first char in a class name.
        return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
        return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
    };
    return generateId;
};
/**
 * Cache the value from the first time a function is called.
 */ var memoize = function memoize1(fn) {
    var value;
    return function() {
        if (!value) value = fn();
        return value;
    };
};
/**
 * Get a style property value.
 */ var getPropertyValue = function getPropertyValue1(cssRule, prop) {
    try {
        // Support CSSTOM.
        if (cssRule.attributeStyleMap) return cssRule.attributeStyleMap.get(prop);
        return cssRule.style.getPropertyValue(prop);
    } catch (err) {
        // IE may throw if property is unknown.
        return '';
    }
};
/**
 * Set a style property.
 */ var setProperty = function setProperty1(cssRule, prop, value) {
    try {
        var cssValue = value;
        if (Array.isArray(value)) {
            cssValue = toCssValue(value, true);
            if (value[value.length - 1] === '!important') {
                cssRule.style.setProperty(prop, cssValue, 'important');
                return true;
            }
        } // Support CSSTOM.
        if (cssRule.attributeStyleMap) cssRule.attributeStyleMap.set(prop, cssValue);
        else cssRule.style.setProperty(prop, cssValue);
    } catch (err) {
        // IE may throw if property is unknown.
        return false;
    }
    return true;
};
/**
 * Remove a style property.
 */ var removeProperty = function removeProperty1(cssRule, prop) {
    try {
        // Support CSSTOM.
        if (cssRule.attributeStyleMap) cssRule.attributeStyleMap.delete(prop);
        else cssRule.style.removeProperty(prop);
    } catch (err) {
        _tinyWarningDefault.default(false, "[JSS] DOMException \"" + err.message + "\" was thrown. Tried to remove property \"" + prop + "\".");
    }
};
/**
 * Set the selector.
 */ var setSelector = function setSelector1(cssRule, selectorText) {
    cssRule.selectorText = selectorText; // Return false if setter was not successful.
    // Currently works in chrome only.
    return cssRule.selectorText === selectorText;
};
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */ var getHead = memoize(function() {
    return document.querySelector('head');
});
/**
 * Find attached sheet with an index higher than the passed one.
 */ function findHigherSheet(registry1, options) {
    for(var i = 0; i < registry1.length; i++){
        var sheet = registry1[i];
        if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) return sheet;
    }
    return null;
}
/**
 * Find attached sheet with the highest index.
 */ function findHighestSheet(registry1, options) {
    for(var i = registry1.length - 1; i >= 0; i--){
        var sheet = registry1[i];
        if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) return sheet;
    }
    return null;
}
/**
 * Find a comment with "jss" inside.
 */ function findCommentNode(text) {
    var head = getHead();
    for(var i = 0; i < head.childNodes.length; i++){
        var node = head.childNodes[i];
        if (node.nodeType === 8 && node.nodeValue.trim() === text) return node;
    }
    return null;
}
/**
 * Find a node before which we can insert the sheet.
 */ function findPrevNode(options) {
    var registry$1 = registry.registry;
    if (registry$1.length > 0) {
        // Try to insert before the next higher sheet.
        var sheet = findHigherSheet(registry$1, options);
        if (sheet && sheet.renderer) return {
            parent: sheet.renderer.element.parentNode,
            node: sheet.renderer.element
        };
         // Otherwise insert after the last attached.
        sheet = findHighestSheet(registry$1, options);
        if (sheet && sheet.renderer) return {
            parent: sheet.renderer.element.parentNode,
            node: sheet.renderer.element.nextSibling
        };
    } // Try to find a comment placeholder if registry is empty.
    var insertionPoint = options.insertionPoint;
    if (insertionPoint && typeof insertionPoint === 'string') {
        var comment = findCommentNode(insertionPoint);
        if (comment) return {
            parent: comment.parentNode,
            node: comment.nextSibling
        };
         // If user specifies an insertion point and it can't be found in the document -
        _tinyWarningDefault.default(false, "[JSS] Insertion point \"" + insertionPoint + "\" not found.");
    }
    return false;
}
/**
 * Insert style element into the DOM.
 */ function insertStyle(style, options) {
    var insertionPoint = options.insertionPoint;
    var nextNode = findPrevNode(options);
    if (nextNode !== false && nextNode.parent) {
        nextNode.parent.insertBefore(style, nextNode.node);
        return;
    } // Works with iframes and any node types.
    if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
        // https://stackoverflow.com/questions/41328728/force-casting-in-flow
        var insertionPointElement = insertionPoint;
        var parentNode = insertionPointElement.parentNode;
        if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);
        else _tinyWarningDefault.default(false, '[JSS] Insertion point is not in the DOM.');
        return;
    }
    getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */ var getNonce = memoize(function() {
    var node = document.querySelector('meta[property="csp-nonce"]');
    return node ? node.getAttribute('content') : null;
});
var _insertRule = function insertRule(container, rule, index) {
    try {
        if ('insertRule' in container) {
            var c = container;
            c.insertRule(rule, index);
        } else if ('appendRule' in container) {
            var _c = container;
            _c.appendRule(rule);
        }
    } catch (err) {
        _tinyWarningDefault.default(false, "[JSS] " + err.message);
        return false;
    }
    return container.cssRules[index];
};
var getValidRuleInsertionIndex = function getValidRuleInsertionIndex1(container, index) {
    var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong
    if (index === undefined || index > maxIndex) // eslint-disable-next-line no-param-reassign
    return maxIndex;
    return index;
};
var createStyle = function createStyle1() {
    var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
    // insert rules after we insert the style tag.
    // It seems to kick-off the source order specificity algorithm.
    el.textContent = '\n';
    return el;
};
var DomRenderer = /*#__PURE__*/ function() {
    // HTMLStyleElement needs fixing https://github.com/facebook/flow/issues/2696
    // Will be empty if link: true option is not set, because
    // it is only for use together with insertRule API.
    function DomRenderer1(sheet) {
        this.getPropertyValue = getPropertyValue;
        this.setProperty = setProperty;
        this.removeProperty = removeProperty;
        this.setSelector = setSelector;
        this.element = void 0;
        this.sheet = void 0;
        this.hasInsertedRules = false;
        this.cssRules = [];
        // There is no sheet when the renderer is used from a standalone StyleRule.
        if (sheet) registry.add(sheet);
        this.sheet = sheet;
        var _ref = this.sheet ? this.sheet.options : {
        }, media = _ref.media, meta = _ref.meta, element = _ref.element;
        this.element = element || createStyle();
        this.element.setAttribute('data-jss', '');
        if (media) this.element.setAttribute('media', media);
        if (meta) this.element.setAttribute('data-meta', meta);
        var nonce = getNonce();
        if (nonce) this.element.setAttribute('nonce', nonce);
    }
    /**
   * Insert style element into render tree.
   */ var _proto = DomRenderer1.prototype;
    _proto.attach = function attach() {
        // In the case the element node is external and it is already in the DOM.
        if (this.element.parentNode || !this.sheet) return;
        insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
        // most browsers create a new CSSStyleSheet, except of all IEs.
        var deployed = Boolean(this.sheet && this.sheet.deployed);
        if (this.hasInsertedRules && deployed) {
            this.hasInsertedRules = false;
            this.deploy();
        }
    };
    _proto.detach = function detach() {
        if (!this.sheet) return;
        var parentNode = this.element.parentNode;
        if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
        // Though IE will keep them and we need a consistent behavior.
        if (this.sheet.options.link) {
            this.cssRules = [];
            this.element.textContent = '\n';
        }
    };
    _proto.deploy = function deploy() {
        var sheet = this.sheet;
        if (!sheet) return;
        if (sheet.options.link) {
            this.insertRules(sheet.rules);
            return;
        }
        this.element.textContent = "\n" + sheet.toString() + "\n";
    };
    _proto.insertRules = function insertRules(rules, nativeParent) {
        for(var i = 0; i < rules.index.length; i++)this.insertRule(rules.index[i], i, nativeParent);
    };
    _proto.insertRule = function insertRule1(rule, index, nativeParent) {
        if (nativeParent === void 0) nativeParent = this.element.sheet;
        if (rule.rules) {
            var parent = rule;
            var latestNativeParent = nativeParent;
            if (rule.type === 'conditional' || rule.type === 'keyframes') {
                var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.
                latestNativeParent = _insertRule(nativeParent, parent.toString({
                    children: false
                }), _insertionIndex);
                if (latestNativeParent === false) return false;
                this.refCssRule(rule, _insertionIndex, latestNativeParent);
            }
            this.insertRules(parent.rules, latestNativeParent);
            return latestNativeParent;
        }
        var ruleStr = rule.toString();
        if (!ruleStr) return false;
        var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);
        var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);
        if (nativeRule === false) return false;
        this.hasInsertedRules = true;
        this.refCssRule(rule, insertionIndex, nativeRule);
        return nativeRule;
    };
    _proto.refCssRule = function refCssRule(rule, index, cssRule) {
        rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
        // like rules inside media queries or keyframes
        if (rule.options.parent instanceof StyleSheet1) this.cssRules[index] = cssRule;
    };
    _proto.deleteRule = function deleteRule(cssRule) {
        var sheet = this.element.sheet;
        var index = this.indexOf(cssRule);
        if (index === -1) return false;
        sheet.deleteRule(index);
        this.cssRules.splice(index, 1);
        return true;
    };
    _proto.indexOf = function indexOf(cssRule) {
        return this.cssRules.indexOf(cssRule);
    };
    _proto.replaceRule = function replaceRule(cssRule, rule) {
        var index = this.indexOf(cssRule);
        if (index === -1) return false;
        this.element.sheet.deleteRule(index);
        this.cssRules.splice(index, 1);
        return this.insertRule(rule, index);
    };
    _proto.getRules = function getRules() {
        return this.element.sheet.cssRules;
    };
    return DomRenderer1;
}();
var instanceCounter = 0;
var Jss = /*#__PURE__*/ function() {
    function Jss1(options) {
        this.id = instanceCounter++;
        this.version = "10.7.1";
        this.plugins = new PluginsRegistry();
        this.options = {
            id: {
                minify: false
            },
            createGenerateId: createGenerateId,
            Renderer: _isInBrowserDefault.default ? DomRenderer : null,
            plugins: []
        };
        this.generateId = createGenerateId({
            minify: false
        });
        for(var i = 0; i < plugins.length; i++)this.plugins.use(plugins[i], {
            queue: 'internal'
        });
        this.setup(options);
    }
    /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */ var _proto = Jss1.prototype;
    _proto.setup = function setup(options) {
        if (options === void 0) options = {
        };
        if (options.createGenerateId) this.options.createGenerateId = options.createGenerateId;
        if (options.id) this.options.id = _extendsDefault.default({
        }, this.options.id, options.id);
        if (options.createGenerateId || options.id) this.generateId = this.options.createGenerateId(this.options.id);
        if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;
        if ('Renderer' in options) this.options.Renderer = options.Renderer;
         // eslint-disable-next-line prefer-spread
        if (options.plugins) this.use.apply(this, options.plugins);
        return this;
    };
    _proto.createStyleSheet = function createStyleSheet(styles, options) {
        if (options === void 0) options = {
        };
        var _options = options, index = _options.index;
        if (typeof index !== 'number') index = registry.index === 0 ? 0 : registry.index + 1;
        var sheet = new StyleSheet1(styles, _extendsDefault.default({
        }, options, {
            jss: this,
            generateId: options.generateId || this.generateId,
            insertionPoint: this.options.insertionPoint,
            Renderer: this.options.Renderer,
            index: index
        }));
        this.plugins.onProcessSheet(sheet);
        return sheet;
    };
    _proto.removeStyleSheet = function removeStyleSheet(sheet) {
        sheet.detach();
        registry.remove(sheet);
        return this;
    };
    _proto.createRule = function createRule$1(name, style, options) {
        if (style === void 0) style = {
        };
        if (options === void 0) options = {
        };
        // Enable rule without name for inline styles.
        if (typeof name === 'object') // $FlowFixMe[incompatible-call]
        return this.createRule(undefined, name, style);
         // $FlowFixMe[incompatible-type]
        var ruleOptions = _extendsDefault.default({
        }, options, {
            name: name,
            jss: this,
            Renderer: this.options.Renderer
        });
        if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
        if (!ruleOptions.classes) ruleOptions.classes = {
        };
        if (!ruleOptions.keyframes) ruleOptions.keyframes = {
        };
        var rule = createRule(name, style, ruleOptions);
        if (rule) this.plugins.onProcessRule(rule);
        return rule;
    };
    _proto.use = function use() {
        var _this = this;
        for(var _len = arguments.length, plugins1 = new Array(_len), _key = 0; _key < _len; _key++)plugins1[_key] = arguments[_key];
        plugins1.forEach(function(plugin1) {
            _this.plugins.use(plugin1);
        });
        return this;
    };
    return Jss1;
}();
/**
 * Extracts a styles object with only props that contain function values.
 */ function getDynamicStyles(styles) {
    var to = null;
    for(var key in styles){
        var value = styles[key];
        var type = typeof value;
        if (type === 'function') {
            if (!to) to = {
            };
            to[key] = value;
        } else if (type === 'object' && value !== null && !Array.isArray(value)) {
            var extracted = getDynamicStyles(value);
            if (extracted) {
                if (!to) to = {
                };
                to[key] = extracted;
            }
        }
    }
    return to;
}
/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 */ var SheetsManager = /*#__PURE__*/ function() {
    function SheetsManager1() {
        this.length = 0;
        this.sheets = new WeakMap();
    }
    var _proto = SheetsManager1.prototype;
    _proto.get = function get(key) {
        var entry = this.sheets.get(key);
        return entry && entry.sheet;
    };
    _proto.add = function add(key, sheet) {
        if (this.sheets.has(key)) return;
        this.length++;
        this.sheets.set(key, {
            sheet: sheet,
            refs: 0
        });
    };
    _proto.manage = function manage(key) {
        var entry = this.sheets.get(key);
        if (entry) {
            if (entry.refs === 0) entry.sheet.attach();
            entry.refs++;
            return entry.sheet;
        }
        _tinyWarningDefault.default(false, "[JSS] SheetsManager: can't find sheet to manage");
        return undefined;
    };
    _proto.unmanage = function unmanage(key) {
        var entry = this.sheets.get(key);
        if (entry) {
            if (entry.refs > 0) {
                entry.refs--;
                if (entry.refs === 0) entry.sheet.detach();
            }
        } else _tinyWarningDefault.default(false, "SheetsManager: can't find sheet to unmanage");
    };
    _createClassDefault.default(SheetsManager1, [
        {
            key: "size",
            get: function get1() {
                return this.length;
            }
        }
    ]);
    return SheetsManager1;
}();
/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */ /**
 * Export a constant indicating if this browser has CSSTOM support.
 * https://developers.google.com/web/updates/2018/03/cssom
 */ var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;
/**
 * Creates a new instance of Jss.
 */ var create = function create1(options) {
    return new Jss(options);
};
/**
 * A global Jss instance.
 */ var jss = create();
exports.default = jss;

},{"@babel/runtime/helpers/esm/extends":"esrVD","is-in-browser":"dKhYK","tiny-warning":"aQcGE","@babel/runtime/helpers/esm/createClass":"hVEAO","@babel/runtime/helpers/esm/inheritsLoose":"bzy6T","@babel/runtime/helpers/esm/assertThisInitialized":"lzVdl","@babel/runtime/helpers/esm/objectWithoutPropertiesLoose":"5cFhH","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"dKhYK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBrowser", ()=>isBrowser
);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
} : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;
exports.default = isBrowser;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hVEAO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
exports.default = _createClass;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"bzy6T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setPrototypeOfJs = require("./setPrototypeOf.js");
var _setPrototypeOfJsDefault = parcelHelpers.interopDefault(_setPrototypeOfJs);
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOfJsDefault.default(subClass, superClass);
}
exports.default = _inheritsLoose;

},{"./setPrototypeOf.js":"78ECE","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"78ECE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf1(o1, p1) {
        o1.__proto__ = p1;
        return o1;
    };
    return _setPrototypeOf(o, p);
}
exports.default = _setPrototypeOf;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"lzVdl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
exports.default = _assertThisInitialized;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"b1IM2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _jss = require("jss");
var at = '@global';
var atPrefix = '@global ';
var GlobalContainerRule = /*#__PURE__*/ function() {
    function GlobalContainerRule1(key, styles, options) {
        this.type = 'global';
        this.at = at;
        this.rules = void 0;
        this.options = void 0;
        this.key = void 0;
        this.isProcessed = false;
        this.key = key;
        this.options = options;
        this.rules = new _jss.RuleList(_extendsDefault.default({
        }, options, {
            parent: this
        }));
        for(var selector in styles)this.rules.add(selector, styles[selector]);
        this.rules.process();
    }
    /**
   * Get a rule.
   */ var _proto = GlobalContainerRule1.prototype;
    _proto.getRule = function getRule(name) {
        return this.rules.get(name);
    };
    _proto.addRule = function addRule(name, style, options) {
        var rule = this.rules.add(name, style, options);
        if (rule) this.options.jss.plugins.onProcessRule(rule);
        return rule;
    };
    _proto.indexOf = function indexOf(rule) {
        return this.rules.indexOf(rule);
    };
    _proto.toString = function toString() {
        return this.rules.toString();
    };
    return GlobalContainerRule1;
}();
var GlobalPrefixedRule = /*#__PURE__*/ function() {
    function GlobalPrefixedRule1(key, style, options) {
        this.type = 'global';
        this.at = at;
        this.options = void 0;
        this.rule = void 0;
        this.isProcessed = false;
        this.key = void 0;
        this.key = key;
        this.options = options;
        var selector = key.substr(atPrefix.length);
        this.rule = options.jss.createRule(selector, style, _extendsDefault.default({
        }, options, {
            parent: this
        }));
    }
    var _proto2 = GlobalPrefixedRule1.prototype;
    _proto2.toString = function toString(options) {
        return this.rule ? this.rule.toString(options) : '';
    };
    return GlobalPrefixedRule1;
}();
var separatorRegExp = /\s*,\s*/g;
function addScope(selector, scope) {
    var parts = selector.split(separatorRegExp);
    var scoped = '';
    for(var i = 0; i < parts.length; i++){
        scoped += scope + " " + parts[i].trim();
        if (parts[i + 1]) scoped += ', ';
    }
    return scoped;
}
function handleNestedGlobalContainerRule(rule, sheet) {
    var options = rule.options, style = rule.style;
    var rules = style ? style[at] : null;
    if (!rules) return;
    for(var name in rules)sheet.addRule(name, rules[name], _extendsDefault.default({
    }, options, {
        selector: addScope(name, rule.selector)
    }));
    delete style[at];
}
function handlePrefixedGlobalRule(rule, sheet) {
    var options = rule.options, style = rule.style;
    for(var prop in style){
        if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
        var selector = addScope(prop.substr(at.length), rule.selector);
        sheet.addRule(selector, style[prop], _extendsDefault.default({
        }, options, {
            selector: selector
        }));
        delete style[prop];
    }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */ function jssGlobal() {
    function onCreateRule(name, styles, options) {
        if (!name) return null;
        if (name === at) return new GlobalContainerRule(name, styles, options);
        if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) return new GlobalPrefixedRule(name, styles, options);
        var parent = options.parent;
        if (parent) {
            if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') options.scoped = false;
        }
        if (options.scoped === false) options.selector = name;
        return null;
    }
    function onProcessRule(rule, sheet) {
        if (rule.type !== 'style' || !sheet) return;
        handleNestedGlobalContainerRule(rule, sheet);
        handlePrefixedGlobalRule(rule, sheet);
    }
    return {
        onCreateRule: onCreateRule,
        onProcessRule: onProcessRule
    };
}
exports.default = jssGlobal;

},{"@babel/runtime/helpers/esm/extends":"esrVD","jss":"bJs7q","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5ScGL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _tinyWarning = require("tiny-warning");
var _tinyWarningDefault = parcelHelpers.interopDefault(_tinyWarning);
var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;
/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */ function jssNested() {
    // Get a function to be used for $ref replacement.
    function getReplaceRef(container, sheet) {
        return function(match, key) {
            var rule = container.getRule(key) || sheet && sheet.getRule(key);
            if (rule) return rule.selector;
            _tinyWarningDefault.default(false, "[JSS] Could not find the referenced rule \"" + key + "\" in \"" + (container.options.meta || container.toString()) + "\".");
            return key;
        };
    }
    function replaceParentRefs(nestedProp, parentProp) {
        var parentSelectors = parentProp.split(separatorRegExp);
        var nestedSelectors = nestedProp.split(separatorRegExp);
        var result = '';
        for(var i = 0; i < parentSelectors.length; i++){
            var parent = parentSelectors[i];
            for(var j = 0; j < nestedSelectors.length; j++){
                var nested = nestedSelectors[j];
                if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.
                result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
            }
        }
        return result;
    }
    function getOptions(rule, container, prevOptions) {
        // Options has been already created, now we only increase index.
        if (prevOptions) return _extendsDefault.default({
        }, prevOptions, {
            index: prevOptions.index + 1 // $FlowFixMe[prop-missing]
        });
        var nestingLevel = rule.options.nestingLevel;
        nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;
        var options = _extendsDefault.default({
        }, rule.options, {
            nestingLevel: nestingLevel,
            index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.
        });
        delete options.name;
        return options;
    }
    function onProcessStyle(style, rule, sheet) {
        if (rule.type !== 'style') return style;
        var styleRule = rule;
        var container = styleRule.options.parent;
        var options;
        var replaceRef;
        for(var prop in style){
            var isNested = prop.indexOf('&') !== -1;
            var isNestedConditional = prop[0] === '@';
            if (!isNested && !isNestedConditional) continue;
            options = getOptions(styleRule, container, options);
            if (isNested) {
                var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
                // all nested rules within the sheet.
                if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.
                selector = selector.replace(refRegExp, replaceRef);
                container.addRule(selector, style[prop], _extendsDefault.default({
                }, options, {
                    selector: selector
                }));
            } else if (isNestedConditional) // Place conditional right after the parent rule to ensure right ordering.
            container.addRule(prop, {
            }, options) // Flow expects more options but they aren't required
            // And flow doesn't know this will always be a StyleRule which has the addRule method
            // $FlowFixMe[incompatible-use]
            // $FlowFixMe[prop-missing]
            .addRule(styleRule.key, style[prop], {
                selector: styleRule.selector
            });
            delete style[prop];
        }
        return style;
    }
    return {
        onProcessStyle: onProcessStyle
    };
}
exports.default = jssNested;

},{"@babel/runtime/helpers/esm/extends":"esrVD","tiny-warning":"aQcGE","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hk5qj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hyphenateStyleName = require("hyphenate-style-name");
var _hyphenateStyleNameDefault = parcelHelpers.interopDefault(_hyphenateStyleName);
/**
 * Convert camel cased property names to dash separated.
 *
 * @param {Object} style
 * @return {Object}
 */ function convertCase(style) {
    var converted = {
    };
    for(var prop in style){
        var key = prop.indexOf('--') === 0 ? prop : _hyphenateStyleNameDefault.default(prop);
        converted[key] = style[prop];
    }
    if (style.fallbacks) {
        if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);
        else converted.fallbacks = convertCase(style.fallbacks);
    }
    return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 *
 * @param {Rule} rule
 */ function camelCase() {
    function onProcessStyle(style) {
        if (Array.isArray(style)) {
            // Handle rules like @font-face, which can have multiple styles in an array
            for(var index = 0; index < style.length; index++)style[index] = convertCase(style[index]);
            return style;
        }
        return convertCase(style);
    }
    function onChangeValue(value, prop, rule) {
        if (prop.indexOf('--') === 0) return value;
        var hyphenatedProp = _hyphenateStyleNameDefault.default(prop); // There was no camel case in place
        if (prop === hyphenatedProp) return value;
        rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.
        return null;
    }
    return {
        onProcessStyle: onProcessStyle,
        onChangeValue: onChangeValue
    };
}
exports.default = camelCase;

},{"hyphenate-style-name":"1hple","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"1hple":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-var, prefer-template */ var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {
};
function toHyphenLower(match) {
    return '-' + match.toLowerCase();
}
function hyphenateStyleName(name) {
    if (cache.hasOwnProperty(name)) return cache[name];
    var hName = name.replace(uppercasePattern, toHyphenLower);
    return cache[name] = msPattern.test(hName) ? '-' + hName : hName;
}
exports.default = hyphenateStyleName;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"9T4i1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jss = require("jss");
var px = _jss.hasCSSTOMSupport && CSS ? CSS.px : 'px';
var ms = _jss.hasCSSTOMSupport && CSS ? CSS.ms : 'ms';
var percent = _jss.hasCSSTOMSupport && CSS ? CSS.percent : '%';
/**
 * Generated jss-plugin-default-unit CSS property units
 *
 * @type object
 */ var defaultUnits = {
    // Animation properties
    'animation-delay': ms,
    'animation-duration': ms,
    // Background properties
    'background-position': px,
    'background-position-x': px,
    'background-position-y': px,
    'background-size': px,
    // Border Properties
    border: px,
    'border-bottom': px,
    'border-bottom-left-radius': px,
    'border-bottom-right-radius': px,
    'border-bottom-width': px,
    'border-left': px,
    'border-left-width': px,
    'border-radius': px,
    'border-right': px,
    'border-right-width': px,
    'border-top': px,
    'border-top-left-radius': px,
    'border-top-right-radius': px,
    'border-top-width': px,
    'border-width': px,
    'border-block': px,
    'border-block-end': px,
    'border-block-end-width': px,
    'border-block-start': px,
    'border-block-start-width': px,
    'border-block-width': px,
    'border-inline': px,
    'border-inline-end': px,
    'border-inline-end-width': px,
    'border-inline-start': px,
    'border-inline-start-width': px,
    'border-inline-width': px,
    'border-start-start-radius': px,
    'border-start-end-radius': px,
    'border-end-start-radius': px,
    'border-end-end-radius': px,
    // Margin properties
    margin: px,
    'margin-bottom': px,
    'margin-left': px,
    'margin-right': px,
    'margin-top': px,
    'margin-block': px,
    'margin-block-end': px,
    'margin-block-start': px,
    'margin-inline': px,
    'margin-inline-end': px,
    'margin-inline-start': px,
    // Padding properties
    padding: px,
    'padding-bottom': px,
    'padding-left': px,
    'padding-right': px,
    'padding-top': px,
    'padding-block': px,
    'padding-block-end': px,
    'padding-block-start': px,
    'padding-inline': px,
    'padding-inline-end': px,
    'padding-inline-start': px,
    // Mask properties
    'mask-position-x': px,
    'mask-position-y': px,
    'mask-size': px,
    // Width and height properties
    height: px,
    width: px,
    'min-height': px,
    'max-height': px,
    'min-width': px,
    'max-width': px,
    // Position properties
    bottom: px,
    left: px,
    top: px,
    right: px,
    inset: px,
    'inset-block': px,
    'inset-block-end': px,
    'inset-block-start': px,
    'inset-inline': px,
    'inset-inline-end': px,
    'inset-inline-start': px,
    // Shadow properties
    'box-shadow': px,
    'text-shadow': px,
    // Column properties
    'column-gap': px,
    'column-rule': px,
    'column-rule-width': px,
    'column-width': px,
    // Font and text properties
    'font-size': px,
    'font-size-delta': px,
    'letter-spacing': px,
    'text-decoration-thickness': px,
    'text-indent': px,
    'text-stroke': px,
    'text-stroke-width': px,
    'word-spacing': px,
    // Motion properties
    motion: px,
    'motion-offset': px,
    // Outline properties
    outline: px,
    'outline-offset': px,
    'outline-width': px,
    // Perspective properties
    perspective: px,
    'perspective-origin-x': percent,
    'perspective-origin-y': percent,
    // Transform properties
    'transform-origin': percent,
    'transform-origin-x': percent,
    'transform-origin-y': percent,
    'transform-origin-z': percent,
    // Transition properties
    'transition-delay': ms,
    'transition-duration': ms,
    // Alignment properties
    'vertical-align': px,
    'flex-basis': px,
    // Some random properties
    'shape-margin': px,
    size: px,
    gap: px,
    // Grid properties
    grid: px,
    'grid-gap': px,
    'row-gap': px,
    'grid-row-gap': px,
    'grid-column-gap': px,
    'grid-template-rows': px,
    'grid-template-columns': px,
    'grid-auto-rows': px,
    'grid-auto-columns': px,
    // Not existing properties.
    // Used to avoid issues with jss-plugin-expand integration.
    'box-shadow-x': px,
    'box-shadow-y': px,
    'box-shadow-blur': px,
    'box-shadow-spread': px,
    'font-line-height': px,
    'text-shadow-x': px,
    'text-shadow-y': px,
    'text-shadow-blur': px
};
/**
 * Clones the object and adds a camel cased property version.
 */ function addCamelCasedVersion(obj) {
    var regExp = /(-[a-z])/g;
    var replace = function replace1(str) {
        return str[1].toUpperCase();
    };
    var newObj = {
    };
    for(var _key in obj){
        newObj[_key] = obj[_key];
        newObj[_key.replace(regExp, replace)] = obj[_key];
    }
    return newObj;
}
var units = addCamelCasedVersion(defaultUnits);
/**
 * Recursive deep style passing function
 */ function iterate(prop, value, options) {
    if (value == null) return value;
    if (Array.isArray(value)) for(var i = 0; i < value.length; i++)value[i] = iterate(prop, value[i], options);
    else if (typeof value === 'object') {
        if (prop === 'fallbacks') for(var innerProp in value)value[innerProp] = iterate(innerProp, value[innerProp], options);
        else for(var _innerProp in value)value[_innerProp] = iterate(prop + "-" + _innerProp, value[_innerProp], options);
         // eslint-disable-next-line no-restricted-globals
    } else if (typeof value === 'number' && isNaN(value) === false) {
        var unit = options[prop] || units[prop]; // Add the unit if available, except for the special case of 0px.
        if (unit && !(value === 0 && unit === px)) return typeof unit === 'function' ? unit(value).toString() : "" + value + unit;
        return value.toString();
    }
    return value;
}
/**
 * Add unit to numeric values.
 */ function defaultUnit(options) {
    if (options === void 0) options = {
    };
    var camelCasedOptions = addCamelCasedVersion(options);
    function onProcessStyle(style, rule) {
        if (rule.type !== 'style') return style;
        for(var prop in style)style[prop] = iterate(prop, style[prop], camelCasedOptions);
        return style;
    }
    function onChangeValue(value, prop) {
        return iterate(prop, value, camelCasedOptions);
    }
    return {
        onProcessStyle: onProcessStyle,
        onChangeValue: onChangeValue
    };
}
exports.default = defaultUnit;

},{"jss":"bJs7q","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"7X7VV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cssVendor = require("css-vendor");
var _jss = require("jss");
/**
 * Add vendor prefix to a property name when needed.
 *
 * @api public
 */ function jssVendorPrefixer() {
    function onProcessRule(rule) {
        if (rule.type === 'keyframes') {
            var atRule = rule;
            atRule.at = _cssVendor.supportedKeyframes(atRule.at);
        }
    }
    function prefixStyle(style) {
        for(var prop in style){
            var value = style[prop];
            if (prop === 'fallbacks' && Array.isArray(value)) {
                style[prop] = value.map(prefixStyle);
                continue;
            }
            var changeProp = false;
            var supportedProp = _cssVendor.supportedProperty(prop);
            if (supportedProp && supportedProp !== prop) changeProp = true;
            var changeValue = false;
            var supportedValue$1 = _cssVendor.supportedValue(supportedProp, _jss.toCssValue(value));
            if (supportedValue$1 && supportedValue$1 !== value) changeValue = true;
            if (changeProp || changeValue) {
                if (changeProp) delete style[prop];
                style[supportedProp || prop] = supportedValue$1 || value;
            }
        }
        return style;
    }
    function onProcessStyle(style, rule) {
        if (rule.type !== 'style') return style;
        return prefixStyle(style);
    }
    function onChangeValue(value, prop) {
        return _cssVendor.supportedValue(prop, _jss.toCssValue(value)) || value;
    }
    return {
        onProcessRule: onProcessRule,
        onProcessStyle: onProcessStyle,
        onChangeValue: onChangeValue
    };
}
exports.default = jssVendorPrefixer;

},{"css-vendor":"aX4oC","jss":"bJs7q","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"aX4oC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "prefix", ()=>prefix
);
parcelHelpers.export(exports, "supportedKeyframes", ()=>supportedKeyframes
);
parcelHelpers.export(exports, "supportedProperty", ()=>supportedProperty
);
parcelHelpers.export(exports, "supportedValue", ()=>supportedValue
);
var _isInBrowser = require("is-in-browser");
var _isInBrowserDefault = parcelHelpers.interopDefault(_isInBrowser);
var _toConsumableArray = require("@babel/runtime/helpers/esm/toConsumableArray");
var _toConsumableArrayDefault = parcelHelpers.interopDefault(_toConsumableArray);
// Export javascript style and css style vendor prefixes.
var js = '';
var css = '';
var vendor = '';
var browser = '';
var isTouch = _isInBrowserDefault.default && 'ontouchstart' in document.documentElement; // We should not do anything if required serverside.
if (_isInBrowserDefault.default) {
    // Order matters. We need to check Webkit the last one because
    // other vendors use to add Webkit prefixes to some properties
    var jsCssMap = {
        Moz: '-moz-',
        ms: '-ms-',
        O: '-o-',
        Webkit: '-webkit-'
    };
    var _document$createEleme = document.createElement('p'), style = _document$createEleme.style;
    var testProp = 'Transform';
    for(var key in jsCssMap)if (key + testProp in style) {
        js = key;
        css = jsCssMap[key];
        break;
    }
     // Correctly detect the Edge browser.
    if (js === 'Webkit' && 'msHyphens' in style) {
        js = 'ms';
        css = jsCssMap.ms;
        browser = 'edge';
    } // Correctly detect the Safari browser.
    if (js === 'Webkit' && '-apple-trailing-word' in style) vendor = 'apple';
}
/**
 * Vendor prefix string for the current browser.
 *
 * @type {{js: String, css: String, vendor: String, browser: String}}
 * @api public
 */ var prefix = {
    js: js,
    css: css,
    vendor: vendor,
    browser: browser,
    isTouch: isTouch
};
/**
 * Test if a keyframe at-rule should be prefixed or not
 *
 * @param {String} vendor prefix string for the current browser.
 * @return {String}
 * @api public
 */ function supportedKeyframes(key) {
    // Keyframes is already prefixed. e.g. key = '@-webkit-keyframes a'
    if (key[1] === '-') return key; // No need to prefix IE/Edge. Older browsers will ignore unsupported rules.
    // https://caniuse.com/#search=keyframes
    if (prefix.js === 'ms') return key;
    return "@" + prefix.css + "keyframes" + key.substr(10);
}
// https://caniuse.com/#search=appearance
var appearence = {
    noPrefill: [
        'appearance'
    ],
    supportedProperty: function supportedProperty(prop) {
        if (prop !== 'appearance') return false;
        if (prefix.js === 'ms') return "-webkit-" + prop;
        return prefix.css + prop;
    }
};
// https://caniuse.com/#search=color-adjust
var colorAdjust = {
    noPrefill: [
        'color-adjust'
    ],
    supportedProperty: function supportedProperty(prop) {
        if (prop !== 'color-adjust') return false;
        if (prefix.js === 'Webkit') return prefix.css + "print-" + prop;
        return prop;
    }
};
var regExp = /[-\s]+(.)?/g;
/**
 * Replaces the letter with the capital letter
 *
 * @param {String} match
 * @param {String} c
 * @return {String}
 * @api private
 */ function toUpper(match, c) {
    return c ? c.toUpperCase() : '';
}
/**
 * Convert dash separated strings to camel-cased.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */ function camelize(str) {
    return str.replace(regExp, toUpper);
}
/**
 * Convert dash separated strings to pascal cased.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */ function pascalize(str) {
    return camelize("-" + str);
}
// but we can use a longhand property instead.
// https://caniuse.com/#search=mask
var mask = {
    noPrefill: [
        'mask'
    ],
    supportedProperty: function supportedProperty(prop, style) {
        if (!/^mask/.test(prop)) return false;
        if (prefix.js === 'Webkit') {
            var longhand = 'mask-image';
            if (camelize(longhand) in style) return prop;
            if (prefix.js + pascalize(longhand) in style) return prefix.css + prop;
        }
        return prop;
    }
};
// https://caniuse.com/#search=text-orientation
var textOrientation = {
    noPrefill: [
        'text-orientation'
    ],
    supportedProperty: function supportedProperty(prop) {
        if (prop !== 'text-orientation') return false;
        if (prefix.vendor === 'apple' && !prefix.isTouch) return prefix.css + prop;
        return prop;
    }
};
// https://caniuse.com/#search=transform
var transform = {
    noPrefill: [
        'transform'
    ],
    supportedProperty: function supportedProperty(prop, style, options) {
        if (prop !== 'transform') return false;
        if (options.transform) return prop;
        return prefix.css + prop;
    }
};
// https://caniuse.com/#search=transition
var transition = {
    noPrefill: [
        'transition'
    ],
    supportedProperty: function supportedProperty(prop, style, options) {
        if (prop !== 'transition') return false;
        if (options.transition) return prop;
        return prefix.css + prop;
    }
};
// https://caniuse.com/#search=writing-mode
var writingMode = {
    noPrefill: [
        'writing-mode'
    ],
    supportedProperty: function supportedProperty(prop) {
        if (prop !== 'writing-mode') return false;
        if (prefix.js === 'Webkit' || prefix.js === 'ms' && prefix.browser !== 'edge') return prefix.css + prop;
        return prop;
    }
};
// https://caniuse.com/#search=user-select
var userSelect = {
    noPrefill: [
        'user-select'
    ],
    supportedProperty: function supportedProperty(prop) {
        if (prop !== 'user-select') return false;
        if (prefix.js === 'Moz' || prefix.js === 'ms' || prefix.vendor === 'apple') return prefix.css + prop;
        return prop;
    }
};
// https://caniuse.com/#search=multicolumn
// https://github.com/postcss/autoprefixer/issues/491
// https://github.com/postcss/autoprefixer/issues/177
var breakPropsOld = {
    supportedProperty: function supportedProperty(prop, style) {
        if (!/^break-/.test(prop)) return false;
        if (prefix.js === 'Webkit') {
            var jsProp = "WebkitColumn" + pascalize(prop);
            return jsProp in style ? prefix.css + "column-" + prop : false;
        }
        if (prefix.js === 'Moz') {
            var _jsProp = "page" + pascalize(prop);
            return _jsProp in style ? "page-" + prop : false;
        }
        return false;
    }
};
// See https://github.com/postcss/autoprefixer/issues/324.
var inlineLogicalOld = {
    supportedProperty: function supportedProperty(prop, style) {
        if (!/^(border|margin|padding)-inline/.test(prop)) return false;
        if (prefix.js === 'Moz') return prop;
        var newProp = prop.replace('-inline', '');
        return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
    }
};
// Camelization is required because we can't test using.
// CSS syntax for e.g. in FF.
var unprefixed = {
    supportedProperty: function supportedProperty(prop, style) {
        return camelize(prop) in style ? prop : false;
    }
};
var prefixed = {
    supportedProperty: function supportedProperty(prop, style) {
        var pascalized = pascalize(prop); // Return custom CSS variable without prefixing.
        if (prop[0] === '-') return prop; // Return already prefixed value without prefixing.
        if (prop[0] === '-' && prop[1] === '-') return prop;
        if (prefix.js + pascalized in style) return prefix.css + prop; // Try webkit fallback.
        if (prefix.js !== 'Webkit' && "Webkit" + pascalized in style) return "-webkit-" + prop;
        return false;
    }
};
// https://caniuse.com/#search=scroll-snap
var scrollSnap = {
    supportedProperty: function supportedProperty(prop) {
        if (prop.substring(0, 11) !== 'scroll-snap') return false;
        if (prefix.js === 'ms') return "" + prefix.css + prop;
        return prop;
    }
};
// https://caniuse.com/#search=overscroll-behavior
var overscrollBehavior = {
    supportedProperty: function supportedProperty(prop) {
        if (prop !== 'overscroll-behavior') return false;
        if (prefix.js === 'ms') return prefix.css + "scroll-chaining";
        return prop;
    }
};
var propMap = {
    'flex-grow': 'flex-positive',
    'flex-shrink': 'flex-negative',
    'flex-basis': 'flex-preferred-size',
    'justify-content': 'flex-pack',
    order: 'flex-order',
    'align-items': 'flex-align',
    'align-content': 'flex-line-pack' // 'align-self' is handled by 'align-self' plugin.
}; // Support old flex spec from 2012.
var flex2012 = {
    supportedProperty: function supportedProperty(prop, style) {
        var newProp = propMap[prop];
        if (!newProp) return false;
        return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
    }
};
var propMap$1 = {
    flex: 'box-flex',
    'flex-grow': 'box-flex',
    'flex-direction': [
        'box-orient',
        'box-direction'
    ],
    order: 'box-ordinal-group',
    'align-items': 'box-align',
    'flex-flow': [
        'box-orient',
        'box-direction'
    ],
    'justify-content': 'box-pack'
};
var propKeys = Object.keys(propMap$1);
var prefixCss = function prefixCss1(p) {
    return prefix.css + p;
}; // Support old flex spec from 2009.
var flex2009 = {
    supportedProperty: function supportedProperty(prop, style, _ref) {
        var multiple = _ref.multiple;
        if (propKeys.indexOf(prop) > -1) {
            var newProp = propMap$1[prop];
            if (!Array.isArray(newProp)) return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
            if (!multiple) return false;
            for(var i = 0; i < newProp.length; i++){
                if (!(prefix.js + pascalize(newProp[0]) in style)) return false;
            }
            return newProp.map(prefixCss);
        }
        return false;
    }
};
// plugins = [
//   ...plugins,
//    breakPropsOld,
//    inlineLogicalOld,
//    unprefixed,
//    prefixed,
//    scrollSnap,
//    flex2012,
//    flex2009
// ]
// Plugins without 'noPrefill' value, going last.
// 'flex-*' plugins should be at the bottom.
// 'flex2009' going after 'flex2012'.
// 'prefixed' going after 'unprefixed'
var plugins = [
    appearence,
    colorAdjust,
    mask,
    textOrientation,
    transform,
    transition,
    writingMode,
    userSelect,
    breakPropsOld,
    inlineLogicalOld,
    unprefixed,
    prefixed,
    scrollSnap,
    overscrollBehavior,
    flex2012,
    flex2009
];
var propertyDetectors = plugins.filter(function(p) {
    return p.supportedProperty;
}).map(function(p) {
    return p.supportedProperty;
});
var noPrefill = plugins.filter(function(p) {
    return p.noPrefill;
}).reduce(function(a, p) {
    a.push.apply(a, _toConsumableArrayDefault.default(p.noPrefill));
    return a;
}, []);
var el;
var cache = {
};
if (_isInBrowserDefault.default) {
    el = document.createElement('p'); // We test every property on vendor prefix requirement.
    // Once tested, result is cached. It gives us up to 70% perf boost.
    // http://jsperf.com/element-style-object-access-vs-plain-object
    //
    // Prefill cache with known css properties to reduce amount of
    // properties we need to feature test at runtime.
    // http://davidwalsh.name/vendor-prefix
    var computed = window.getComputedStyle(document.documentElement, '');
    for(var key$1 in computed)// eslint-disable-next-line no-restricted-globals
    if (!isNaN(key$1)) cache[computed[key$1]] = computed[key$1];
     // Properties that cannot be correctly detected using the
    // cache prefill method.
    noPrefill.forEach(function(x) {
        return delete cache[x];
    });
}
/**
 * Test if a property is supported, returns supported property with vendor
 * prefix if required. Returns `false` if not supported.
 *
 * @param {String} prop dash separated
 * @param {Object} [options]
 * @return {String|Boolean}
 * @api public
 */ function supportedProperty(prop, options) {
    if (options === void 0) options = {
    };
    // For server-side rendering.
    if (!el) return prop; // Remove cache for benchmark tests or return property from the cache.
    if (cache[prop] != null) return cache[prop];
     // Check if 'transition' or 'transform' natively supported in browser.
    if (prop === 'transition' || prop === 'transform') options[prop] = prop in el.style;
     // Find a plugin for current prefix property.
    for(var i = 0; i < propertyDetectors.length; i++){
        cache[prop] = propertyDetectors[i](prop, el.style, options); // Break loop, if value found.
        if (cache[prop]) break;
    } // Reset styles for current property.
    // Firefox can even throw an error for invalid properties, e.g., "0".
    try {
        el.style[prop] = '';
    } catch (err) {
        return false;
    }
    return cache[prop];
}
var cache$1 = {
};
var transitionProperties = {
    transition: 1,
    'transition-property': 1,
    '-webkit-transition': 1,
    '-webkit-transition-property': 1
};
var transPropsRegExp = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g;
var el$1;
/**
 * Returns prefixed value transition/transform if needed.
 *
 * @param {String} match
 * @param {String} p1
 * @param {String} p2
 * @return {String}
 * @api private
 */ function prefixTransitionCallback(match, p1, p2) {
    if (p1 === 'var') return 'var';
    if (p1 === 'all') return 'all';
    if (p2 === 'all') return ', all';
    var prefixedValue = p1 ? supportedProperty(p1) : ", " + supportedProperty(p2);
    if (!prefixedValue) return p1 || p2;
    return prefixedValue;
}
if (_isInBrowserDefault.default) el$1 = document.createElement('p');
/**
 * Returns prefixed value if needed. Returns `false` if value is not supported.
 *
 * @param {String} property
 * @param {String} value
 * @return {String|Boolean}
 * @api public
 */ function supportedValue(property, value) {
    // For server-side rendering.
    var prefixedValue = value;
    if (!el$1 || property === 'content') return value; // It is a string or a number as a string like '1'.
    // We want only prefixable values here.
    // eslint-disable-next-line no-restricted-globals
    if (typeof prefixedValue !== 'string' || !isNaN(parseInt(prefixedValue, 10))) return prefixedValue;
     // Create cache key for current value.
    var cacheKey = property + prefixedValue; // Remove cache for benchmark tests or return value from cache.
    if (cache$1[cacheKey] != null) return cache$1[cacheKey];
     // IE can even throw an error in some cases, for e.g. style.content = 'bar'.
    try {
        // Test value as it is.
        el$1.style[property] = prefixedValue;
    } catch (err) {
        // Return false if value not supported.
        cache$1[cacheKey] = false;
        return false;
    } // If 'transition' or 'transition-property' property.
    if (transitionProperties[property]) prefixedValue = prefixedValue.replace(transPropsRegExp, prefixTransitionCallback);
    else if (el$1.style[property] === '') {
        // Value with a vendor prefix.
        prefixedValue = prefix.css + prefixedValue; // Hardcode test to convert "flex" to "-ms-flexbox" for IE10.
        if (prefixedValue === '-ms-flex') el$1.style[property] = '-ms-flexbox'; // Test prefixed value.
        el$1.style[property] = prefixedValue; // Return false if value not supported.
        if (el$1.style[property] === '') {
            cache$1[cacheKey] = false;
            return false;
        }
    } // Reset styles for current property.
    el$1.style[property] = ''; // Write current value to cache.
    cache$1[cacheKey] = prefixedValue;
    return cache$1[cacheKey];
}

},{"is-in-browser":"dKhYK","@babel/runtime/helpers/esm/toConsumableArray":"fbqwi","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"fbqwi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayWithoutHolesJs = require("./arrayWithoutHoles.js");
var _arrayWithoutHolesJsDefault = parcelHelpers.interopDefault(_arrayWithoutHolesJs);
var _iterableToArrayJs = require("./iterableToArray.js");
var _iterableToArrayJsDefault = parcelHelpers.interopDefault(_iterableToArrayJs);
var _unsupportedIterableToArrayJs = require("./unsupportedIterableToArray.js");
var _unsupportedIterableToArrayJsDefault = parcelHelpers.interopDefault(_unsupportedIterableToArrayJs);
var _nonIterableSpreadJs = require("./nonIterableSpread.js");
var _nonIterableSpreadJsDefault = parcelHelpers.interopDefault(_nonIterableSpreadJs);
function _toConsumableArray(arr) {
    return _arrayWithoutHolesJsDefault.default(arr) || _iterableToArrayJsDefault.default(arr) || _unsupportedIterableToArrayJsDefault.default(arr) || _nonIterableSpreadJsDefault.default();
}
exports.default = _toConsumableArray;

},{"./arrayWithoutHoles.js":"coxU6","./iterableToArray.js":"206jS","./unsupportedIterableToArray.js":"2SFEG","./nonIterableSpread.js":"lOeNE","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"coxU6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayLikeToArrayJs = require("./arrayLikeToArray.js");
var _arrayLikeToArrayJsDefault = parcelHelpers.interopDefault(_arrayLikeToArrayJs);
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArrayJsDefault.default(arr);
}
exports.default = _arrayWithoutHoles;

},{"./arrayLikeToArray.js":"aTQhs","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"aTQhs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
exports.default = _arrayLikeToArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"206jS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
exports.default = _iterableToArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"2SFEG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayLikeToArrayJs = require("./arrayLikeToArray.js");
var _arrayLikeToArrayJsDefault = parcelHelpers.interopDefault(_arrayLikeToArrayJs);
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArrayJsDefault.default(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArrayJsDefault.default(o, minLen);
}
exports.default = _unsupportedIterableToArray;

},{"./arrayLikeToArray.js":"aTQhs","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"lOeNE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
exports.default = _nonIterableSpread;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"e7RN0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Sort props by length.
 */ function jssPropsSort() {
    var sort = function sort1(prop0, prop1) {
        if (prop0.length === prop1.length) return prop0 > prop1 ? 1 : -1;
        return prop0.length - prop1.length;
    };
    return {
        onProcessStyle: function onProcessStyle(style, rule) {
            if (rule.type !== 'style') return style;
            var newStyle = {
            };
            var props = Object.keys(style).sort(sort);
            for(var i = 0; i < props.length; i++)newStyle[props[i]] = style[props[i]];
            return newStyle;
        }
    };
}
exports.default = jssPropsSort;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8KWuW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_makeStylesDefault.default
);
var _makeStyles = require("./makeStyles");
var _makeStylesDefault = parcelHelpers.interopDefault(_makeStyles);

},{"./makeStyles":"7B9PR","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"7B9PR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _jss = require("jss");
var _mergeClasses = require("../mergeClasses");
var _mergeClassesDefault = parcelHelpers.interopDefault(_mergeClasses);
var _multiKeyStore = require("./multiKeyStore");
var _multiKeyStoreDefault = parcelHelpers.interopDefault(_multiKeyStore);
var _useTheme = require("../useTheme");
var _useThemeDefault = parcelHelpers.interopDefault(_useTheme);
var _stylesProvider = require("../StylesProvider");
var _indexCounter = require("./indexCounter");
var _getStylesCreator = require("../getStylesCreator");
var _getStylesCreatorDefault = parcelHelpers.interopDefault(_getStylesCreator);
var _noopTheme = require("../getStylesCreator/noopTheme");
var _noopThemeDefault = parcelHelpers.interopDefault(_noopTheme);
function getClasses(_ref, classes, Component) {
    var state = _ref.state, stylesOptions = _ref.stylesOptions;
    if (stylesOptions.disableGeneration) return classes || {
    };
    if (!state.cacheClasses) state.cacheClasses = {
        // Cache for the finalized classes value.
        value: null,
        // Cache for the last used classes prop pointer.
        lastProp: null,
        // Cache for the last used rendered classes pointer.
        lastJSS: {
        }
    };
     // Tracks if either the rendered classes or classes prop has changed,
    // requiring the generation of a new finalized classes object.
    var generate = false;
    if (state.classes !== state.cacheClasses.lastJSS) {
        state.cacheClasses.lastJSS = state.classes;
        generate = true;
    }
    if (classes !== state.cacheClasses.lastProp) {
        state.cacheClasses.lastProp = classes;
        generate = true;
    }
    if (generate) state.cacheClasses.value = _mergeClassesDefault.default({
        baseClasses: state.cacheClasses.lastJSS,
        newClasses: classes,
        Component: Component
    });
    return state.cacheClasses.value;
}
function attach(_ref2, props) {
    var state = _ref2.state, theme = _ref2.theme, stylesOptions = _ref2.stylesOptions, stylesCreator = _ref2.stylesCreator, name = _ref2.name;
    if (stylesOptions.disableGeneration) return;
    var sheetManager = _multiKeyStoreDefault.default.get(stylesOptions.sheetsManager, stylesCreator, theme);
    if (!sheetManager) {
        sheetManager = {
            refs: 0,
            staticSheet: null,
            dynamicStyles: null
        };
        _multiKeyStoreDefault.default.set(stylesOptions.sheetsManager, stylesCreator, theme, sheetManager);
    }
    var options = _extendsDefault.default({
    }, stylesCreator.options, stylesOptions, {
        theme: theme,
        flip: typeof stylesOptions.flip === 'boolean' ? stylesOptions.flip : theme.direction === 'rtl'
    });
    options.generateId = options.serverGenerateClassName || options.generateClassName;
    var sheetsRegistry = stylesOptions.sheetsRegistry;
    if (sheetManager.refs === 0) {
        var staticSheet;
        if (stylesOptions.sheetsCache) staticSheet = _multiKeyStoreDefault.default.get(stylesOptions.sheetsCache, stylesCreator, theme);
        var styles = stylesCreator.create(theme, name);
        if (!staticSheet) {
            staticSheet = stylesOptions.jss.createStyleSheet(styles, _extendsDefault.default({
                link: false
            }, options));
            staticSheet.attach();
            if (stylesOptions.sheetsCache) _multiKeyStoreDefault.default.set(stylesOptions.sheetsCache, stylesCreator, theme, staticSheet);
        }
        if (sheetsRegistry) sheetsRegistry.add(staticSheet);
        sheetManager.staticSheet = staticSheet;
        sheetManager.dynamicStyles = _jss.getDynamicStyles(styles);
    }
    if (sheetManager.dynamicStyles) {
        var dynamicSheet = stylesOptions.jss.createStyleSheet(sheetManager.dynamicStyles, _extendsDefault.default({
            link: true
        }, options));
        dynamicSheet.update(props);
        dynamicSheet.attach();
        state.dynamicSheet = dynamicSheet;
        state.classes = _mergeClassesDefault.default({
            baseClasses: sheetManager.staticSheet.classes,
            newClasses: dynamicSheet.classes
        });
        if (sheetsRegistry) sheetsRegistry.add(dynamicSheet);
    } else state.classes = sheetManager.staticSheet.classes;
    sheetManager.refs += 1;
}
function update(_ref3, props) {
    var state = _ref3.state;
    if (state.dynamicSheet) state.dynamicSheet.update(props);
}
function detach(_ref4) {
    var state = _ref4.state, theme = _ref4.theme, stylesOptions = _ref4.stylesOptions, stylesCreator = _ref4.stylesCreator;
    if (stylesOptions.disableGeneration) return;
    var sheetManager = _multiKeyStoreDefault.default.get(stylesOptions.sheetsManager, stylesCreator, theme);
    sheetManager.refs -= 1;
    var sheetsRegistry = stylesOptions.sheetsRegistry;
    if (sheetManager.refs === 0) {
        _multiKeyStoreDefault.default.delete(stylesOptions.sheetsManager, stylesCreator, theme);
        stylesOptions.jss.removeStyleSheet(sheetManager.staticSheet);
        if (sheetsRegistry) sheetsRegistry.remove(sheetManager.staticSheet);
    }
    if (state.dynamicSheet) {
        stylesOptions.jss.removeStyleSheet(state.dynamicSheet);
        if (sheetsRegistry) sheetsRegistry.remove(state.dynamicSheet);
    }
}
function useSynchronousEffect(func, values) {
    var key = _reactDefault.default.useRef([]);
    var output; // Store "generation" key. Just returns a new object every time
    var currentKey = _reactDefault.default.useMemo(function() {
        return {
        };
    }, values); // eslint-disable-line react-hooks/exhaustive-deps
    // "the first render", or "memo dropped the value"
    if (key.current !== currentKey) {
        key.current = currentKey;
        output = func();
    }
    _reactDefault.default.useEffect(function() {
        return function() {
            if (output) output();
        };
    }, [
        currentKey
    ] // eslint-disable-line react-hooks/exhaustive-deps
    );
}
function makeStyles(stylesOrCreator) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    };
    var name = options.name, classNamePrefixOption = options.classNamePrefix, Component = options.Component, _options$defaultTheme = options.defaultTheme, defaultTheme = _options$defaultTheme === void 0 ? _noopThemeDefault.default : _options$defaultTheme, stylesOptions2 = _objectWithoutPropertiesDefault.default(options, [
        "name",
        "classNamePrefix",
        "Component",
        "defaultTheme"
    ]);
    var stylesCreator = _getStylesCreatorDefault.default(stylesOrCreator);
    var classNamePrefix = name || classNamePrefixOption || 'makeStyles';
    stylesCreator.options = {
        index: _indexCounter.increment(),
        name: name,
        meta: classNamePrefix,
        classNamePrefix: classNamePrefix
    };
    var useStyles = function useStyles1() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        };
        var theme = _useThemeDefault.default() || defaultTheme;
        var stylesOptions = _extendsDefault.default({
        }, _reactDefault.default.useContext(_stylesProvider.StylesContext), stylesOptions2);
        var instance = _reactDefault.default.useRef();
        var shouldUpdate = _reactDefault.default.useRef();
        useSynchronousEffect(function() {
            var current = {
                name: name,
                state: {
                },
                stylesCreator: stylesCreator,
                stylesOptions: stylesOptions,
                theme: theme
            };
            attach(current, props);
            shouldUpdate.current = false;
            instance.current = current;
            return function() {
                detach(current);
            };
        }, [
            theme,
            stylesCreator
        ]);
        _reactDefault.default.useEffect(function() {
            if (shouldUpdate.current) update(instance.current, props);
            shouldUpdate.current = true;
        });
        var classes = getClasses(instance.current, props.classes, Component);
        // eslint-disable-next-line react-hooks/rules-of-hooks
        _reactDefault.default.useDebugValue(classes);
        return classes;
    };
    return useStyles;
}
exports.default = makeStyles;

},{"@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@babel/runtime/helpers/esm/extends":"esrVD","react":"cKM0D","jss":"bJs7q","../mergeClasses":"bj8Xo","./multiKeyStore":"3v7lF","../useTheme":"1dQw3","../StylesProvider":"6XQfg","./indexCounter":"iY5cw","../getStylesCreator":"1BHod","../getStylesCreator/noopTheme":"bWXLV","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"bj8Xo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_mergeClassesDefault.default
);
var _mergeClasses = require("./mergeClasses");
var _mergeClassesDefault = parcelHelpers.interopDefault(_mergeClasses);

},{"./mergeClasses":"bs0zX","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"bs0zX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _utils = require("@material-ui/utils");
function mergeClasses() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    };
    var baseClasses = options.baseClasses, newClasses = options.newClasses, Component = options.Component;
    if (!newClasses) return baseClasses;
    var nextClasses = _extendsDefault.default({
    }, baseClasses);
    if (typeof newClasses === 'string') {
        console.error([
            "Material-UI: The value `".concat(newClasses, "` ") + "provided to the classes prop of ".concat(_utils.getDisplayName(Component), " is incorrect."),
            'You might want to use the className prop instead.'
        ].join('\n'));
        return baseClasses;
    }
    Object.keys(newClasses).forEach(function(key) {
        if (!baseClasses[key] && newClasses[key]) console.error([
            "Material-UI: The key `".concat(key, "` ") + "provided to the classes prop is not implemented in ".concat(_utils.getDisplayName(Component), "."),
            "You can only override one of the following: ".concat(Object.keys(baseClasses).join(','), ".")
        ].join('\n'));
        if (newClasses[key] && typeof newClasses[key] !== 'string') console.error([
            "Material-UI: The key `".concat(key, "` ") + "provided to the classes prop is not valid for ".concat(_utils.getDisplayName(Component), "."),
            "You need to provide a non empty string instead of: ".concat(newClasses[key], ".")
        ].join('\n'));
        if (newClasses[key]) nextClasses[key] = "".concat(baseClasses[key], " ").concat(newClasses[key]);
    });
    return nextClasses;
}
exports.default = mergeClasses;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@material-ui/utils":"Uumnw","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"3v7lF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Used https://github.com/thinkloop/multi-key-cache as inspiration
var multiKeyStore = {
    set: function set(cache, key1, key2, value) {
        var subCache = cache.get(key1);
        if (!subCache) {
            subCache = new Map();
            cache.set(key1, subCache);
        }
        subCache.set(key2, value);
    },
    get: function get(cache, key1, key2) {
        var subCache = cache.get(key1);
        return subCache ? subCache.get(key2) : undefined;
    },
    delete: function _delete(cache, key1, key2) {
        var subCache = cache.get(key1);
        subCache.delete(key2);
    }
};
exports.default = multiKeyStore;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"1dQw3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_useThemeDefault.default
);
var _useTheme = require("./useTheme");
var _useThemeDefault = parcelHelpers.interopDefault(_useTheme);

},{"./useTheme":"hKYiS","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hKYiS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _themeContext = require("./ThemeContext");
var _themeContextDefault = parcelHelpers.interopDefault(_themeContext);
function useTheme() {
    var theme = _reactDefault.default.useContext(_themeContextDefault.default);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    _reactDefault.default.useDebugValue(theme);
    return theme;
}
exports.default = useTheme;

},{"react":"cKM0D","./ThemeContext":"atEi3","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"atEi3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var ThemeContext = _reactDefault.default.createContext(null);
ThemeContext.displayName = 'ThemeContext';
exports.default = ThemeContext;

},{"react":"cKM0D","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"6XQfg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_stylesProviderDefault.default
);
var _stylesProvider = require("./StylesProvider");
var _stylesProviderDefault = parcelHelpers.interopDefault(_stylesProvider);
parcelHelpers.exportAll(_stylesProvider, exports);

},{"./StylesProvider":"8q7n7","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8q7n7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sheetsManager", ()=>sheetsManager
);
parcelHelpers.export(exports, "StylesContext", ()=>StylesContext
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _utils = require("@material-ui/utils");
var _createGenerateClassName = require("../createGenerateClassName");
var _createGenerateClassNameDefault = parcelHelpers.interopDefault(_createGenerateClassName);
var _jss = require("jss");
var _jssPreset = require("../jssPreset"); // Default JSS instance.
var _jssPresetDefault = parcelHelpers.interopDefault(_jssPreset);
var jss = _jss.create(_jssPresetDefault.default()); // Use a singleton or the provided one by the context.
//
// The counter-based approach doesn't tolerate any mistake.
// It's much safer to use the same counter everywhere.
var generateClassName = _createGenerateClassNameDefault.default(); // Exported for test purposes
var sheetsManager = new Map();
var defaultOptions = {
    disableGeneration: false,
    generateClassName: generateClassName,
    jss: jss,
    sheetsCache: null,
    sheetsManager: sheetsManager,
    sheetsRegistry: null
};
var StylesContext = _reactDefault.default.createContext(defaultOptions);
StylesContext.displayName = 'StylesContext';
var injectFirstNode;
function StylesProvider(props) {
    var children = props.children, _props$injectFirst = props.injectFirst, injectFirst = _props$injectFirst === void 0 ? false : _props$injectFirst, _props$disableGenerat = props.disableGeneration, disableGeneration = _props$disableGenerat === void 0 ? false : _props$disableGenerat, localOptions = _objectWithoutPropertiesDefault.default(props, [
        "children",
        "injectFirst",
        "disableGeneration"
    ]);
    var outerOptions = _reactDefault.default.useContext(StylesContext);
    var context = _extendsDefault.default({
    }, outerOptions, {
        disableGeneration: disableGeneration
    }, localOptions);
    if (typeof window === 'undefined' && !context.sheetsManager) console.error('Material-UI: You need to use the ServerStyleSheets API when rendering on the server.');
    if (context.jss.options.insertionPoint && injectFirst) console.error('Material-UI: You cannot use a custom insertionPoint and <StylesContext injectFirst> at the same time.');
    if (injectFirst && localOptions.jss) console.error('Material-UI: You cannot use the jss and injectFirst props at the same time.');
    if (!context.jss.options.insertionPoint && injectFirst && typeof window !== 'undefined') {
        if (!injectFirstNode) {
            var head = document.head;
            injectFirstNode = document.createComment('mui-inject-first');
            head.insertBefore(injectFirstNode, head.firstChild);
        }
        context.jss = _jss.create({
            plugins: _jssPresetDefault.default().plugins,
            insertionPoint: injectFirstNode
        });
    }
    return(/*#__PURE__*/ _reactDefault.default.createElement(StylesContext.Provider, {
        value: context
    }, children));
}
exports.default = StylesProvider;
StylesProvider.propTypes = {
    /**
   * Your component tree.
   */ children: _propTypesDefault.default.node.isRequired,
    /**
   * You can disable the generation of the styles with this option.
   * It can be useful when traversing the React tree outside of the HTML
   * rendering step on the server.
   * Let's say you are using react-apollo to extract all
   * the queries made by the interface server-side - you can significantly speed up the traversal with this prop.
   */ disableGeneration: _propTypesDefault.default.bool,
    /**
   * JSS's class name generator.
   */ generateClassName: _propTypesDefault.default.func,
    /**
   * By default, the styles are injected last in the <head> element of the page.
   * As a result, they gain more specificity than any other style sheet.
   * If you want to override Material-UI's styles, set this prop.
   */ injectFirst: _propTypesDefault.default.bool,
    /**
   * JSS's instance.
   */ jss: _propTypesDefault.default.object,
    /**
   * @ignore
   */ serverGenerateClassName: _propTypesDefault.default.func,
    /**
   * @ignore
   *
   * Beta feature.
   *
   * Cache for the sheets.
   */ sheetsCache: _propTypesDefault.default.object,
    /**
   * @ignore
   *
   * The sheetsManager is used to deduplicate style sheet injection in the page.
   * It's deduplicating using the (theme, styles) couple.
   * On the server, you should provide a new instance for each request.
   */ sheetsManager: _propTypesDefault.default.object,
    /**
   * @ignore
   *
   * Collect the sheets.
   */ sheetsRegistry: _propTypesDefault.default.object
};
StylesProvider.propTypes = _utils.exactProp(StylesProvider.propTypes);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","@material-ui/utils":"Uumnw","../createGenerateClassName":"eGtjv","jss":"bJs7q","../jssPreset":"hyu7L","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"iY5cw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "increment", ()=>increment
);
/* eslint-disable import/prefer-default-export */ // Global index counter to preserve source order.
// We create the style sheet during the creation of the component,
// children are handled after the parents, so the order of style elements would be parent->child.
// It is a problem though when a parent passes a className
// which needs to override any child's styles.
// StyleSheet of the child has a higher specificity, because of the source order.
// So our solution is to render sheets them in the reverse order child->sheet, so
// that parent has a higher specificity.
var indexCounter = -1000000000;
function increment() {
    indexCounter += 1;
    if (indexCounter >= 0) console.warn([
        'Material-UI: You might have a memory leak.',
        'The indexCounter is not supposed to grow that much.'
    ].join('\n'));
    return indexCounter;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"1BHod":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_getStylesCreatorDefault.default
);
var _getStylesCreator = require("./getStylesCreator");
var _getStylesCreatorDefault = parcelHelpers.interopDefault(_getStylesCreator);

},{"./getStylesCreator":"7cqfP","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"7cqfP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _typeof = require("@babel/runtime/helpers/esm/typeof");
var _typeofDefault = parcelHelpers.interopDefault(_typeof);
var _utils = require("@material-ui/utils");
var _noopTheme = require("./noopTheme");
var _noopThemeDefault = parcelHelpers.interopDefault(_noopTheme);
function getStylesCreator(stylesOrCreator) {
    var themingEnabled = typeof stylesOrCreator === 'function';
    if (_typeofDefault.default(stylesOrCreator) !== 'object' && !themingEnabled) console.error([
        'Material-UI: The `styles` argument provided is invalid.',
        'You need to provide a function generating the styles or a styles object.'
    ].join('\n'));
    return {
        create: function create(theme, name) {
            var styles;
            try {
                styles = themingEnabled ? stylesOrCreator(theme) : stylesOrCreator;
            } catch (err) {
                if (themingEnabled === true && theme === _noopThemeDefault.default) // TODO: prepend error message/name instead
                console.error([
                    'Material-UI: The `styles` argument provided is invalid.',
                    'You are providing a function without a theme in the context.',
                    'One of the parent elements needs to use a ThemeProvider.'
                ].join('\n'));
                throw err;
            }
            if (!name || !theme.overrides || !theme.overrides[name]) return styles;
            var overrides = theme.overrides[name];
            var stylesWithOverrides = _extendsDefault.default({
            }, styles);
            Object.keys(overrides).forEach(function(key) {
                if (!stylesWithOverrides[key]) console.warn([
                    'Material-UI: You are trying to override a style that does not exist.',
                    "Fix the `".concat(key, "` key of `theme.overrides.").concat(name, "`.")
                ].join('\n'));
                stylesWithOverrides[key] = _utils.deepmerge(stylesWithOverrides[key], overrides[key]);
            });
            return stylesWithOverrides;
        },
        options: {
        }
    };
}
exports.default = getStylesCreator;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/typeof":"sHS2O","@material-ui/utils":"Uumnw","./noopTheme":"bWXLV","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"bWXLV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// We use the same empty object to ref count the styles that don't need a theme object.
var noopTheme = {
};
exports.default = noopTheme;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hIR08":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_serverStyleSheetsDefault.default
);
var _serverStyleSheets = require("./ServerStyleSheets");
var _serverStyleSheetsDefault = parcelHelpers.interopDefault(_serverStyleSheets);

},{"./ServerStyleSheets":"eNdJa","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"eNdJa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ServerStyleSheets
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _classCallCheck = require("@babel/runtime/helpers/esm/classCallCheck");
var _classCallCheckDefault = parcelHelpers.interopDefault(_classCallCheck);
var _createClass = require("@babel/runtime/helpers/esm/createClass");
var _createClassDefault = parcelHelpers.interopDefault(_createClass);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _jss = require("jss");
var _stylesProvider = require("../StylesProvider");
var _stylesProviderDefault = parcelHelpers.interopDefault(_stylesProvider);
var _createGenerateClassName = require("../createGenerateClassName");
var _createGenerateClassNameDefault = parcelHelpers.interopDefault(_createGenerateClassName);
var ServerStyleSheets = /*#__PURE__*/ function() {
    function ServerStyleSheets1() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        };
        _classCallCheckDefault.default(this, ServerStyleSheets1);
        this.options = options;
    }
    _createClassDefault.default(ServerStyleSheets1, [
        {
            key: "collect",
            value: function collect(children) {
                // This is needed in order to deduplicate the injection of CSS in the page.
                var sheetsManager = new Map(); // This is needed in order to inject the critical CSS.
                this.sheetsRegistry = new _jss.SheetsRegistry(); // A new class name generator
                var generateClassName = _createGenerateClassNameDefault.default();
                return(/*#__PURE__*/ _reactDefault.default.createElement(_stylesProviderDefault.default, _extendsDefault.default({
                    sheetsManager: sheetsManager,
                    serverGenerateClassName: generateClassName,
                    sheetsRegistry: this.sheetsRegistry
                }, this.options), children));
            }
        },
        {
            key: "toString",
            value: function toString() {
                return this.sheetsRegistry ? this.sheetsRegistry.toString() : '';
            }
        },
        {
            key: "getStyleElement",
            value: function getStyleElement(props) {
                return(/*#__PURE__*/ _reactDefault.default.createElement('style', _extendsDefault.default({
                    id: 'jss-server-side',
                    key: 'jss-server-side',
                    dangerouslySetInnerHTML: {
                        __html: this.toString()
                    }
                }, props)));
            }
        }
    ]);
    return ServerStyleSheets1;
}();

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/classCallCheck":"6zViz","@babel/runtime/helpers/esm/createClass":"hVEAO","react":"cKM0D","jss":"bJs7q","../StylesProvider":"6XQfg","../createGenerateClassName":"eGtjv","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"6zViz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
exports.default = _classCallCheck;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"75v2p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_styledDefault.default
);
var _styled = require("./styled");
var _styledDefault = parcelHelpers.interopDefault(_styled);

},{"./styled":"a0ylO","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"a0ylO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _utils = require("@material-ui/utils");
var _hoistNonReactStatics = require("hoist-non-react-statics");
var _hoistNonReactStaticsDefault = parcelHelpers.interopDefault(_hoistNonReactStatics);
var _makeStyles = require("../makeStyles");
var _makeStylesDefault = parcelHelpers.interopDefault(_makeStyles);
function omit(input, fields) {
    var output = {
    };
    Object.keys(input).forEach(function(prop) {
        if (fields.indexOf(prop) === -1) output[prop] = input[prop];
    });
    return output;
} // styled-components's API removes the mapping between components and styles.
function styled(Component) {
    var componentCreator = function componentCreator1(style) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        };
        var name = options.name, stylesOptions = _objectWithoutPropertiesDefault.default(options, [
            "name"
        ]);
        if (Component === undefined) throw new Error([
            'You are calling styled(Component)(style) with an undefined component.',
            'You may have forgotten to import it.'
        ].join('\n'));
        var classNamePrefix = name;
        if (!name) {
            // Provide a better DX outside production.
            var displayName = _utils.getDisplayName(Component);
            if (displayName !== undefined) classNamePrefix = displayName;
        }
        var stylesOrCreator = typeof style === 'function' ? function(theme) {
            return {
                root: function root(props) {
                    return style(_extendsDefault.default({
                        theme: theme
                    }, props));
                }
            };
        } : {
            root: style
        };
        var useStyles = _makeStylesDefault.default(stylesOrCreator, _extendsDefault.default({
            Component: Component,
            name: name || Component.displayName,
            classNamePrefix: classNamePrefix
        }, stylesOptions));
        var filterProps;
        var propTypes = {
        };
        if (style.filterProps) {
            filterProps = style.filterProps;
            delete style.filterProps;
        }
        /* eslint-disable react/forbid-foreign-prop-types */ if (style.propTypes) {
            propTypes = style.propTypes;
            delete style.propTypes;
        }
        /* eslint-enable react/forbid-foreign-prop-types */ var StyledComponent = /*#__PURE__*/ _reactDefault.default.forwardRef(function StyledComponent1(props, ref) {
            var children = props.children, classNameProp = props.className, clone = props.clone, ComponentProp = props.component, other = _objectWithoutPropertiesDefault.default(props, [
                "children",
                "className",
                "clone",
                "component"
            ]);
            var classes = useStyles(props);
            var className = _clsxDefault.default(classes.root, classNameProp);
            var spread = other;
            if (filterProps) spread = omit(spread, filterProps);
            if (clone) return(/*#__PURE__*/ _reactDefault.default.cloneElement(children, _extendsDefault.default({
                className: _clsxDefault.default(children.props.className, className)
            }, spread)));
            if (typeof children === 'function') return children(_extendsDefault.default({
                className: className
            }, spread));
            var FinalComponent = ComponentProp || Component;
            return(/*#__PURE__*/ _reactDefault.default.createElement(FinalComponent, _extendsDefault.default({
                ref: ref,
                className: className
            }, spread), children));
        });
        StyledComponent.propTypes = _extendsDefault.default({
            /**
       * A render function or node.
       */ children: _propTypesDefault.default.oneOfType([
                _propTypesDefault.default.node,
                _propTypesDefault.default.func
            ]),
            /**
       * @ignore
       */ className: _propTypesDefault.default.string,
            /**
       * If `true`, the component will recycle it's children HTML element.
       * It's using `React.cloneElement` internally.
       *
       * This prop will be deprecated and removed in v5
       */ clone: _utils.chainPropTypes(_propTypesDefault.default.bool, function(props) {
                if (props.clone && props.component) return new Error('You can not use the clone and component prop at the same time.');
                return null;
            }),
            /**
       * The component used for the root node.
       * Either a string to use a HTML element or a component.
       */ component: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .elementType
        }, propTypes);
        StyledComponent.displayName = "Styled(".concat(classNamePrefix, ")");
        _hoistNonReactStaticsDefault.default(StyledComponent, Component);
        return StyledComponent;
    };
    return componentCreator;
}
exports.default = styled;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","clsx":"cS959","prop-types":"lYCp3","@material-ui/utils":"Uumnw","hoist-non-react-statics":"drAHU","../makeStyles":"8KWuW","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"drAHU":[function(require,module,exports) {
'use strict';
var reactIs = require('react-is');
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */ var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};
var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};
var FORWARD_REF_STATICS = {
    '$$typeof': true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
};
var MEMO_STATICS = {
    '$$typeof': true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
};
var TYPE_STATICS = {
};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
function getStatics(component) {
    // React v16.11 and below
    if (reactIs.isMemo(component)) return MEMO_STATICS;
     // React v16.12 and above
    return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components
        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for(var i = 0; i < keys.length; ++i){
            var key = keys[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {
                }
            }
        }
    }
    return targetComponent;
}
module.exports = hoistNonReactStatics;

},{"react-is":"27q9m"}],"27q9m":[function(require,module,exports) {
'use strict';
module.exports = require('./cjs/react-is.development.js');

},{"./cjs/react-is.development.js":"hzj31"}],"hzj31":[function(require,module,exports) {
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var hasSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 60103;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 60106;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 60107;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 60108;
    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 60114;
    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 60109;
    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 60110; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
    // (unstable) APIs that have been removed. Can we remove the symbols?
    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 60111;
    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 60111;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 60112;
    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 60113;
    var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 60120;
    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 60115;
    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 60116;
    var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 60121;
    var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 60117;
    var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 60118;
    var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 60119;
    function isValidElementType(type) {
        return typeof type === 'string' || typeof type === 'function' || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
    }
    function typeOf(object) {
        if (typeof object === 'object' && object !== null) {
            var $$typeof = object.$$typeof;
            switch($$typeof){
                case REACT_ELEMENT_TYPE:
                    var type = object.type;
                    switch(type){
                        case REACT_ASYNC_MODE_TYPE:
                        case REACT_CONCURRENT_MODE_TYPE:
                        case REACT_FRAGMENT_TYPE:
                        case REACT_PROFILER_TYPE:
                        case REACT_STRICT_MODE_TYPE:
                        case REACT_SUSPENSE_TYPE:
                            return type;
                        default:
                            var $$typeofType = type && type.$$typeof;
                            switch($$typeofType){
                                case REACT_CONTEXT_TYPE:
                                case REACT_FORWARD_REF_TYPE:
                                case REACT_LAZY_TYPE:
                                case REACT_MEMO_TYPE:
                                case REACT_PROVIDER_TYPE:
                                    return $$typeofType;
                                default:
                                    return $$typeof;
                            }
                    }
                case REACT_PORTAL_TYPE:
                    return $$typeof;
            }
        }
        return undefined;
    } // AsyncMode is deprecated along with isAsyncMode
    var AsyncMode = REACT_ASYNC_MODE_TYPE;
    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
    var ContextConsumer = REACT_CONTEXT_TYPE;
    var ContextProvider = REACT_PROVIDER_TYPE;
    var Element1 = REACT_ELEMENT_TYPE;
    var ForwardRef = REACT_FORWARD_REF_TYPE;
    var Fragment = REACT_FRAGMENT_TYPE;
    var Lazy = REACT_LAZY_TYPE;
    var Memo = REACT_MEMO_TYPE;
    var Portal = REACT_PORTAL_TYPE;
    var Profiler = REACT_PROFILER_TYPE;
    var StrictMode = REACT_STRICT_MODE_TYPE;
    var Suspense = REACT_SUSPENSE_TYPE;
    var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated
    function isAsyncMode(object) {
        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint
            console['warn']("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
    }
    function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
    }
    function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
    }
    function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
    }
    function isElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }
    function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
    }
    function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
    }
    function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
    }
    function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
    }
    function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
    }
    function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }
    function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
    }
    exports.AsyncMode = AsyncMode;
    exports.ConcurrentMode = ConcurrentMode;
    exports.ContextConsumer = ContextConsumer;
    exports.ContextProvider = ContextProvider;
    exports.Element = Element1;
    exports.ForwardRef = ForwardRef;
    exports.Fragment = Fragment;
    exports.Lazy = Lazy;
    exports.Memo = Memo;
    exports.Portal = Portal;
    exports.Profiler = Profiler;
    exports.StrictMode = StrictMode;
    exports.Suspense = Suspense;
    exports.isAsyncMode = isAsyncMode;
    exports.isConcurrentMode = isConcurrentMode;
    exports.isContextConsumer = isContextConsumer;
    exports.isContextProvider = isContextProvider;
    exports.isElement = isElement;
    exports.isForwardRef = isForwardRef;
    exports.isFragment = isFragment;
    exports.isLazy = isLazy;
    exports.isMemo = isMemo;
    exports.isPortal = isPortal;
    exports.isProfiler = isProfiler;
    exports.isStrictMode = isStrictMode;
    exports.isSuspense = isSuspense;
    exports.isValidElementType = isValidElementType;
    exports.typeOf = typeOf;
})();

},{}],"gfkCJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_themeProviderDefault.default
);
var _themeProvider = require("./ThemeProvider");
var _themeProviderDefault = parcelHelpers.interopDefault(_themeProvider);

},{"./ThemeProvider":"1iIVI","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"1iIVI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _utils = require("@material-ui/utils");
var _themeContext = require("../useTheme/ThemeContext");
var _themeContextDefault = parcelHelpers.interopDefault(_themeContext);
var _useTheme = require("../useTheme");
var _useThemeDefault = parcelHelpers.interopDefault(_useTheme);
var _nested = require("./nested"); // To support composition of theme.
var _nestedDefault = parcelHelpers.interopDefault(_nested);
function mergeOuterLocalTheme(outerTheme, localTheme) {
    if (typeof localTheme === 'function') {
        var mergedTheme = localTheme(outerTheme);
        if (!mergedTheme) console.error([
            'Material-UI: You should return an object from your theme function, i.e.',
            '<ThemeProvider theme={() => ({})} />'
        ].join('\n'));
        return mergedTheme;
    }
    return _extendsDefault.default({
    }, outerTheme, localTheme);
}
/**
 * This component takes a `theme` prop.
 * It makes the `theme` available down the React tree thanks to React context.
 * This component should preferably be used at **the root of your component tree**.
 */ function ThemeProvider(props) {
    var children = props.children, localTheme = props.theme;
    var outerTheme = _useThemeDefault.default();
    if (outerTheme === null && typeof localTheme === 'function') console.error([
        'Material-UI: You are providing a theme function prop to the ThemeProvider component:',
        '<ThemeProvider theme={outerTheme => outerTheme} />',
        '',
        'However, no outer theme is present.',
        "Make sure a theme is already injected higher in the React tree or provide a theme object."
    ].join('\n'));
    var theme = _reactDefault.default.useMemo(function() {
        var output = outerTheme === null ? localTheme : mergeOuterLocalTheme(outerTheme, localTheme);
        if (output != null) output[_nestedDefault.default] = outerTheme !== null;
        return output;
    }, [
        localTheme,
        outerTheme
    ]);
    return(/*#__PURE__*/ _reactDefault.default.createElement(_themeContextDefault.default.Provider, {
        value: theme
    }, children));
}
ThemeProvider.propTypes = {
    /**
   * Your component tree.
   */ children: _propTypesDefault.default.node.isRequired,
    /**
   * A theme object. You can provide a function to extend the outer theme.
   */ theme: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.object,
        _propTypesDefault.default.func
    ]).isRequired
};
ThemeProvider.propTypes = _utils.exactProp(ThemeProvider.propTypes);
exports.default = ThemeProvider;

},{"@babel/runtime/helpers/esm/extends":"esrVD","react":"cKM0D","prop-types":"lYCp3","@material-ui/utils":"Uumnw","../useTheme/ThemeContext":"atEi3","../useTheme":"1dQw3","./nested":"5t4Fq","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"4C5Hz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_withStylesDefault.default
);
var _withStyles = require("./withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);

},{"./withStyles":"3Xrea","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"3Xrea":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _hoistNonReactStatics = require("hoist-non-react-statics");
var _hoistNonReactStaticsDefault = parcelHelpers.interopDefault(_hoistNonReactStatics);
var _utils = require("@material-ui/utils");
var _makeStyles = require("../makeStyles");
var _makeStylesDefault = parcelHelpers.interopDefault(_makeStyles);
var _getThemeProps = require("../getThemeProps");
var _getThemePropsDefault = parcelHelpers.interopDefault(_getThemeProps);
var _useTheme = require("../useTheme"); // Link a style sheet with a component.
var _useThemeDefault = parcelHelpers.interopDefault(_useTheme);
// It does not modify the component passed to it;
// instead, it returns a new component, with a `classes` property.
var withStyles = function withStyles1(stylesOrCreator) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    };
    return function(Component) {
        var defaultTheme = options.defaultTheme, _options$withTheme = options.withTheme, withTheme = _options$withTheme === void 0 ? false : _options$withTheme, name = options.name, stylesOptions = _objectWithoutPropertiesDefault.default(options, [
            "defaultTheme",
            "withTheme",
            "name"
        ]);
        if (Component === undefined) throw new Error([
            'You are calling withStyles(styles)(Component) with an undefined component.',
            'You may have forgotten to import it.'
        ].join('\n'));
        var classNamePrefix = name;
        if (!name) {
            // Provide a better DX outside production.
            var displayName = _utils.getDisplayName(Component);
            if (displayName !== undefined) classNamePrefix = displayName;
        }
        var useStyles = _makeStylesDefault.default(stylesOrCreator, _extendsDefault.default({
            defaultTheme: defaultTheme,
            Component: Component,
            name: name || Component.displayName,
            classNamePrefix: classNamePrefix
        }, stylesOptions));
        var WithStyles = /*#__PURE__*/ _reactDefault.default.forwardRef(function WithStyles1(props, ref) {
            var classesProp = props.classes, innerRef = props.innerRef, other = _objectWithoutPropertiesDefault.default(props, [
                "classes",
                "innerRef"
            ]); // The wrapper receives only user supplied props, which could be a subset of
            // the actual props Component might receive due to merging with defaultProps.
            // So copying it here would give us the same result in the wrapper as well.
            var classes = useStyles(_extendsDefault.default({
            }, Component.defaultProps, props));
            var theme;
            var more = other;
            if (typeof name === 'string' || withTheme) {
                // name and withTheme are invariant in the outer scope
                // eslint-disable-next-line react-hooks/rules-of-hooks
                theme = _useThemeDefault.default() || defaultTheme;
                if (name) more = _getThemePropsDefault.default({
                    theme: theme,
                    name: name,
                    props: other
                });
                 // Provide the theme to the wrapped component.
                // So we don't have to use the `withTheme()` Higher-order Component.
                if (withTheme && !more.theme) more.theme = theme;
            }
            return(/*#__PURE__*/ _reactDefault.default.createElement(Component, _extendsDefault.default({
                ref: innerRef || ref,
                classes: classes
            }, more)));
        });
        WithStyles.propTypes = {
            /**
       * Override or extend the styles applied to the component.
       */ classes: _propTypesDefault.default.object,
            /**
       * Use that prop to pass a ref to the decorated component.
       * @deprecated
       */ innerRef: _utils.chainPropTypes(_propTypesDefault.default.oneOfType([
                _propTypesDefault.default.func,
                _propTypesDefault.default.object
            ]), function(props) {
                if (props.innerRef == null) return null;
                return null; // return new Error(
            //   'Material-UI: The `innerRef` prop is deprecated and will be removed in v5. ' +
            //     'Refs are now automatically forwarded to the inner component.',
            // );
            })
        };
        WithStyles.displayName = "WithStyles(".concat(_utils.getDisplayName(Component), ")");
        _hoistNonReactStaticsDefault.default(WithStyles, Component);
        // Exposed for test purposes.
        WithStyles.Naked = Component;
        WithStyles.options = options;
        WithStyles.useStyles = useStyles;
        return WithStyles;
    };
};
exports.default = withStyles;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","hoist-non-react-statics":"drAHU","@material-ui/utils":"Uumnw","../makeStyles":"8KWuW","../getThemeProps":"iGlkZ","../useTheme":"1dQw3","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"4Nh79":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_withThemeDefault.default
);
var _withTheme = require("./withTheme");
var _withThemeDefault = parcelHelpers.interopDefault(_withTheme);
parcelHelpers.exportAll(_withTheme, exports);

},{"./withTheme":"8TRzY","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8TRzY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "withThemeCreator", ()=>withThemeCreator
) // Provide the theme object as a prop to the input component.
;
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _hoistNonReactStatics = require("hoist-non-react-statics");
var _hoistNonReactStaticsDefault = parcelHelpers.interopDefault(_hoistNonReactStatics);
var _utils = require("@material-ui/utils");
var _useTheme = require("../useTheme");
var _useThemeDefault = parcelHelpers.interopDefault(_useTheme);
function withThemeCreator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    };
    var defaultTheme = options.defaultTheme;
    var withTheme = function withTheme1(Component) {
        if (Component === undefined) throw new Error([
            'You are calling withTheme(Component) with an undefined component.',
            'You may have forgotten to import it.'
        ].join('\n'));
        var WithTheme = /*#__PURE__*/ _reactDefault.default.forwardRef(function WithTheme1(props, ref) {
            var innerRef = props.innerRef, other = _objectWithoutPropertiesDefault.default(props, [
                "innerRef"
            ]);
            var theme = _useThemeDefault.default() || defaultTheme;
            return(/*#__PURE__*/ _reactDefault.default.createElement(Component, _extendsDefault.default({
                theme: theme,
                ref: innerRef || ref
            }, other)));
        });
        WithTheme.propTypes = {
            /**
       * Use that prop to pass a ref to the decorated component.
       * @deprecated
       */ innerRef: _utils.chainPropTypes(_propTypesDefault.default.oneOfType([
                _propTypesDefault.default.func,
                _propTypesDefault.default.object
            ]), function(props) {
                if (props.innerRef == null) return null;
                return new Error("Material-UI: The `innerRef` prop is deprecated and will be removed in v5. Refs are now automatically forwarded to the inner component.");
            })
        };
        WithTheme.displayName = "WithTheme(".concat(_utils.getDisplayName(Component), ")");
        _hoistNonReactStaticsDefault.default(WithTheme, Component);
        // Exposed for test purposes.
        WithTheme.Naked = Component;
        return WithTheme;
    };
    return withTheme;
}
// It's an alternative API to useTheme().
// We encourage the usage of useTheme() where possible.
var withTheme = withThemeCreator();
exports.default = withTheme;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","hoist-non-react-statics":"drAHU","@material-ui/utils":"Uumnw","../useTheme":"1dQw3","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"l1m84":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createTheme = require("./createTheme");
var _createThemeDefault = parcelHelpers.interopDefault(_createTheme);
var defaultTheme = _createThemeDefault.default();
exports.default = defaultTheme;

},{"./createTheme":"1GLUF","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"1GLUF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createMuiTheme", ()=>createMuiTheme
);
var _defineProperty = require("@babel/runtime/helpers/esm/defineProperty");
var _definePropertyDefault = parcelHelpers.interopDefault(_defineProperty);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _utils = require("@material-ui/utils");
var _createBreakpoints = require("./createBreakpoints");
var _createBreakpointsDefault = parcelHelpers.interopDefault(_createBreakpoints);
var _createMixins = require("./createMixins");
var _createMixinsDefault = parcelHelpers.interopDefault(_createMixins);
var _createPalette = require("./createPalette");
var _createPaletteDefault = parcelHelpers.interopDefault(_createPalette);
var _createTypography = require("./createTypography");
var _createTypographyDefault = parcelHelpers.interopDefault(_createTypography);
var _shadows = require("./shadows");
var _shadowsDefault = parcelHelpers.interopDefault(_shadows);
var _shape = require("./shape");
var _shapeDefault = parcelHelpers.interopDefault(_shape);
var _createSpacing = require("./createSpacing");
var _createSpacingDefault = parcelHelpers.interopDefault(_createSpacing);
var _transitions = require("./transitions");
var _transitionsDefault = parcelHelpers.interopDefault(_transitions);
var _zIndex = require("./zIndex");
var _zIndexDefault = parcelHelpers.interopDefault(_zIndex);
function createTheme() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    };
    var _options$breakpoints = options.breakpoints, breakpointsInput = _options$breakpoints === void 0 ? {
    } : _options$breakpoints, _options$mixins = options.mixins, mixinsInput = _options$mixins === void 0 ? {
    } : _options$mixins, _options$palette = options.palette, paletteInput = _options$palette === void 0 ? {
    } : _options$palette, spacingInput = options.spacing, _options$typography = options.typography, typographyInput = _options$typography === void 0 ? {
    } : _options$typography, other = _objectWithoutPropertiesDefault.default(options, [
        "breakpoints",
        "mixins",
        "palette",
        "spacing",
        "typography"
    ]);
    var palette = _createPaletteDefault.default(paletteInput);
    var breakpoints = _createBreakpointsDefault.default(breakpointsInput);
    var spacing = _createSpacingDefault.default(spacingInput);
    var muiTheme = _utils.deepmerge({
        breakpoints: breakpoints,
        direction: 'ltr',
        mixins: _createMixinsDefault.default(breakpoints, spacing, mixinsInput),
        overrides: {
        },
        // Inject custom styles
        palette: palette,
        props: {
        },
        // Provide default props
        shadows: _shadowsDefault.default,
        typography: _createTypographyDefault.default(palette, typographyInput),
        spacing: spacing,
        shape: _shapeDefault.default,
        transitions: _transitionsDefault.default,
        zIndex: _zIndexDefault.default
    }, other);
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
    muiTheme = args.reduce(function(acc, argument) {
        return _utils.deepmerge(acc, argument);
    }, muiTheme);
    var pseudoClasses = [
        'checked',
        'disabled',
        'error',
        'focused',
        'focusVisible',
        'required',
        'expanded',
        'selected'
    ];
    var traverse = function traverse1(node, parentKey) {
        var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        var key; // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for(key in node){
            var child = node[key];
            if (depth === 1) {
                if (key.indexOf('Mui') === 0 && child) traverse1(child, key, depth + 1);
            } else if (pseudoClasses.indexOf(key) !== -1 && Object.keys(child).length > 0) {
                console.error([
                    "Material-UI: The `".concat(parentKey, "` component increases ") + "the CSS specificity of the `".concat(key, "` internal state."),
                    'You can not override it like this: ',
                    JSON.stringify(node, null, 2),
                    '',
                    'Instead, you need to use the $ruleName syntax:',
                    JSON.stringify({
                        root: _definePropertyDefault.default({
                        }, "&$".concat(key), child)
                    }, null, 2),
                    '',
                    'https://material-ui.com/r/pseudo-classes-guide'
                ].join('\n'));
                node[key] = {
                };
            }
        }
    };
    traverse(muiTheme.overrides);
    return muiTheme;
}
var warnedOnce = false;
function createMuiTheme() {
    if (!warnedOnce) {
        warnedOnce = true;
        console.error([
            'Material-UI: the createMuiTheme function was renamed to createTheme.',
            '',
            "You should use `import { createTheme } from '@material-ui/core/styles'`"
        ].join('\n'));
    }
    return createTheme.apply(void 0, arguments);
}
exports.default = createTheme;

},{"@babel/runtime/helpers/esm/defineProperty":"c51LI","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@material-ui/utils":"Uumnw","./createBreakpoints":"8HFSK","./createMixins":"jiUTY","./createPalette":"3ue9g","./createTypography":"6SmVg","./shadows":"2mYOz","./shape":"9HyRe","./createSpacing":"iTr0U","./transitions":"h7gKO","./zIndex":"9eg4Q","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8HFSK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "keys", ()=>keys
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var keys = [
    'xs',
    'sm',
    'md',
    'lg',
    'xl'
]; // Keep in mind that @media is inclusive by the CSS specification.
function createBreakpoints(breakpoints) {
    var _breakpoints$values = breakpoints.values, values = _breakpoints$values === void 0 ? {
        xs: 0,
        sm: 600,
        md: 960,
        lg: 1280,
        xl: 1920
    } : _breakpoints$values, _breakpoints$unit = breakpoints.unit, unit = _breakpoints$unit === void 0 ? 'px' : _breakpoints$unit, _breakpoints$step = breakpoints.step, step = _breakpoints$step === void 0 ? 5 : _breakpoints$step, other = _objectWithoutPropertiesDefault.default(breakpoints, [
        "values",
        "unit",
        "step"
    ]);
    function up(key) {
        var value = typeof values[key] === 'number' ? values[key] : key;
        return "@media (min-width:".concat(value).concat(unit, ")");
    }
    function down(key) {
        var endIndex = keys.indexOf(key) + 1;
        var upperbound = values[keys[endIndex]];
        if (endIndex === keys.length) // xl down applies to all sizes
        return up('xs');
        var value = typeof upperbound === 'number' && endIndex > 0 ? upperbound : key;
        return "@media (max-width:".concat(value - step / 100).concat(unit, ")");
    }
    function between(start, end) {
        var endIndex = keys.indexOf(end);
        if (endIndex === keys.length - 1) return up(start);
        return "@media (min-width:".concat(typeof values[start] === 'number' ? values[start] : start).concat(unit, ") and ") + "(max-width:".concat((endIndex !== -1 && typeof values[keys[endIndex + 1]] === 'number' ? values[keys[endIndex + 1]] : end) - step / 100).concat(unit, ")");
    }
    function only(key) {
        return between(key, key);
    }
    var warnedOnce = false;
    function width(key) {
        if (!warnedOnce) {
            warnedOnce = true;
            console.warn([
                "Material-UI: The `theme.breakpoints.width` utility is deprecated because it's redundant.",
                'Use the `theme.breakpoints.values` instead.'
            ].join('\n'));
        }
        return values[key];
    }
    return _extendsDefault.default({
        keys: keys,
        values: values,
        up: up,
        down: down,
        between: between,
        only: only,
        width: width
    }, other);
}
exports.default = createBreakpoints;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"jiUTY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defineProperty = require("@babel/runtime/helpers/esm/defineProperty");
var _definePropertyDefault = parcelHelpers.interopDefault(_defineProperty);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
function createMixins(breakpoints, spacing, mixins) {
    var _toolbar;
    return _extendsDefault.default({
        gutters: function gutters() {
            var styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            };
            console.warn([
                'Material-UI: theme.mixins.gutters() is deprecated.',
                'You can use the source of the mixin directly:',
                "\n      paddingLeft: theme.spacing(2),\n      paddingRight: theme.spacing(2),\n      [theme.breakpoints.up('sm')]: {\n        paddingLeft: theme.spacing(3),\n        paddingRight: theme.spacing(3),\n      },\n      "
            ].join('\n'));
            return _extendsDefault.default({
                paddingLeft: spacing(2),
                paddingRight: spacing(2)
            }, styles, _definePropertyDefault.default({
            }, breakpoints.up('sm'), _extendsDefault.default({
                paddingLeft: spacing(3),
                paddingRight: spacing(3)
            }, styles[breakpoints.up('sm')])));
        },
        toolbar: (_toolbar = {
            minHeight: 56
        }, _definePropertyDefault.default(_toolbar, "".concat(breakpoints.up('xs'), " and (orientation: landscape)"), {
            minHeight: 48
        }), _definePropertyDefault.default(_toolbar, breakpoints.up('sm'), {
            minHeight: 64
        }), _toolbar)
    }, mixins);
}
exports.default = createMixins;

},{"@babel/runtime/helpers/esm/defineProperty":"c51LI","@babel/runtime/helpers/esm/extends":"esrVD","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"3ue9g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "light", ()=>light
);
parcelHelpers.export(exports, "dark", ()=>dark
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _utils = require("@material-ui/utils");
var _common = require("../colors/common");
var _commonDefault = parcelHelpers.interopDefault(_common);
var _grey = require("../colors/grey");
var _greyDefault = parcelHelpers.interopDefault(_grey);
var _indigo = require("../colors/indigo");
var _indigoDefault = parcelHelpers.interopDefault(_indigo);
var _pink = require("../colors/pink");
var _pinkDefault = parcelHelpers.interopDefault(_pink);
var _red = require("../colors/red");
var _redDefault = parcelHelpers.interopDefault(_red);
var _orange = require("../colors/orange");
var _orangeDefault = parcelHelpers.interopDefault(_orange);
var _blue = require("../colors/blue");
var _blueDefault = parcelHelpers.interopDefault(_blue);
var _green = require("../colors/green");
var _greenDefault = parcelHelpers.interopDefault(_green);
var _colorManipulator = require("./colorManipulator");
var light = {
    // The colors used to style the text.
    text: {
        // The most important text.
        primary: 'rgba(0, 0, 0, 0.87)',
        // Secondary text.
        secondary: 'rgba(0, 0, 0, 0.54)',
        // Disabled text have even lower visual prominence.
        disabled: 'rgba(0, 0, 0, 0.38)',
        // Text hints.
        hint: 'rgba(0, 0, 0, 0.38)'
    },
    // The color used to divide different elements.
    divider: 'rgba(0, 0, 0, 0.12)',
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
        paper: _commonDefault.default.white,
        default: _greyDefault.default[50]
    },
    // The colors used to style the action elements.
    action: {
        // The color of an active action like an icon button.
        active: 'rgba(0, 0, 0, 0.54)',
        // The color of an hovered action.
        hover: 'rgba(0, 0, 0, 0.04)',
        hoverOpacity: 0.04,
        // The color of a selected action.
        selected: 'rgba(0, 0, 0, 0.08)',
        selectedOpacity: 0.08,
        // The color of a disabled action.
        disabled: 'rgba(0, 0, 0, 0.26)',
        // The background color of a disabled action.
        disabledBackground: 'rgba(0, 0, 0, 0.12)',
        disabledOpacity: 0.38,
        focus: 'rgba(0, 0, 0, 0.12)',
        focusOpacity: 0.12,
        activatedOpacity: 0.12
    }
};
var dark = {
    text: {
        primary: _commonDefault.default.white,
        secondary: 'rgba(255, 255, 255, 0.7)',
        disabled: 'rgba(255, 255, 255, 0.5)',
        hint: 'rgba(255, 255, 255, 0.5)',
        icon: 'rgba(255, 255, 255, 0.5)'
    },
    divider: 'rgba(255, 255, 255, 0.12)',
    background: {
        paper: _greyDefault.default[800],
        default: '#303030'
    },
    action: {
        active: _commonDefault.default.white,
        hover: 'rgba(255, 255, 255, 0.08)',
        hoverOpacity: 0.08,
        selected: 'rgba(255, 255, 255, 0.16)',
        selectedOpacity: 0.16,
        disabled: 'rgba(255, 255, 255, 0.3)',
        disabledBackground: 'rgba(255, 255, 255, 0.12)',
        disabledOpacity: 0.38,
        focus: 'rgba(255, 255, 255, 0.12)',
        focusOpacity: 0.12,
        activatedOpacity: 0.24
    }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
    var tonalOffsetLight = tonalOffset.light || tonalOffset;
    var tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
    if (!intent[direction]) {
        if (intent.hasOwnProperty(shade)) intent[direction] = intent[shade];
        else if (direction === 'light') intent.light = _colorManipulator.lighten(intent.main, tonalOffsetLight);
        else if (direction === 'dark') intent.dark = _colorManipulator.darken(intent.main, tonalOffsetDark);
    }
}
function createPalette(palette) {
    var _palette$primary = palette.primary, primary = _palette$primary === void 0 ? {
        light: _indigoDefault.default[300],
        main: _indigoDefault.default[500],
        dark: _indigoDefault.default[700]
    } : _palette$primary, _palette$secondary = palette.secondary, secondary = _palette$secondary === void 0 ? {
        light: _pinkDefault.default.A200,
        main: _pinkDefault.default.A400,
        dark: _pinkDefault.default.A700
    } : _palette$secondary, _palette$error = palette.error, error = _palette$error === void 0 ? {
        light: _redDefault.default[300],
        main: _redDefault.default[500],
        dark: _redDefault.default[700]
    } : _palette$error, _palette$warning = palette.warning, warning = _palette$warning === void 0 ? {
        light: _orangeDefault.default[300],
        main: _orangeDefault.default[500],
        dark: _orangeDefault.default[700]
    } : _palette$warning, _palette$info = palette.info, info = _palette$info === void 0 ? {
        light: _blueDefault.default[300],
        main: _blueDefault.default[500],
        dark: _blueDefault.default[700]
    } : _palette$info, _palette$success = palette.success, success = _palette$success === void 0 ? {
        light: _greenDefault.default[300],
        main: _greenDefault.default[500],
        dark: _greenDefault.default[700]
    } : _palette$success, _palette$type = palette.type, type = _palette$type === void 0 ? 'light' : _palette$type, _palette$contrastThre = palette.contrastThreshold, contrastThreshold = _palette$contrastThre === void 0 ? 3 : _palette$contrastThre, _palette$tonalOffset = palette.tonalOffset, tonalOffset = _palette$tonalOffset === void 0 ? 0.2 : _palette$tonalOffset, other = _objectWithoutPropertiesDefault.default(palette, [
        "primary",
        "secondary",
        "error",
        "warning",
        "info",
        "success",
        "type",
        "contrastThreshold",
        "tonalOffset"
    ]); // Use the same logic as
    // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59
    // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54
    function getContrastText(background) {
        var contrastText = _colorManipulator.getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
        var contrast = _colorManipulator.getContrastRatio(background, contrastText);
        if (contrast < 3) console.error([
            "Material-UI: The contrast ratio of ".concat(contrast, ":1 for ").concat(contrastText, " on ").concat(background),
            'falls below the WCAG recommended absolute minimum contrast ratio of 3:1.',
            'https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast'
        ].join('\n'));
        return contrastText;
    }
    var augmentColor = function augmentColor1(color) {
        var mainShade = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
        var lightShade = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;
        var darkShade = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 700;
        color = _extendsDefault.default({
        }, color);
        if (!color.main && color[mainShade]) color.main = color[mainShade];
        if (!color.main) throw new Error("Material-UI: The color provided to augmentColor(color) is invalid.\nThe color object needs to have a `main` property or a `".concat(mainShade, "` property."));
        if (typeof color.main !== 'string') throw new Error("Material-UI: The color provided to augmentColor(color) is invalid.\n`color.main` should be a string, but `".concat(JSON.stringify(color.main), "` was provided instead.\n\nDid you intend to use one of the following approaches?\n\nimport {\xA0green } from \"@material-ui/core/colors\";\n\nconst theme1 = createTheme({ palette: {\n  primary: green,\n} });\n\nconst theme2 = createTheme({ palette: {\n  primary: { main: green[500] },\n} });"));
        addLightOrDark(color, 'light', lightShade, tonalOffset);
        addLightOrDark(color, 'dark', darkShade, tonalOffset);
        if (!color.contrastText) color.contrastText = getContrastText(color.main);
        return color;
    };
    var types = {
        dark: dark,
        light: light
    };
    if (!types[type]) console.error("Material-UI: The palette type `".concat(type, "` is not supported."));
    var paletteOutput = _utils.deepmerge(_extendsDefault.default({
        // A collection of common colors.
        common: _commonDefault.default,
        // The palette type, can be light or dark.
        type: type,
        // The colors used to represent primary interface elements for a user.
        primary: augmentColor(primary),
        // The colors used to represent secondary interface elements for a user.
        secondary: augmentColor(secondary, 'A400', 'A200', 'A700'),
        // The colors used to represent interface elements that the user should be made aware of.
        error: augmentColor(error),
        // The colors used to represent potentially dangerous actions or important messages.
        warning: augmentColor(warning),
        // The colors used to present information to the user that is neutral and not necessarily important.
        info: augmentColor(info),
        // The colors used to indicate the successful completion of an action that user triggered.
        success: augmentColor(success),
        // The grey colors.
        grey: _greyDefault.default,
        // Used by `getContrastText()` to maximize the contrast between
        // the background and the text.
        contrastThreshold: contrastThreshold,
        // Takes a background color and returns the text color that maximizes the contrast.
        getContrastText: getContrastText,
        // Generate a rich color object.
        augmentColor: augmentColor,
        // Used by the functions below to shift a color's luminance by approximately
        // two indexes within its tonal palette.
        // E.g., shift from Red 500 to Red 300 or Red 700.
        tonalOffset: tonalOffset
    }, types[type]), other);
    return paletteOutput;
}
exports.default = createPalette;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@material-ui/utils":"Uumnw","../colors/common":"3dBGM","../colors/grey":"1ru9Q","../colors/indigo":"cKF1p","../colors/pink":"lvK8G","../colors/red":"jDOse","../colors/orange":"cRpu7","../colors/blue":"GXOXp","../colors/green":"iD3aB","./colorManipulator":"4vQbC","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"3dBGM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var common = {
    black: '#000',
    white: '#fff'
};
exports.default = common;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"1ru9Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var grey = {
    50: '#fafafa',
    100: '#f5f5f5',
    200: '#eeeeee',
    300: '#e0e0e0',
    400: '#bdbdbd',
    500: '#9e9e9e',
    600: '#757575',
    700: '#616161',
    800: '#424242',
    900: '#212121',
    A100: '#d5d5d5',
    A200: '#aaaaaa',
    A400: '#303030',
    A700: '#616161'
};
exports.default = grey;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"cKF1p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var indigo = {
    50: '#e8eaf6',
    100: '#c5cae9',
    200: '#9fa8da',
    300: '#7986cb',
    400: '#5c6bc0',
    500: '#3f51b5',
    600: '#3949ab',
    700: '#303f9f',
    800: '#283593',
    900: '#1a237e',
    A100: '#8c9eff',
    A200: '#536dfe',
    A400: '#3d5afe',
    A700: '#304ffe'
};
exports.default = indigo;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"lvK8G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var pink = {
    50: '#fce4ec',
    100: '#f8bbd0',
    200: '#f48fb1',
    300: '#f06292',
    400: '#ec407a',
    500: '#e91e63',
    600: '#d81b60',
    700: '#c2185b',
    800: '#ad1457',
    900: '#880e4f',
    A100: '#ff80ab',
    A200: '#ff4081',
    A400: '#f50057',
    A700: '#c51162'
};
exports.default = pink;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"jDOse":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var red = {
    50: '#ffebee',
    100: '#ffcdd2',
    200: '#ef9a9a',
    300: '#e57373',
    400: '#ef5350',
    500: '#f44336',
    600: '#e53935',
    700: '#d32f2f',
    800: '#c62828',
    900: '#b71c1c',
    A100: '#ff8a80',
    A200: '#ff5252',
    A400: '#ff1744',
    A700: '#d50000'
};
exports.default = red;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"cRpu7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var orange = {
    50: '#fff3e0',
    100: '#ffe0b2',
    200: '#ffcc80',
    300: '#ffb74d',
    400: '#ffa726',
    500: '#ff9800',
    600: '#fb8c00',
    700: '#f57c00',
    800: '#ef6c00',
    900: '#e65100',
    A100: '#ffd180',
    A200: '#ffab40',
    A400: '#ff9100',
    A700: '#ff6d00'
};
exports.default = orange;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"GXOXp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var blue = {
    50: '#e3f2fd',
    100: '#bbdefb',
    200: '#90caf9',
    300: '#64b5f6',
    400: '#42a5f5',
    500: '#2196f3',
    600: '#1e88e5',
    700: '#1976d2',
    800: '#1565c0',
    900: '#0d47a1',
    A100: '#82b1ff',
    A200: '#448aff',
    A400: '#2979ff',
    A700: '#2962ff'
};
exports.default = blue;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"iD3aB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var green = {
    50: '#e8f5e9',
    100: '#c8e6c9',
    200: '#a5d6a7',
    300: '#81c784',
    400: '#66bb6a',
    500: '#4caf50',
    600: '#43a047',
    700: '#388e3c',
    800: '#2e7d32',
    900: '#1b5e20',
    A100: '#b9f6ca',
    A200: '#69f0ae',
    A400: '#00e676',
    A700: '#00c853'
};
exports.default = green;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"4vQbC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts a color from CSS hex format to CSS rgb format.
 *
 * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
 * @returns {string} A CSS rgb color string
 */ parcelHelpers.export(exports, "hexToRgb", ()=>hexToRgb
);
/**
 * Converts a color from CSS rgb format to CSS hex format.
 *
 * @param {string} color - RGB color, i.e. rgb(n, n, n)
 * @returns {string} A CSS rgb color string, i.e. #nnnnnn
 */ parcelHelpers.export(exports, "rgbToHex", ()=>rgbToHex
);
/**
 * Converts a color from hsl format to rgb format.
 *
 * @param {string} color - HSL color values
 * @returns {string} rgb color values
 */ parcelHelpers.export(exports, "hslToRgb", ()=>hslToRgb
);
/**
 * Returns an object with the type and values of a color.
 *
 * Note: Does not support rgb % values.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {object} - A MUI color object: {type: string, values: number[]}
 */ parcelHelpers.export(exports, "decomposeColor", ()=>decomposeColor
);
/**
 * Converts a color object with type and values to a string.
 *
 * @param {object} color - Decomposed color
 * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla'
 * @param {array} color.values - [n,n,n] or [n,n,n,n]
 * @returns {string} A CSS color string
 */ parcelHelpers.export(exports, "recomposeColor", ()=>recomposeColor
);
/**
 * Calculates the contrast ratio between two colors.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 *
 * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {number} A contrast ratio value in the range 0 - 21.
 */ parcelHelpers.export(exports, "getContrastRatio", ()=>getContrastRatio
);
/**
 * The relative brightness of any point in a color space,
 * normalized to 0 for darkest black and 1 for lightest white.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {number} The relative brightness of the color in the range 0 - 1
 */ parcelHelpers.export(exports, "getLuminance", ()=>getLuminance
);
/**
 * Darken or lighten a color, depending on its luminance.
 * Light colors are darkened, dark colors are lightened.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {number} coefficient=0.15 - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */ parcelHelpers.export(exports, "emphasize", ()=>emphasize
);
/**
 * Set the absolute transparency of a color.
 * Any existing alpha values are overwritten.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {number} value - value to set the alpha channel to in the range 0 -1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 *
 * @deprecated
 * Use `import { alpha } from '@material-ui/core/styles'` instead.
 */ parcelHelpers.export(exports, "fade", ()=>fade
);
/**
 * Set the absolute transparency of a color.
 * Any existing alpha value is overwritten.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {number} value - value to set the alpha channel to in the range 0-1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */ parcelHelpers.export(exports, "alpha", ()=>alpha
);
/**
 * Darkens a color.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */ parcelHelpers.export(exports, "darken", ()=>darken
);
/**
 * Lightens a color.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */ parcelHelpers.export(exports, "lighten", ()=>lighten
);
var _utils = require("@material-ui/utils");
/* eslint-disable no-use-before-define */ /**
 * Returns a number whose value is limited to the given range.
 *
 * @param {number} value The value to be clamped
 * @param {number} min The lower boundary of the output range
 * @param {number} max The upper boundary of the output range
 * @returns {number} A number in the range [min, max]
 */ function clamp(value) {
    var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    if (value < min || value > max) console.error("Material-UI: The value provided ".concat(value, " is out of range [").concat(min, ", ").concat(max, "]."));
    return Math.min(Math.max(min, value), max);
}
function hexToRgb(color) {
    color = color.substr(1);
    var re = new RegExp(".{1,".concat(color.length >= 6 ? 2 : 1, "}"), 'g');
    var colors = color.match(re);
    if (colors && colors[0].length === 1) colors = colors.map(function(n) {
        return n + n;
    });
    return colors ? "rgb".concat(colors.length === 4 ? 'a' : '', "(").concat(colors.map(function(n, index) {
        return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;
    }).join(', '), ")") : '';
}
function intToHex(int) {
    var hex = int.toString(16);
    return hex.length === 1 ? "0".concat(hex) : hex;
}
function rgbToHex(color) {
    // Idempotent
    if (color.indexOf('#') === 0) return color;
    var _decomposeColor = decomposeColor(color), values = _decomposeColor.values;
    return "#".concat(values.map(function(n) {
        return intToHex(n);
    }).join(''));
}
function hslToRgb(color) {
    color = decomposeColor(color);
    var _color = color, values = _color.values;
    var h = values[0];
    var s = values[1] / 100;
    var l = values[2] / 100;
    var a = s * Math.min(l, 1 - l);
    var f = function f1(n) {
        var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + h / 30) % 12;
        return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    };
    var type = 'rgb';
    var rgb = [
        Math.round(f(0) * 255),
        Math.round(f(8) * 255),
        Math.round(f(4) * 255)
    ];
    if (color.type === 'hsla') {
        type += 'a';
        rgb.push(values[3]);
    }
    return recomposeColor({
        type: type,
        values: rgb
    });
}
function decomposeColor(color) {
    // Idempotent
    if (color.type) return color;
    if (color.charAt(0) === '#') return decomposeColor(hexToRgb(color));
    var marker = color.indexOf('(');
    var type = color.substring(0, marker);
    if ([
        'rgb',
        'rgba',
        'hsl',
        'hsla'
    ].indexOf(type) === -1) throw new Error("Material-UI: Unsupported `".concat(color, "` color.\nWe support the following formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()."));
    var values = color.substring(marker + 1, color.length - 1).split(',');
    values = values.map(function(value) {
        return parseFloat(value);
    });
    return {
        type: type,
        values: values
    };
}
function recomposeColor(color) {
    var type = color.type;
    var values = color.values;
    if (type.indexOf('rgb') !== -1) // Only convert the first 3 values to int (i.e. not alpha)
    values = values.map(function(n, i) {
        return i < 3 ? parseInt(n, 10) : n;
    });
    else if (type.indexOf('hsl') !== -1) {
        values[1] = "".concat(values[1], "%");
        values[2] = "".concat(values[2], "%");
    }
    return "".concat(type, "(").concat(values.join(', '), ")");
}
function getContrastRatio(foreground, background) {
    var lumA = getLuminance(foreground);
    var lumB = getLuminance(background);
    return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function getLuminance(color) {
    color = decomposeColor(color);
    var rgb = color.type === 'hsl' ? decomposeColor(hslToRgb(color)).values : color.values;
    rgb = rgb.map(function(val) {
        val /= 255; // normalized
        return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
    }); // Truncate at 3 digits
    return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function emphasize(color) {
    var coefficient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.15;
    return getLuminance(color) > 0.5 ? darken(color, coefficient) : lighten(color, coefficient);
}
var warnedOnce = false;
function fade(color, value) {
    if (!warnedOnce) {
        warnedOnce = true;
        console.error([
            'Material-UI: The `fade` color utility was renamed to `alpha` to better describe its functionality.',
            '',
            "You should use `import { alpha } from '@material-ui/core/styles'`"
        ].join('\n'));
    }
    return alpha(color, value);
}
function alpha(color, value) {
    color = decomposeColor(color);
    value = clamp(value);
    if (color.type === 'rgb' || color.type === 'hsl') color.type += 'a';
    color.values[3] = value;
    return recomposeColor(color);
}
function darken(color, coefficient) {
    color = decomposeColor(color);
    coefficient = clamp(coefficient);
    if (color.type.indexOf('hsl') !== -1) color.values[2] *= 1 - coefficient;
    else if (color.type.indexOf('rgb') !== -1) for(var i = 0; i < 3; i += 1)color.values[i] *= 1 - coefficient;
    return recomposeColor(color);
}
function lighten(color, coefficient) {
    color = decomposeColor(color);
    coefficient = clamp(coefficient);
    if (color.type.indexOf('hsl') !== -1) color.values[2] += (100 - color.values[2]) * coefficient;
    else if (color.type.indexOf('rgb') !== -1) for(var i = 0; i < 3; i += 1)color.values[i] += (255 - color.values[i]) * coefficient;
    return recomposeColor(color);
}

},{"@material-ui/utils":"Uumnw","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"6SmVg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _utils = require("@material-ui/utils");
function round(value) {
    return Math.round(value * 100000) / 100000;
}
var warnedOnce = false;
function roundWithDeprecationWarning(value) {
    if (!warnedOnce) {
        console.warn([
            'Material-UI: The `theme.typography.round` helper is deprecated.',
            'Head to https://material-ui.com/r/migration-v4/#theme for a migration path.'
        ].join('\n'));
        warnedOnce = true;
    }
    return round(value);
}
var caseAllCaps = {
    textTransform: 'uppercase'
};
var defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
    var _ref = typeof typography === 'function' ? typography(palette) : typography, _ref$fontFamily = _ref.fontFamily, fontFamily = _ref$fontFamily === void 0 ? defaultFontFamily : _ref$fontFamily, _ref$fontSize = _ref.fontSize, fontSize = _ref$fontSize === void 0 ? 14 : _ref$fontSize, _ref$fontWeightLight = _ref.fontWeightLight, fontWeightLight = _ref$fontWeightLight === void 0 ? 300 : _ref$fontWeightLight, _ref$fontWeightRegula = _ref.fontWeightRegular, fontWeightRegular = _ref$fontWeightRegula === void 0 ? 400 : _ref$fontWeightRegula, _ref$fontWeightMedium = _ref.fontWeightMedium, fontWeightMedium = _ref$fontWeightMedium === void 0 ? 500 : _ref$fontWeightMedium, _ref$fontWeightBold = _ref.fontWeightBold, fontWeightBold = _ref$fontWeightBold === void 0 ? 700 : _ref$fontWeightBold, _ref$htmlFontSize = _ref.htmlFontSize, htmlFontSize = _ref$htmlFontSize === void 0 ? 16 : _ref$htmlFontSize, allVariants = _ref.allVariants, pxToRem2 = _ref.pxToRem, other = _objectWithoutPropertiesDefault.default(_ref, [
        "fontFamily",
        "fontSize",
        "fontWeightLight",
        "fontWeightRegular",
        "fontWeightMedium",
        "fontWeightBold",
        "htmlFontSize",
        "allVariants",
        "pxToRem"
    ]);
    if (typeof fontSize !== 'number') console.error('Material-UI: `fontSize` is required to be a number.');
    if (typeof htmlFontSize !== 'number') console.error('Material-UI: `htmlFontSize` is required to be a number.');
    var coef = fontSize / 14;
    var pxToRem = pxToRem2 || function(size) {
        return "".concat(size / htmlFontSize * coef, "rem");
    };
    var buildVariant = function buildVariant1(fontWeight, size, lineHeight, letterSpacing, casing) {
        return _extendsDefault.default({
            fontFamily: fontFamily,
            fontWeight: fontWeight,
            fontSize: pxToRem(size),
            // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
            lineHeight: lineHeight
        }, fontFamily === defaultFontFamily ? {
            letterSpacing: "".concat(round(letterSpacing / size), "em")
        } : {
        }, casing, allVariants);
    };
    var variants = {
        h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
        h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
        h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
        h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
        h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
        h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
        subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
        subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
        body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
        body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
        button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
        caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
        overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
    };
    return _utils.deepmerge(_extendsDefault.default({
        htmlFontSize: htmlFontSize,
        pxToRem: pxToRem,
        round: roundWithDeprecationWarning,
        // TODO v5: remove
        fontFamily: fontFamily,
        fontSize: fontSize,
        fontWeightLight: fontWeightLight,
        fontWeightRegular: fontWeightRegular,
        fontWeightMedium: fontWeightMedium,
        fontWeightBold: fontWeightBold
    }, variants), other, {
        clone: false // No need to clone deep
    });
}
exports.default = createTypography;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@material-ui/utils":"Uumnw","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"2mYOz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var shadowKeyUmbraOpacity = 0.2;
var shadowKeyPenumbraOpacity = 0.14;
var shadowAmbientShadowOpacity = 0.12;
function createShadow() {
    return [
        "".concat(arguments.length <= 0 ? undefined : arguments[0], "px ").concat(arguments.length <= 1 ? undefined : arguments[1], "px ").concat(arguments.length <= 2 ? undefined : arguments[2], "px ").concat(arguments.length <= 3 ? undefined : arguments[3], "px rgba(0,0,0,").concat(shadowKeyUmbraOpacity, ")"),
        "".concat(arguments.length <= 4 ? undefined : arguments[4], "px ").concat(arguments.length <= 5 ? undefined : arguments[5], "px ").concat(arguments.length <= 6 ? undefined : arguments[6], "px ").concat(arguments.length <= 7 ? undefined : arguments[7], "px rgba(0,0,0,").concat(shadowKeyPenumbraOpacity, ")"),
        "".concat(arguments.length <= 8 ? undefined : arguments[8], "px ").concat(arguments.length <= 9 ? undefined : arguments[9], "px ").concat(arguments.length <= 10 ? undefined : arguments[10], "px ").concat(arguments.length <= 11 ? undefined : arguments[11], "px rgba(0,0,0,").concat(shadowAmbientShadowOpacity, ")")
    ].join(',');
} // Values from https://github.com/material-components/material-components-web/blob/be8747f94574669cb5e7add1a7c54fa41a89cec7/packages/mdc-elevation/_variables.scss
var shadows = [
    'none',
    createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
    createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
    createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
    createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
    createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
    createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
    createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
    createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
    createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
    createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
    createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
    createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
    createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
    createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
    createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
    createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
    createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
    createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
    createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
    createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
    createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
    createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
    createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
    createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)
];
exports.default = shadows;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"9HyRe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var shape = {
    borderRadius: 4
};
exports.default = shape;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"iTr0U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _system = require("@material-ui/system");
var warnOnce;
function createSpacing() {
    var spacingInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
    // Already transformed.
    if (spacingInput.mui) return spacingInput;
     // Material Design layouts are visually balanced. Most measurements align to an 8dp grid applied, which aligns both spacing and the overall layout.
    // Smaller components, such as icons and type, can align to a 4dp grid.
    // https://material.io/design/layout/understanding-layout.html#usage
    var transform = _system.createUnarySpacing({
        spacing: spacingInput
    });
    var spacing = function spacing1() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        if (!(args.length <= 4)) console.error("Material-UI: Too many arguments provided, expected between 0 and 4, got ".concat(args.length));
        if (args.length === 0) return transform(1);
        if (args.length === 1) return transform(args[0]);
        return args.map(function(argument) {
            if (typeof argument === 'string') return argument;
            var output = transform(argument);
            return typeof output === 'number' ? "".concat(output, "px") : output;
        }).join(' ');
    }; // Backward compatibility, to remove in v5.
    Object.defineProperty(spacing, 'unit', {
        get: function get() {
            if (!warnOnce || false) console.error([
                'Material-UI: theme.spacing.unit usage has been deprecated.',
                'It will be removed in v5.',
                'You can replace `theme.spacing.unit * y` with `theme.spacing(y)`.',
                '',
                'You can use the `https://github.com/mui-org/material-ui/tree/master/packages/material-ui-codemod/README.md#theme-spacing-api` migration helper to make the process smoother.'
            ].join('\n'));
            warnOnce = true;
            return spacingInput;
        }
    });
    spacing.mui = true;
    return spacing;
}
exports.default = createSpacing;

},{"@material-ui/system":"6LykZ","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"6LykZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @license Material-UI v4.12.1
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ parcelHelpers.export(exports, "borders", ()=>_bordersDefault.default
);
parcelHelpers.export(exports, "breakpoints", ()=>_breakpointsDefault.default
);
parcelHelpers.export(exports, "compose", ()=>_composeDefault.default
);
parcelHelpers.export(exports, "styleFunctionSx", ()=>_styleFunctionSxDefault.default
);
parcelHelpers.export(exports, "display", ()=>_displayDefault.default
);
parcelHelpers.export(exports, "flexbox", ()=>_flexboxDefault.default
);
parcelHelpers.export(exports, "grid", ()=>_gridDefault.default
);
parcelHelpers.export(exports, "palette", ()=>_paletteDefault.default
);
parcelHelpers.export(exports, "positions", ()=>_positionsDefault.default
);
parcelHelpers.export(exports, "shadows", ()=>_shadowsDefault.default
);
parcelHelpers.export(exports, "sizing", ()=>_sizingDefault.default
);
parcelHelpers.export(exports, "spacing", ()=>_spacingDefault.default
);
parcelHelpers.export(exports, "style", ()=>_styleDefault.default
);
parcelHelpers.export(exports, "typography", ()=>_typographyDefault.default
);
var _borders = require("./borders");
var _bordersDefault = parcelHelpers.interopDefault(_borders);
parcelHelpers.exportAll(_borders, exports);
var _breakpoints = require("./breakpoints");
var _breakpointsDefault = parcelHelpers.interopDefault(_breakpoints);
var _compose = require("./compose");
var _composeDefault = parcelHelpers.interopDefault(_compose);
var _styleFunctionSx = require("./styleFunctionSx");
var _styleFunctionSxDefault = parcelHelpers.interopDefault(_styleFunctionSx);
parcelHelpers.exportAll(_styleFunctionSx, exports);
var _display = require("./display");
var _displayDefault = parcelHelpers.interopDefault(_display);
var _flexbox = require("./flexbox");
var _flexboxDefault = parcelHelpers.interopDefault(_flexbox);
parcelHelpers.exportAll(_flexbox, exports);
var _grid = require("./grid");
var _gridDefault = parcelHelpers.interopDefault(_grid);
parcelHelpers.exportAll(_grid, exports);
var _palette = require("./palette");
var _paletteDefault = parcelHelpers.interopDefault(_palette);
parcelHelpers.exportAll(_palette, exports);
var _positions = require("./positions");
var _positionsDefault = parcelHelpers.interopDefault(_positions);
parcelHelpers.exportAll(_positions, exports);
var _shadows = require("./shadows");
var _shadowsDefault = parcelHelpers.interopDefault(_shadows);
var _sizing = require("./sizing");
var _sizingDefault = parcelHelpers.interopDefault(_sizing);
parcelHelpers.exportAll(_sizing, exports);
var _spacing = require("./spacing");
var _spacingDefault = parcelHelpers.interopDefault(_spacing);
parcelHelpers.exportAll(_spacing, exports);
var _style = require("./style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _typography = require("./typography");
var _typographyDefault = parcelHelpers.interopDefault(_typography);
parcelHelpers.exportAll(_typography, exports);

},{"./borders":"lKkxL","./breakpoints":"h7T02","./compose":"cq2yA","./styleFunctionSx":"8bF0x","./display":"bYIgu","./flexbox":"8H628","./grid":"gShvl","./palette":"6uAvj","./positions":"cpdXe","./shadows":"1FZQl","./sizing":"d8dU7","./spacing":"d9WDc","./style":"docOS","./typography":"ibEMD","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"lKkxL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "border", ()=>border
);
parcelHelpers.export(exports, "borderTop", ()=>borderTop
);
parcelHelpers.export(exports, "borderRight", ()=>borderRight
);
parcelHelpers.export(exports, "borderBottom", ()=>borderBottom
);
parcelHelpers.export(exports, "borderLeft", ()=>borderLeft
);
parcelHelpers.export(exports, "borderColor", ()=>borderColor
);
parcelHelpers.export(exports, "borderRadius", ()=>borderRadius
);
var _style = require("./style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _compose = require("./compose");
var _composeDefault = parcelHelpers.interopDefault(_compose);
function getBorder(value) {
    if (typeof value !== 'number') return value;
    return "".concat(value, "px solid");
}
var border = _styleDefault.default({
    prop: 'border',
    themeKey: 'borders',
    transform: getBorder
});
var borderTop = _styleDefault.default({
    prop: 'borderTop',
    themeKey: 'borders',
    transform: getBorder
});
var borderRight = _styleDefault.default({
    prop: 'borderRight',
    themeKey: 'borders',
    transform: getBorder
});
var borderBottom = _styleDefault.default({
    prop: 'borderBottom',
    themeKey: 'borders',
    transform: getBorder
});
var borderLeft = _styleDefault.default({
    prop: 'borderLeft',
    themeKey: 'borders',
    transform: getBorder
});
var borderColor = _styleDefault.default({
    prop: 'borderColor',
    themeKey: 'palette'
});
var borderRadius = _styleDefault.default({
    prop: 'borderRadius',
    themeKey: 'shape'
});
var borders = _composeDefault.default(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderRadius);
exports.default = borders;

},{"./style":"docOS","./compose":"cq2yA","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"docOS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defineProperty = require("@babel/runtime/helpers/esm/defineProperty");
var _definePropertyDefault = parcelHelpers.interopDefault(_defineProperty);
var _responsivePropType = require("./responsivePropType");
var _responsivePropTypeDefault = parcelHelpers.interopDefault(_responsivePropType);
var _breakpoints = require("./breakpoints");
function getPath(obj, path) {
    if (!path || typeof path !== 'string') return null;
    return path.split('.').reduce(function(acc, item) {
        return acc && acc[item] ? acc[item] : null;
    }, obj);
}
function style(options) {
    var prop = options.prop, _options$cssProperty = options.cssProperty, cssProperty = _options$cssProperty === void 0 ? options.prop : _options$cssProperty, themeKey = options.themeKey, transform = options.transform;
    var fn = function fn1(props) {
        if (props[prop] == null) return null;
        var propValue = props[prop];
        var theme = props.theme;
        var themeMapping = getPath(theme, themeKey) || {
        };
        var styleFromPropValue = function styleFromPropValue1(propValueFinal) {
            var value;
            if (typeof themeMapping === 'function') value = themeMapping(propValueFinal);
            else if (Array.isArray(themeMapping)) value = themeMapping[propValueFinal] || propValueFinal;
            else {
                value = getPath(themeMapping, propValueFinal) || propValueFinal;
                if (transform) value = transform(value);
            }
            if (cssProperty === false) return value;
            return _definePropertyDefault.default({
            }, cssProperty, value);
        };
        return _breakpoints.handleBreakpoints(props, propValue, styleFromPropValue);
    };
    fn.propTypes = _definePropertyDefault.default({
    }, prop, _responsivePropTypeDefault.default);
    fn.filterProps = [
        prop
    ];
    return fn;
}
exports.default = style;

},{"@babel/runtime/helpers/esm/defineProperty":"c51LI","./responsivePropType":"8k9G8","./breakpoints":"h7T02","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8k9G8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var responsivePropType = _propTypesDefault.default.oneOfType([
    _propTypesDefault.default.number,
    _propTypesDefault.default.string,
    _propTypesDefault.default.object,
    _propTypesDefault.default.array
]);
exports.default = responsivePropType;

},{"prop-types":"lYCp3","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"h7T02":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "handleBreakpoints", ()=>handleBreakpoints
);
var _toConsumableArray = require("@babel/runtime/helpers/esm/toConsumableArray");
var _toConsumableArrayDefault = parcelHelpers.interopDefault(_toConsumableArray);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _typeof = require("@babel/runtime/helpers/esm/typeof");
var _typeofDefault = parcelHelpers.interopDefault(_typeof);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _merge = require("./merge"); // The breakpoint **start** at this value.
var _mergeDefault = parcelHelpers.interopDefault(_merge);
// For instance with the first breakpoint xs: [xs, sm[.
var values = {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920
};
var defaultBreakpoints = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: [
        'xs',
        'sm',
        'md',
        'lg',
        'xl'
    ],
    up: function up(key) {
        return "@media (min-width:".concat(values[key], "px)");
    }
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
    if (!props.theme) console.error('Material-UI: You are calling a style function without a theme value.');
    if (Array.isArray(propValue)) {
        var themeBreakpoints = props.theme.breakpoints || defaultBreakpoints;
        return propValue.reduce(function(acc, item, index) {
            acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
            return acc;
        }, {
        });
    }
    if (_typeofDefault.default(propValue) === 'object') {
        var _themeBreakpoints = props.theme.breakpoints || defaultBreakpoints;
        return Object.keys(propValue).reduce(function(acc, breakpoint) {
            acc[_themeBreakpoints.up(breakpoint)] = styleFromPropValue(propValue[breakpoint]);
            return acc;
        }, {
        });
    }
    var output = styleFromPropValue(propValue);
    return output;
}
function breakpoints(styleFunction) {
    var newStyleFunction = function newStyleFunction1(props) {
        var base = styleFunction(props);
        var themeBreakpoints = props.theme.breakpoints || defaultBreakpoints;
        var extended = themeBreakpoints.keys.reduce(function(acc, key) {
            if (props[key]) {
                acc = acc || {
                };
                acc[themeBreakpoints.up(key)] = styleFunction(_extendsDefault.default({
                    theme: props.theme
                }, props[key]));
            }
            return acc;
        }, null);
        return _mergeDefault.default(base, extended);
    };
    newStyleFunction.propTypes = _extendsDefault.default({
    }, styleFunction.propTypes, {
        xs: _propTypesDefault.default.object,
        sm: _propTypesDefault.default.object,
        md: _propTypesDefault.default.object,
        lg: _propTypesDefault.default.object,
        xl: _propTypesDefault.default.object
    });
    newStyleFunction.filterProps = [
        'xs',
        'sm',
        'md',
        'lg',
        'xl'
    ].concat(_toConsumableArrayDefault.default(styleFunction.filterProps));
    return newStyleFunction;
}
exports.default = breakpoints;

},{"@babel/runtime/helpers/esm/toConsumableArray":"fbqwi","@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/typeof":"sHS2O","prop-types":"lYCp3","./merge":"ij8Hy","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"ij8Hy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("@material-ui/utils");
function merge(acc, item) {
    if (!item) return acc;
    return _utils.deepmerge(acc, item, {
        clone: false // No need to clone deep, it's way faster.
    });
}
exports.default = merge;

},{"@material-ui/utils":"Uumnw","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"cq2yA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _merge = require("./merge");
var _mergeDefault = parcelHelpers.interopDefault(_merge);
function compose() {
    for(var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++)styles[_key] = arguments[_key];
    var fn = function fn1(props) {
        return styles.reduce(function(acc, style) {
            var output = style(props);
            if (output) return _mergeDefault.default(acc, output);
            return acc;
        }, {
        });
    }; // Alternative approach that doesn't yield any performance gain.
    // const handlers = styles.reduce((acc, style) => {
    //   style.filterProps.forEach(prop => {
    //     acc[prop] = style;
    //   });
    //   return acc;
    // }, {});
    // const fn = props => {
    //   return Object.keys(props).reduce((acc, prop) => {
    //     if (handlers[prop]) {
    //       return merge(acc, handlers[prop](props));
    //     }
    //     return acc;
    //   }, {});
    // };
    fn.propTypes = styles.reduce(function(acc, style) {
        return _extendsDefault.default(acc, style.propTypes);
    }, {
    });
    fn.filterProps = styles.reduce(function(acc, style) {
        return acc.concat(style.filterProps);
    }, []);
    return fn;
}
exports.default = compose;

},{"@babel/runtime/helpers/esm/extends":"esrVD","./merge":"ij8Hy","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8bF0x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 *
 * @deprecated
 * The css style function is deprecated. Use the `styleFunctionSx` instead.
 */ parcelHelpers.export(exports, "css", ()=>css
);
var _toConsumableArray = require("@babel/runtime/helpers/esm/toConsumableArray");
var _toConsumableArrayDefault = parcelHelpers.interopDefault(_toConsumableArray);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _utils = require("@material-ui/utils");
var _merge = require("./merge");
var _mergeDefault = parcelHelpers.interopDefault(_merge);
function omit(input, fields) {
    var output = {
    };
    Object.keys(input).forEach(function(prop) {
        if (fields.indexOf(prop) === -1) output[prop] = input[prop];
    });
    return output;
}
var warnedOnce = false;
function styleFunctionSx(styleFunction) {
    var newStyleFunction = function newStyleFunction1(props) {
        var output = styleFunction(props);
        if (props.css) return _extendsDefault.default({
        }, _mergeDefault.default(output, styleFunction(_extendsDefault.default({
            theme: props.theme
        }, props.css))), omit(props.css, [
            styleFunction.filterProps
        ]));
        if (props.sx) return _extendsDefault.default({
        }, _mergeDefault.default(output, styleFunction(_extendsDefault.default({
            theme: props.theme
        }, props.sx))), omit(props.sx, [
            styleFunction.filterProps
        ]));
        return output;
    };
    newStyleFunction.propTypes = _extendsDefault.default({
    }, styleFunction.propTypes, {
        css: _utils.chainPropTypes(_propTypesDefault.default.object, function(props) {
            if (!warnedOnce && props.css !== undefined) {
                warnedOnce = true;
                return new Error('Material-UI: The `css` prop is deprecated, please use the `sx` prop instead.');
            }
            return null;
        }),
        sx: _propTypesDefault.default.object
    });
    newStyleFunction.filterProps = [
        'css',
        'sx'
    ].concat(_toConsumableArrayDefault.default(styleFunction.filterProps));
    return newStyleFunction;
}
function css(styleFunction) {
    console.warn('Material-UI: The `css` function is deprecated. Use the `styleFunctionSx` instead.');
    return styleFunctionSx(styleFunction);
}
exports.default = styleFunctionSx;

},{"@babel/runtime/helpers/esm/toConsumableArray":"fbqwi","@babel/runtime/helpers/esm/extends":"esrVD","prop-types":"lYCp3","@material-ui/utils":"Uumnw","./merge":"ij8Hy","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"bYIgu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "displayPrint", ()=>displayPrint
);
parcelHelpers.export(exports, "displayRaw", ()=>displayRaw
);
parcelHelpers.export(exports, "overflow", ()=>overflow
);
parcelHelpers.export(exports, "textOverflow", ()=>textOverflow
);
parcelHelpers.export(exports, "visibility", ()=>visibility
);
parcelHelpers.export(exports, "whiteSpace", ()=>whiteSpace
);
var _style = require("./style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _compose = require("./compose");
var _composeDefault = parcelHelpers.interopDefault(_compose);
var displayPrint = _styleDefault.default({
    prop: 'displayPrint',
    cssProperty: false,
    transform: function transform(value) {
        return {
            '@media print': {
                display: value
            }
        };
    }
});
var displayRaw = _styleDefault.default({
    prop: 'display'
});
var overflow = _styleDefault.default({
    prop: 'overflow'
});
var textOverflow = _styleDefault.default({
    prop: 'textOverflow'
});
var visibility = _styleDefault.default({
    prop: 'visibility'
});
var whiteSpace = _styleDefault.default({
    prop: 'whiteSpace'
});
exports.default = _composeDefault.default(displayPrint, displayRaw, overflow, textOverflow, visibility, whiteSpace);

},{"./style":"docOS","./compose":"cq2yA","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8H628":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "flexBasis", ()=>flexBasis
);
parcelHelpers.export(exports, "flexDirection", ()=>flexDirection
);
parcelHelpers.export(exports, "flexWrap", ()=>flexWrap
);
parcelHelpers.export(exports, "justifyContent", ()=>justifyContent
);
parcelHelpers.export(exports, "alignItems", ()=>alignItems
);
parcelHelpers.export(exports, "alignContent", ()=>alignContent
);
parcelHelpers.export(exports, "order", ()=>order
);
parcelHelpers.export(exports, "flex", ()=>flex
);
parcelHelpers.export(exports, "flexGrow", ()=>flexGrow
);
parcelHelpers.export(exports, "flexShrink", ()=>flexShrink
);
parcelHelpers.export(exports, "alignSelf", ()=>alignSelf
);
parcelHelpers.export(exports, "justifyItems", ()=>justifyItems
);
parcelHelpers.export(exports, "justifySelf", ()=>justifySelf
);
var _style = require("./style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _compose = require("./compose");
var _composeDefault = parcelHelpers.interopDefault(_compose);
var flexBasis = _styleDefault.default({
    prop: 'flexBasis'
});
var flexDirection = _styleDefault.default({
    prop: 'flexDirection'
});
var flexWrap = _styleDefault.default({
    prop: 'flexWrap'
});
var justifyContent = _styleDefault.default({
    prop: 'justifyContent'
});
var alignItems = _styleDefault.default({
    prop: 'alignItems'
});
var alignContent = _styleDefault.default({
    prop: 'alignContent'
});
var order = _styleDefault.default({
    prop: 'order'
});
var flex = _styleDefault.default({
    prop: 'flex'
});
var flexGrow = _styleDefault.default({
    prop: 'flexGrow'
});
var flexShrink = _styleDefault.default({
    prop: 'flexShrink'
});
var alignSelf = _styleDefault.default({
    prop: 'alignSelf'
});
var justifyItems = _styleDefault.default({
    prop: 'justifyItems'
});
var justifySelf = _styleDefault.default({
    prop: 'justifySelf'
});
var flexbox = _composeDefault.default(flexBasis, flexDirection, flexWrap, justifyContent, alignItems, alignContent, order, flex, flexGrow, flexShrink, alignSelf, justifyItems, justifySelf);
exports.default = flexbox;

},{"./style":"docOS","./compose":"cq2yA","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"gShvl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gridGap", ()=>gridGap
);
parcelHelpers.export(exports, "gridColumnGap", ()=>gridColumnGap
);
parcelHelpers.export(exports, "gridRowGap", ()=>gridRowGap
);
parcelHelpers.export(exports, "gridColumn", ()=>gridColumn
);
parcelHelpers.export(exports, "gridRow", ()=>gridRow
);
parcelHelpers.export(exports, "gridAutoFlow", ()=>gridAutoFlow
);
parcelHelpers.export(exports, "gridAutoColumns", ()=>gridAutoColumns
);
parcelHelpers.export(exports, "gridAutoRows", ()=>gridAutoRows
);
parcelHelpers.export(exports, "gridTemplateColumns", ()=>gridTemplateColumns
);
parcelHelpers.export(exports, "gridTemplateRows", ()=>gridTemplateRows
);
parcelHelpers.export(exports, "gridTemplateAreas", ()=>gridTemplateAreas
);
parcelHelpers.export(exports, "gridArea", ()=>gridArea
);
var _style = require("./style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _compose = require("./compose");
var _composeDefault = parcelHelpers.interopDefault(_compose);
var gridGap = _styleDefault.default({
    prop: 'gridGap'
});
var gridColumnGap = _styleDefault.default({
    prop: 'gridColumnGap'
});
var gridRowGap = _styleDefault.default({
    prop: 'gridRowGap'
});
var gridColumn = _styleDefault.default({
    prop: 'gridColumn'
});
var gridRow = _styleDefault.default({
    prop: 'gridRow'
});
var gridAutoFlow = _styleDefault.default({
    prop: 'gridAutoFlow'
});
var gridAutoColumns = _styleDefault.default({
    prop: 'gridAutoColumns'
});
var gridAutoRows = _styleDefault.default({
    prop: 'gridAutoRows'
});
var gridTemplateColumns = _styleDefault.default({
    prop: 'gridTemplateColumns'
});
var gridTemplateRows = _styleDefault.default({
    prop: 'gridTemplateRows'
});
var gridTemplateAreas = _styleDefault.default({
    prop: 'gridTemplateAreas'
});
var gridArea = _styleDefault.default({
    prop: 'gridArea'
});
var grid = _composeDefault.default(gridGap, gridColumnGap, gridRowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
exports.default = grid;

},{"./style":"docOS","./compose":"cq2yA","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"6uAvj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "color", ()=>color
);
parcelHelpers.export(exports, "bgcolor", ()=>bgcolor
);
var _style = require("./style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _compose = require("./compose");
var _composeDefault = parcelHelpers.interopDefault(_compose);
var color = _styleDefault.default({
    prop: 'color',
    themeKey: 'palette'
});
var bgcolor = _styleDefault.default({
    prop: 'bgcolor',
    cssProperty: 'backgroundColor',
    themeKey: 'palette'
});
var palette = _composeDefault.default(color, bgcolor);
exports.default = palette;

},{"./style":"docOS","./compose":"cq2yA","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"cpdXe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "position", ()=>position
);
parcelHelpers.export(exports, "zIndex", ()=>zIndex
);
parcelHelpers.export(exports, "top", ()=>top
);
parcelHelpers.export(exports, "right", ()=>right
);
parcelHelpers.export(exports, "bottom", ()=>bottom
);
parcelHelpers.export(exports, "left", ()=>left
);
var _style = require("./style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _compose = require("./compose");
var _composeDefault = parcelHelpers.interopDefault(_compose);
var position = _styleDefault.default({
    prop: 'position'
});
var zIndex = _styleDefault.default({
    prop: 'zIndex',
    themeKey: 'zIndex'
});
var top = _styleDefault.default({
    prop: 'top'
});
var right = _styleDefault.default({
    prop: 'right'
});
var bottom = _styleDefault.default({
    prop: 'bottom'
});
var left = _styleDefault.default({
    prop: 'left'
});
exports.default = _composeDefault.default(position, zIndex, top, right, bottom, left);

},{"./style":"docOS","./compose":"cq2yA","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"1FZQl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _style = require("./style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var boxShadow = _styleDefault.default({
    prop: 'boxShadow',
    themeKey: 'shadows'
});
exports.default = boxShadow;

},{"./style":"docOS","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"d8dU7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "width", ()=>width
);
parcelHelpers.export(exports, "maxWidth", ()=>maxWidth
);
parcelHelpers.export(exports, "minWidth", ()=>minWidth
);
parcelHelpers.export(exports, "height", ()=>height
);
parcelHelpers.export(exports, "maxHeight", ()=>maxHeight
);
parcelHelpers.export(exports, "minHeight", ()=>minHeight
);
parcelHelpers.export(exports, "sizeWidth", ()=>sizeWidth
);
parcelHelpers.export(exports, "sizeHeight", ()=>sizeHeight
);
parcelHelpers.export(exports, "boxSizing", ()=>boxSizing
);
var _style = require("./style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _compose = require("./compose");
var _composeDefault = parcelHelpers.interopDefault(_compose);
function transform(value) {
    return value <= 1 ? "".concat(value * 100, "%") : value;
}
var width = _styleDefault.default({
    prop: 'width',
    transform: transform
});
var maxWidth = _styleDefault.default({
    prop: 'maxWidth',
    transform: transform
});
var minWidth = _styleDefault.default({
    prop: 'minWidth',
    transform: transform
});
var height = _styleDefault.default({
    prop: 'height',
    transform: transform
});
var maxHeight = _styleDefault.default({
    prop: 'maxHeight',
    transform: transform
});
var minHeight = _styleDefault.default({
    prop: 'minHeight',
    transform: transform
});
var sizeWidth = _styleDefault.default({
    prop: 'size',
    cssProperty: 'width',
    transform: transform
});
var sizeHeight = _styleDefault.default({
    prop: 'size',
    cssProperty: 'height',
    transform: transform
});
var boxSizing = _styleDefault.default({
    prop: 'boxSizing'
});
var sizing = _composeDefault.default(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
exports.default = sizing;

},{"./style":"docOS","./compose":"cq2yA","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"d9WDc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createUnarySpacing", ()=>createUnarySpacing
);
var _slicedToArray = require("@babel/runtime/helpers/esm/slicedToArray");
var _slicedToArrayDefault = parcelHelpers.interopDefault(_slicedToArray);
var _responsivePropType = require("./responsivePropType");
var _responsivePropTypeDefault = parcelHelpers.interopDefault(_responsivePropType);
var _breakpoints = require("./breakpoints");
var _merge = require("./merge");
var _mergeDefault = parcelHelpers.interopDefault(_merge);
var _memoize = require("./memoize");
var _memoizeDefault = parcelHelpers.interopDefault(_memoize);
var properties = {
    m: 'margin',
    p: 'padding'
};
var directions = {
    t: 'Top',
    r: 'Right',
    b: 'Bottom',
    l: 'Left',
    x: [
        'Left',
        'Right'
    ],
    y: [
        'Top',
        'Bottom'
    ]
};
var aliases = {
    marginX: 'mx',
    marginY: 'my',
    paddingX: 'px',
    paddingY: 'py'
}; // memoize() impact:
// From 300,000 ops/sec
// To 350,000 ops/sec
var getCssProperties = _memoizeDefault.default(function(prop) {
    // It's not a shorthand notation.
    if (prop.length > 2) {
        if (aliases[prop]) prop = aliases[prop];
        else return [
            prop
        ];
    }
    var _prop$split = prop.split(''), _prop$split2 = _slicedToArrayDefault.default(_prop$split, 2), a = _prop$split2[0], b = _prop$split2[1];
    var property = properties[a];
    var direction = directions[b] || '';
    return Array.isArray(direction) ? direction.map(function(dir) {
        return property + dir;
    }) : [
        property + direction
    ];
});
var spacingKeys = [
    'm',
    'mt',
    'mr',
    'mb',
    'ml',
    'mx',
    'my',
    'p',
    'pt',
    'pr',
    'pb',
    'pl',
    'px',
    'py',
    'margin',
    'marginTop',
    'marginRight',
    'marginBottom',
    'marginLeft',
    'marginX',
    'marginY',
    'padding',
    'paddingTop',
    'paddingRight',
    'paddingBottom',
    'paddingLeft',
    'paddingX',
    'paddingY'
];
function createUnarySpacing(theme) {
    var themeSpacing = theme.spacing || 8;
    if (typeof themeSpacing === 'number') return function(abs) {
        if (typeof abs !== 'number') console.error("Material-UI: Expected spacing argument to be a number, got ".concat(abs, "."));
        return themeSpacing * abs;
    };
    if (Array.isArray(themeSpacing)) return function(abs) {
        if (abs > themeSpacing.length - 1) console.error([
            "Material-UI: The value provided (".concat(abs, ") overflows."),
            "The supported values are: ".concat(JSON.stringify(themeSpacing), "."),
            "".concat(abs, " > ").concat(themeSpacing.length - 1, ", you need to add the missing values.")
        ].join('\n'));
        return themeSpacing[abs];
    };
    if (typeof themeSpacing === 'function') return themeSpacing;
    console.error([
        "Material-UI: The `theme.spacing` value (".concat(themeSpacing, ") is invalid."),
        'It should be a number, an array or a function.'
    ].join('\n'));
    return function() {
        return undefined;
    };
}
function getValue(transformer, propValue) {
    if (typeof propValue === 'string' || propValue == null) return propValue;
    var abs = Math.abs(propValue);
    var transformed = transformer(abs);
    if (propValue >= 0) return transformed;
    if (typeof transformed === 'number') return -transformed;
    return "-".concat(transformed);
}
function getStyleFromPropValue(cssProperties, transformer) {
    return function(propValue) {
        return cssProperties.reduce(function(acc, cssProperty) {
            acc[cssProperty] = getValue(transformer, propValue);
            return acc;
        }, {
        });
    };
}
function spacing(props) {
    var theme = props.theme;
    var transformer = createUnarySpacing(theme);
    return Object.keys(props).map(function(prop) {
        // Using a hash computation over an array iteration could be faster, but with only 28 items,
        // it's doesn't worth the bundle size.
        if (spacingKeys.indexOf(prop) === -1) return null;
        var cssProperties = getCssProperties(prop);
        var styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
        var propValue = props[prop];
        return _breakpoints.handleBreakpoints(props, propValue, styleFromPropValue);
    }).reduce(_mergeDefault.default, {
    });
}
spacing.propTypes = spacingKeys.reduce(function(obj, key) {
    obj[key] = _responsivePropTypeDefault.default;
    return obj;
}, {
});
spacing.filterProps = spacingKeys;
exports.default = spacing;

},{"@babel/runtime/helpers/esm/slicedToArray":"cT2nX","./responsivePropType":"8k9G8","./breakpoints":"h7T02","./merge":"ij8Hy","./memoize":"iOGik","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"cT2nX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayWithHolesJs = require("./arrayWithHoles.js");
var _arrayWithHolesJsDefault = parcelHelpers.interopDefault(_arrayWithHolesJs);
var _iterableToArrayLimitJs = require("./iterableToArrayLimit.js");
var _iterableToArrayLimitJsDefault = parcelHelpers.interopDefault(_iterableToArrayLimitJs);
var _unsupportedIterableToArrayJs = require("./unsupportedIterableToArray.js");
var _unsupportedIterableToArrayJsDefault = parcelHelpers.interopDefault(_unsupportedIterableToArrayJs);
var _nonIterableRestJs = require("./nonIterableRest.js");
var _nonIterableRestJsDefault = parcelHelpers.interopDefault(_nonIterableRestJs);
function _slicedToArray(arr, i) {
    return _arrayWithHolesJsDefault.default(arr) || _iterableToArrayLimitJsDefault.default(arr, i) || _unsupportedIterableToArrayJsDefault.default(arr, i) || _nonIterableRestJsDefault.default();
}
exports.default = _slicedToArray;

},{"./arrayWithHoles.js":"baM7d","./iterableToArrayLimit.js":"5Luxo","./unsupportedIterableToArray.js":"2SFEG","./nonIterableRest.js":"hW9ch","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"baM7d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
exports.default = _arrayWithHoles;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5Luxo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
exports.default = _iterableToArrayLimit;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hW9ch":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
exports.default = _nonIterableRest;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"iOGik":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function memoize(fn) {
    var cache = {
    };
    return function(arg) {
        if (cache[arg] === undefined) cache[arg] = fn(arg);
        return cache[arg];
    };
}
exports.default = memoize;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"ibEMD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fontFamily", ()=>fontFamily
);
parcelHelpers.export(exports, "fontSize", ()=>fontSize
);
parcelHelpers.export(exports, "fontStyle", ()=>fontStyle
);
parcelHelpers.export(exports, "fontWeight", ()=>fontWeight
);
parcelHelpers.export(exports, "letterSpacing", ()=>letterSpacing
);
parcelHelpers.export(exports, "lineHeight", ()=>lineHeight
);
parcelHelpers.export(exports, "textAlign", ()=>textAlign
);
var _style = require("./style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _compose = require("./compose");
var _composeDefault = parcelHelpers.interopDefault(_compose);
var fontFamily = _styleDefault.default({
    prop: 'fontFamily',
    themeKey: 'typography'
});
var fontSize = _styleDefault.default({
    prop: 'fontSize',
    themeKey: 'typography'
});
var fontStyle = _styleDefault.default({
    prop: 'fontStyle',
    themeKey: 'typography'
});
var fontWeight = _styleDefault.default({
    prop: 'fontWeight',
    themeKey: 'typography'
});
var letterSpacing = _styleDefault.default({
    prop: 'letterSpacing'
});
var lineHeight = _styleDefault.default({
    prop: 'lineHeight'
});
var textAlign = _styleDefault.default({
    prop: 'textAlign'
});
var typography = _composeDefault.default(fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, textAlign);
exports.default = typography;

},{"./style":"docOS","./compose":"cq2yA","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"h7gKO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "easing", ()=>easing
);
parcelHelpers.export(exports, "duration", ()=>duration
);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var easing = {
    // This is the most common easing curve.
    easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
}; // Follow https://material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations
var duration = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
};
function formatMs(milliseconds) {
    return "".concat(Math.round(milliseconds), "ms");
}
exports.default = {
    easing: easing,
    duration: duration,
    create: function create() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [
            'all'
        ];
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        };
        var _options$duration = options.duration, durationOption = _options$duration === void 0 ? duration.standard : _options$duration, _options$easing = options.easing, easingOption = _options$easing === void 0 ? easing.easeInOut : _options$easing, _options$delay = options.delay, delay = _options$delay === void 0 ? 0 : _options$delay, other = _objectWithoutPropertiesDefault.default(options, [
            "duration",
            "easing",
            "delay"
        ]);
        var isString = function isString1(value) {
            return typeof value === 'string';
        };
        var isNumber = function isNumber1(value) {
            return !isNaN(parseFloat(value));
        };
        if (!isString(props) && !Array.isArray(props)) console.error('Material-UI: Argument "props" must be a string or Array.');
        if (!isNumber(durationOption) && !isString(durationOption)) console.error("Material-UI: Argument \"duration\" must be a number or a string but found ".concat(durationOption, "."));
        if (!isString(easingOption)) console.error('Material-UI: Argument "easing" must be a string.');
        if (!isNumber(delay) && !isString(delay)) console.error('Material-UI: Argument "delay" must be a number or a string.');
        if (Object.keys(other).length !== 0) console.error("Material-UI: Unrecognized argument(s) [".concat(Object.keys(other).join(','), "]."));
        return (Array.isArray(props) ? props : [
            props
        ]).map(function(animatedProp) {
            return "".concat(animatedProp, " ").concat(typeof durationOption === 'string' ? durationOption : formatMs(durationOption), " ").concat(easingOption, " ").concat(typeof delay === 'string' ? delay : formatMs(delay));
        }).join(',');
    },
    getAutoHeightDuration: function getAutoHeightDuration(height) {
        if (!height) return 0;
        var constant = height / 36; // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10
        return Math.round((4 + 15 * Math.pow(constant, 0.25) + constant / 5) * 10);
    }
};

},{"@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"9eg4Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// We need to centralize the zIndex definitions as they work
// like global values in the browser.
var zIndex = {
    mobileStepper: 1000,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
};
exports.default = zIndex;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"4RyDE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("@material-ui/utils");
function capitalize(string) {
    if (typeof string !== 'string') throw new Error("Material-UI: capitalize(string) expects a string argument.");
    return string.charAt(0).toUpperCase() + string.slice(1);
}
exports.default = capitalize;

},{"@material-ui/utils":"Uumnw","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"bLpHM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _setRef = require("./setRef");
var _setRefDefault = parcelHelpers.interopDefault(_setRef);
function useForkRef(refA, refB) {
    /**
   * This will create a new function if the ref props change and are defined.
   * This means react will call the old forkRef with `null` and the new forkRef
   * with the ref. Cleanup naturally emerges from this behavior
   */ return _react.useMemo(function() {
        if (refA == null && refB == null) return null;
        return function(refValue) {
            _setRefDefault.default(refA, refValue);
            _setRefDefault.default(refB, refValue);
        };
    }, [
        refA,
        refB
    ]);
}
exports.default = useForkRef;

},{"react":"cKM0D","./setRef":"s1tt1","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"s1tt1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function setRef(ref, value) {
    if (typeof ref === 'function') ref(value);
    else if (ref) ref.current = value;
}
exports.default = setRef;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5gMaw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_textareaAutosizeDefault.default
);
var _textareaAutosize = require("./TextareaAutosize");
var _textareaAutosizeDefault = parcelHelpers.interopDefault(_textareaAutosize);

},{"./TextareaAutosize":"cV0fk","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"cV0fk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _debounce = require("../utils/debounce");
var _debounceDefault = parcelHelpers.interopDefault(_debounce);
var _useForkRef = require("../utils/useForkRef");
var _useForkRefDefault = parcelHelpers.interopDefault(_useForkRef);
var _deprecatedPropType = require("../utils/deprecatedPropType");
var _deprecatedPropTypeDefault = parcelHelpers.interopDefault(_deprecatedPropType);
function getStyleValue(computedStyle, property) {
    return parseInt(computedStyle[property], 10) || 0;
}
var useEnhancedEffect = typeof window !== 'undefined' ? _react.useLayoutEffect : _react.useEffect;
var styles = {
    /* Styles applied to the shadow textarea element. */ shadow: {
        // Visibility needed to hide the extra text area on iPads
        visibility: 'hidden',
        // Remove from the content flow
        position: 'absolute',
        // Ignore the scrollbar width
        overflow: 'hidden',
        height: 0,
        top: 0,
        left: 0,
        // Create a new layer, increase the isolation of the computed values
        transform: 'translateZ(0)'
    }
};
var TextareaAutosize = /*#__PURE__*/ _react.forwardRef(function TextareaAutosize1(props, ref) {
    var onChange = props.onChange, rows = props.rows, rowsMax = props.rowsMax, rowsMinProp = props.rowsMin, maxRowsProp = props.maxRows, _props$minRows = props.minRows, minRowsProp = _props$minRows === void 0 ? 1 : _props$minRows, style = props.style, value = props.value, other = _objectWithoutPropertiesDefault.default(props, [
        "onChange",
        "rows",
        "rowsMax",
        "rowsMin",
        "maxRows",
        "minRows",
        "style",
        "value"
    ]);
    var maxRows = maxRowsProp || rowsMax;
    var minRows = rows || rowsMinProp || minRowsProp;
    var _React$useRef = _react.useRef(value != null), isControlled = _React$useRef.current;
    var inputRef = _react.useRef(null);
    var handleRef = _useForkRefDefault.default(ref, inputRef);
    var shadowRef = _react.useRef(null);
    var renders = _react.useRef(0);
    var _React$useState = _react.useState({
    }), state = _React$useState[0], setState = _React$useState[1];
    var syncHeight = _react.useCallback(function() {
        var input = inputRef.current;
        var computedStyle = window.getComputedStyle(input);
        var inputShallow = shadowRef.current;
        inputShallow.style.width = computedStyle.width;
        inputShallow.value = input.value || props.placeholder || 'x';
        if (inputShallow.value.slice(-1) === '\n') // Certain fonts which overflow the line height will cause the textarea
        // to report a different scrollHeight depending on whether the last line
        // is empty. Make it non-empty to avoid this issue.
        inputShallow.value += ' ';
        var boxSizing = computedStyle['box-sizing'];
        var padding = getStyleValue(computedStyle, 'padding-bottom') + getStyleValue(computedStyle, 'padding-top');
        var border = getStyleValue(computedStyle, 'border-bottom-width') + getStyleValue(computedStyle, 'border-top-width'); // The height of the inner content
        var innerHeight = inputShallow.scrollHeight - padding; // Measure height of a textarea with a single row
        inputShallow.value = 'x';
        var singleRowHeight = inputShallow.scrollHeight - padding; // The height of the outer content
        var outerHeight = innerHeight;
        if (minRows) outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
        if (maxRows) outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
        outerHeight = Math.max(outerHeight, singleRowHeight); // Take the box sizing into account for applying this value as a style.
        var outerHeightStyle = outerHeight + (boxSizing === 'border-box' ? padding + border : 0);
        var overflow = Math.abs(outerHeight - innerHeight) <= 1;
        setState(function(prevState) {
            // Need a large enough difference to update the height.
            // This prevents infinite rendering loop.
            if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
                renders.current += 1;
                return {
                    overflow: overflow,
                    outerHeightStyle: outerHeightStyle
                };
            }
            if (renders.current === 20) console.error([
                'Material-UI: Too many re-renders. The layout is unstable.',
                'TextareaAutosize limits the number of renders to prevent an infinite loop.'
            ].join('\n'));
            return prevState;
        });
    }, [
        maxRows,
        minRows,
        props.placeholder
    ]);
    _react.useEffect(function() {
        var handleResize = _debounceDefault.default(function() {
            renders.current = 0;
            syncHeight();
        });
        window.addEventListener('resize', handleResize);
        return function() {
            handleResize.clear();
            window.removeEventListener('resize', handleResize);
        };
    }, [
        syncHeight
    ]);
    useEnhancedEffect(function() {
        syncHeight();
    });
    _react.useEffect(function() {
        renders.current = 0;
    }, [
        value
    ]);
    var handleChange = function handleChange1(event) {
        renders.current = 0;
        if (!isControlled) syncHeight();
        if (onChange) onChange(event);
    };
    return(/*#__PURE__*/ _react.createElement(_react.Fragment, null, /*#__PURE__*/ _react.createElement("textarea", _extendsDefault.default({
        value: value,
        onChange: handleChange,
        ref: handleRef // Apply the rows prop to get a "correct" first SSR paint
        ,
        rows: minRows,
        style: _extendsDefault.default({
            height: state.outerHeightStyle,
            // Need a large enough difference to allow scrolling.
            // This prevents infinite rendering loop.
            overflow: state.overflow ? 'hidden' : null
        }, style)
    }, other)), /*#__PURE__*/ _react.createElement("textarea", {
        "aria-hidden": true,
        className: props.className,
        readOnly: true,
        ref: shadowRef,
        tabIndex: -1,
        style: _extendsDefault.default({
        }, styles.shadow, style)
    })));
});
TextareaAutosize.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * Maximum number of rows to display.
   */ maxRows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * Minimum number of rows to display.
   */ minRows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * @ignore
   */ onChange: _propTypesDefault.default.func,
    /**
   * @ignore
   */ placeholder: _propTypesDefault.default.string,
    /**
   * Minimum number of rows to display.
   * @deprecated Use `minRows` instead.
   */ rows: _deprecatedPropTypeDefault.default(_propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]), 'Use `minRows` instead.'),
    /**
   * Maximum number of rows to display.
   * @deprecated Use `maxRows` instead.
   */ rowsMax: _deprecatedPropTypeDefault.default(_propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]), 'Use `maxRows` instead.'),
    /**
   * Minimum number of rows to display.
   * @deprecated Use `minRows` instead.
   */ rowsMin: _deprecatedPropTypeDefault.default(_propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]), 'Use `minRows` instead.'),
    /**
   * @ignore
   */ style: _propTypesDefault.default.object,
    /**
   * @ignore
   */ value: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.arrayOf(_propTypesDefault.default.string),
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ])
};
exports.default = TextareaAutosize;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","../utils/debounce":"9S1vL","../utils/useForkRef":"bLpHM","../utils/deprecatedPropType":"6Zj6s","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"9S1vL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function debounce(func) {
    var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 166;
    var timeout;
    function debounced() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        // eslint-disable-next-line consistent-this
        var that = this;
        var later = function later1() {
            func.apply(that, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    }
    debounced.clear = function() {
        clearTimeout(timeout);
    };
    return debounced;
}
exports.default = debounce;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"6Zj6s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function deprecatedPropType(validator, reason) {
    return function(props, propName, componentName, location, propFullName) {
        var componentNameSafe = componentName || '<<anonymous>>';
        var propFullNameSafe = propFullName || propName;
        if (typeof props[propName] !== 'undefined') return new Error("The ".concat(location, " `").concat(propFullNameSafe, "` of ") + "`".concat(componentNameSafe, "` is deprecated. ").concat(reason));
        return null;
    };
}
exports.default = deprecatedPropType;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"4cvQH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Supports determination of isControlled().
// Controlled input accepts its current value as a prop.
//
// @see https://facebook.github.io/react/docs/forms.html#controlled-components
// @param value
// @returns {boolean} true if string (including '') or number (including zero)
parcelHelpers.export(exports, "hasValue", ()=>hasValue
) // Determine if field is empty or filled.
;
// Response determines if label is presented above field or as placeholder.
//
// @param obj
// @param SSR
// @returns {boolean} False when not present or empty string.
//                    True when any number or string with length.
parcelHelpers.export(exports, "isFilled", ()=>isFilled
) // Determine if an Input is adorned on start.
;
// It's corresponding to the left with LTR.
//
// @param obj
// @returns {boolean} False when no adornments.
//                    True when adorned at the start.
parcelHelpers.export(exports, "isAdornedStart", ()=>isAdornedStart
);
function hasValue(value) {
    return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj) {
    var SSR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return obj && (hasValue(obj.value) && obj.value !== '' || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== '');
}
function isAdornedStart(obj) {
    return obj.startAdornment;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"XFeMl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_filledInputDefault.default
);
var _filledInput = require("./FilledInput");
var _filledInputDefault = parcelHelpers.interopDefault(_filledInput);

},{"./FilledInput":"g5sMl","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"g5sMl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _inputBase = require("../InputBase");
var _inputBaseDefault = parcelHelpers.interopDefault(_inputBase);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var styles = function styles1(theme) {
    var light = theme.palette.type === 'light';
    var bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
    var backgroundColor = light ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.09)';
    return {
        /* Styles applied to the root element. */ root: {
            position: 'relative',
            backgroundColor: backgroundColor,
            borderTopLeftRadius: theme.shape.borderRadius,
            borderTopRightRadius: theme.shape.borderRadius,
            transition: theme.transitions.create('background-color', {
                duration: theme.transitions.duration.shorter,
                easing: theme.transitions.easing.easeOut
            }),
            '&:hover': {
                backgroundColor: light ? 'rgba(0, 0, 0, 0.13)' : 'rgba(255, 255, 255, 0.13)',
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    backgroundColor: backgroundColor
                }
            },
            '&$focused': {
                backgroundColor: light ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.09)'
            },
            '&$disabled': {
                backgroundColor: light ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.12)'
            }
        },
        /* Styles applied to the root element if color secondary. */ colorSecondary: {
            '&$underline:after': {
                borderBottomColor: theme.palette.secondary.main
            }
        },
        /* Styles applied to the root element if `disableUnderline={false}`. */ underline: {
            '&:after': {
                borderBottom: "2px solid ".concat(theme.palette.primary.main),
                left: 0,
                bottom: 0,
                // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
                content: '""',
                position: 'absolute',
                right: 0,
                transform: 'scaleX(0)',
                transition: theme.transitions.create('transform', {
                    duration: theme.transitions.duration.shorter,
                    easing: theme.transitions.easing.easeOut
                }),
                pointerEvents: 'none' // Transparent to the hover style.
            },
            '&$focused:after': {
                transform: 'scaleX(1)'
            },
            '&$error:after': {
                borderBottomColor: theme.palette.error.main,
                transform: 'scaleX(1)' // error is always underlined in red
            },
            '&:before': {
                borderBottom: "1px solid ".concat(bottomLineColor),
                left: 0,
                bottom: 0,
                // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
                content: '"\\00a0"',
                position: 'absolute',
                right: 0,
                transition: theme.transitions.create('border-bottom-color', {
                    duration: theme.transitions.duration.shorter
                }),
                pointerEvents: 'none' // Transparent to the hover style.
            },
            '&:hover:before': {
                borderBottom: "1px solid ".concat(theme.palette.text.primary)
            },
            '&$disabled:before': {
                borderBottomStyle: 'dotted'
            }
        },
        /* Pseudo-class applied to the root element if the component is focused. */ focused: {
        },
        /* Pseudo-class applied to the root element if `disabled={true}`. */ disabled: {
        },
        /* Styles applied to the root element if `startAdornment` is provided. */ adornedStart: {
            paddingLeft: 12
        },
        /* Styles applied to the root element if `endAdornment` is provided. */ adornedEnd: {
            paddingRight: 12
        },
        /* Pseudo-class applied to the root element if `error={true}`. */ error: {
        },
        /* Styles applied to the `input` element if `margin="dense"`. */ marginDense: {
        },
        /* Styles applied to the root element if `multiline={true}`. */ multiline: {
            padding: '27px 12px 10px',
            '&$marginDense': {
                paddingTop: 23,
                paddingBottom: 6
            }
        },
        /* Styles applied to the `input` element. */ input: {
            padding: '27px 12px 10px',
            '&:-webkit-autofill': {
                WebkitBoxShadow: theme.palette.type === 'light' ? null : '0 0 0 100px #266798 inset',
                WebkitTextFillColor: theme.palette.type === 'light' ? null : '#fff',
                caretColor: theme.palette.type === 'light' ? null : '#fff',
                borderTopLeftRadius: 'inherit',
                borderTopRightRadius: 'inherit'
            }
        },
        /* Styles applied to the `input` element if `margin="dense"`. */ inputMarginDense: {
            paddingTop: 23,
            paddingBottom: 6
        },
        /* Styles applied to the `input` if in `<FormControl hiddenLabel />`. */ inputHiddenLabel: {
            paddingTop: 18,
            paddingBottom: 19,
            '&$inputMarginDense': {
                paddingTop: 10,
                paddingBottom: 11
            }
        },
        /* Styles applied to the `input` element if `multiline={true}`. */ inputMultiline: {
            padding: 0
        },
        /* Styles applied to the `input` element if `startAdornment` is provided. */ inputAdornedStart: {
            paddingLeft: 0
        },
        /* Styles applied to the `input` element if `endAdornment` is provided. */ inputAdornedEnd: {
            paddingRight: 0
        }
    };
};
var FilledInput = /*#__PURE__*/ _react.forwardRef(function FilledInput1(props, ref) {
    var disableUnderline = props.disableUnderline, classes = props.classes, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$inputComponent = props.inputComponent, inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent, _props$multiline = props.multiline, multiline = _props$multiline === void 0 ? false : _props$multiline, _props$type = props.type, type = _props$type === void 0 ? 'text' : _props$type, other = _objectWithoutPropertiesDefault.default(props, [
        "disableUnderline",
        "classes",
        "fullWidth",
        "inputComponent",
        "multiline",
        "type"
    ]);
    return(/*#__PURE__*/ _react.createElement(_inputBaseDefault.default, _extendsDefault.default({
        classes: _extendsDefault.default({
        }, classes, {
            root: _clsxDefault.default(classes.root, !disableUnderline && classes.underline),
            underline: null
        }),
        fullWidth: fullWidth,
        inputComponent: inputComponent,
        multiline: multiline,
        ref: ref,
        type: type
    }, other)));
});
FilledInput.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */ autoComplete: _propTypesDefault.default.string,
    /**
   * If `true`, the `input` element will be focused during the first mount.
   */ autoFocus: _propTypesDefault.default.bool,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */ color: _propTypesDefault.default.oneOf([
        'primary',
        'secondary'
    ]),
    /**
   * The default `input` element value. Use when the component is not controlled.
   */ defaultValue: _propTypesDefault.default.any,
    /**
   * If `true`, the `input` element will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * If `true`, the input will not have an underline.
   */ disableUnderline: _propTypesDefault.default.bool,
    /**
   * End `InputAdornment` for this component.
   */ endAdornment: _propTypesDefault.default.node,
    /**
   * If `true`, the input will indicate an error. This is normally obtained via context from
   * FormControl.
   */ error: _propTypesDefault.default.bool,
    /**
   * If `true`, the input will take up the full width of its container.
   */ fullWidth: _propTypesDefault.default.bool,
    /**
   * The id of the `input` element.
   */ id: _propTypesDefault.default.string,
    /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   */ inputComponent: _propTypesDefault.default.elementType,
    /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */ inputProps: _propTypesDefault.default.object,
    /**
   * Pass a ref to the `input` element.
   */ inputRef: _utils.refType,
    /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */ margin: _propTypesDefault.default.oneOf([
        'dense',
        'none'
    ]),
    /**
   * Maximum number of rows to display when multiline option is set to true.
   */ maxRows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * If `true`, a textarea element will be rendered.
   */ multiline: _propTypesDefault.default.bool,
    /**
   * Name attribute of the `input` element.
   */ name: _propTypesDefault.default.string,
    /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */ onChange: _propTypesDefault.default.func,
    /**
   * The short hint displayed in the input before the user enters a value.
   */ placeholder: _propTypesDefault.default.string,
    /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */ readOnly: _propTypesDefault.default.bool,
    /**
   * If `true`, the `input` element will be required.
   */ required: _propTypesDefault.default.bool,
    /**
   * Number of rows to display when multiline option is set to true.
   */ rows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * Start `InputAdornment` for this component.
   */ startAdornment: _propTypesDefault.default.node,
    /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */ type: _propTypesDefault.default.string,
    /**
   * The value of the `input` element, required for a controlled component.
   */ value: _propTypesDefault.default.any
};
FilledInput.muiName = 'Input';
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiFilledInput'
})(FilledInput);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","@material-ui/utils":"Uumnw","../InputBase":"43mUM","../styles/withStyles":"3pIr2","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"lvlVJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_outlinedInputDefault.default
);
var _outlinedInput = require("./OutlinedInput");
var _outlinedInputDefault = parcelHelpers.interopDefault(_outlinedInput);

},{"./OutlinedInput":"apT7q","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"apT7q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _inputBase = require("../InputBase");
var _inputBaseDefault = parcelHelpers.interopDefault(_inputBase);
var _notchedOutline = require("./NotchedOutline");
var _notchedOutlineDefault = parcelHelpers.interopDefault(_notchedOutline);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var styles = function styles1(theme) {
    var borderColor = theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)';
    return {
        /* Styles applied to the root element. */ root: {
            position: 'relative',
            borderRadius: theme.shape.borderRadius,
            '&:hover $notchedOutline': {
                borderColor: theme.palette.text.primary
            },
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
                '&:hover $notchedOutline': {
                    borderColor: borderColor
                }
            },
            '&$focused $notchedOutline': {
                borderColor: theme.palette.primary.main,
                borderWidth: 2
            },
            '&$error $notchedOutline': {
                borderColor: theme.palette.error.main
            },
            '&$disabled $notchedOutline': {
                borderColor: theme.palette.action.disabled
            }
        },
        /* Styles applied to the root element if the color is secondary. */ colorSecondary: {
            '&$focused $notchedOutline': {
                borderColor: theme.palette.secondary.main
            }
        },
        /* Styles applied to the root element if the component is focused. */ focused: {
        },
        /* Styles applied to the root element if `disabled={true}`. */ disabled: {
        },
        /* Styles applied to the root element if `startAdornment` is provided. */ adornedStart: {
            paddingLeft: 14
        },
        /* Styles applied to the root element if `endAdornment` is provided. */ adornedEnd: {
            paddingRight: 14
        },
        /* Pseudo-class applied to the root element if `error={true}`. */ error: {
        },
        /* Styles applied to the `input` element if `margin="dense"`. */ marginDense: {
        },
        /* Styles applied to the root element if `multiline={true}`. */ multiline: {
            padding: '18.5px 14px',
            '&$marginDense': {
                paddingTop: 10.5,
                paddingBottom: 10.5
            }
        },
        /* Styles applied to the `NotchedOutline` element. */ notchedOutline: {
            borderColor: borderColor
        },
        /* Styles applied to the `input` element. */ input: {
            padding: '18.5px 14px',
            '&:-webkit-autofill': {
                WebkitBoxShadow: theme.palette.type === 'light' ? null : '0 0 0 100px #266798 inset',
                WebkitTextFillColor: theme.palette.type === 'light' ? null : '#fff',
                caretColor: theme.palette.type === 'light' ? null : '#fff',
                borderRadius: 'inherit'
            }
        },
        /* Styles applied to the `input` element if `margin="dense"`. */ inputMarginDense: {
            paddingTop: 10.5,
            paddingBottom: 10.5
        },
        /* Styles applied to the `input` element if `multiline={true}`. */ inputMultiline: {
            padding: 0
        },
        /* Styles applied to the `input` element if `startAdornment` is provided. */ inputAdornedStart: {
            paddingLeft: 0
        },
        /* Styles applied to the `input` element if `endAdornment` is provided. */ inputAdornedEnd: {
            paddingRight: 0
        }
    };
};
var OutlinedInput = /*#__PURE__*/ _react.forwardRef(function OutlinedInput1(props, ref) {
    var classes = props.classes, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$inputComponent = props.inputComponent, inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent, label = props.label, _props$labelWidth = props.labelWidth, labelWidth = _props$labelWidth === void 0 ? 0 : _props$labelWidth, _props$multiline = props.multiline, multiline = _props$multiline === void 0 ? false : _props$multiline, notched = props.notched, _props$type = props.type, type = _props$type === void 0 ? 'text' : _props$type, other = _objectWithoutPropertiesDefault.default(props, [
        "classes",
        "fullWidth",
        "inputComponent",
        "label",
        "labelWidth",
        "multiline",
        "notched",
        "type"
    ]);
    return(/*#__PURE__*/ _react.createElement(_inputBaseDefault.default, _extendsDefault.default({
        renderSuffix: function renderSuffix(state) {
            return(/*#__PURE__*/ _react.createElement(_notchedOutlineDefault.default, {
                className: classes.notchedOutline,
                label: label,
                labelWidth: labelWidth,
                notched: typeof notched !== 'undefined' ? notched : Boolean(state.startAdornment || state.filled || state.focused)
            }));
        },
        classes: _extendsDefault.default({
        }, classes, {
            root: _clsxDefault.default(classes.root, classes.underline),
            notchedOutline: null
        }),
        fullWidth: fullWidth,
        inputComponent: inputComponent,
        multiline: multiline,
        ref: ref,
        type: type
    }, other)));
});
OutlinedInput.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */ autoComplete: _propTypesDefault.default.string,
    /**
   * If `true`, the `input` element will be focused during the first mount.
   */ autoFocus: _propTypesDefault.default.bool,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */ color: _propTypesDefault.default.oneOf([
        'primary',
        'secondary'
    ]),
    /**
   * The default `input` element value. Use when the component is not controlled.
   */ defaultValue: _propTypesDefault.default.any,
    /**
   * If `true`, the `input` element will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * End `InputAdornment` for this component.
   */ endAdornment: _propTypesDefault.default.node,
    /**
   * If `true`, the input will indicate an error. This is normally obtained via context from
   * FormControl.
   */ error: _propTypesDefault.default.bool,
    /**
   * If `true`, the input will take up the full width of its container.
   */ fullWidth: _propTypesDefault.default.bool,
    /**
   * The id of the `input` element.
   */ id: _propTypesDefault.default.string,
    /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   */ inputComponent: _propTypesDefault.default.elementType,
    /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */ inputProps: _propTypesDefault.default.object,
    /**
   * Pass a ref to the `input` element.
   */ inputRef: _utils.refType,
    /**
   * The label of the input. It is only used for layout. The actual labelling
   * is handled by `InputLabel`. If specified `labelWidth` is ignored.
   */ label: _propTypesDefault.default.node,
    /**
   * The width of the label. Is ignored if `label` is provided. Prefer `label`
   * if the input label appears with a strike through.
   */ labelWidth: _propTypesDefault.default.number,
    /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */ margin: _propTypesDefault.default.oneOf([
        'dense',
        'none'
    ]),
    /**
   * Maximum number of rows to display when multiline option is set to true.
   */ maxRows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * If `true`, a textarea element will be rendered.
   */ multiline: _propTypesDefault.default.bool,
    /**
   * Name attribute of the `input` element.
   */ name: _propTypesDefault.default.string,
    /**
   * If `true`, the outline is notched to accommodate the label.
   */ notched: _propTypesDefault.default.bool,
    /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */ onChange: _propTypesDefault.default.func,
    /**
   * The short hint displayed in the input before the user enters a value.
   */ placeholder: _propTypesDefault.default.string,
    /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */ readOnly: _propTypesDefault.default.bool,
    /**
   * If `true`, the `input` element will be required.
   */ required: _propTypesDefault.default.bool,
    /**
   * Number of rows to display when multiline option is set to true.
   */ rows: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * Start `InputAdornment` for this component.
   */ startAdornment: _propTypesDefault.default.node,
    /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */ type: _propTypesDefault.default.string,
    /**
   * The value of the `input` element, required for a controlled component.
   */ value: _propTypesDefault.default.any
};
OutlinedInput.muiName = 'Input';
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiOutlinedInput'
})(OutlinedInput);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","@material-ui/utils":"Uumnw","../InputBase":"43mUM","./NotchedOutline":"k4Ymh","../styles/withStyles":"3pIr2","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"k4Ymh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _defineProperty = require("@babel/runtime/helpers/esm/defineProperty");
var _definePropertyDefault = parcelHelpers.interopDefault(_defineProperty);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _useTheme = require("../styles/useTheme");
var _useThemeDefault = parcelHelpers.interopDefault(_useTheme);
var _capitalize = require("../utils/capitalize");
var _capitalizeDefault = parcelHelpers.interopDefault(_capitalize);
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            position: 'absolute',
            bottom: 0,
            right: 0,
            top: -5,
            left: 0,
            margin: 0,
            padding: '0 8px',
            pointerEvents: 'none',
            borderRadius: 'inherit',
            borderStyle: 'solid',
            borderWidth: 1,
            overflow: 'hidden'
        },
        /* Styles applied to the legend element when `labelWidth` is provided. */ legend: {
            textAlign: 'left',
            padding: 0,
            lineHeight: '11px',
            // sync with `height` in `legend` styles
            transition: theme.transitions.create('width', {
                duration: 150,
                easing: theme.transitions.easing.easeOut
            })
        },
        /* Styles applied to the legend element. */ legendLabelled: {
            display: 'block',
            width: 'auto',
            textAlign: 'left',
            padding: 0,
            height: 11,
            // sync with `lineHeight` in `legend` styles
            fontSize: '0.75em',
            visibility: 'hidden',
            maxWidth: 0.01,
            transition: theme.transitions.create('max-width', {
                duration: 50,
                easing: theme.transitions.easing.easeOut
            }),
            '& > span': {
                paddingLeft: 5,
                paddingRight: 5,
                display: 'inline-block'
            }
        },
        /* Styles applied to the legend element is notched. */ legendNotched: {
            maxWidth: 1000,
            transition: theme.transitions.create('max-width', {
                duration: 100,
                easing: theme.transitions.easing.easeOut,
                delay: 50
            })
        }
    };
};
/**
 * @ignore - internal component.
 */ var NotchedOutline = /*#__PURE__*/ _react.forwardRef(function NotchedOutline1(props, ref) {
    var children = props.children, classes = props.classes, className = props.className, label = props.label, labelWidthProp = props.labelWidth, notched = props.notched, style = props.style, other = _objectWithoutPropertiesDefault.default(props, [
        "children",
        "classes",
        "className",
        "label",
        "labelWidth",
        "notched",
        "style"
    ]);
    var theme = _useThemeDefault.default();
    var align = theme.direction === 'rtl' ? 'right' : 'left';
    if (label !== undefined) return(/*#__PURE__*/ _react.createElement("fieldset", _extendsDefault.default({
        "aria-hidden": true,
        className: _clsxDefault.default(classes.root, className),
        ref: ref,
        style: style
    }, other), /*#__PURE__*/ _react.createElement("legend", {
        className: _clsxDefault.default(classes.legendLabelled, notched && classes.legendNotched)
    }, label ? /*#__PURE__*/ _react.createElement("span", null, label) : /*#__PURE__*/ _react.createElement("span", {
        dangerouslySetInnerHTML: {
            __html: '&#8203;'
        }
    }))));
    var labelWidth = labelWidthProp > 0 ? labelWidthProp * 0.75 + 8 : 0.01;
    return(/*#__PURE__*/ _react.createElement("fieldset", _extendsDefault.default({
        "aria-hidden": true,
        style: _extendsDefault.default(_definePropertyDefault.default({
        }, "padding".concat(_capitalizeDefault.default(align)), 8), style),
        className: _clsxDefault.default(classes.root, className),
        ref: ref
    }, other), /*#__PURE__*/ _react.createElement("legend", {
        className: classes.legend,
        style: {
            // IE 11: fieldset with legend does not render
            // a border radius. This maintains consistency
            // by always having a legend rendered
            width: notched ? labelWidth : 0.01
        }
    }, /*#__PURE__*/ _react.createElement("span", {
        dangerouslySetInnerHTML: {
            __html: '&#8203;'
        }
    }))));
});
NotchedOutline.propTypes = {
    /**
   * The content of the component.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The label.
   */ label: _propTypesDefault.default.node,
    /**
   * The width of the label.
   */ labelWidth: _propTypesDefault.default.number.isRequired,
    /**
   * If `true`, the outline is notched to accommodate the label.
   */ notched: _propTypesDefault.default.bool.isRequired,
    /**
   * @ignore
   */ style: _propTypesDefault.default.object
};
exports.default = _withStylesDefault.default(styles, {
    name: 'PrivateNotchedOutline'
})(NotchedOutline);

},{"@babel/runtime/helpers/esm/defineProperty":"c51LI","@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","../styles/withStyles":"3pIr2","../styles/useTheme":"jysVY","../utils/capitalize":"4RyDE","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"jysVY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _styles = require("@material-ui/styles");
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _defaultTheme = require("./defaultTheme");
var _defaultThemeDefault = parcelHelpers.interopDefault(_defaultTheme);
function useTheme() {
    var theme = _styles.useTheme() || _defaultThemeDefault.default;
    // eslint-disable-next-line react-hooks/rules-of-hooks
    _reactDefault.default.useDebugValue(theme);
    return theme;
}
exports.default = useTheme;

},{"@material-ui/styles":"lPqjv","react":"cKM0D","./defaultTheme":"l1m84","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"4k6Kc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_inputLabelDefault.default
);
var _inputLabel = require("./InputLabel");
var _inputLabelDefault = parcelHelpers.interopDefault(_inputLabel);

},{"./InputLabel":"btT84","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"btT84":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _formControlState = require("../FormControl/formControlState");
var _formControlStateDefault = parcelHelpers.interopDefault(_formControlState);
var _useFormControl = require("../FormControl/useFormControl");
var _useFormControlDefault = parcelHelpers.interopDefault(_useFormControl);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _formLabel = require("../FormLabel");
var _formLabelDefault = parcelHelpers.interopDefault(_formLabel);
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            display: 'block',
            transformOrigin: 'top left'
        },
        /* Pseudo-class applied to the root element if `focused={true}`. */ focused: {
        },
        /* Pseudo-class applied to the root element if `disabled={true}`. */ disabled: {
        },
        /* Pseudo-class applied to the root element if `error={true}`. */ error: {
        },
        /* Pseudo-class applied to the root element if `required={true}`. */ required: {
        },
        /* Pseudo-class applied to the asterisk element. */ asterisk: {
        },
        /* Styles applied to the root element if the component is a descendant of `FormControl`. */ formControl: {
            position: 'absolute',
            left: 0,
            top: 0,
            // slight alteration to spec spacing to match visual spec result
            transform: 'translate(0, 24px) scale(1)'
        },
        /* Styles applied to the root element if `margin="dense"`. */ marginDense: {
            // Compensation for the `Input.inputDense` style.
            transform: 'translate(0, 21px) scale(1)'
        },
        /* Styles applied to the `input` element if `shrink={true}`. */ shrink: {
            transform: 'translate(0, 1.5px) scale(0.75)',
            transformOrigin: 'top left'
        },
        /* Styles applied to the `input` element if `disableAnimation={false}`. */ animated: {
            transition: theme.transitions.create([
                'color',
                'transform'
            ], {
                duration: theme.transitions.duration.shorter,
                easing: theme.transitions.easing.easeOut
            })
        },
        /* Styles applied to the root element if `variant="filled"`. */ filled: {
            // Chrome's autofill feature gives the input field a yellow background.
            // Since the input field is behind the label in the HTML tree,
            // the input field is drawn last and hides the label with an opaque background color.
            // zIndex: 1 will raise the label above opaque background-colors of input.
            zIndex: 1,
            pointerEvents: 'none',
            transform: 'translate(12px, 20px) scale(1)',
            '&$marginDense': {
                transform: 'translate(12px, 17px) scale(1)'
            },
            '&$shrink': {
                transform: 'translate(12px, 10px) scale(0.75)',
                '&$marginDense': {
                    transform: 'translate(12px, 7px) scale(0.75)'
                }
            }
        },
        /* Styles applied to the root element if `variant="outlined"`. */ outlined: {
            // see comment above on filled.zIndex
            zIndex: 1,
            pointerEvents: 'none',
            transform: 'translate(14px, 20px) scale(1)',
            '&$marginDense': {
                transform: 'translate(14px, 12px) scale(1)'
            },
            '&$shrink': {
                transform: 'translate(14px, -6px) scale(0.75)'
            }
        }
    };
};
var InputLabel = /*#__PURE__*/ _react.forwardRef(function InputLabel1(props, ref) {
    var classes = props.classes, className = props.className, _props$disableAnimati = props.disableAnimation, disableAnimation = _props$disableAnimati === void 0 ? false : _props$disableAnimati, margin = props.margin, shrinkProp = props.shrink, variant = props.variant, other = _objectWithoutPropertiesDefault.default(props, [
        "classes",
        "className",
        "disableAnimation",
        "margin",
        "shrink",
        "variant"
    ]);
    var muiFormControl = _useFormControlDefault.default();
    var shrink = shrinkProp;
    if (typeof shrink === 'undefined' && muiFormControl) shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
    var fcs = _formControlStateDefault.default({
        props: props,
        muiFormControl: muiFormControl,
        states: [
            'margin',
            'variant'
        ]
    });
    return(/*#__PURE__*/ _react.createElement(_formLabelDefault.default, _extendsDefault.default({
        "data-shrink": shrink,
        className: _clsxDefault.default(classes.root, className, muiFormControl && classes.formControl, !disableAnimation && classes.animated, shrink && classes.shrink, fcs.margin === 'dense' && classes.marginDense, {
            'filled': classes.filled,
            'outlined': classes.outlined
        }[fcs.variant]),
        classes: {
            focused: classes.focused,
            disabled: classes.disabled,
            error: classes.error,
            required: classes.required,
            asterisk: classes.asterisk
        },
        ref: ref
    }, other)));
});
InputLabel.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * The contents of the `InputLabel`.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */ color: _propTypesDefault.default.oneOf([
        'primary',
        'secondary'
    ]),
    /**
   * If `true`, the transition animation is disabled.
   */ disableAnimation: _propTypesDefault.default.bool,
    /**
   * If `true`, apply disabled class.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * If `true`, the label will be displayed in an error state.
   */ error: _propTypesDefault.default.bool,
    /**
   * If `true`, the input of this label is focused.
   */ focused: _propTypesDefault.default.bool,
    /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */ margin: _propTypesDefault.default.oneOf([
        'dense'
    ]),
    /**
   * if `true`, the label will indicate that the input is required.
   */ required: _propTypesDefault.default.bool,
    /**
   * If `true`, the label is shrunk.
   */ shrink: _propTypesDefault.default.bool,
    /**
   * The variant to use.
   */ variant: _propTypesDefault.default.oneOf([
        'filled',
        'outlined',
        'standard'
    ])
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiInputLabel'
})(InputLabel);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","../FormControl/formControlState":"hHO4w","../FormControl/useFormControl":"hjPoI","../styles/withStyles":"3pIr2","../FormLabel":"jGKEG","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hjPoI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _formControlContext = require("./FormControlContext");
var _formControlContextDefault = parcelHelpers.interopDefault(_formControlContext);
function useFormControl() {
    return _react.useContext(_formControlContextDefault.default);
}
exports.default = useFormControl;

},{"react":"cKM0D","./FormControlContext":"k2RBZ","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"jGKEG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_formLabelDefault.default
);
var _formLabel = require("./FormLabel");
var _formLabelDefault = parcelHelpers.interopDefault(_formLabel);

},{"./FormLabel":"5lk9d","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5lk9d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _formControlState = require("../FormControl/formControlState");
var _formControlStateDefault = parcelHelpers.interopDefault(_formControlState);
var _useFormControl = require("../FormControl/useFormControl");
var _useFormControlDefault = parcelHelpers.interopDefault(_useFormControl);
var _capitalize = require("../utils/capitalize");
var _capitalizeDefault = parcelHelpers.interopDefault(_capitalize);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: _extendsDefault.default({
            color: theme.palette.text.secondary
        }, theme.typography.body1, {
            lineHeight: 1,
            padding: 0,
            '&$focused': {
                color: theme.palette.primary.main
            },
            '&$disabled': {
                color: theme.palette.text.disabled
            },
            '&$error': {
                color: theme.palette.error.main
            }
        }),
        /* Styles applied to the root element if the color is secondary. */ colorSecondary: {
            '&$focused': {
                color: theme.palette.secondary.main
            }
        },
        /* Pseudo-class applied to the root element if `focused={true}`. */ focused: {
        },
        /* Pseudo-class applied to the root element if `disabled={true}`. */ disabled: {
        },
        /* Pseudo-class applied to the root element if `error={true}`. */ error: {
        },
        /* Pseudo-class applied to the root element if `filled={true}`. */ filled: {
        },
        /* Pseudo-class applied to the root element if `required={true}`. */ required: {
        },
        /* Styles applied to the asterisk element. */ asterisk: {
            '&$error': {
                color: theme.palette.error.main
            }
        }
    };
};
var FormLabel = /*#__PURE__*/ _react.forwardRef(function FormLabel1(props, ref) {
    var children = props.children, classes = props.classes, className = props.className, color = props.color, _props$component = props.component, Component = _props$component === void 0 ? 'label' : _props$component, disabled = props.disabled, error = props.error, filled = props.filled, focused = props.focused, required = props.required, other = _objectWithoutPropertiesDefault.default(props, [
        "children",
        "classes",
        "className",
        "color",
        "component",
        "disabled",
        "error",
        "filled",
        "focused",
        "required"
    ]);
    var muiFormControl = _useFormControlDefault.default();
    var fcs = _formControlStateDefault.default({
        props: props,
        muiFormControl: muiFormControl,
        states: [
            'color',
            'required',
            'focused',
            'disabled',
            'error',
            'filled'
        ]
    });
    return(/*#__PURE__*/ _react.createElement(Component, _extendsDefault.default({
        className: _clsxDefault.default(classes.root, classes["color".concat(_capitalizeDefault.default(fcs.color || 'primary'))], className, fcs.disabled && classes.disabled, fcs.error && classes.error, fcs.filled && classes.filled, fcs.focused && classes.focused, fcs.required && classes.required),
        ref: ref
    }, other), children, fcs.required && /*#__PURE__*/ _react.createElement("span", {
        "aria-hidden": true,
        className: _clsxDefault.default(classes.asterisk, fcs.error && classes.error)
    }, "\u2009", '*')));
});
FormLabel.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * The content of the component.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */ color: _propTypesDefault.default.oneOf([
        'primary',
        'secondary'
    ]),
    /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */ component: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .elementType,
    /**
   * If `true`, the label should be displayed in a disabled state.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * If `true`, the label should be displayed in an error state.
   */ error: _propTypesDefault.default.bool,
    /**
   * If `true`, the label should use filled classes key.
   */ filled: _propTypesDefault.default.bool,
    /**
   * If `true`, the input of this label is focused (used by `FormGroup` components).
   */ focused: _propTypesDefault.default.bool,
    /**
   * If `true`, the label will indicate that the input is required.
   */ required: _propTypesDefault.default.bool
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiFormLabel'
})(FormLabel);

},{"@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@babel/runtime/helpers/esm/extends":"esrVD","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","../FormControl/formControlState":"hHO4w","../FormControl/useFormControl":"hjPoI","../utils/capitalize":"4RyDE","../styles/withStyles":"3pIr2","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8200A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_formControlDefault.default
);
parcelHelpers.export(exports, "useFormControl", ()=>_useFormControlDefault.default
);
var _formControl = require("./FormControl");
var _formControlDefault = parcelHelpers.interopDefault(_formControl);
var _useFormControl = require("./useFormControl");
var _useFormControlDefault = parcelHelpers.interopDefault(_useFormControl);

},{"./FormControl":"brgMB","./useFormControl":"hjPoI","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"brgMB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("../InputBase/utils");
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _capitalize = require("../utils/capitalize");
var _capitalizeDefault = parcelHelpers.interopDefault(_capitalize);
var _isMuiElement = require("../utils/isMuiElement");
var _isMuiElementDefault = parcelHelpers.interopDefault(_isMuiElement);
var _formControlContext = require("./FormControlContext");
var _formControlContextDefault = parcelHelpers.interopDefault(_formControlContext);
var styles = {
    /* Styles applied to the root element. */ root: {
        display: 'inline-flex',
        flexDirection: 'column',
        position: 'relative',
        // Reset fieldset default style.
        minWidth: 0,
        padding: 0,
        margin: 0,
        border: 0,
        verticalAlign: 'top' // Fix alignment issue on Safari.
    },
    /* Styles applied to the root element if `margin="normal"`. */ marginNormal: {
        marginTop: 16,
        marginBottom: 8
    },
    /* Styles applied to the root element if `margin="dense"`. */ marginDense: {
        marginTop: 8,
        marginBottom: 4
    },
    /* Styles applied to the root element if `fullWidth={true}`. */ fullWidth: {
        width: '100%'
    }
};
/**
 * Provides context such as filled/focused/error/required for form inputs.
 * Relying on the context provides high flexibility and ensures that the state always stays
 * consistent across the children of the `FormControl`.
 * This context is used by the following components:
 *
 *  - FormLabel
 *  - FormHelperText
 *  - Input
 *  - InputLabel
 *
 * You can find one composition example below and more going to [the demos](/components/text-fields/#components).
 *
 * ```jsx
 * <FormControl>
 *   <InputLabel htmlFor="my-input">Email address</InputLabel>
 *   <Input id="my-input" aria-describedby="my-helper-text" />
 *   <FormHelperText id="my-helper-text">We'll never share your email.</FormHelperText>
 * </FormControl>
 * ```
 *
 * ⚠️Only one input can be used within a FormControl.
 */ var FormControl = /*#__PURE__*/ _react.forwardRef(function FormControl1(props, ref) {
    var children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? 'primary' : _props$color, _props$component = props.component, Component = _props$component === void 0 ? 'div' : _props$component, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$error = props.error, error = _props$error === void 0 ? false : _props$error, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, visuallyFocused = props.focused, _props$hiddenLabel = props.hiddenLabel, hiddenLabel = _props$hiddenLabel === void 0 ? false : _props$hiddenLabel, _props$margin = props.margin, margin = _props$margin === void 0 ? 'none' : _props$margin, _props$required = props.required, required = _props$required === void 0 ? false : _props$required, size = props.size, _props$variant = props.variant, variant = _props$variant === void 0 ? 'standard' : _props$variant, other = _objectWithoutPropertiesDefault.default(props, [
        "children",
        "classes",
        "className",
        "color",
        "component",
        "disabled",
        "error",
        "fullWidth",
        "focused",
        "hiddenLabel",
        "margin",
        "required",
        "size",
        "variant"
    ]);
    var _React$useState = _react.useState(function() {
        // We need to iterate through the children and find the Input in order
        // to fully support server-side rendering.
        var initialAdornedStart = false;
        if (children) _react.Children.forEach(children, function(child) {
            if (!_isMuiElementDefault.default(child, [
                'Input',
                'Select'
            ])) return;
            var input = _isMuiElementDefault.default(child, [
                'Select'
            ]) ? child.props.input : child;
            if (input && _utils.isAdornedStart(input.props)) initialAdornedStart = true;
        });
        return initialAdornedStart;
    }), adornedStart = _React$useState[0], setAdornedStart = _React$useState[1];
    var _React$useState2 = _react.useState(function() {
        // We need to iterate through the children and find the Input in order
        // to fully support server-side rendering.
        var initialFilled = false;
        if (children) _react.Children.forEach(children, function(child) {
            if (!_isMuiElementDefault.default(child, [
                'Input',
                'Select'
            ])) return;
            if (_utils.isFilled(child.props, true)) initialFilled = true;
        });
        return initialFilled;
    }), filled = _React$useState2[0], setFilled = _React$useState2[1];
    var _React$useState3 = _react.useState(false), _focused = _React$useState3[0], setFocused = _React$useState3[1];
    var focused = visuallyFocused !== undefined ? visuallyFocused : _focused;
    if (disabled && focused) setFocused(false);
    var registerEffect;
    // eslint-disable-next-line react-hooks/rules-of-hooks
    var registeredInput = _react.useRef(false);
    registerEffect = function registerEffect1() {
        if (registeredInput.current) console.error([
            'Material-UI: There are multiple InputBase components inside a FormControl.',
            'This is not supported. It might cause infinite rendering loops.',
            'Only use one InputBase.'
        ].join('\n'));
        registeredInput.current = true;
        return function() {
            registeredInput.current = false;
        };
    };
    var onFilled = _react.useCallback(function() {
        setFilled(true);
    }, []);
    var onEmpty = _react.useCallback(function() {
        setFilled(false);
    }, []);
    var childContext = {
        adornedStart: adornedStart,
        setAdornedStart: setAdornedStart,
        color: color,
        disabled: disabled,
        error: error,
        filled: filled,
        focused: focused,
        fullWidth: fullWidth,
        hiddenLabel: hiddenLabel,
        margin: (size === 'small' ? 'dense' : undefined) || margin,
        onBlur: function onBlur() {
            setFocused(false);
        },
        onEmpty: onEmpty,
        onFilled: onFilled,
        onFocus: function onFocus() {
            setFocused(true);
        },
        registerEffect: registerEffect,
        required: required,
        variant: variant
    };
    return(/*#__PURE__*/ _react.createElement(_formControlContextDefault.default.Provider, {
        value: childContext
    }, /*#__PURE__*/ _react.createElement(Component, _extendsDefault.default({
        className: _clsxDefault.default(classes.root, className, margin !== 'none' && classes["margin".concat(_capitalizeDefault.default(margin))], fullWidth && classes.fullWidth),
        ref: ref
    }, other), children)));
});
FormControl.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * The contents of the form control.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */ color: _propTypesDefault.default.oneOf([
        'primary',
        'secondary'
    ]),
    /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */ component: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .elementType,
    /**
   * If `true`, the label, input and helper text should be displayed in a disabled state.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * If `true`, the label should be displayed in an error state.
   */ error: _propTypesDefault.default.bool,
    /**
   * If `true`, the component will be displayed in focused state.
   */ focused: _propTypesDefault.default.bool,
    /**
   * If `true`, the component will take up the full width of its container.
   */ fullWidth: _propTypesDefault.default.bool,
    /**
   * If `true`, the label will be hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   */ hiddenLabel: _propTypesDefault.default.bool,
    /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   */ margin: _propTypesDefault.default.oneOf([
        'dense',
        'none',
        'normal'
    ]),
    /**
   * If `true`, the label will indicate that the input is required.
   */ required: _propTypesDefault.default.bool,
    /**
   * The size of the text field.
   */ size: _propTypesDefault.default.oneOf([
        'medium',
        'small'
    ]),
    /**
   * The variant to use.
   */ variant: _propTypesDefault.default.oneOf([
        'filled',
        'outlined',
        'standard'
    ])
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiFormControl'
})(FormControl);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","../InputBase/utils":"4cvQH","../styles/withStyles":"3pIr2","../utils/capitalize":"4RyDE","../utils/isMuiElement":"hMgpw","./FormControlContext":"k2RBZ","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hMgpw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
function isMuiElement(element, muiNames) {
    return(/*#__PURE__*/ _react.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1);
}
exports.default = isMuiElement;

},{"react":"cKM0D","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"iLeKI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_formHelperTextDefault.default
);
var _formHelperText = require("./FormHelperText");
var _formHelperTextDefault = parcelHelpers.interopDefault(_formHelperText);

},{"./FormHelperText":"eZvAb","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"eZvAb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _formControlState = require("../FormControl/formControlState");
var _formControlStateDefault = parcelHelpers.interopDefault(_formControlState);
var _useFormControl = require("../FormControl/useFormControl");
var _useFormControlDefault = parcelHelpers.interopDefault(_useFormControl);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: _extendsDefault.default({
            color: theme.palette.text.secondary
        }, theme.typography.caption, {
            textAlign: 'left',
            marginTop: 3,
            margin: 0,
            '&$disabled': {
                color: theme.palette.text.disabled
            },
            '&$error': {
                color: theme.palette.error.main
            }
        }),
        /* Pseudo-class applied to the root element if `error={true}`. */ error: {
        },
        /* Pseudo-class applied to the root element if `disabled={true}`. */ disabled: {
        },
        /* Styles applied to the root element if `margin="dense"`. */ marginDense: {
            marginTop: 4
        },
        /* Styles applied to the root element if `variant="filled"` or `variant="outlined"`. */ contained: {
            marginLeft: 14,
            marginRight: 14
        },
        /* Pseudo-class applied to the root element if `focused={true}`. */ focused: {
        },
        /* Pseudo-class applied to the root element if `filled={true}`. */ filled: {
        },
        /* Pseudo-class applied to the root element if `required={true}`. */ required: {
        }
    };
};
var FormHelperText = /*#__PURE__*/ _react.forwardRef(function FormHelperText1(props, ref) {
    var children = props.children, classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? 'p' : _props$component, disabled = props.disabled, error = props.error, filled = props.filled, focused = props.focused, margin = props.margin, required = props.required, variant = props.variant, other = _objectWithoutPropertiesDefault.default(props, [
        "children",
        "classes",
        "className",
        "component",
        "disabled",
        "error",
        "filled",
        "focused",
        "margin",
        "required",
        "variant"
    ]);
    var muiFormControl = _useFormControlDefault.default();
    var fcs = _formControlStateDefault.default({
        props: props,
        muiFormControl: muiFormControl,
        states: [
            'variant',
            'margin',
            'disabled',
            'error',
            'filled',
            'focused',
            'required'
        ]
    });
    return(/*#__PURE__*/ _react.createElement(Component, _extendsDefault.default({
        className: _clsxDefault.default(classes.root, (fcs.variant === 'filled' || fcs.variant === 'outlined') && classes.contained, className, fcs.disabled && classes.disabled, fcs.error && classes.error, fcs.filled && classes.filled, fcs.focused && classes.focused, fcs.required && classes.required, fcs.margin === 'dense' && classes.marginDense),
        ref: ref
    }, other), children === ' ' ? /*#__PURE__*/ // eslint-disable-next-line react/no-danger
    _react.createElement("span", {
        dangerouslySetInnerHTML: {
            __html: '&#8203;'
        }
    }) : children));
});
FormHelperText.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * The content of the component.
   *
   * If `' '` is provided, the component reserves one line height for displaying a future message.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */ component: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .elementType,
    /**
   * If `true`, the helper text should be displayed in a disabled state.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * If `true`, helper text should be displayed in an error state.
   */ error: _propTypesDefault.default.bool,
    /**
   * If `true`, the helper text should use filled classes key.
   */ filled: _propTypesDefault.default.bool,
    /**
   * If `true`, the helper text should use focused classes key.
   */ focused: _propTypesDefault.default.bool,
    /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */ margin: _propTypesDefault.default.oneOf([
        'dense'
    ]),
    /**
   * If `true`, the helper text should use required classes key.
   */ required: _propTypesDefault.default.bool,
    /**
   * The variant to use.
   */ variant: _propTypesDefault.default.oneOf([
        'filled',
        'outlined',
        'standard'
    ])
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiFormHelperText'
})(FormHelperText);

},{"@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@babel/runtime/helpers/esm/extends":"esrVD","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","../FormControl/formControlState":"hHO4w","../FormControl/useFormControl":"hjPoI","../styles/withStyles":"3pIr2","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"1kFm7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_selectDefault.default
);
var _select = require("./Select");
var _selectDefault = parcelHelpers.interopDefault(_select);

},{"./Select":"idBFw","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"idBFw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _styles = require("@material-ui/styles");
var _selectInput = require("./SelectInput");
var _selectInputDefault = parcelHelpers.interopDefault(_selectInput);
var _formControlState = require("../FormControl/formControlState");
var _formControlStateDefault = parcelHelpers.interopDefault(_formControlState);
var _useFormControl = require("../FormControl/useFormControl");
var _useFormControlDefault = parcelHelpers.interopDefault(_useFormControl);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _arrowDropDown = require("../internal/svg-icons/ArrowDropDown");
var _arrowDropDownDefault = parcelHelpers.interopDefault(_arrowDropDown);
var _input = require("../Input");
var _inputDefault = parcelHelpers.interopDefault(_input);
var _nativeSelect = require("../NativeSelect/NativeSelect");
var _nativeSelectInput = require("../NativeSelect/NativeSelectInput");
var _nativeSelectInputDefault = parcelHelpers.interopDefault(_nativeSelectInput);
var _filledInput = require("../FilledInput");
var _filledInputDefault = parcelHelpers.interopDefault(_filledInput);
var _outlinedInput = require("../OutlinedInput");
var _outlinedInputDefault = parcelHelpers.interopDefault(_outlinedInput);
var styles = _nativeSelect.styles;
var _ref = /*#__PURE__*/ _react.createElement(_inputDefault.default, null);
var _ref2 = /*#__PURE__*/ _react.createElement(_filledInputDefault.default, null);
var Select = /*#__PURE__*/ _react.forwardRef(function Select1(props, ref) {
    var _props$autoWidth = props.autoWidth, autoWidth = _props$autoWidth === void 0 ? false : _props$autoWidth, children = props.children, classes = props.classes, _props$displayEmpty = props.displayEmpty, displayEmpty = _props$displayEmpty === void 0 ? false : _props$displayEmpty, _props$IconComponent = props.IconComponent, IconComponent = _props$IconComponent === void 0 ? _arrowDropDownDefault.default : _props$IconComponent, id = props.id, input = props.input, inputProps = props.inputProps, label = props.label, labelId = props.labelId, _props$labelWidth = props.labelWidth, labelWidth = _props$labelWidth === void 0 ? 0 : _props$labelWidth, MenuProps = props.MenuProps, _props$multiple = props.multiple, multiple = _props$multiple === void 0 ? false : _props$multiple, _props$native = props.native, native = _props$native === void 0 ? false : _props$native, onClose = props.onClose, onOpen = props.onOpen, open = props.open, renderValue = props.renderValue, SelectDisplayProps = props.SelectDisplayProps, _props$variant = props.variant, variantProps = _props$variant === void 0 ? 'standard' : _props$variant, other = _objectWithoutPropertiesDefault.default(props, [
        "autoWidth",
        "children",
        "classes",
        "displayEmpty",
        "IconComponent",
        "id",
        "input",
        "inputProps",
        "label",
        "labelId",
        "labelWidth",
        "MenuProps",
        "multiple",
        "native",
        "onClose",
        "onOpen",
        "open",
        "renderValue",
        "SelectDisplayProps",
        "variant"
    ]);
    var inputComponent = native ? _nativeSelectInputDefault.default : _selectInputDefault.default;
    var muiFormControl = _useFormControlDefault.default();
    var fcs = _formControlStateDefault.default({
        props: props,
        muiFormControl: muiFormControl,
        states: [
            'variant'
        ]
    });
    var variant = fcs.variant || variantProps;
    var InputComponent = input || {
        standard: _ref,
        outlined: /*#__PURE__*/ _react.createElement(_outlinedInputDefault.default, {
            label: label,
            labelWidth: labelWidth
        }),
        filled: _ref2
    }[variant];
    return(/*#__PURE__*/ _react.cloneElement(InputComponent, _extendsDefault.default({
        // Most of the logic is implemented in `SelectInput`.
        // The `Select` component is a simple API wrapper to expose something better to play with.
        inputComponent: inputComponent,
        inputProps: _extendsDefault.default({
            children: children,
            IconComponent: IconComponent,
            variant: variant,
            type: undefined,
            // We render a select. We can ignore the type provided by the `Input`.
            multiple: multiple
        }, native ? {
            id: id
        } : {
            autoWidth: autoWidth,
            displayEmpty: displayEmpty,
            labelId: labelId,
            MenuProps: MenuProps,
            onClose: onClose,
            onOpen: onOpen,
            open: open,
            renderValue: renderValue,
            SelectDisplayProps: _extendsDefault.default({
                id: id
            }, SelectDisplayProps)
        }, inputProps, {
            classes: inputProps ? _styles.mergeClasses({
                baseClasses: classes,
                newClasses: inputProps.classes,
                Component: Select1
            }) : classes
        }, input ? input.props.inputProps : {
        }),
        ref: ref
    }, other)));
});
Select.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   */ autoWidth: _propTypesDefault.default.bool,
    /**
   * The option elements to populate the select with.
   * Can be some `MenuItem` when `native` is false and `option` when `native` is true.
   *
   * ⚠️The `MenuItem` elements **must** be direct descendants when `native` is false.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * The default element value. Use when the component is not controlled.
   */ defaultValue: _propTypesDefault.default.any,
    /**
   * If `true`, a value is displayed even if no items are selected.
   *
   * In order to display a meaningful value, a function should be passed to the `renderValue` prop which returns the value to be displayed when no items are selected.
   * You can only use it when the `native` prop is `false` (default).
   */ displayEmpty: _propTypesDefault.default.bool,
    /**
   * The icon that displays the arrow.
   */ IconComponent: _propTypesDefault.default.elementType,
    /**
   * The `id` of the wrapper element or the `select` element when `native`.
   */ id: _propTypesDefault.default.string,
    /**
   * An `Input` element; does not have to be a material-ui specific `Input`.
   */ input: _propTypesDefault.default.element,
    /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * When `native` is `true`, the attributes are applied on the `select` element.
   */ inputProps: _propTypesDefault.default.object,
    /**
   * See [OutlinedInput#label](/api/outlined-input/#props)
   */ label: _propTypesDefault.default.node,
    /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */ labelId: _propTypesDefault.default.string,
    /**
   * See [OutlinedInput#label](/api/outlined-input/#props)
   */ labelWidth: _propTypesDefault.default.number,
    /**
   * Props applied to the [`Menu`](/api/menu/) element.
   */ MenuProps: _propTypesDefault.default.object,
    /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */ multiple: _propTypesDefault.default.bool,
    /**
   * If `true`, the component will be using a native `select` element.
   */ native: _propTypesDefault.default.bool,
    /**
   * Callback function fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * @param {object} [child] The react element that was selected when `native` is `false` (default).
   */ onChange: _propTypesDefault.default.func,
    /**
   * Callback fired when the component requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */ onClose: _propTypesDefault.default.func,
    /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */ onOpen: _propTypesDefault.default.func,
    /**
   * Control `select` open state.
   * You can only use it when the `native` prop is `false` (default).
   */ open: _propTypesDefault.default.bool,
    /**
   * Render the selected value.
   * You can only use it when the `native` prop is `false` (default).
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */ renderValue: _propTypesDefault.default.func,
    /**
   * Props applied to the clickable div element.
   */ SelectDisplayProps: _propTypesDefault.default.object,
    /**
   * The input value. Providing an empty string will select no options.
   * This prop is required when the `native` prop is `false` (default).
   * Set to an empty string `''` if you don't want any of the available options to be selected.
   *
   * If the value is an object it must have reference equality with the option in order to be selected.
   * If the value is not an object, the string representation must match with the string representation of the option in order to be selected.
   */ value: _propTypesDefault.default.any,
    /**
   * The variant to use.
   */ variant: _propTypesDefault.default.oneOf([
        'filled',
        'outlined',
        'standard'
    ])
};
Select.muiName = 'Select';
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiSelect'
})(Select);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","@material-ui/styles":"lPqjv","./SelectInput":"kjxfj","../FormControl/formControlState":"hHO4w","../FormControl/useFormControl":"hjPoI","../styles/withStyles":"3pIr2","../internal/svg-icons/ArrowDropDown":"8XFSg","../Input":"1b3pY","../NativeSelect/NativeSelect":"6Dkyt","../NativeSelect/NativeSelectInput":"2mvpj","../FilledInput":"XFeMl","../OutlinedInput":"lvlVJ","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"kjxfj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _slicedToArray = require("@babel/runtime/helpers/esm/slicedToArray");
var _slicedToArrayDefault = parcelHelpers.interopDefault(_slicedToArray);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _typeof = require("@babel/runtime/helpers/esm/typeof");
var _typeofDefault = parcelHelpers.interopDefault(_typeof);
var _utils = require("@material-ui/utils");
var _react = require("react");
var _reactIs = require("react-is");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _ownerDocument = require("../utils/ownerDocument");
var _ownerDocumentDefault = parcelHelpers.interopDefault(_ownerDocument);
var _capitalize = require("../utils/capitalize");
var _capitalizeDefault = parcelHelpers.interopDefault(_capitalize);
var _menu = require("../Menu/Menu");
var _menuDefault = parcelHelpers.interopDefault(_menu);
var _utils1 = require("../InputBase/utils");
var _useForkRef = require("../utils/useForkRef");
var _useForkRefDefault = parcelHelpers.interopDefault(_useForkRef);
var _useControlled = require("../utils/useControlled");
var _useControlledDefault = parcelHelpers.interopDefault(_useControlled);
function areEqualValues(a, b) {
    if (_typeofDefault.default(b) === 'object' && b !== null) return a === b;
    return String(a) === String(b);
}
function isEmpty(display) {
    return display == null || typeof display === 'string' && !display.trim();
}
/**
 * @ignore - internal component.
 */ var SelectInput = /*#__PURE__*/ _react.forwardRef(function SelectInput1(props, ref) {
    var ariaLabel = props['aria-label'], autoFocus = props.autoFocus, autoWidth = props.autoWidth, children = props.children, classes = props.classes, className = props.className, defaultValue = props.defaultValue, disabled = props.disabled, displayEmpty = props.displayEmpty, IconComponent = props.IconComponent, inputRefProp = props.inputRef, labelId = props.labelId, _props$MenuProps = props.MenuProps, MenuProps = _props$MenuProps === void 0 ? {
    } : _props$MenuProps, multiple = props.multiple, name = props.name, onBlur = props.onBlur, onChange = props.onChange, onClose = props.onClose, onFocus = props.onFocus, onOpen = props.onOpen, openProp = props.open, readOnly = props.readOnly, renderValue = props.renderValue, _props$SelectDisplayP = props.SelectDisplayProps, SelectDisplayProps = _props$SelectDisplayP === void 0 ? {
    } : _props$SelectDisplayP, tabIndexProp = props.tabIndex, type = props.type, valueProp = props.value, _props$variant = props.variant, variant = _props$variant === void 0 ? 'standard' : _props$variant, other = _objectWithoutPropertiesDefault.default(props, [
        "aria-label",
        "autoFocus",
        "autoWidth",
        "children",
        "classes",
        "className",
        "defaultValue",
        "disabled",
        "displayEmpty",
        "IconComponent",
        "inputRef",
        "labelId",
        "MenuProps",
        "multiple",
        "name",
        "onBlur",
        "onChange",
        "onClose",
        "onFocus",
        "onOpen",
        "open",
        "readOnly",
        "renderValue",
        "SelectDisplayProps",
        "tabIndex",
        "type",
        "value",
        "variant"
    ]);
    var _useControlled1 = _useControlledDefault.default({
        controlled: valueProp,
        default: defaultValue,
        name: 'Select'
    }), _useControlled2 = _slicedToArrayDefault.default(_useControlled1, 2), value = _useControlled2[0], setValue = _useControlled2[1];
    var inputRef = _react.useRef(null);
    var _React$useState = _react.useState(null), displayNode = _React$useState[0], setDisplayNode = _React$useState[1];
    var _React$useRef = _react.useRef(openProp != null), isOpenControlled = _React$useRef.current;
    var _React$useState2 = _react.useState(), menuMinWidthState = _React$useState2[0], setMenuMinWidthState = _React$useState2[1];
    var _React$useState3 = _react.useState(false), openState = _React$useState3[0], setOpenState = _React$useState3[1];
    var handleRef = _useForkRefDefault.default(ref, inputRefProp);
    _react.useImperativeHandle(handleRef, function() {
        return {
            focus: function focus() {
                displayNode.focus();
            },
            node: inputRef.current,
            value: value
        };
    }, [
        displayNode,
        value
    ]);
    _react.useEffect(function() {
        if (autoFocus && displayNode) displayNode.focus();
    }, [
        autoFocus,
        displayNode
    ]);
    _react.useEffect(function() {
        if (displayNode) {
            var label = _ownerDocumentDefault.default(displayNode).getElementById(labelId);
            if (label) {
                var handler = function handler1() {
                    if (getSelection().isCollapsed) displayNode.focus();
                };
                label.addEventListener('click', handler);
                return function() {
                    label.removeEventListener('click', handler);
                };
            }
        }
        return undefined;
    }, [
        labelId,
        displayNode
    ]);
    var update = function update1(open, event) {
        if (open) {
            if (onOpen) onOpen(event);
        } else if (onClose) onClose(event);
        if (!isOpenControlled) {
            setMenuMinWidthState(autoWidth ? null : displayNode.clientWidth);
            setOpenState(open);
        }
    };
    var handleMouseDown = function handleMouseDown1(event) {
        // Ignore everything but left-click
        if (event.button !== 0) return;
         // Hijack the default focus behavior.
        event.preventDefault();
        displayNode.focus();
        update(true, event);
    };
    var handleClose = function handleClose1(event) {
        update(false, event);
    };
    var childrenArray = _react.Children.toArray(children); // Support autofill.
    var handleChange = function handleChange1(event) {
        var index = childrenArray.map(function(child) {
            return child.props.value;
        }).indexOf(event.target.value);
        if (index === -1) return;
        var child = childrenArray[index];
        setValue(child.props.value);
        if (onChange) onChange(event, child);
    };
    var handleItemClick = function handleItemClick1(child) {
        return function(event) {
            if (!multiple) update(false, event);
            var newValue;
            if (multiple) {
                newValue = Array.isArray(value) ? value.slice() : [];
                var itemIndex = value.indexOf(child.props.value);
                if (itemIndex === -1) newValue.push(child.props.value);
                else newValue.splice(itemIndex, 1);
            } else newValue = child.props.value;
            if (child.props.onClick) child.props.onClick(event);
            if (value === newValue) return;
            setValue(newValue);
            if (onChange) {
                event.persist(); // Preact support, target is read only property on a native event.
                Object.defineProperty(event, 'target', {
                    writable: true,
                    value: {
                        value: newValue,
                        name: name
                    }
                });
                onChange(event, child);
            }
        };
    };
    var handleKeyDown = function handleKeyDown1(event) {
        if (!readOnly) {
            var validKeys = [
                ' ',
                'ArrowUp',
                'ArrowDown',
                // https://www.w3.org/TR/wai-aria-practices/examples/listbox/listbox-collapsible.html
                'Enter'
            ];
            if (validKeys.indexOf(event.key) !== -1) {
                event.preventDefault();
                update(true, event);
            }
        }
    };
    var open = displayNode !== null && (isOpenControlled ? openProp : openState);
    var handleBlur = function handleBlur1(event) {
        // if open event.stopImmediatePropagation
        if (!open && onBlur) {
            event.persist(); // Preact support, target is read only property on a native event.
            Object.defineProperty(event, 'target', {
                writable: true,
                value: {
                    value: value,
                    name: name
                }
            });
            onBlur(event);
        }
    };
    delete other['aria-invalid'];
    var display;
    var displaySingle;
    var displayMultiple = [];
    var computeDisplay = false;
    var foundMatch = false; // No need to display any value if the field is empty.
    if (_utils1.isFilled({
        value: value
    }) || displayEmpty) {
        if (renderValue) display = renderValue(value);
        else computeDisplay = true;
    }
    var items = childrenArray.map(function(child) {
        if (!/*#__PURE__*/ _react.isValidElement(child)) return null;
        if (_reactIs.isFragment(child)) console.error([
            "Material-UI: The Select component doesn't accept a Fragment as a child.",
            'Consider providing an array instead.'
        ].join('\n'));
        var selected;
        if (multiple) {
            if (!Array.isArray(value)) throw new Error("Material-UI: The `value` prop must be an array when using the `Select` component with `multiple`.");
            selected = value.some(function(v) {
                return areEqualValues(v, child.props.value);
            });
            if (selected && computeDisplay) displayMultiple.push(child.props.children);
        } else {
            selected = areEqualValues(value, child.props.value);
            if (selected && computeDisplay) displaySingle = child.props.children;
        }
        if (selected) foundMatch = true;
        return(/*#__PURE__*/ _react.cloneElement(child, {
            'aria-selected': selected ? 'true' : undefined,
            onClick: handleItemClick(child),
            onKeyUp: function onKeyUp(event) {
                if (event.key === ' ') // otherwise our MenuItems dispatches a click event
                // it's not behavior of the native <option> and causes
                // the select to close immediately since we open on space keydown
                event.preventDefault();
                if (child.props.onKeyUp) child.props.onKeyUp(event);
            },
            role: 'option',
            selected: selected,
            value: undefined,
            // The value is most likely not a valid HTML attribute.
            'data-value': child.props.value // Instead, we provide it as a data attribute.
        }));
    });
    // eslint-disable-next-line react-hooks/rules-of-hooks
    _react.useEffect(function() {
        if (!foundMatch && !multiple && value !== '') {
            var values = childrenArray.map(function(child) {
                return child.props.value;
            });
            console.warn([
                "Material-UI: You have provided an out-of-range value `".concat(value, "` for the select ").concat(name ? "(name=\"".concat(name, "\") ") : '', "component."),
                "Consider providing a value that matches one of the available options or ''.",
                "The available values are ".concat(values.filter(function(x) {
                    return x != null;
                }).map(function(x) {
                    return "`".concat(x, "`");
                }).join(', ') || '""', ".")
            ].join('\n'));
        }
    }, [
        foundMatch,
        childrenArray,
        multiple,
        name,
        value
    ]);
    if (computeDisplay) display = multiple ? displayMultiple.join(', ') : displaySingle;
     // Avoid performing a layout computation in the render method.
    var menuMinWidth = menuMinWidthState;
    if (!autoWidth && isOpenControlled && displayNode) menuMinWidth = displayNode.clientWidth;
    var tabIndex;
    if (typeof tabIndexProp !== 'undefined') tabIndex = tabIndexProp;
    else tabIndex = disabled ? null : 0;
    var buttonId = SelectDisplayProps.id || (name ? "mui-component-select-".concat(name) : undefined);
    return(/*#__PURE__*/ _react.createElement(_react.Fragment, null, /*#__PURE__*/ _react.createElement("div", _extendsDefault.default({
        className: _clsxDefault.default(classes.root, classes.select, classes.selectMenu, classes[variant], className, disabled && classes.disabled),
        ref: setDisplayNode,
        tabIndex: tabIndex,
        role: "button",
        "aria-disabled": disabled ? 'true' : undefined,
        "aria-expanded": open ? 'true' : undefined,
        "aria-haspopup": "listbox",
        "aria-label": ariaLabel,
        "aria-labelledby": [
            labelId,
            buttonId
        ].filter(Boolean).join(' ') || undefined,
        onKeyDown: handleKeyDown,
        onMouseDown: disabled || readOnly ? null : handleMouseDown,
        onBlur: handleBlur,
        onFocus: onFocus
    }, SelectDisplayProps, {
        // The id is required for proper a11y
        id: buttonId
    }), isEmpty(display) ? /*#__PURE__*/ // eslint-disable-next-line react/no-danger
    _react.createElement("span", {
        dangerouslySetInnerHTML: {
            __html: '&#8203;'
        }
    }) : display), /*#__PURE__*/ _react.createElement("input", _extendsDefault.default({
        value: Array.isArray(value) ? value.join(',') : value,
        name: name,
        ref: inputRef,
        "aria-hidden": true,
        onChange: handleChange,
        tabIndex: -1,
        className: classes.nativeInput,
        autoFocus: autoFocus
    }, other)), /*#__PURE__*/ _react.createElement(IconComponent, {
        className: _clsxDefault.default(classes.icon, classes["icon".concat(_capitalizeDefault.default(variant))], open && classes.iconOpen, disabled && classes.disabled)
    }), /*#__PURE__*/ _react.createElement(_menuDefault.default, _extendsDefault.default({
        id: "menu-".concat(name || ''),
        anchorEl: displayNode,
        open: open,
        onClose: handleClose
    }, MenuProps, {
        MenuListProps: _extendsDefault.default({
            'aria-labelledby': labelId,
            role: 'listbox',
            disableListWrap: true
        }, MenuProps.MenuListProps),
        PaperProps: _extendsDefault.default({
        }, MenuProps.PaperProps, {
            style: _extendsDefault.default({
                minWidth: menuMinWidth
            }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)
        })
    }), items)));
});
SelectInput.propTypes = {
    /**
   * @ignore
   */ 'aria-label': _propTypesDefault.default.string,
    /**
   * @ignore
   */ autoFocus: _propTypesDefault.default.bool,
    /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   */ autoWidth: _propTypesDefault.default.bool,
    /**
   * The option elements to populate the select with.
   * Can be some `<MenuItem>` elements.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object.isRequired,
    /**
   * The CSS class name of the select element.
   */ className: _propTypesDefault.default.string,
    /**
   * The default element value. Use when the component is not controlled.
   */ defaultValue: _propTypesDefault.default.any,
    /**
   * If `true`, the select will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * If `true`, the selected item is displayed even if its value is empty.
   */ displayEmpty: _propTypesDefault.default.bool,
    /**
   * The icon that displays the arrow.
   */ IconComponent: _propTypesDefault.default.elementType.isRequired,
    /**
   * Imperative handle implementing `{ value: T, node: HTMLElement, focus(): void }`
   * Equivalent to `ref`
   */ inputRef: _utils.refType,
    /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */ labelId: _propTypesDefault.default.string,
    /**
   * Props applied to the [`Menu`](/api/menu/) element.
   */ MenuProps: _propTypesDefault.default.object,
    /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */ multiple: _propTypesDefault.default.bool,
    /**
   * Name attribute of the `select` or hidden `input` element.
   */ name: _propTypesDefault.default.string,
    /**
   * @ignore
   */ onBlur: _propTypesDefault.default.func,
    /**
   * Callback function fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * @param {object} [child] The react element that was selected.
   */ onChange: _propTypesDefault.default.func,
    /**
   * Callback fired when the component requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */ onClose: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onFocus: _propTypesDefault.default.func,
    /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */ onOpen: _propTypesDefault.default.func,
    /**
   * Control `select` open state.
   */ open: _propTypesDefault.default.bool,
    /**
   * @ignore
   */ readOnly: _propTypesDefault.default.bool,
    /**
   * Render the selected value.
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */ renderValue: _propTypesDefault.default.func,
    /**
   * Props applied to the clickable div element.
   */ SelectDisplayProps: _propTypesDefault.default.object,
    /**
   * @ignore
   */ tabIndex: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * @ignore
   */ type: _propTypesDefault.default.any,
    /**
   * The input value.
   */ value: _propTypesDefault.default.any,
    /**
   * The variant to use.
   */ variant: _propTypesDefault.default.oneOf([
        'standard',
        'outlined',
        'filled'
    ])
};
exports.default = SelectInput;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/slicedToArray":"cT2nX","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@babel/runtime/helpers/esm/typeof":"sHS2O","@material-ui/utils":"Uumnw","react":"cKM0D","react-is":"gtJo0","prop-types":"lYCp3","clsx":"cS959","../utils/ownerDocument":"jeIVD","../utils/capitalize":"4RyDE","../Menu/Menu":"inVmY","../InputBase/utils":"4cvQH","../utils/useForkRef":"bLpHM","../utils/useControlled":"hpiZY","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"jeIVD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function ownerDocument(node) {
    return node && node.ownerDocument || document;
}
exports.default = ownerDocument;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"inVmY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _reactIs = require("react-is");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _popover = require("../Popover");
var _popoverDefault = parcelHelpers.interopDefault(_popover);
var _menuList = require("../MenuList");
var _menuListDefault = parcelHelpers.interopDefault(_menuList);
var _reactDom = require("react-dom");
var _setRef = require("../utils/setRef");
var _setRefDefault = parcelHelpers.interopDefault(_setRef);
var _useTheme = require("../styles/useTheme");
var _useThemeDefault = parcelHelpers.interopDefault(_useTheme);
var _deprecatedPropType = require("../utils/deprecatedPropType");
var _deprecatedPropTypeDefault = parcelHelpers.interopDefault(_deprecatedPropType);
var RTL_ORIGIN = {
    vertical: 'top',
    horizontal: 'right'
};
var LTR_ORIGIN = {
    vertical: 'top',
    horizontal: 'left'
};
var styles = {
    /* Styles applied to the `Paper` component. */ paper: {
        // specZ: The maximum height of a simple menu should be one or more rows less than the view
        // height. This ensures a tapable area outside of the simple menu with which to dismiss
        // the menu.
        maxHeight: 'calc(100% - 96px)',
        // Add iOS momentum scrolling.
        WebkitOverflowScrolling: 'touch'
    },
    /* Styles applied to the `List` component via `MenuList`. */ list: {
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 0
    }
};
var Menu = /*#__PURE__*/ _react.forwardRef(function Menu1(props, ref) {
    var _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus, children = props.children, classes = props.classes, _props$disableAutoFoc = props.disableAutoFocusItem, disableAutoFocusItem = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc, _props$MenuListProps = props.MenuListProps, MenuListProps = _props$MenuListProps === void 0 ? {
    } : _props$MenuListProps, onClose = props.onClose, onEnteringProp = props.onEntering, open = props.open, _props$PaperProps = props.PaperProps, PaperProps = _props$PaperProps === void 0 ? {
    } : _props$PaperProps, PopoverClasses = props.PopoverClasses, _props$transitionDura = props.transitionDuration, transitionDuration = _props$transitionDura === void 0 ? 'auto' : _props$transitionDura, _props$TransitionProp = props.TransitionProps;
    _props$TransitionProp = _props$TransitionProp === void 0 ? {
    } : _props$TransitionProp;
    var onEntering = _props$TransitionProp.onEntering, TransitionProps = _objectWithoutPropertiesDefault.default(_props$TransitionProp, [
        "onEntering"
    ]), _props$variant = props.variant, variant = _props$variant === void 0 ? 'selectedMenu' : _props$variant, other = _objectWithoutPropertiesDefault.default(props, [
        "autoFocus",
        "children",
        "classes",
        "disableAutoFocusItem",
        "MenuListProps",
        "onClose",
        "onEntering",
        "open",
        "PaperProps",
        "PopoverClasses",
        "transitionDuration",
        "TransitionProps",
        "variant"
    ]);
    var theme = _useThemeDefault.default();
    var autoFocusItem = autoFocus && !disableAutoFocusItem && open;
    var menuListActionsRef = _react.useRef(null);
    var contentAnchorRef = _react.useRef(null);
    var getContentAnchorEl = function getContentAnchorEl1() {
        return contentAnchorRef.current;
    };
    var handleEntering = function handleEntering1(element, isAppearing) {
        if (menuListActionsRef.current) menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
        if (onEnteringProp) onEnteringProp(element, isAppearing);
        if (onEntering) onEntering(element, isAppearing);
    };
    var handleListKeyDown = function handleListKeyDown1(event) {
        if (event.key === 'Tab') {
            event.preventDefault();
            if (onClose) onClose(event, 'tabKeyDown');
        }
    };
    /**
   * the index of the item should receive focus
   * in a `variant="selectedMenu"` it's the first `selected` item
   * otherwise it's the very first item.
   */ var activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead
    // to check if there is a `selected` item. We're looking for the last `selected`
    // item and use the first valid item as a fallback
    _react.Children.map(children, function(child, index) {
        if (!/*#__PURE__*/ _react.isValidElement(child)) return;
        if (_reactIs.isFragment(child)) console.error([
            "Material-UI: The Menu component doesn't accept a Fragment as a child.",
            'Consider providing an array instead.'
        ].join('\n'));
        if (!child.props.disabled) {
            if (variant !== "menu" && child.props.selected) activeItemIndex = index;
            else if (activeItemIndex === -1) activeItemIndex = index;
        }
    });
    var items = _react.Children.map(children, function(child, index) {
        if (index === activeItemIndex) return(/*#__PURE__*/ _react.cloneElement(child, {
            ref: function ref1(instance) {
                // #StrictMode ready
                contentAnchorRef.current = _reactDom.findDOMNode(instance);
                _setRefDefault.default(child.ref, instance);
            }
        }));
        return child;
    });
    return(/*#__PURE__*/ _react.createElement(_popoverDefault.default, _extendsDefault.default({
        getContentAnchorEl: getContentAnchorEl,
        classes: PopoverClasses,
        onClose: onClose,
        TransitionProps: _extendsDefault.default({
            onEntering: handleEntering
        }, TransitionProps),
        anchorOrigin: theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN,
        transformOrigin: theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN,
        PaperProps: _extendsDefault.default({
        }, PaperProps, {
            classes: _extendsDefault.default({
            }, PaperProps.classes, {
                root: classes.paper
            })
        }),
        open: open,
        ref: ref,
        transitionDuration: transitionDuration
    }, other), /*#__PURE__*/ _react.createElement(_menuListDefault.default, _extendsDefault.default({
        onKeyDown: handleListKeyDown,
        actions: menuListActionsRef,
        autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
        autoFocusItem: autoFocusItem,
        variant: variant
    }, MenuListProps, {
        className: _clsxDefault.default(classes.list, MenuListProps.className)
    }), items)));
});
Menu.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * A HTML element, or a function that returns it.
   * It's used to set the position of the menu.
   */ anchorEl: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .oneOfType([_utils.HTMLElementType, _propTypesDefault.default.func
    ]),
    /**
   * If `true` (Default) will focus the `[role="menu"]` if no focusable child is found. Disabled
   * children are not focusable. If you set this prop to `false` focus will be placed
   * on the parent modal container. This has severe accessibility implications
   * and should only be considered if you manage focus otherwise.
   */ autoFocus: _propTypesDefault.default.bool,
    /**
   * Menu contents, normally `MenuItem`s.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * When opening the menu will not focus the active item but the `[role="menu"]`
   * unless `autoFocus` is also set to `false`. Not using the default means not
   * following WAI-ARIA authoring practices. Please be considerate about possible
   * accessibility implications.
   */ disableAutoFocusItem: _propTypesDefault.default.bool,
    /**
   * Props applied to the [`MenuList`](/api/menu-list/) element.
   */ MenuListProps: _propTypesDefault.default.object,
    /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`, `"tabKeyDown"`.
   */ onClose: _propTypesDefault.default.func,
    /**
   * Callback fired before the Menu enters.
   * @deprecated Use the `TransitionProps` prop instead.
   */ onEnter: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the `TransitionProps` prop instead.'),
    /**
   * Callback fired when the Menu has entered.
   * @deprecated Use the `TransitionProps` prop instead.
   */ onEntered: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the `TransitionProps` prop instead.'),
    /**
   * Callback fired when the Menu is entering.
   * @deprecated Use the `TransitionProps` prop instead.
   */ onEntering: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the `TransitionProps` prop instead.'),
    /**
   * Callback fired before the Menu exits.
   * @deprecated Use the `TransitionProps` prop instead.
   */ onExit: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the `TransitionProps` prop instead.'),
    /**
   * Callback fired when the Menu has exited.
   * @deprecated Use the `TransitionProps` prop instead.
   */ onExited: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the `TransitionProps` prop instead.'),
    /**
   * Callback fired when the Menu is exiting.
   * @deprecated Use the `TransitionProps` prop instead.
   */ onExiting: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the `TransitionProps` prop instead.'),
    /**
   * If `true`, the menu is visible.
   */ open: _propTypesDefault.default.bool.isRequired,
    /**
   * @ignore
   */ PaperProps: _propTypesDefault.default.object,
    /**
   * `classes` prop applied to the [`Popover`](/api/popover/) element.
   */ PopoverClasses: _propTypesDefault.default.object,
    /**
   * The length of the transition in `ms`, or 'auto'
   */ transitionDuration: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.oneOf([
            'auto'
        ]),
        _propTypesDefault.default.number,
        _propTypesDefault.default.shape({
            appear: _propTypesDefault.default.number,
            enter: _propTypesDefault.default.number,
            exit: _propTypesDefault.default.number
        })
    ]),
    /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition) component.
   */ TransitionProps: _propTypesDefault.default.object,
    /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   */ variant: _propTypesDefault.default.oneOf([
        'menu',
        'selectedMenu'
    ])
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiMenu'
})(Menu);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","react-is":"gtJo0","prop-types":"lYCp3","clsx":"cS959","@material-ui/utils":"Uumnw","../styles/withStyles":"3pIr2","../Popover":"lAqby","../MenuList":"fhGGr","react-dom":"ezGwg","../utils/setRef":"s1tt1","../styles/useTheme":"jysVY","../utils/deprecatedPropType":"6Zj6s","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"lAqby":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_popoverDefault.default
);
var _popover = require("./Popover");
var _popoverDefault = parcelHelpers.interopDefault(_popover);

},{"./Popover":"gc7Wp","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"gc7Wp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getOffsetTop", ()=>getOffsetTop
);
parcelHelpers.export(exports, "getOffsetLeft", ()=>getOffsetLeft
);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _reactDom = require("react-dom");
var _utils = require("@material-ui/utils");
var _debounce = require("../utils/debounce");
var _debounceDefault = parcelHelpers.interopDefault(_debounce);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _ownerDocument = require("../utils/ownerDocument");
var _ownerDocumentDefault = parcelHelpers.interopDefault(_ownerDocument);
var _ownerWindow = require("../utils/ownerWindow");
var _ownerWindowDefault = parcelHelpers.interopDefault(_ownerWindow);
var _createChainedFunction = require("../utils/createChainedFunction");
var _createChainedFunctionDefault = parcelHelpers.interopDefault(_createChainedFunction);
var _deprecatedPropType = require("../utils/deprecatedPropType");
var _deprecatedPropTypeDefault = parcelHelpers.interopDefault(_deprecatedPropType);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _modal = require("../Modal");
var _modalDefault = parcelHelpers.interopDefault(_modal);
var _grow = require("../Grow");
var _growDefault = parcelHelpers.interopDefault(_grow);
var _paper = require("../Paper");
var _paperDefault = parcelHelpers.interopDefault(_paper);
function getOffsetTop(rect, vertical) {
    var offset = 0;
    if (typeof vertical === 'number') offset = vertical;
    else if (vertical === 'center') offset = rect.height / 2;
    else if (vertical === 'bottom') offset = rect.height;
    return offset;
}
function getOffsetLeft(rect, horizontal) {
    var offset = 0;
    if (typeof horizontal === 'number') offset = horizontal;
    else if (horizontal === 'center') offset = rect.width / 2;
    else if (horizontal === 'right') offset = rect.width;
    return offset;
}
function getTransformOriginValue(transformOrigin) {
    return [
        transformOrigin.horizontal,
        transformOrigin.vertical
    ].map(function(n) {
        return typeof n === 'number' ? "".concat(n, "px") : n;
    }).join(' ');
} // Sum the scrollTop between two elements.
function getScrollParent(parent, child) {
    var element = child;
    var scrollTop = 0;
    while(element && element !== parent){
        element = element.parentElement;
        scrollTop += element.scrollTop;
    }
    return scrollTop;
}
function getAnchorEl(anchorEl) {
    return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
}
var styles = {
    /* Styles applied to the root element. */ root: {
    },
    /* Styles applied to the `Paper` component. */ paper: {
        position: 'absolute',
        overflowY: 'auto',
        overflowX: 'hidden',
        // So we see the popover when it's empty.
        // It's most likely on issue on userland.
        minWidth: 16,
        minHeight: 16,
        maxWidth: 'calc(100% - 32px)',
        maxHeight: 'calc(100% - 32px)',
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 0
    }
};
var Popover = /*#__PURE__*/ _react.forwardRef(function Popover1(props, ref) {
    var action = props.action, anchorEl = props.anchorEl, _props$anchorOrigin = props.anchorOrigin, anchorOrigin = _props$anchorOrigin === void 0 ? {
        vertical: 'top',
        horizontal: 'left'
    } : _props$anchorOrigin, anchorPosition = props.anchorPosition, _props$anchorReferenc = props.anchorReference, anchorReference = _props$anchorReferenc === void 0 ? 'anchorEl' : _props$anchorReferenc, children = props.children, classes = props.classes, className = props.className, containerProp = props.container, _props$elevation = props.elevation, elevation = _props$elevation === void 0 ? 8 : _props$elevation, getContentAnchorEl = props.getContentAnchorEl, _props$marginThreshol = props.marginThreshold, marginThreshold = _props$marginThreshol === void 0 ? 16 : _props$marginThreshol, onEnter = props.onEnter, onEntered = props.onEntered, onEntering = props.onEntering, onExit = props.onExit, onExited = props.onExited, onExiting = props.onExiting, open = props.open, _props$PaperProps = props.PaperProps, PaperProps = _props$PaperProps === void 0 ? {
    } : _props$PaperProps, _props$transformOrigi = props.transformOrigin, transformOrigin = _props$transformOrigi === void 0 ? {
        vertical: 'top',
        horizontal: 'left'
    } : _props$transformOrigi, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? _growDefault.default : _props$TransitionComp, _props$transitionDura = props.transitionDuration, transitionDurationProp = _props$transitionDura === void 0 ? 'auto' : _props$transitionDura, _props$TransitionProp = props.TransitionProps, TransitionProps = _props$TransitionProp === void 0 ? {
    } : _props$TransitionProp, other = _objectWithoutPropertiesDefault.default(props, [
        "action",
        "anchorEl",
        "anchorOrigin",
        "anchorPosition",
        "anchorReference",
        "children",
        "classes",
        "className",
        "container",
        "elevation",
        "getContentAnchorEl",
        "marginThreshold",
        "onEnter",
        "onEntered",
        "onEntering",
        "onExit",
        "onExited",
        "onExiting",
        "open",
        "PaperProps",
        "transformOrigin",
        "TransitionComponent",
        "transitionDuration",
        "TransitionProps"
    ]);
    var paperRef = _react.useRef(); // Returns the top/left offset of the position
    // to attach to on the anchor element (or body if none is provided)
    var getAnchorOffset = _react.useCallback(function(contentAnchorOffset) {
        if (anchorReference === 'anchorPosition') {
            if (!anchorPosition) console.error("Material-UI: You need to provide a `anchorPosition` prop when using <Popover anchorReference=\"anchorPosition\" />.");
            return anchorPosition;
        }
        var resolvedAnchorEl = getAnchorEl(anchorEl); // If an anchor element wasn't provided, just use the parent body element of this Popover
        var anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : _ownerDocumentDefault.default(paperRef.current).body;
        var anchorRect = anchorElement.getBoundingClientRect();
        var box = anchorElement.getBoundingClientRect();
        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) console.warn([
            'Material-UI: The `anchorEl` prop provided to the component is invalid.',
            'The anchor element should be part of the document layout.',
            "Make sure the element is present in the document or that it's not display none."
        ].join('\n'));
        var anchorVertical = contentAnchorOffset === 0 ? anchorOrigin.vertical : 'center';
        return {
            top: anchorRect.top + getOffsetTop(anchorRect, anchorVertical),
            left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
        };
    }, [
        anchorEl,
        anchorOrigin.horizontal,
        anchorOrigin.vertical,
        anchorPosition,
        anchorReference
    ]); // Returns the vertical offset of inner content to anchor the transform on if provided
    var getContentAnchorOffset = _react.useCallback(function(element) {
        var contentAnchorOffset = 0;
        if (getContentAnchorEl && anchorReference === 'anchorEl') {
            var contentAnchorEl = getContentAnchorEl(element);
            if (contentAnchorEl && element.contains(contentAnchorEl)) {
                var scrollTop = getScrollParent(element, contentAnchorEl);
                contentAnchorOffset = contentAnchorEl.offsetTop + contentAnchorEl.clientHeight / 2 - scrollTop || 0;
            } // != the default value
            if (anchorOrigin.vertical !== 'top') console.error([
                'Material-UI: You can not change the default `anchorOrigin.vertical` value ',
                'when also providing the `getContentAnchorEl` prop to the popover component.',
                'Only use one of the two props.',
                "Set `getContentAnchorEl` to `null | undefined` or leave `anchorOrigin.vertical` unchanged."
            ].join('\n'));
        }
        return contentAnchorOffset;
    }, [
        anchorOrigin.vertical,
        anchorReference,
        getContentAnchorEl
    ]); // Return the base transform origin using the element
    // and taking the content anchor offset into account if in use
    var getTransformOrigin = _react.useCallback(function(elemRect) {
        var contentAnchorOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return {
            vertical: getOffsetTop(elemRect, transformOrigin.vertical) + contentAnchorOffset,
            horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
        };
    }, [
        transformOrigin.horizontal,
        transformOrigin.vertical
    ]);
    var getPositioningStyle = _react.useCallback(function(element) {
        // Check if the parent has requested anchoring on an inner content node
        var contentAnchorOffset = getContentAnchorOffset(element);
        var elemRect = {
            width: element.offsetWidth,
            height: element.offsetHeight
        }; // Get the transform origin point on the element itself
        var elemTransformOrigin = getTransformOrigin(elemRect, contentAnchorOffset);
        if (anchorReference === 'none') return {
            top: null,
            left: null,
            transformOrigin: getTransformOriginValue(elemTransformOrigin)
        };
         // Get the offset of of the anchoring element
        var anchorOffset = getAnchorOffset(contentAnchorOffset); // Calculate element positioning
        var top = anchorOffset.top - elemTransformOrigin.vertical;
        var left = anchorOffset.left - elemTransformOrigin.horizontal;
        var bottom = top + elemRect.height;
        var right = left + elemRect.width; // Use the parent window of the anchorEl if provided
        var containerWindow = _ownerWindowDefault.default(getAnchorEl(anchorEl)); // Window thresholds taking required margin into account
        var heightThreshold = containerWindow.innerHeight - marginThreshold;
        var widthThreshold = containerWindow.innerWidth - marginThreshold; // Check if the vertical axis needs shifting
        if (top < marginThreshold) {
            var diff = top - marginThreshold;
            top -= diff;
            elemTransformOrigin.vertical += diff;
        } else if (bottom > heightThreshold) {
            var _diff = bottom - heightThreshold;
            top -= _diff;
            elemTransformOrigin.vertical += _diff;
        }
        if (elemRect.height > heightThreshold && elemRect.height && heightThreshold) console.error([
            'Material-UI: The popover component is too tall.',
            "Some part of it can not be seen on the screen (".concat(elemRect.height - heightThreshold, "px)."),
            'Please consider adding a `max-height` to improve the user-experience.'
        ].join('\n'));
        if (left < marginThreshold) {
            var _diff2 = left - marginThreshold;
            left -= _diff2;
            elemTransformOrigin.horizontal += _diff2;
        } else if (right > widthThreshold) {
            var _diff3 = right - widthThreshold;
            left -= _diff3;
            elemTransformOrigin.horizontal += _diff3;
        }
        return {
            top: "".concat(Math.round(top), "px"),
            left: "".concat(Math.round(left), "px"),
            transformOrigin: getTransformOriginValue(elemTransformOrigin)
        };
    }, [
        anchorEl,
        anchorReference,
        getAnchorOffset,
        getContentAnchorOffset,
        getTransformOrigin,
        marginThreshold
    ]);
    var setPositioningStyles = _react.useCallback(function() {
        var element = paperRef.current;
        if (!element) return;
        var positioning = getPositioningStyle(element);
        if (positioning.top !== null) element.style.top = positioning.top;
        if (positioning.left !== null) element.style.left = positioning.left;
        element.style.transformOrigin = positioning.transformOrigin;
    }, [
        getPositioningStyle
    ]);
    var handleEntering = function handleEntering1(element, isAppearing) {
        if (onEntering) onEntering(element, isAppearing);
        setPositioningStyles();
    };
    var handlePaperRef = _react.useCallback(function(instance) {
        // #StrictMode ready
        paperRef.current = _reactDom.findDOMNode(instance);
    }, []);
    _react.useEffect(function() {
        if (open) setPositioningStyles();
    });
    _react.useImperativeHandle(action, function() {
        return open ? {
            updatePosition: function updatePosition() {
                setPositioningStyles();
            }
        } : null;
    }, [
        open,
        setPositioningStyles
    ]);
    _react.useEffect(function() {
        if (!open) return undefined;
        var handleResize = _debounceDefault.default(function() {
            setPositioningStyles();
        });
        window.addEventListener('resize', handleResize);
        return function() {
            handleResize.clear();
            window.removeEventListener('resize', handleResize);
        };
    }, [
        open,
        setPositioningStyles
    ]);
    var transitionDuration = transitionDurationProp;
    if (transitionDurationProp === 'auto' && !TransitionComponent.muiSupportAuto) transitionDuration = undefined;
     // If the container prop is provided, use that
    // If the anchorEl prop is provided, use its parent body element as the container
    // If neither are provided let the Modal take care of choosing the container
    var container = containerProp || (anchorEl ? _ownerDocumentDefault.default(getAnchorEl(anchorEl)).body : undefined);
    return(/*#__PURE__*/ _react.createElement(_modalDefault.default, _extendsDefault.default({
        container: container,
        open: open,
        ref: ref,
        BackdropProps: {
            invisible: true
        },
        className: _clsxDefault.default(classes.root, className)
    }, other), /*#__PURE__*/ _react.createElement(TransitionComponent, _extendsDefault.default({
        appear: true,
        in: open,
        onEnter: onEnter,
        onEntered: onEntered,
        onExit: onExit,
        onExited: onExited,
        onExiting: onExiting,
        timeout: transitionDuration
    }, TransitionProps, {
        onEntering: _createChainedFunctionDefault.default(handleEntering, TransitionProps.onEntering)
    }), /*#__PURE__*/ _react.createElement(_paperDefault.default, _extendsDefault.default({
        elevation: elevation,
        ref: handlePaperRef
    }, PaperProps, {
        className: _clsxDefault.default(classes.paper, PaperProps.className)
    }), children))));
});
Popover.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * A ref for imperative actions.
   * It currently only supports updatePosition() action.
   */ action: _utils.refType,
    /**
   * A HTML element, or a function that returns it.
   * It's used to set the position of the popover.
   */ anchorEl: _utils.chainPropTypes(_propTypesDefault.default.oneOfType([_utils.HTMLElementType, _propTypesDefault.default.func
    ]), function(props) {
        if (props.open && (!props.anchorReference || props.anchorReference === 'anchorEl')) {
            var resolvedAnchorEl = getAnchorEl(props.anchorEl);
            if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
                var box = resolvedAnchorEl.getBoundingClientRect();
                if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) return new Error([
                    'Material-UI: The `anchorEl` prop provided to the component is invalid.',
                    'The anchor element should be part of the document layout.',
                    "Make sure the element is present in the document or that it's not display none."
                ].join('\n'));
            } else return new Error([
                'Material-UI: The `anchorEl` prop provided to the component is invalid.',
                "It should be an Element instance but it's `".concat(resolvedAnchorEl, "` instead.")
            ].join('\n'));
        }
        return null;
    }),
    /**
   * This is the point on the anchor where the popover's
   * `anchorEl` will attach to. This is not used when the
   * anchorReference is 'anchorPosition'.
   *
   * Options:
   * vertical: [top, center, bottom];
   * horizontal: [left, center, right].
   */ anchorOrigin: _propTypesDefault.default.shape({
        horizontal: _propTypesDefault.default.oneOfType([
            _propTypesDefault.default.oneOf([
                'center',
                'left',
                'right'
            ]),
            _propTypesDefault.default.number
        ]).isRequired,
        vertical: _propTypesDefault.default.oneOfType([
            _propTypesDefault.default.oneOf([
                'bottom',
                'center',
                'top'
            ]),
            _propTypesDefault.default.number
        ]).isRequired
    }),
    /**
   * This is the position that may be used
   * to set the position of the popover.
   * The coordinates are relative to
   * the application's client area.
   */ anchorPosition: _propTypesDefault.default.shape({
        left: _propTypesDefault.default.number.isRequired,
        top: _propTypesDefault.default.number.isRequired
    }),
    /**
   * This determines which anchor prop to refer to to set
   * the position of the popover.
   */ anchorReference: _propTypesDefault.default.oneOf([
        'anchorEl',
        'anchorPosition',
        'none'
    ]),
    /**
   * The content of the component.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * A HTML element, component instance, or function that returns either.
   * The `container` will passed to the Modal component.
   *
   * By default, it uses the body of the anchorEl's top-level document object,
   * so it's simply `document.body` most of the time.
   */ container: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .oneOfType([_utils.HTMLElementType, _propTypesDefault.default.instanceOf(_react.Component),
        _propTypesDefault.default.func
    ]),
    /**
   * The elevation of the popover.
   */ elevation: _propTypesDefault.default.number,
    /**
   * This function is called in order to retrieve the content anchor element.
   * It's the opposite of the `anchorEl` prop.
   * The content anchor element should be an element inside the popover.
   * It's used to correctly scroll and set the position of the popover.
   * The positioning strategy tries to make the content anchor element just above the
   * anchor element.
   */ getContentAnchorEl: _propTypesDefault.default.func,
    /**
   * Specifies how close to the edge of the window the popover can appear.
   */ marginThreshold: _propTypesDefault.default.number,
    /**
   * Callback fired when the component requests to be closed.
   */ onClose: _propTypesDefault.default.func,
    /**
   * Callback fired before the component is entering.
   * @deprecated Use the `TransitionProps` prop instead.
   */ onEnter: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the `TransitionProps` prop instead.'),
    /**
   * Callback fired when the component has entered.
   * @deprecated Use the `TransitionProps` prop instead.
   */ onEntered: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the `TransitionProps` prop instead.'),
    /**
   * Callback fired when the component is entering.
   * @deprecated Use the `TransitionProps` prop instead.
   */ onEntering: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the `TransitionProps` prop instead.'),
    /**
   * Callback fired before the component is exiting.
   * @deprecated Use the `TransitionProps` prop instead.
   */ onExit: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the `TransitionProps` prop instead.'),
    /**
   * Callback fired when the component has exited.
   * @deprecated Use the `TransitionProps` prop instead.
   */ onExited: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the `TransitionProps` prop instead.'),
    /**
   * Callback fired when the component is exiting.
   * @deprecated Use the `TransitionProps` prop instead.
   */ onExiting: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the `TransitionProps` prop instead.'),
    /**
   * If `true`, the popover is visible.
   */ open: _propTypesDefault.default.bool.isRequired,
    /**
   * Props applied to the [`Paper`](/api/paper/) element.
   */ PaperProps: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .shape({
        component: _utils.elementTypeAcceptingRef
    }),
    /**
   * This is the point on the popover which
   * will attach to the anchor's origin.
   *
   * Options:
   * vertical: [top, center, bottom, x(px)];
   * horizontal: [left, center, right, x(px)].
   */ transformOrigin: _propTypesDefault.default.shape({
        horizontal: _propTypesDefault.default.oneOfType([
            _propTypesDefault.default.oneOf([
                'center',
                'left',
                'right'
            ]),
            _propTypesDefault.default.number
        ]).isRequired,
        vertical: _propTypesDefault.default.oneOfType([
            _propTypesDefault.default.oneOf([
                'bottom',
                'center',
                'top'
            ]),
            _propTypesDefault.default.number
        ]).isRequired
    }),
    /**
   * The component used for the transition.
   * [Follow this guide](/components/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   */ TransitionComponent: _propTypesDefault.default.elementType,
    /**
   * Set to 'auto' to automatically calculate transition time based on height.
   */ transitionDuration: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.oneOf([
            'auto'
        ]),
        _propTypesDefault.default.number,
        _propTypesDefault.default.shape({
            appear: _propTypesDefault.default.number,
            enter: _propTypesDefault.default.number,
            exit: _propTypesDefault.default.number
        })
    ]),
    /**
   * Props applied to the [`Transition`](http://reactcommunity.org/react-transition-group/transition#Transition-props) element.
   */ TransitionProps: _propTypesDefault.default.object
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiPopover'
})(Popover);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","react-dom":"ezGwg","@material-ui/utils":"Uumnw","../utils/debounce":"9S1vL","clsx":"cS959","../utils/ownerDocument":"jeIVD","../utils/ownerWindow":"6ek2F","../utils/createChainedFunction":"annRX","../utils/deprecatedPropType":"6Zj6s","../styles/withStyles":"3pIr2","../Modal":"3jVxn","../Grow":"adzIq","../Paper":"ifp4E","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"6ek2F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _ownerDocument = require("./ownerDocument");
var _ownerDocumentDefault = parcelHelpers.interopDefault(_ownerDocument);
function ownerWindow(node) {
    var doc = _ownerDocumentDefault.default(node);
    return doc.defaultView || window;
}
exports.default = ownerWindow;

},{"./ownerDocument":"jeIVD","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"annRX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function createChainedFunction() {
    for(var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++)funcs[_key] = arguments[_key];
    return funcs.reduce(function(acc, func) {
        if (func == null) return acc;
        if (typeof func !== 'function') console.error('Material-UI: Invalid Argument Type, must only provide functions, undefined, or null.');
        return function chainedFunction() {
            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];
            acc.apply(this, args);
            func.apply(this, args);
        };
    }, function() {
    });
}
exports.default = createChainedFunction;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"3jVxn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_modalDefault.default
);
parcelHelpers.export(exports, "ModalManager", ()=>_modalManagerDefault.default
);
var _modal = require("./Modal");
var _modalDefault = parcelHelpers.interopDefault(_modal);
var _modalManager = require("./ModalManager");
var _modalManagerDefault = parcelHelpers.interopDefault(_modalManager);

},{"./Modal":"esyyE","./ModalManager":"fqpmV","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"esyyE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _react = require("react");
var _reactDom = require("react-dom");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _styles = require("@material-ui/styles");
var _utils = require("@material-ui/utils");
var _deprecatedPropType = require("../utils/deprecatedPropType");
var _deprecatedPropTypeDefault = parcelHelpers.interopDefault(_deprecatedPropType);
var _ownerDocument = require("../utils/ownerDocument");
var _ownerDocumentDefault = parcelHelpers.interopDefault(_ownerDocument);
var _portal = require("../Portal");
var _portalDefault = parcelHelpers.interopDefault(_portal);
var _createChainedFunction = require("../utils/createChainedFunction");
var _createChainedFunctionDefault = parcelHelpers.interopDefault(_createChainedFunction);
var _useForkRef = require("../utils/useForkRef");
var _useForkRefDefault = parcelHelpers.interopDefault(_useForkRef);
var _useEventCallback = require("../utils/useEventCallback");
var _useEventCallbackDefault = parcelHelpers.interopDefault(_useEventCallback);
var _zIndex = require("../styles/zIndex");
var _zIndexDefault = parcelHelpers.interopDefault(_zIndex);
var _modalManager = require("./ModalManager");
var _modalManagerDefault = parcelHelpers.interopDefault(_modalManager);
var _unstableTrapFocus = require("../Unstable_TrapFocus");
var _unstableTrapFocusDefault = parcelHelpers.interopDefault(_unstableTrapFocus);
var _simpleBackdrop = require("./SimpleBackdrop");
var _simpleBackdropDefault = parcelHelpers.interopDefault(_simpleBackdrop);
function getContainer(container) {
    container = typeof container === 'function' ? container() : container;
    return _reactDom.findDOMNode(container);
}
function getHasTransition(props) {
    return props.children ? props.children.props.hasOwnProperty('in') : false;
} // A modal manager used to track and manage the state of open Modals.
// Modals don't open on the server so this won't conflict with concurrent requests.
var defaultManager = new _modalManagerDefault.default();
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            position: 'fixed',
            zIndex: theme.zIndex.modal,
            right: 0,
            bottom: 0,
            top: 0,
            left: 0
        },
        /* Styles applied to the root element if the `Modal` has exited. */ hidden: {
            visibility: 'hidden'
        }
    };
};
/**
 * Modal is a lower-level construct that is leveraged by the following components:
 *
 * - [Dialog](/api/dialog/)
 * - [Drawer](/api/drawer/)
 * - [Menu](/api/menu/)
 * - [Popover](/api/popover/)
 *
 * If you are creating a modal dialog, you probably want to use the [Dialog](/api/dialog/) component
 * rather than directly using Modal.
 *
 * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).
 */ var Modal = /*#__PURE__*/ _react.forwardRef(function Modal1(inProps, ref) {
    var theme = _styles.useTheme();
    var props = _styles.getThemeProps({
        name: 'MuiModal',
        props: _extendsDefault.default({
        }, inProps),
        theme: theme
    });
    var _props$BackdropCompon = props.BackdropComponent, BackdropComponent = _props$BackdropCompon === void 0 ? _simpleBackdropDefault.default : _props$BackdropCompon, BackdropProps = props.BackdropProps, children = props.children, _props$closeAfterTran = props.closeAfterTransition, closeAfterTransition = _props$closeAfterTran === void 0 ? false : _props$closeAfterTran, container = props.container, _props$disableAutoFoc = props.disableAutoFocus, disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc, _props$disableBackdro = props.disableBackdropClick, disableBackdropClick = _props$disableBackdro === void 0 ? false : _props$disableBackdro, _props$disableEnforce = props.disableEnforceFocus, disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce, _props$disableEscapeK = props.disableEscapeKeyDown, disableEscapeKeyDown = _props$disableEscapeK === void 0 ? false : _props$disableEscapeK, _props$disablePortal = props.disablePortal, disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal, _props$disableRestore = props.disableRestoreFocus, disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore, _props$disableScrollL = props.disableScrollLock, disableScrollLock = _props$disableScrollL === void 0 ? false : _props$disableScrollL, _props$hideBackdrop = props.hideBackdrop, hideBackdrop = _props$hideBackdrop === void 0 ? false : _props$hideBackdrop, _props$keepMounted = props.keepMounted, keepMounted = _props$keepMounted === void 0 ? false : _props$keepMounted, _props$manager = props.manager, manager = _props$manager === void 0 ? defaultManager : _props$manager, onBackdropClick = props.onBackdropClick, onClose = props.onClose, onEscapeKeyDown = props.onEscapeKeyDown, onRendered = props.onRendered, open = props.open, other = _objectWithoutPropertiesDefault.default(props, [
        "BackdropComponent",
        "BackdropProps",
        "children",
        "closeAfterTransition",
        "container",
        "disableAutoFocus",
        "disableBackdropClick",
        "disableEnforceFocus",
        "disableEscapeKeyDown",
        "disablePortal",
        "disableRestoreFocus",
        "disableScrollLock",
        "hideBackdrop",
        "keepMounted",
        "manager",
        "onBackdropClick",
        "onClose",
        "onEscapeKeyDown",
        "onRendered",
        "open"
    ]);
    var _React$useState = _react.useState(true), exited = _React$useState[0], setExited = _React$useState[1];
    var modal = _react.useRef({
    });
    var mountNodeRef = _react.useRef(null);
    var modalRef = _react.useRef(null);
    var handleRef = _useForkRefDefault.default(modalRef, ref);
    var hasTransition = getHasTransition(props);
    var getDoc = function getDoc1() {
        return _ownerDocumentDefault.default(mountNodeRef.current);
    };
    var getModal = function getModal1() {
        modal.current.modalRef = modalRef.current;
        modal.current.mountNode = mountNodeRef.current;
        return modal.current;
    };
    var handleMounted = function handleMounted1() {
        manager.mount(getModal(), {
            disableScrollLock: disableScrollLock
        }); // Fix a bug on Chrome where the scroll isn't initially 0.
        modalRef.current.scrollTop = 0;
    };
    var handleOpen = _useEventCallbackDefault.default(function() {
        var resolvedContainer = getContainer(container) || getDoc().body;
        manager.add(getModal(), resolvedContainer); // The element was already mounted.
        if (modalRef.current) handleMounted();
    });
    var isTopModal = _react.useCallback(function() {
        return manager.isTopModal(getModal());
    }, [
        manager
    ]);
    var handlePortalRef = _useEventCallbackDefault.default(function(node) {
        mountNodeRef.current = node;
        if (!node) return;
        if (onRendered) onRendered();
        if (open && isTopModal()) handleMounted();
        else _modalManager.ariaHidden(modalRef.current, true);
    });
    var handleClose = _react.useCallback(function() {
        manager.remove(getModal());
    }, [
        manager
    ]);
    _react.useEffect(function() {
        return function() {
            handleClose();
        };
    }, [
        handleClose
    ]);
    _react.useEffect(function() {
        if (open) handleOpen();
        else if (!hasTransition || !closeAfterTransition) handleClose();
    }, [
        open,
        handleClose,
        hasTransition,
        closeAfterTransition,
        handleOpen
    ]);
    if (!keepMounted && !open && (!hasTransition || exited)) return null;
    var handleEnter = function handleEnter1() {
        setExited(false);
    };
    var handleExited = function handleExited1() {
        setExited(true);
        if (closeAfterTransition) handleClose();
    };
    var handleBackdropClick = function handleBackdropClick1(event) {
        if (event.target !== event.currentTarget) return;
        if (onBackdropClick) onBackdropClick(event);
        if (!disableBackdropClick && onClose) onClose(event, 'backdropClick');
    };
    var handleKeyDown = function handleKeyDown1(event) {
        // The handler doesn't take event.defaultPrevented into account:
        //
        // event.preventDefault() is meant to stop default behaviours like
        // clicking a checkbox to check it, hitting a button to submit a form,
        // and hitting left arrow to move the cursor in a text input etc.
        // Only special HTML elements have these default behaviors.
        if (event.key !== 'Escape' || !isTopModal()) return;
        if (onEscapeKeyDown) onEscapeKeyDown(event);
        if (!disableEscapeKeyDown) {
            // Swallow the event, in case someone is listening for the escape key on the body.
            event.stopPropagation();
            if (onClose) onClose(event, 'escapeKeyDown');
        }
    };
    var inlineStyle = styles(theme || {
        zIndex: _zIndexDefault.default
    });
    var childProps = {
    };
    if (children.props.tabIndex === undefined) childProps.tabIndex = children.props.tabIndex || '-1';
     // It's a Transition like component
    if (hasTransition) {
        childProps.onEnter = _createChainedFunctionDefault.default(handleEnter, children.props.onEnter);
        childProps.onExited = _createChainedFunctionDefault.default(handleExited, children.props.onExited);
    }
    return(/*#__PURE__*/ _react.createElement(_portalDefault.default, {
        ref: handlePortalRef,
        container: container,
        disablePortal: disablePortal
    }, /*#__PURE__*/ _react.createElement("div", _extendsDefault.default({
        ref: handleRef,
        onKeyDown: handleKeyDown,
        role: "presentation"
    }, other, {
        style: _extendsDefault.default({
        }, inlineStyle.root, !open && exited ? inlineStyle.hidden : {
        }, other.style)
    }), hideBackdrop ? null : /*#__PURE__*/ _react.createElement(BackdropComponent, _extendsDefault.default({
        open: open,
        onClick: handleBackdropClick
    }, BackdropProps)), /*#__PURE__*/ _react.createElement(_unstableTrapFocusDefault.default, {
        disableEnforceFocus: disableEnforceFocus,
        disableAutoFocus: disableAutoFocus,
        disableRestoreFocus: disableRestoreFocus,
        getDoc: getDoc,
        isEnabled: isTopModal,
        open: open
    }, /*#__PURE__*/ _react.cloneElement(children, childProps)))));
});
Modal.propTypes = {
    /**
   * A backdrop component. This prop enables custom backdrop rendering.
   */ BackdropComponent: _propTypesDefault.default.elementType,
    /**
   * Props applied to the [`Backdrop`](/api/backdrop/) element.
   */ BackdropProps: _propTypesDefault.default.object,
    /**
   * A single child content element.
   */ children: _utils.elementAcceptingRef.isRequired,
    /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   */ closeAfterTransition: _propTypesDefault.default.bool,
    /**
   * A HTML element, component instance, or function that returns either.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */ container: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .oneOfType([_utils.HTMLElementType, _propTypesDefault.default.instanceOf(_react.Component),
        _propTypesDefault.default.func
    ]),
    /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   */ disableAutoFocus: _propTypesDefault.default.bool,
    /**
   * If `true`, clicking the backdrop will not fire `onClose`.
   */ disableBackdropClick: _deprecatedPropTypeDefault.default(_propTypesDefault.default.bool, 'Use the onClose prop with the `reason` argument to filter the `backdropClick` events.'),
    /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   */ disableEnforceFocus: _propTypesDefault.default.bool,
    /**
   * If `true`, hitting escape will not fire `onClose`.
   */ disableEscapeKeyDown: _propTypesDefault.default.bool,
    /**
   * Disable the portal behavior.
   * The children stay within it's parent DOM hierarchy.
   */ disablePortal: _propTypesDefault.default.bool,
    /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden.
   */ disableRestoreFocus: _propTypesDefault.default.bool,
    /**
   * Disable the scroll lock behavior.
   */ disableScrollLock: _propTypesDefault.default.bool,
    /**
   * If `true`, the backdrop is not rendered.
   */ hideBackdrop: _propTypesDefault.default.bool,
    /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   */ keepMounted: _propTypesDefault.default.bool,
    /**
   * @ignore
   */ manager: _propTypesDefault.default.object,
    /**
   * Callback fired when the backdrop is clicked.
   */ onBackdropClick: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the onClose prop with the `reason` argument to handle the `backdropClick` events.'),
    /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */ onClose: _propTypesDefault.default.func,
    /**
   * Callback fired when the escape key is pressed,
   * `disableEscapeKeyDown` is false and the modal is in focus.
   */ onEscapeKeyDown: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the onClose prop with the `reason` argument to handle the `escapeKeyDown` events.'),
    /**
   * Callback fired once the children has been mounted into the `container`.
   * It signals that the `open={true}` prop took effect.
   *
   * This prop will be removed in v5, the ref can be used instead.
   */ onRendered: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the ref instead.'),
    /**
   * If `true`, the modal is open.
   */ open: _propTypesDefault.default.bool.isRequired
};
exports.default = Modal;

},{"@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@babel/runtime/helpers/esm/extends":"esrVD","react":"cKM0D","react-dom":"ezGwg","prop-types":"lYCp3","@material-ui/styles":"lPqjv","@material-ui/utils":"Uumnw","../utils/deprecatedPropType":"6Zj6s","../utils/ownerDocument":"jeIVD","../Portal":"5rh53","../utils/createChainedFunction":"annRX","../utils/useForkRef":"bLpHM","../utils/useEventCallback":"dZ8YH","../styles/zIndex":"9eg4Q","./ModalManager":"fqpmV","../Unstable_TrapFocus":"hO5i1","./SimpleBackdrop":"5fXPG","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5rh53":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_portalDefault.default
);
var _portal = require("./Portal");
var _portalDefault = parcelHelpers.interopDefault(_portal);

},{"./Portal":"3hTqn","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"3hTqn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _reactDom = require("react-dom");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _utils = require("@material-ui/utils");
var _deprecatedPropType = require("../utils/deprecatedPropType");
var _deprecatedPropTypeDefault = parcelHelpers.interopDefault(_deprecatedPropType);
var _setRef = require("../utils/setRef");
var _setRefDefault = parcelHelpers.interopDefault(_setRef);
var _useForkRef = require("../utils/useForkRef");
var _useForkRefDefault = parcelHelpers.interopDefault(_useForkRef);
function getContainer(container) {
    container = typeof container === 'function' ? container() : container; // #StrictMode ready
    return _reactDom.findDOMNode(container);
}
var useEnhancedEffect = typeof window !== 'undefined' ? _react.useLayoutEffect : _react.useEffect;
/**
 * Portals provide a first-class way to render children into a DOM node
 * that exists outside the DOM hierarchy of the parent component.
 */ var Portal = /*#__PURE__*/ _react.forwardRef(function Portal1(props, ref) {
    var children = props.children, container = props.container, _props$disablePortal = props.disablePortal, disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal, onRendered = props.onRendered;
    var _React$useState = _react.useState(null), mountNode = _React$useState[0], setMountNode = _React$useState[1];
    var handleRef = _useForkRefDefault.default(/*#__PURE__*/ _react.isValidElement(children) ? children.ref : null, ref);
    useEnhancedEffect(function() {
        if (!disablePortal) setMountNode(getContainer(container) || document.body);
    }, [
        container,
        disablePortal
    ]);
    useEnhancedEffect(function() {
        if (mountNode && !disablePortal) {
            _setRefDefault.default(ref, mountNode);
            return function() {
                _setRefDefault.default(ref, null);
            };
        }
        return undefined;
    }, [
        ref,
        mountNode,
        disablePortal
    ]);
    useEnhancedEffect(function() {
        if (onRendered && (mountNode || disablePortal)) onRendered();
    }, [
        onRendered,
        mountNode,
        disablePortal
    ]);
    if (disablePortal) {
        if (/*#__PURE__*/ _react.isValidElement(children)) return(/*#__PURE__*/ _react.cloneElement(children, {
            ref: handleRef
        }));
        return children;
    }
    return mountNode ? /*#__PURE__*/ _reactDom.createPortal(children, mountNode) : mountNode;
});
Portal.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * The children to render into the `container`.
   */ children: _propTypesDefault.default.node,
    /**
   * A HTML element, component instance, or function that returns either.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */ container: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .oneOfType([_utils.HTMLElementType, _propTypesDefault.default.instanceOf(_react.Component),
        _propTypesDefault.default.func
    ]),
    /**
   * Disable the portal behavior.
   * The children stay within it's parent DOM hierarchy.
   */ disablePortal: _propTypesDefault.default.bool,
    /**
   * Callback fired once the children has been mounted into the `container`.
   *
   * This prop will be removed in v5, the ref can be used instead.
   * @deprecated Use the ref instead.
   */ onRendered: _deprecatedPropTypeDefault.default(_propTypesDefault.default.func, 'Use the ref instead.')
};
// eslint-disable-next-line
Portal['propTypes' + ''] = _utils.exactProp(Portal.propTypes);
exports.default = Portal;

},{"react":"cKM0D","react-dom":"ezGwg","prop-types":"lYCp3","@material-ui/utils":"Uumnw","../utils/deprecatedPropType":"6Zj6s","../utils/setRef":"s1tt1","../utils/useForkRef":"bLpHM","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"dZ8YH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var useEnhancedEffect = typeof window !== 'undefined' ? _react.useLayoutEffect : _react.useEffect;
function useEventCallback(fn) {
    var ref = _react.useRef(fn);
    useEnhancedEffect(function() {
        ref.current = fn;
    });
    return _react.useCallback(function() {
        return ref.current.apply(void 0, arguments);
    }, []);
}
exports.default = useEventCallback;

},{"react":"cKM0D","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"fqpmV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ariaHidden", ()=>ariaHidden
);
parcelHelpers.export(exports, "default", ()=>ModalManager
);
var _classCallCheck = require("@babel/runtime/helpers/esm/classCallCheck");
var _classCallCheckDefault = parcelHelpers.interopDefault(_classCallCheck);
var _createClass = require("@babel/runtime/helpers/esm/createClass");
var _createClassDefault = parcelHelpers.interopDefault(_createClass);
var _toConsumableArray = require("@babel/runtime/helpers/esm/toConsumableArray");
var _toConsumableArrayDefault = parcelHelpers.interopDefault(_toConsumableArray);
var _getScrollbarSize = require("../utils/getScrollbarSize");
var _getScrollbarSizeDefault = parcelHelpers.interopDefault(_getScrollbarSize);
var _ownerDocument = require("../utils/ownerDocument");
var _ownerDocumentDefault = parcelHelpers.interopDefault(_ownerDocument);
var _ownerWindow = require("../utils/ownerWindow"); // Is a vertical scrollbar displayed?
var _ownerWindowDefault = parcelHelpers.interopDefault(_ownerWindow);
function isOverflowing(container) {
    var doc = _ownerDocumentDefault.default(container);
    if (doc.body === container) return _ownerWindowDefault.default(doc).innerWidth > doc.documentElement.clientWidth;
    return container.scrollHeight > container.clientHeight;
}
function ariaHidden(node, show) {
    if (show) node.setAttribute('aria-hidden', 'true');
    else node.removeAttribute('aria-hidden');
}
function getPaddingRight(node) {
    return parseInt(window.getComputedStyle(node)['padding-right'], 10) || 0;
}
function ariaHiddenSiblings(container, mountNode, currentNode) {
    var nodesToExclude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    var show = arguments.length > 4 ? arguments[4] : undefined;
    var blacklist = [
        mountNode,
        currentNode
    ].concat(_toConsumableArrayDefault.default(nodesToExclude));
    var blacklistTagNames = [
        'TEMPLATE',
        'SCRIPT',
        'STYLE'
    ];
    [].forEach.call(container.children, function(node) {
        if (node.nodeType === 1 && blacklist.indexOf(node) === -1 && blacklistTagNames.indexOf(node.tagName) === -1) ariaHidden(node, show);
    });
}
function findIndexOf(containerInfo, callback) {
    var idx = -1;
    containerInfo.some(function(item, index) {
        if (callback(item)) {
            idx = index;
            return true;
        }
        return false;
    });
    return idx;
}
function handleContainer(containerInfo, props) {
    var restoreStyle = [];
    var restorePaddings = [];
    var container = containerInfo.container;
    var fixedNodes;
    if (!props.disableScrollLock) {
        if (isOverflowing(container)) {
            // Compute the size before applying overflow hidden to avoid any scroll jumps.
            var scrollbarSize = _getScrollbarSizeDefault.default();
            restoreStyle.push({
                value: container.style.paddingRight,
                key: 'padding-right',
                el: container
            }); // Use computed style, here to get the real padding to add our scrollbar width.
            container.style['padding-right'] = "".concat(getPaddingRight(container) + scrollbarSize, "px"); // .mui-fixed is a global helper.
            fixedNodes = _ownerDocumentDefault.default(container).querySelectorAll('.mui-fixed');
            [].forEach.call(fixedNodes, function(node) {
                restorePaddings.push(node.style.paddingRight);
                node.style.paddingRight = "".concat(getPaddingRight(node) + scrollbarSize, "px");
            });
        } // Improve Gatsby support
        // https://css-tricks.com/snippets/css/force-vertical-scrollbar/
        var parent = container.parentElement;
        var scrollContainer = parent.nodeName === 'HTML' && window.getComputedStyle(parent)['overflow-y'] === 'scroll' ? parent : container; // Block the scroll even if no scrollbar is visible to account for mobile keyboard
        // screensize shrink.
        restoreStyle.push({
            value: scrollContainer.style.overflow,
            key: 'overflow',
            el: scrollContainer
        });
        scrollContainer.style.overflow = 'hidden';
    }
    var restore = function restore1() {
        if (fixedNodes) [].forEach.call(fixedNodes, function(node, i) {
            if (restorePaddings[i]) node.style.paddingRight = restorePaddings[i];
            else node.style.removeProperty('padding-right');
        });
        restoreStyle.forEach(function(_ref) {
            var value = _ref.value, el = _ref.el, key = _ref.key;
            if (value) el.style.setProperty(key, value);
            else el.style.removeProperty(key);
        });
    };
    return restore;
}
function getHiddenSiblings(container) {
    var hiddenSiblings = [];
    [].forEach.call(container.children, function(node) {
        if (node.getAttribute && node.getAttribute('aria-hidden') === 'true') hiddenSiblings.push(node);
    });
    return hiddenSiblings;
}
/**
 * @ignore - do not document.
 *
 * Proper state management for containers and the modals in those containers.
 * Simplified, but inspired by react-overlay's ModalManager class.
 * Used by the Modal to ensure proper styling of containers.
 */ var ModalManager = /*#__PURE__*/ function() {
    function ModalManager1() {
        _classCallCheckDefault.default(this, ModalManager1);
        // this.modals[modalIndex] = modal
        this.modals = []; // this.containers[containerIndex] = {
        //   modals: [],
        //   container,
        //   restore: null,
        // }
        this.containers = [];
    }
    _createClassDefault.default(ModalManager1, [
        {
            key: "add",
            value: function add(modal, container) {
                var modalIndex = this.modals.indexOf(modal);
                if (modalIndex !== -1) return modalIndex;
                modalIndex = this.modals.length;
                this.modals.push(modal); // If the modal we are adding is already in the DOM.
                if (modal.modalRef) ariaHidden(modal.modalRef, false);
                var hiddenSiblingNodes = getHiddenSiblings(container);
                ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, hiddenSiblingNodes, true);
                var containerIndex = findIndexOf(this.containers, function(item) {
                    return item.container === container;
                });
                if (containerIndex !== -1) {
                    this.containers[containerIndex].modals.push(modal);
                    return modalIndex;
                }
                this.containers.push({
                    modals: [
                        modal
                    ],
                    container: container,
                    restore: null,
                    hiddenSiblingNodes: hiddenSiblingNodes
                });
                return modalIndex;
            }
        },
        {
            key: "mount",
            value: function mount(modal, props) {
                var containerIndex = findIndexOf(this.containers, function(item) {
                    return item.modals.indexOf(modal) !== -1;
                });
                var containerInfo = this.containers[containerIndex];
                if (!containerInfo.restore) containerInfo.restore = handleContainer(containerInfo, props);
            }
        },
        {
            key: "remove",
            value: function remove(modal) {
                var modalIndex = this.modals.indexOf(modal);
                if (modalIndex === -1) return modalIndex;
                var containerIndex = findIndexOf(this.containers, function(item) {
                    return item.modals.indexOf(modal) !== -1;
                });
                var containerInfo = this.containers[containerIndex];
                containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
                this.modals.splice(modalIndex, 1); // If that was the last modal in a container, clean up the container.
                if (containerInfo.modals.length === 0) {
                    // The modal might be closed before it had the chance to be mounted in the DOM.
                    if (containerInfo.restore) containerInfo.restore();
                    if (modal.modalRef) // In case the modal wasn't in the DOM yet.
                    ariaHidden(modal.modalRef, true);
                    ariaHiddenSiblings(containerInfo.container, modal.mountNode, modal.modalRef, containerInfo.hiddenSiblingNodes, false);
                    this.containers.splice(containerIndex, 1);
                } else {
                    // Otherwise make sure the next top modal is visible to a screen reader.
                    var nextTop = containerInfo.modals[containerInfo.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set
                    // aria-hidden because the dom element doesn't exist either
                    // when modal was unmounted before modalRef gets null
                    if (nextTop.modalRef) ariaHidden(nextTop.modalRef, false);
                }
                return modalIndex;
            }
        },
        {
            key: "isTopModal",
            value: function isTopModal(modal) {
                return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
            }
        }
    ]);
    return ModalManager1;
}();

},{"@babel/runtime/helpers/esm/classCallCheck":"6zViz","@babel/runtime/helpers/esm/createClass":"hVEAO","@babel/runtime/helpers/esm/toConsumableArray":"fbqwi","../utils/getScrollbarSize":"7fSUR","../utils/ownerDocument":"jeIVD","../utils/ownerWindow":"6ek2F","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"7fSUR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getScrollbarSize() {
    var scrollDiv = document.createElement('div');
    scrollDiv.style.width = '99px';
    scrollDiv.style.height = '99px';
    scrollDiv.style.position = 'absolute';
    scrollDiv.style.top = '-9999px';
    scrollDiv.style.overflow = 'scroll';
    document.body.appendChild(scrollDiv);
    var scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    return scrollbarSize;
}
exports.default = getScrollbarSize;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hO5i1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_unstableTrapFocusDefault.default
);
var _unstableTrapFocus = require("./Unstable_TrapFocus");
var _unstableTrapFocusDefault = parcelHelpers.interopDefault(_unstableTrapFocus);

},{"./Unstable_TrapFocus":"3LbMw","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"3LbMw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable consistent-return, jsx-a11y/no-noninteractive-tabindex, camelcase */ var _react = require("react");
var _reactDom = require("react-dom");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _ownerDocument = require("../utils/ownerDocument");
var _ownerDocumentDefault = parcelHelpers.interopDefault(_ownerDocument);
var _useForkRef = require("../utils/useForkRef");
var _useForkRefDefault = parcelHelpers.interopDefault(_useForkRef);
var _utils = require("@material-ui/utils");
/**
 * Utility component that locks focus inside the component.
 */ function Unstable_TrapFocus(props) {
    var children = props.children, _props$disableAutoFoc = props.disableAutoFocus, disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc, _props$disableEnforce = props.disableEnforceFocus, disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce, _props$disableRestore = props.disableRestoreFocus, disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore, getDoc = props.getDoc, isEnabled = props.isEnabled, open = props.open;
    var ignoreNextEnforceFocus = _react.useRef();
    var sentinelStart = _react.useRef(null);
    var sentinelEnd = _react.useRef(null);
    var nodeToRestore = _react.useRef();
    var rootRef = _react.useRef(null); // can be removed once we drop support for non ref forwarding class components
    var handleOwnRef = _react.useCallback(function(instance) {
        // #StrictMode ready
        rootRef.current = _reactDom.findDOMNode(instance);
    }, []);
    var handleRef = _useForkRefDefault.default(children.ref, handleOwnRef);
    var prevOpenRef = _react.useRef();
    _react.useEffect(function() {
        prevOpenRef.current = open;
    }, [
        open
    ]);
    if (!prevOpenRef.current && open && typeof window !== 'undefined') // WARNING: Potentially unsafe in concurrent mode.
    // The way the read on `nodeToRestore` is setup could make this actually safe.
    // Say we render `open={false}` -> `open={true}` but never commit.
    // We have now written a state that wasn't committed. But no committed effect
    // will read this wrong value. We only read from `nodeToRestore` in effects
    // that were committed on `open={true}`
    // WARNING: Prevents the instance from being garbage collected. Should only
    // hold a weak ref.
    nodeToRestore.current = getDoc().activeElement;
    _react.useEffect(function() {
        if (!open) return;
        var doc = _ownerDocumentDefault.default(rootRef.current); // We might render an empty child.
        if (!disableAutoFocus && rootRef.current && !rootRef.current.contains(doc.activeElement)) {
            if (!rootRef.current.hasAttribute('tabIndex')) {
                console.error([
                    'Material-UI: The modal content node does not accept focus.',
                    "For the benefit of assistive technologies, the tabIndex of the node is being set to \"-1\"."
                ].join('\n'));
                rootRef.current.setAttribute('tabIndex', -1);
            }
            rootRef.current.focus();
        }
        var contain = function contain1() {
            var rootElement = rootRef.current; // Cleanup functions are executed lazily in React 17.
            // Contain can be called between the component being unmounted and its cleanup function being run.
            if (rootElement === null) return;
            if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
                ignoreNextEnforceFocus.current = false;
                return;
            }
            if (rootRef.current && !rootRef.current.contains(doc.activeElement)) rootRef.current.focus();
        };
        var loopFocus = function loopFocus1(event) {
            // 9 = Tab
            if (disableEnforceFocus || !isEnabled() || event.keyCode !== 9) return;
             // Make sure the next tab starts from the right place.
            if (doc.activeElement === rootRef.current) {
                // We need to ignore the next contain as
                // it will try to move the focus back to the rootRef element.
                ignoreNextEnforceFocus.current = true;
                if (event.shiftKey) sentinelEnd.current.focus();
                else sentinelStart.current.focus();
            }
        };
        doc.addEventListener('focus', contain, true);
        doc.addEventListener('keydown', loopFocus, true); // With Edge, Safari and Firefox, no focus related events are fired when the focused area stops being a focused area
        // e.g. https://bugzilla.mozilla.org/show_bug.cgi?id=559561.
        //
        // The whatwg spec defines how the browser should behave but does not explicitly mention any events:
        // https://html.spec.whatwg.org/multipage/interaction.html#focus-fixup-rule.
        var interval = setInterval(function() {
            contain();
        }, 50);
        return function() {
            clearInterval(interval);
            doc.removeEventListener('focus', contain, true);
            doc.removeEventListener('keydown', loopFocus, true); // restoreLastFocus()
            if (!disableRestoreFocus) {
                // In IE 11 it is possible for document.activeElement to be null resulting
                // in nodeToRestore.current being null.
                // Not all elements in IE 11 have a focus method.
                // Once IE 11 support is dropped the focus() call can be unconditional.
                if (nodeToRestore.current && nodeToRestore.current.focus) nodeToRestore.current.focus();
                nodeToRestore.current = null;
            }
        };
    }, [
        disableAutoFocus,
        disableEnforceFocus,
        disableRestoreFocus,
        isEnabled,
        open
    ]);
    return(/*#__PURE__*/ _react.createElement(_react.Fragment, null, /*#__PURE__*/ _react.createElement("div", {
        tabIndex: 0,
        ref: sentinelStart,
        "data-test": "sentinelStart"
    }), /*#__PURE__*/ _react.cloneElement(children, {
        ref: handleRef
    }), /*#__PURE__*/ _react.createElement("div", {
        tabIndex: 0,
        ref: sentinelEnd,
        "data-test": "sentinelEnd"
    })));
}
Unstable_TrapFocus.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * A single child content element.
   */ children: _propTypesDefault.default.node,
    /**
   * If `true`, the trap focus will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any trap focus children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the trap focus less
   * accessible to assistive technologies, like screen readers.
   */ disableAutoFocus: _propTypesDefault.default.bool,
    /**
   * If `true`, the trap focus will not prevent focus from leaving the trap focus while open.
   *
   * Generally this should never be set to `true` as it makes the trap focus less
   * accessible to assistive technologies, like screen readers.
   */ disableEnforceFocus: _propTypesDefault.default.bool,
    /**
   * If `true`, the trap focus will not restore focus to previously focused element once
   * trap focus is hidden.
   */ disableRestoreFocus: _propTypesDefault.default.bool,
    /**
   * Return the document to consider.
   * We use it to implement the restore focus between different browser documents.
   */ getDoc: _propTypesDefault.default.func.isRequired,
    /**
   * Do we still want to enforce the focus?
   * This prop helps nesting TrapFocus elements.
   */ isEnabled: _propTypesDefault.default.func.isRequired,
    /**
   * If `true`, focus will be locked.
   */ open: _propTypesDefault.default.bool.isRequired
};
// eslint-disable-next-line
Unstable_TrapFocus['propTypes' + ''] = _utils.exactProp(Unstable_TrapFocus.propTypes);
exports.default = Unstable_TrapFocus;

},{"react":"cKM0D","react-dom":"ezGwg","prop-types":"lYCp3","../utils/ownerDocument":"jeIVD","../utils/useForkRef":"bLpHM","@material-ui/utils":"Uumnw","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5fXPG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var styles = {
    /* Styles applied to the root element. */ root: {
        zIndex: -1,
        position: 'fixed',
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        WebkitTapHighlightColor: 'transparent'
    },
    /* Styles applied to the root element if `invisible={true}`. */ invisible: {
        backgroundColor: 'transparent'
    }
};
/**
 * @ignore - internal component.
 */ var SimpleBackdrop = /*#__PURE__*/ _react.forwardRef(function SimpleBackdrop1(props, ref) {
    var _props$invisible = props.invisible, invisible = _props$invisible === void 0 ? false : _props$invisible, open = props.open, other = _objectWithoutPropertiesDefault.default(props, [
        "invisible",
        "open"
    ]);
    return open ? /*#__PURE__*/ _react.createElement("div", _extendsDefault.default({
        "aria-hidden": true,
        ref: ref
    }, other, {
        style: _extendsDefault.default({
        }, styles.root, invisible ? styles.invisible : {
        }, other.style)
    })) : null;
});
SimpleBackdrop.propTypes = {
    /**
   * If `true`, the backdrop is invisible.
   * It can be used when rendering a popover or a custom select component.
   */ invisible: _propTypesDefault.default.bool,
    /**
   * If `true`, the backdrop is open.
   */ open: _propTypesDefault.default.bool.isRequired
};
exports.default = SimpleBackdrop;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"adzIq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_growDefault.default
);
var _grow = require("./Grow");
var _growDefault = parcelHelpers.interopDefault(_grow);

},{"./Grow":"7YcIZ","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"7YcIZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _slicedToArray = require("@babel/runtime/helpers/esm/slicedToArray");
var _slicedToArrayDefault = parcelHelpers.interopDefault(_slicedToArray);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _reactTransitionGroup = require("react-transition-group");
var _useTheme = require("../styles/useTheme");
var _useThemeDefault = parcelHelpers.interopDefault(_useTheme);
var _utils = require("../transitions/utils");
var _useForkRef = require("../utils/useForkRef");
var _useForkRefDefault = parcelHelpers.interopDefault(_useForkRef);
function getScale(value) {
    return "scale(".concat(value, ", ").concat(Math.pow(value, 2), ")");
}
var styles = {
    entering: {
        opacity: 1,
        transform: getScale(1)
    },
    entered: {
        opacity: 1,
        transform: 'none'
    }
};
/**
 * The Grow transition is used by the [Tooltip](/components/tooltips/) and
 * [Popover](/components/popover/) components.
 * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
 */ var Grow = /*#__PURE__*/ _react.forwardRef(function Grow1(props, ref) {
    var children = props.children, _props$disableStrictM = props.disableStrictModeCompat, disableStrictModeCompat = _props$disableStrictM === void 0 ? false : _props$disableStrictM, inProp = props.in, onEnter = props.onEnter, onEntered = props.onEntered, onEntering = props.onEntering, onExit = props.onExit, onExited = props.onExited, onExiting = props.onExiting, style = props.style, _props$timeout = props.timeout, timeout = _props$timeout === void 0 ? 'auto' : _props$timeout, _props$TransitionComp = props.TransitionComponent, TransitionComponent = _props$TransitionComp === void 0 ? _reactTransitionGroup.Transition : _props$TransitionComp, other = _objectWithoutPropertiesDefault.default(props, [
        "children",
        "disableStrictModeCompat",
        "in",
        "onEnter",
        "onEntered",
        "onEntering",
        "onExit",
        "onExited",
        "onExiting",
        "style",
        "timeout",
        "TransitionComponent"
    ]);
    var timer = _react.useRef();
    var autoTimeout = _react.useRef();
    var theme = _useThemeDefault.default();
    var enableStrictModeCompat = theme.unstable_strictMode && !disableStrictModeCompat;
    var nodeRef = _react.useRef(null);
    var foreignRef = _useForkRefDefault.default(children.ref, ref);
    var handleRef = _useForkRefDefault.default(enableStrictModeCompat ? nodeRef : undefined, foreignRef);
    var normalizedTransitionCallback = function normalizedTransitionCallback1(callback) {
        return function(nodeOrAppearing, maybeAppearing) {
            if (callback) {
                var _ref = enableStrictModeCompat ? [
                    nodeRef.current,
                    nodeOrAppearing
                ] : [
                    nodeOrAppearing,
                    maybeAppearing
                ], _ref2 = _slicedToArrayDefault.default(_ref, 2), node = _ref2[0], isAppearing = _ref2[1]; // onEnterXxx and onExitXxx callbacks have a different arguments.length value.
                if (isAppearing === undefined) callback(node);
                else callback(node, isAppearing);
            }
        };
    };
    var handleEntering = normalizedTransitionCallback(onEntering);
    var handleEnter = normalizedTransitionCallback(function(node, isAppearing) {
        _utils.reflow(node); // So the animation always start from the start.
        var _getTransitionProps = _utils.getTransitionProps({
            style: style,
            timeout: timeout
        }, {
            mode: 'enter'
        }), transitionDuration = _getTransitionProps.duration, delay = _getTransitionProps.delay;
        var duration;
        if (timeout === 'auto') {
            duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
            autoTimeout.current = duration;
        } else duration = transitionDuration;
        node.style.transition = [
            theme.transitions.create('opacity', {
                duration: duration,
                delay: delay
            }),
            theme.transitions.create('transform', {
                duration: duration * 0.666,
                delay: delay
            })
        ].join(',');
        if (onEnter) onEnter(node, isAppearing);
    });
    var handleEntered = normalizedTransitionCallback(onEntered);
    var handleExiting = normalizedTransitionCallback(onExiting);
    var handleExit = normalizedTransitionCallback(function(node) {
        var _getTransitionProps2 = _utils.getTransitionProps({
            style: style,
            timeout: timeout
        }, {
            mode: 'exit'
        }), transitionDuration = _getTransitionProps2.duration, delay = _getTransitionProps2.delay;
        var duration;
        if (timeout === 'auto') {
            duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
            autoTimeout.current = duration;
        } else duration = transitionDuration;
        node.style.transition = [
            theme.transitions.create('opacity', {
                duration: duration,
                delay: delay
            }),
            theme.transitions.create('transform', {
                duration: duration * 0.666,
                delay: delay || duration * 0.333
            })
        ].join(',');
        node.style.opacity = '0';
        node.style.transform = getScale(0.75);
        if (onExit) onExit(node);
    });
    var handleExited = normalizedTransitionCallback(onExited);
    var addEndListener = function addEndListener1(nodeOrNext, maybeNext) {
        var next = enableStrictModeCompat ? nodeOrNext : maybeNext;
        if (timeout === 'auto') timer.current = setTimeout(next, autoTimeout.current || 0);
    };
    _react.useEffect(function() {
        return function() {
            clearTimeout(timer.current);
        };
    }, []);
    return(/*#__PURE__*/ _react.createElement(TransitionComponent, _extendsDefault.default({
        appear: true,
        in: inProp,
        nodeRef: enableStrictModeCompat ? nodeRef : undefined,
        onEnter: handleEnter,
        onEntered: handleEntered,
        onEntering: handleEntering,
        onExit: handleExit,
        onExited: handleExited,
        onExiting: handleExiting,
        addEndListener: addEndListener,
        timeout: timeout === 'auto' ? null : timeout
    }, other), function(state, childProps) {
        return(/*#__PURE__*/ _react.cloneElement(children, _extendsDefault.default({
            style: _extendsDefault.default({
                opacity: 0,
                transform: getScale(0.75),
                visibility: state === 'exited' && !inProp ? 'hidden' : undefined
            }, styles[state], style, children.props.style),
            ref: handleRef
        }, childProps)));
    }));
});
Grow.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * A single child content element.
   */ children: _propTypesDefault.default.element,
    /**
   * Enable this prop if you encounter 'Function components cannot be given refs',
   * use `unstable_createStrictModeTheme`,
   * and can't forward the ref in the child component.
   */ disableStrictModeCompat: _propTypesDefault.default.bool,
    /**
   * If `true`, show the component; triggers the enter or exit animation.
   */ in: _propTypesDefault.default.bool,
    /**
   * @ignore
   */ onEnter: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onEntered: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onEntering: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onExit: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onExited: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onExiting: _propTypesDefault.default.func,
    /**
   * @ignore
   */ style: _propTypesDefault.default.object,
    /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   *
   * Set to 'auto' to automatically calculate transition time based on height.
   */ timeout: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.oneOf([
            'auto'
        ]),
        _propTypesDefault.default.number,
        _propTypesDefault.default.shape({
            appear: _propTypesDefault.default.number,
            enter: _propTypesDefault.default.number,
            exit: _propTypesDefault.default.number
        })
    ])
};
Grow.muiSupportAuto = true;
exports.default = Grow;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/slicedToArray":"cT2nX","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","react-transition-group":"4asrk","../styles/useTheme":"jysVY","../transitions/utils":"5rBJ1","../utils/useForkRef":"bLpHM","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"4asrk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CSSTransition", ()=>_csstransitionDefault.default
);
parcelHelpers.export(exports, "ReplaceTransition", ()=>_replaceTransitionDefault.default
);
parcelHelpers.export(exports, "SwitchTransition", ()=>_switchTransitionDefault.default
);
parcelHelpers.export(exports, "TransitionGroup", ()=>_transitionGroupDefault.default
);
parcelHelpers.export(exports, "Transition", ()=>_transitionDefault.default
);
parcelHelpers.export(exports, "config", ()=>_configDefault.default
);
var _csstransition = require("./CSSTransition");
var _csstransitionDefault = parcelHelpers.interopDefault(_csstransition);
var _replaceTransition = require("./ReplaceTransition");
var _replaceTransitionDefault = parcelHelpers.interopDefault(_replaceTransition);
var _switchTransition = require("./SwitchTransition");
var _switchTransitionDefault = parcelHelpers.interopDefault(_switchTransition);
var _transitionGroup = require("./TransitionGroup");
var _transitionGroupDefault = parcelHelpers.interopDefault(_transitionGroup);
var _transition = require("./Transition");
var _transitionDefault = parcelHelpers.interopDefault(_transition);
var _config = require("./config");
var _configDefault = parcelHelpers.interopDefault(_config);

},{"./CSSTransition":"7qKG2","./ReplaceTransition":"hiVLh","./SwitchTransition":"aKgfI","./TransitionGroup":"dlcUl","./Transition":"3rht9","./config":"fc2lB","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"7qKG2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutPropertiesLoose = require("@babel/runtime/helpers/esm/objectWithoutPropertiesLoose");
var _objectWithoutPropertiesLooseDefault = parcelHelpers.interopDefault(_objectWithoutPropertiesLoose);
var _inheritsLoose = require("@babel/runtime/helpers/esm/inheritsLoose");
var _inheritsLooseDefault = parcelHelpers.interopDefault(_inheritsLoose);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _addClass = require("dom-helpers/addClass");
var _addClassDefault = parcelHelpers.interopDefault(_addClass);
var _removeClass = require("dom-helpers/removeClass");
var _removeClassDefault = parcelHelpers.interopDefault(_removeClass);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _transition = require("./Transition");
var _transitionDefault = parcelHelpers.interopDefault(_transition);
var _propTypes1 = require("./utils/PropTypes");
var _addClass1 = function addClass(node, classes) {
    return node && classes && classes.split(' ').forEach(function(c) {
        return _addClassDefault.default(node, c);
    });
};
var removeClass = function removeClass1(node, classes) {
    return node && classes && classes.split(' ').forEach(function(c) {
        return _removeClassDefault.default(node, c);
    });
};
/**
 * A transition component inspired by the excellent
 * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
 * use it if you're using CSS transitions or animations. It's built upon the
 * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
 * component, so it inherits all of its props.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` states of the transition. The first class is applied and then a
 * second `*-active` class in order to activate the CSS transition. After the
 * transition, matching `*-done` class names are applied to persist the
 * transition state.
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
 *         <div>
 *           {"I'll receive my-node-* classes"}
 *         </div>
 *       </CSSTransition>
 *       <button type="button" onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the `in` prop is set to `true`, the child component will first receive
 * the class `example-enter`, then the `example-enter-active` will be added in
 * the next tick. `CSSTransition` [forces a
 * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * between before adding the `example-enter-active`. This is an important trick
 * because it allows us to transition between `example-enter` and
 * `example-enter-active` even though they were added immediately one after
 * another. Most notably, this is what makes it possible for us to animate
 * _appearance_.
 *
 * ```css
 * .my-node-enter {
 *   opacity: 0;
 * }
 * .my-node-enter-active {
 *   opacity: 1;
 *   transition: opacity 200ms;
 * }
 * .my-node-exit {
 *   opacity: 1;
 * }
 * .my-node-exit-active {
 *   opacity: 0;
 *   transition: opacity 200ms;
 * }
 * ```
 *
 * `*-active` classes represent which styles you want to animate **to**, so it's
 * important to add `transition` declaration only to them, otherwise transitions
 * might not behave as intended! This might not be obvious when the transitions
 * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
 * the example above (minus `transition`), but it becomes apparent in more
 * complex transitions.
 *
 * **Note**: If you're using the
 * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
 * prop, make sure to define styles for `.appear-*` classes as well.
 */ var CSSTransition1 = /*#__PURE__*/ function(_React$Component) {
    _inheritsLooseDefault.default(CSSTransition2, _React$Component);
    function CSSTransition2() {
        var _this;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _React$Component.call.apply(_React$Component, [
            this
        ].concat(args)) || this;
        _this.appliedClasses = {
            appear: {
            },
            enter: {
            },
            exit: {
            }
        };
        _this.onEnter = function(maybeNode, maybeAppearing) {
            var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
            _this.removeClasses(node, 'exit');
            _this.addClass(node, appearing ? 'appear' : 'enter', 'base');
            if (_this.props.onEnter) _this.props.onEnter(maybeNode, maybeAppearing);
        };
        _this.onEntering = function(maybeNode, maybeAppearing) {
            var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
            var type = appearing ? 'appear' : 'enter';
            _this.addClass(node, type, 'active');
            if (_this.props.onEntering) _this.props.onEntering(maybeNode, maybeAppearing);
        };
        _this.onEntered = function(maybeNode, maybeAppearing) {
            var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
            var type = appearing ? 'appear' : 'enter';
            _this.removeClasses(node, type);
            _this.addClass(node, type, 'done');
            if (_this.props.onEntered) _this.props.onEntered(maybeNode, maybeAppearing);
        };
        _this.onExit = function(maybeNode) {
            var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
            _this.removeClasses(node, 'appear');
            _this.removeClasses(node, 'enter');
            _this.addClass(node, 'exit', 'base');
            if (_this.props.onExit) _this.props.onExit(maybeNode);
        };
        _this.onExiting = function(maybeNode) {
            var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
            _this.addClass(node, 'exit', 'active');
            if (_this.props.onExiting) _this.props.onExiting(maybeNode);
        };
        _this.onExited = function(maybeNode) {
            var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
            _this.removeClasses(node, 'exit');
            _this.addClass(node, 'exit', 'done');
            if (_this.props.onExited) _this.props.onExited(maybeNode);
        };
        _this.resolveArguments = function(maybeNode, maybeAppearing) {
            return _this.props.nodeRef ? [
                _this.props.nodeRef.current,
                maybeNode
            ] // here `maybeNode` is actually `appearing`
             : [
                maybeNode,
                maybeAppearing
            ];
        };
        _this.getClassNames = function(type) {
            var classNames = _this.props.classNames;
            var isStringClassNames = typeof classNames === 'string';
            var prefix = isStringClassNames && classNames ? classNames + "-" : '';
            var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
            var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
            var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
            return {
                baseClassName: baseClassName,
                activeClassName: activeClassName,
                doneClassName: doneClassName
            };
        };
        return _this;
    }
    var _proto = CSSTransition2.prototype;
    _proto.addClass = function addClass1(node, type, phase) {
        var className = this.getClassNames(type)[phase + "ClassName"];
        var _this$getClassNames = this.getClassNames('enter'), doneClassName = _this$getClassNames.doneClassName;
        if (type === 'appear' && phase === 'done' && doneClassName) className += " " + doneClassName;
         // This is to force a repaint,
        // which is necessary in order to transition styles when adding a class name.
        if (phase === 'active') /* eslint-disable no-unused-expressions */ node && node.scrollTop;
        if (className) {
            this.appliedClasses[type][phase] = className;
            _addClass1(node, className);
        }
    };
    _proto.removeClasses = function removeClasses(node, type) {
        var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
        this.appliedClasses[type] = {
        };
        if (baseClassName) removeClass(node, baseClassName);
        if (activeClassName) removeClass(node, activeClassName);
        if (doneClassName) removeClass(node, doneClassName);
    };
    _proto.render = function render() {
        var _this$props = this.props, _ = _this$props.classNames, props = _objectWithoutPropertiesLooseDefault.default(_this$props, [
            "classNames"
        ]);
        return(/*#__PURE__*/ _reactDefault.default.createElement(_transitionDefault.default, _extendsDefault.default({
        }, props, {
            onEnter: this.onEnter,
            onEntered: this.onEntered,
            onEntering: this.onEntering,
            onExit: this.onExit,
            onExiting: this.onExiting,
            onExited: this.onExited
        })));
    };
    return CSSTransition2;
}(_reactDefault.default.Component);
CSSTransition1.defaultProps = {
    classNames: ''
};
CSSTransition1.propTypes = _extendsDefault.default({
}, _transitionDefault.default.propTypes, {
    /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */ classNames: _propTypes1.classNamesShape,
    /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */ onEnter: _propTypesDefault.default.func,
    /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */ onEntering: _propTypesDefault.default.func,
    /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */ onEntered: _propTypesDefault.default.func,
    /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */ onExit: _propTypesDefault.default.func,
    /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */ onExiting: _propTypesDefault.default.func,
    /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */ onExited: _propTypesDefault.default.func
});
exports.default = CSSTransition1;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutPropertiesLoose":"5cFhH","@babel/runtime/helpers/esm/inheritsLoose":"bzy6T","prop-types":"lYCp3","dom-helpers/addClass":"enuLx","dom-helpers/removeClass":"6hAcA","react":"cKM0D","./Transition":"3rht9","./utils/PropTypes":"lFhYs","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"enuLx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasClass = require("./hasClass");
var _hasClassDefault = parcelHelpers.interopDefault(_hasClass);
function addClass(element, className) {
    if (element.classList) element.classList.add(className);
    else if (!_hasClassDefault.default(element, className)) {
        if (typeof element.className === 'string') element.className = element.className + " " + className;
        else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
    }
}
exports.default = addClass;

},{"./hasClass":"8rOHk","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8rOHk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function hasClass(element, className) {
    if (element.classList) return !!className && element.classList.contains(className);
    return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
exports.default = hasClass;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"6hAcA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function replaceClassName(origClass, classToRemove) {
    return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
function removeClass(element, className) {
    if (element.classList) element.classList.remove(className);
    else if (typeof element.className === 'string') element.className = replaceClassName(element.className, className);
    else element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
}
exports.default = removeClass;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"3rht9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UNMOUNTED", ()=>UNMOUNTED
);
parcelHelpers.export(exports, "EXITED", ()=>EXITED
);
parcelHelpers.export(exports, "ENTERING", ()=>ENTERING
);
parcelHelpers.export(exports, "ENTERED", ()=>ENTERED
);
parcelHelpers.export(exports, "EXITING", ()=>EXITING
);
var _objectWithoutPropertiesLoose = require("@babel/runtime/helpers/esm/objectWithoutPropertiesLoose");
var _objectWithoutPropertiesLooseDefault = parcelHelpers.interopDefault(_objectWithoutPropertiesLoose);
var _inheritsLoose = require("@babel/runtime/helpers/esm/inheritsLoose");
var _inheritsLooseDefault = parcelHelpers.interopDefault(_inheritsLoose);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _reactDom = require("react-dom");
var _reactDomDefault = parcelHelpers.interopDefault(_reactDom);
var _config = require("./config");
var _configDefault = parcelHelpers.interopDefault(_config);
var _propTypes1 = require("./utils/PropTypes");
var _transitionGroupContext = require("./TransitionGroupContext");
var _transitionGroupContextDefault = parcelHelpers.interopDefault(_transitionGroupContext);
var UNMOUNTED = 'unmounted';
var EXITED = 'exited';
var ENTERING = 'entering';
var ENTERED = 'entered';
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */ var Transition1 = /*#__PURE__*/ function(_React$Component) {
    _inheritsLooseDefault.default(Transition2, _React$Component);
    function Transition2(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var parentGroup = context; // In the context of a TransitionGroup all enters are really appears
        var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
        var initialStatus;
        _this.appearStatus = null;
        if (props.in) {
            if (appear) {
                initialStatus = EXITED;
                _this.appearStatus = ENTERING;
            } else initialStatus = ENTERED;
        } else if (props.unmountOnExit || props.mountOnEnter) initialStatus = UNMOUNTED;
        else initialStatus = EXITED;
        _this.state = {
            status: initialStatus
        };
        _this.nextCallback = null;
        return _this;
    }
    Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
        var nextIn = _ref.in;
        if (nextIn && prevState.status === UNMOUNTED) return {
            status: EXITED
        };
        return null;
    } // getSnapshotBeforeUpdate(prevProps) {
    ;
    var _proto = Transition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
        this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var nextStatus = null;
        if (prevProps !== this.props) {
            var status = this.state.status;
            if (this.props.in) {
                if (status !== ENTERING && status !== ENTERED) nextStatus = ENTERING;
            } else if (status === ENTERING || status === ENTERED) nextStatus = EXITING;
        }
        this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
        this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
        var timeout = this.props.timeout;
        var exit, enter, appear;
        exit = enter = appear = timeout;
        if (timeout != null && typeof timeout !== 'number') {
            exit = timeout.exit;
            enter = timeout.enter; // TODO: remove fallback for next major
            appear = timeout.appear !== undefined ? timeout.appear : enter;
        }
        return {
            exit: exit,
            enter: enter,
            appear: appear
        };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
        if (mounting === void 0) mounting = false;
        if (nextStatus !== null) {
            // nextStatus will always be ENTERING or EXITING.
            this.cancelNextCallback();
            if (nextStatus === ENTERING) this.performEnter(mounting);
            else this.performExit();
        } else if (this.props.unmountOnExit && this.state.status === EXITED) this.setState({
            status: UNMOUNTED
        });
    };
    _proto.performEnter = function performEnter(mounting) {
        var _this2 = this;
        var enter = this.props.enter;
        var appearing = this.context ? this.context.isMounting : mounting;
        var _ref2 = this.props.nodeRef ? [
            appearing
        ] : [
            _reactDomDefault.default.findDOMNode(this),
            appearing
        ], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
        var timeouts = this.getTimeouts();
        var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
        // if we are mounting and running this it means appear _must_ be set
        if (!mounting && !enter || _configDefault.default.disabled) {
            this.safeSetState({
                status: ENTERED
            }, function() {
                _this2.props.onEntered(maybeNode);
            });
            return;
        }
        this.props.onEnter(maybeNode, maybeAppearing);
        this.safeSetState({
            status: ENTERING
        }, function() {
            _this2.props.onEntering(maybeNode, maybeAppearing);
            _this2.onTransitionEnd(enterTimeout, function() {
                _this2.safeSetState({
                    status: ENTERED
                }, function() {
                    _this2.props.onEntered(maybeNode, maybeAppearing);
                });
            });
        });
    };
    _proto.performExit = function performExit() {
        var _this3 = this;
        var exit = this.props.exit;
        var timeouts = this.getTimeouts();
        var maybeNode = this.props.nodeRef ? undefined : _reactDomDefault.default.findDOMNode(this); // no exit animation skip right to EXITED
        if (!exit || _configDefault.default.disabled) {
            this.safeSetState({
                status: EXITED
            }, function() {
                _this3.props.onExited(maybeNode);
            });
            return;
        }
        this.props.onExit(maybeNode);
        this.safeSetState({
            status: EXITING
        }, function() {
            _this3.props.onExiting(maybeNode);
            _this3.onTransitionEnd(timeouts.exit, function() {
                _this3.safeSetState({
                    status: EXITED
                }, function() {
                    _this3.props.onExited(maybeNode);
                });
            });
        });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
        if (this.nextCallback !== null) {
            this.nextCallback.cancel();
            this.nextCallback = null;
        }
    };
    _proto.safeSetState = function safeSetState(nextState, callback) {
        // This shouldn't be necessary, but there are weird race conditions with
        // setState callbacks and unmounting in testing, so always make sure that
        // we can cancel any pending setState callbacks after we unmount.
        callback = this.setNextCallback(callback);
        this.setState(nextState, callback);
    };
    _proto.setNextCallback = function setNextCallback(callback) {
        var _this4 = this;
        var active = true;
        this.nextCallback = function(event) {
            if (active) {
                active = false;
                _this4.nextCallback = null;
                callback(event);
            }
        };
        this.nextCallback.cancel = function() {
            active = false;
        };
        return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
        this.setNextCallback(handler);
        var node = this.props.nodeRef ? this.props.nodeRef.current : _reactDomDefault.default.findDOMNode(this);
        var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
        if (!node || doesNotHaveTimeoutOrListener) {
            setTimeout(this.nextCallback, 0);
            return;
        }
        if (this.props.addEndListener) {
            var _ref3 = this.props.nodeRef ? [
                this.nextCallback
            ] : [
                node,
                this.nextCallback
            ], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
            this.props.addEndListener(maybeNode, maybeNextCallback);
        }
        if (timeout != null) setTimeout(this.nextCallback, timeout);
    };
    _proto.render = function render() {
        var status = this.state.status;
        if (status === UNMOUNTED) return null;
        var _this$props = this.props, children = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLooseDefault.default(_this$props, [
            "children",
            "in",
            "mountOnEnter",
            "unmountOnExit",
            "appear",
            "enter",
            "exit",
            "timeout",
            "addEndListener",
            "onEnter",
            "onEntering",
            "onEntered",
            "onExit",
            "onExiting",
            "onExited",
            "nodeRef"
        ]);
        return(/*#__PURE__*/ // allows for nested Transitions
        _reactDefault.default.createElement(_transitionGroupContextDefault.default.Provider, {
            value: null
        }, typeof children === 'function' ? children(status, childProps) : _reactDefault.default.cloneElement(_reactDefault.default.Children.only(children), childProps)));
    };
    return Transition2;
}(_reactDefault.default.Component);
Transition1.contextType = _transitionGroupContextDefault.default;
Transition1.propTypes = {
    /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */ nodeRef: _propTypesDefault.default.shape({
        current: typeof Element === 'undefined' ? _propTypesDefault.default.any : function(propValue, key, componentName, location, propFullName, secret) {
            var value = propValue[key];
            return _propTypesDefault.default.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
        }
    }),
    /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */ children: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.func.isRequired,
        _propTypesDefault.default.element.isRequired
    ]).isRequired,
    /**
   * Show the component; triggers the enter or exit states
   */ in: _propTypesDefault.default.bool,
    /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */ mountOnEnter: _propTypesDefault.default.bool,
    /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */ unmountOnExit: _propTypesDefault.default.bool,
    /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */ appear: _propTypesDefault.default.bool,
    /**
   * Enable or disable enter transitions.
   */ enter: _propTypesDefault.default.bool,
    /**
   * Enable or disable exit transitions.
   */ exit: _propTypesDefault.default.bool,
    /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */ timeout: function timeout(props) {
        var pt = _propTypes1.timeoutsShape;
        if (!props.addEndListener) pt = pt.isRequired;
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
        return pt.apply(void 0, [
            props
        ].concat(args));
    },
    /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */ addEndListener: _propTypesDefault.default.func,
    /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */ onEnter: _propTypesDefault.default.func,
    /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */ onEntering: _propTypesDefault.default.func,
    /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */ onEntered: _propTypesDefault.default.func,
    /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */ onExit: _propTypesDefault.default.func,
    /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */ onExiting: _propTypesDefault.default.func,
    /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */ onExited: _propTypesDefault.default.func
}; // Name the function so it is clearer in the documentation
function noop() {
}
Transition1.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop,
    onEntering: noop,
    onEntered: noop,
    onExit: noop,
    onExiting: noop,
    onExited: noop
};
Transition1.UNMOUNTED = UNMOUNTED;
Transition1.EXITED = EXITED;
Transition1.ENTERING = ENTERING;
Transition1.ENTERED = ENTERED;
Transition1.EXITING = EXITING;
exports.default = Transition1;

},{"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose":"5cFhH","@babel/runtime/helpers/esm/inheritsLoose":"bzy6T","prop-types":"lYCp3","react":"cKM0D","react-dom":"ezGwg","./config":"fc2lB","./utils/PropTypes":"lFhYs","./TransitionGroupContext":"ixNEj","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"fc2lB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    disabled: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"lFhYs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timeoutsShape", ()=>timeoutsShape
);
parcelHelpers.export(exports, "classNamesShape", ()=>classNamesShape
);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var timeoutsShape = _propTypesDefault.default.oneOfType([
    _propTypesDefault.default.number,
    _propTypesDefault.default.shape({
        enter: _propTypesDefault.default.number,
        exit: _propTypesDefault.default.number,
        appear: _propTypesDefault.default.number
    }).isRequired
]);
var classNamesShape = _propTypesDefault.default.oneOfType([
    _propTypesDefault.default.string,
    _propTypesDefault.default.shape({
        enter: _propTypesDefault.default.string,
        exit: _propTypesDefault.default.string,
        active: _propTypesDefault.default.string
    }),
    _propTypesDefault.default.shape({
        enter: _propTypesDefault.default.string,
        enterDone: _propTypesDefault.default.string,
        enterActive: _propTypesDefault.default.string,
        exit: _propTypesDefault.default.string,
        exitDone: _propTypesDefault.default.string,
        exitActive: _propTypesDefault.default.string
    })
]);

},{"prop-types":"lYCp3","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"ixNEj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
exports.default = _reactDefault.default.createContext(null);

},{"react":"cKM0D","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hiVLh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectWithoutPropertiesLoose = require("@babel/runtime/helpers/esm/objectWithoutPropertiesLoose");
var _objectWithoutPropertiesLooseDefault = parcelHelpers.interopDefault(_objectWithoutPropertiesLoose);
var _inheritsLoose = require("@babel/runtime/helpers/esm/inheritsLoose");
var _inheritsLooseDefault = parcelHelpers.interopDefault(_inheritsLoose);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _reactDom = require("react-dom");
var _reactDomDefault = parcelHelpers.interopDefault(_reactDom);
var _transitionGroup = require("./TransitionGroup");
var _transitionGroupDefault = parcelHelpers.interopDefault(_transitionGroup);
/**
 * The `<ReplaceTransition>` component is a specialized `Transition` component
 * that animates between two children.
 *
 * ```jsx
 * <ReplaceTransition in>
 *   <Fade><div>I appear first</div></Fade>
 *   <Fade><div>I replace the above</div></Fade>
 * </ReplaceTransition>
 * ```
 */ var ReplaceTransition1 = /*#__PURE__*/ function(_React$Component) {
    _inheritsLooseDefault.default(ReplaceTransition2, _React$Component);
    function ReplaceTransition2() {
        var _this;
        for(var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++)_args[_key] = arguments[_key];
        _this = _React$Component.call.apply(_React$Component, [
            this
        ].concat(_args)) || this;
        _this.handleEnter = function() {
            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];
            return _this.handleLifecycle('onEnter', 0, args);
        };
        _this.handleEntering = function() {
            for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)args[_key3] = arguments[_key3];
            return _this.handleLifecycle('onEntering', 0, args);
        };
        _this.handleEntered = function() {
            for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)args[_key4] = arguments[_key4];
            return _this.handleLifecycle('onEntered', 0, args);
        };
        _this.handleExit = function() {
            for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++)args[_key5] = arguments[_key5];
            return _this.handleLifecycle('onExit', 1, args);
        };
        _this.handleExiting = function() {
            for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++)args[_key6] = arguments[_key6];
            return _this.handleLifecycle('onExiting', 1, args);
        };
        _this.handleExited = function() {
            for(var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++)args[_key7] = arguments[_key7];
            return _this.handleLifecycle('onExited', 1, args);
        };
        return _this;
    }
    var _proto = ReplaceTransition2.prototype;
    _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
        var _child$props;
        var children = this.props.children;
        var child = _reactDefault.default.Children.toArray(children)[idx];
        if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);
        if (this.props[handler]) {
            var maybeNode = child.props.nodeRef ? undefined : _reactDomDefault.default.findDOMNode(this);
            this.props[handler](maybeNode);
        }
    };
    _proto.render = function render() {
        var _this$props = this.props, children = _this$props.children, inProp = _this$props.in, props = _objectWithoutPropertiesLooseDefault.default(_this$props, [
            "children",
            "in"
        ]);
        var _React$Children$toArr = _reactDefault.default.Children.toArray(children), first = _React$Children$toArr[0], second = _React$Children$toArr[1];
        delete props.onEnter;
        delete props.onEntering;
        delete props.onEntered;
        delete props.onExit;
        delete props.onExiting;
        delete props.onExited;
        return(/*#__PURE__*/ _reactDefault.default.createElement(_transitionGroupDefault.default, props, inProp ? _reactDefault.default.cloneElement(first, {
            key: 'first',
            onEnter: this.handleEnter,
            onEntering: this.handleEntering,
            onEntered: this.handleEntered
        }) : _reactDefault.default.cloneElement(second, {
            key: 'second',
            onEnter: this.handleExit,
            onEntering: this.handleExiting,
            onEntered: this.handleExited
        })));
    };
    return ReplaceTransition2;
}(_reactDefault.default.Component);
ReplaceTransition1.propTypes = {
    in: _propTypesDefault.default.bool.isRequired,
    children: function children(props, propName) {
        if (_reactDefault.default.Children.count(props[propName]) !== 2) return new Error("\"" + propName + "\" must be exactly two transition components.");
        return null;
    }
};
exports.default = ReplaceTransition1;

},{"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose":"5cFhH","@babel/runtime/helpers/esm/inheritsLoose":"bzy6T","prop-types":"lYCp3","react":"cKM0D","react-dom":"ezGwg","./TransitionGroup":"dlcUl","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"dlcUl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectWithoutPropertiesLoose = require("@babel/runtime/helpers/esm/objectWithoutPropertiesLoose");
var _objectWithoutPropertiesLooseDefault = parcelHelpers.interopDefault(_objectWithoutPropertiesLoose);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _assertThisInitialized = require("@babel/runtime/helpers/esm/assertThisInitialized");
var _assertThisInitializedDefault = parcelHelpers.interopDefault(_assertThisInitialized);
var _inheritsLoose = require("@babel/runtime/helpers/esm/inheritsLoose");
var _inheritsLooseDefault = parcelHelpers.interopDefault(_inheritsLoose);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _transitionGroupContext = require("./TransitionGroupContext");
var _transitionGroupContextDefault = parcelHelpers.interopDefault(_transitionGroupContext);
var _childMapping = require("./utils/ChildMapping");
var values = Object.values || function(obj) {
    return Object.keys(obj).map(function(k) {
        return obj[k];
    });
};
var defaultProps = {
    component: 'div',
    childFactory: function childFactory(child) {
        return child;
    }
};
/**
 * The `<TransitionGroup>` component manages a set of transition components
 * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
 * components, `<TransitionGroup>` is a state machine for managing the mounting
 * and unmounting of components over time.
 *
 * Consider the example below. As items are removed or added to the TodoList the
 * `in` prop is toggled automatically by the `<TransitionGroup>`.
 *
 * Note that `<TransitionGroup>`  does not define any animation behavior!
 * Exactly _how_ a list item animates is up to the individual transition
 * component. This means you can mix and match animations across different list
 * items.
 */ var TransitionGroup1 = /*#__PURE__*/ function(_React$Component) {
    _inheritsLooseDefault.default(TransitionGroup2, _React$Component);
    function TransitionGroup2(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var handleExited = _this.handleExited.bind(_assertThisInitializedDefault.default(_this)); // Initial children should all be entering, dependent on appear
        _this.state = {
            contextValue: {
                isMounting: true
            },
            handleExited: handleExited,
            firstRender: true
        };
        return _this;
    }
    var _proto = TransitionGroup2.prototype;
    _proto.componentDidMount = function componentDidMount() {
        this.mounted = true;
        this.setState({
            contextValue: {
                isMounting: false
            }
        });
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
    };
    TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
        var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
        return {
            children: firstRender ? _childMapping.getInitialChildMapping(nextProps, handleExited) : _childMapping.getNextChildMapping(nextProps, prevChildMapping, handleExited),
            firstRender: false
        };
    } // node is `undefined` when user provided `nodeRef` prop
    ;
    _proto.handleExited = function handleExited(child, node) {
        var currentChildMapping = _childMapping.getChildMapping(this.props.children);
        if (child.key in currentChildMapping) return;
        if (child.props.onExited) child.props.onExited(node);
        if (this.mounted) this.setState(function(state) {
            var children = _extendsDefault.default({
            }, state.children);
            delete children[child.key];
            return {
                children: children
            };
        });
    };
    _proto.render = function render() {
        var _this$props = this.props, Component = _this$props.component, childFactory = _this$props.childFactory, props = _objectWithoutPropertiesLooseDefault.default(_this$props, [
            "component",
            "childFactory"
        ]);
        var contextValue = this.state.contextValue;
        var children = values(this.state.children).map(childFactory);
        delete props.appear;
        delete props.enter;
        delete props.exit;
        if (Component === null) return(/*#__PURE__*/ _reactDefault.default.createElement(_transitionGroupContextDefault.default.Provider, {
            value: contextValue
        }, children));
        return(/*#__PURE__*/ _reactDefault.default.createElement(_transitionGroupContextDefault.default.Provider, {
            value: contextValue
        }, /*#__PURE__*/ _reactDefault.default.createElement(Component, props, children)));
    };
    return TransitionGroup2;
}(_reactDefault.default.Component);
TransitionGroup1.propTypes = {
    /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */ component: _propTypesDefault.default.any,
    /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */ children: _propTypesDefault.default.node,
    /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */ appear: _propTypesDefault.default.bool,
    /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */ enter: _propTypesDefault.default.bool,
    /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */ exit: _propTypesDefault.default.bool,
    /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */ childFactory: _propTypesDefault.default.func
};
TransitionGroup1.defaultProps = defaultProps;
exports.default = TransitionGroup1;

},{"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose":"5cFhH","@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/assertThisInitialized":"lzVdl","@babel/runtime/helpers/esm/inheritsLoose":"bzy6T","prop-types":"lYCp3","react":"cKM0D","./TransitionGroupContext":"ixNEj","./utils/ChildMapping":"8NMdC","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8NMdC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */ parcelHelpers.export(exports, "getChildMapping", ()=>getChildMapping
);
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */ parcelHelpers.export(exports, "mergeChildMappings", ()=>mergeChildMappings
);
parcelHelpers.export(exports, "getInitialChildMapping", ()=>getInitialChildMapping
);
parcelHelpers.export(exports, "getNextChildMapping", ()=>getNextChildMapping
);
var _react = require("react");
function getChildMapping(children, mapFn) {
    var mapper = function mapper1(child) {
        return mapFn && _react.isValidElement(child) ? mapFn(child) : child;
    };
    var result = Object.create(null);
    if (children) _react.Children.map(children, function(c) {
        return c;
    }).forEach(function(child) {
        // run the map function here instead so that the key is the computed one
        result[child.key] = mapper(child);
    });
    return result;
}
function mergeChildMappings(prev, next) {
    prev = prev || {
    };
    next = next || {
    };
    function getValueForKey(key) {
        return key in next ? next[key] : prev[key];
    } // For each key of `next`, the list of keys to insert before that key in
    // the combined list
    var nextKeysPending = Object.create(null);
    var pendingKeys = [];
    for(var prevKey in prev){
        if (prevKey in next) {
            if (pendingKeys.length) {
                nextKeysPending[prevKey] = pendingKeys;
                pendingKeys = [];
            }
        } else pendingKeys.push(prevKey);
    }
    var i;
    var childMapping = {
    };
    for(var nextKey in next){
        if (nextKeysPending[nextKey]) for(i = 0; i < nextKeysPending[nextKey].length; i++){
            var pendingNextKey = nextKeysPending[nextKey][i];
            childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
        childMapping[nextKey] = getValueForKey(nextKey);
    } // Finally, add the keys which didn't appear before any key in `next`
    for(i = 0; i < pendingKeys.length; i++)childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    return childMapping;
}
function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function(child) {
        return _react.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: true,
            appear: getProp(child, 'appear', props),
            enter: getProp(child, 'enter', props),
            exit: getProp(child, 'exit', props)
        });
    });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function(key) {
        var child = children[key];
        if (!_react.isValidElement(child)) return;
        var hasPrev = key in prevChildMapping;
        var hasNext = key in nextChildMapping;
        var prevChild = prevChildMapping[key];
        var isLeaving = _react.isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)
        if (hasNext && (!hasPrev || isLeaving)) // console.log('entering', key)
        children[key] = _react.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: true,
            exit: getProp(child, 'exit', nextProps),
            enter: getProp(child, 'enter', nextProps)
        });
        else if (!hasNext && hasPrev && !isLeaving) // item is old (exiting)
        // console.log('leaving', key)
        children[key] = _react.cloneElement(child, {
            in: false
        });
        else if (hasNext && hasPrev && _react.isValidElement(prevChild)) // item hasn't changed transition states
        // copy over the last transition props;
        // console.log('unchanged', key)
        children[key] = _react.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: prevChild.props.in,
            exit: getProp(child, 'exit', nextProps),
            enter: getProp(child, 'enter', nextProps)
        });
    });
    return children;
}

},{"react":"cKM0D","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"aKgfI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "modes", ()=>modes
);
var _inheritsLoose = require("@babel/runtime/helpers/esm/inheritsLoose");
var _inheritsLooseDefault = parcelHelpers.interopDefault(_inheritsLoose);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _transition = require("./Transition");
var _transitionGroupContext = require("./TransitionGroupContext");
var _transitionGroupContextDefault = parcelHelpers.interopDefault(_transitionGroupContext);
var _leaveRenders, _enterRenders;
function areChildrenDifferent(oldChildren, newChildren) {
    if (oldChildren === newChildren) return false;
    if (_reactDefault.default.isValidElement(oldChildren) && _reactDefault.default.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) return false;
    return true;
}
var modes = {
    out: 'out-in',
    in: 'in-out'
};
var callHook = function callHook1(element, name, cb) {
    return function() {
        var _element$props;
        element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
        cb();
    };
};
var leaveRenders = (_leaveRenders = {
}, _leaveRenders[modes.out] = function(_ref) {
    var current = _ref.current, changeState = _ref.changeState;
    return _reactDefault.default.cloneElement(current, {
        in: false,
        onExited: callHook(current, 'onExited', function() {
            changeState(_transition.ENTERING, null);
        })
    });
}, _leaveRenders[modes.in] = function(_ref2) {
    var current = _ref2.current, changeState = _ref2.changeState, children = _ref2.children;
    return [
        current,
        _reactDefault.default.cloneElement(children, {
            in: true,
            onEntered: callHook(children, 'onEntered', function() {
                changeState(_transition.ENTERING);
            })
        })
    ];
}, _leaveRenders);
var enterRenders = (_enterRenders = {
}, _enterRenders[modes.out] = function(_ref3) {
    var children = _ref3.children, changeState = _ref3.changeState;
    return _reactDefault.default.cloneElement(children, {
        in: true,
        onEntered: callHook(children, 'onEntered', function() {
            changeState(_transition.ENTERED, _reactDefault.default.cloneElement(children, {
                in: true
            }));
        })
    });
}, _enterRenders[modes.in] = function(_ref4) {
    var current = _ref4.current, children = _ref4.children, changeState = _ref4.changeState;
    return [
        _reactDefault.default.cloneElement(current, {
            in: false,
            onExited: callHook(current, 'onExited', function() {
                changeState(_transition.ENTERED, _reactDefault.default.cloneElement(children, {
                    in: true
                }));
            })
        }),
        _reactDefault.default.cloneElement(children, {
            in: true
        })
    ];
}, _enterRenders);
/**
 * A transition component inspired by the [vue transition modes](https://vuejs.org/v2/guide/transitions.html#Transition-Modes).
 * You can use it when you want to control the render between state transitions.
 * Based on the selected mode and the child's key which is the `Transition` or `CSSTransition` component, the `SwitchTransition` makes a consistent transition between them.
 *
 * If the `out-in` mode is selected, the `SwitchTransition` waits until the old child leaves and then inserts a new child.
 * If the `in-out` mode is selected, the `SwitchTransition` inserts a new child first, waits for the new child to enter and then removes the old child.
 *
 * **Note**: If you want the animation to happen simultaneously
 * (that is, to have the old child removed and a new child inserted **at the same time**),
 * you should use
 * [`TransitionGroup`](https://reactcommunity.org/react-transition-group/transition-group)
 * instead.
 *
 * ```jsx
 * function App() {
 *  const [state, setState] = useState(false);
 *  return (
 *    <SwitchTransition>
 *      <CSSTransition
 *        key={state ? "Goodbye, world!" : "Hello, world!"}
 *        addEndListener={(node, done) => node.addEventListener("transitionend", done, false)}
 *        classNames='fade'
 *      >
 *        <button onClick={() => setState(state => !state)}>
 *          {state ? "Goodbye, world!" : "Hello, world!"}
 *        </button>
 *      </CSSTransition>
 *    </SwitchTransition>
 *  );
 * }
 * ```
 *
 * ```css
 * .fade-enter{
 *    opacity: 0;
 * }
 * .fade-exit{
 *    opacity: 1;
 * }
 * .fade-enter-active{
 *    opacity: 1;
 * }
 * .fade-exit-active{
 *    opacity: 0;
 * }
 * .fade-enter-active,
 * .fade-exit-active{
 *    transition: opacity 500ms;
 * }
 * ```
 */ var SwitchTransition1 = /*#__PURE__*/ function(_React$Component) {
    _inheritsLooseDefault.default(SwitchTransition2, _React$Component);
    function SwitchTransition2() {
        var _this;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        _this = _React$Component.call.apply(_React$Component, [
            this
        ].concat(args)) || this;
        _this.state = {
            status: _transition.ENTERED,
            current: null
        };
        _this.appeared = false;
        _this.changeState = function(status, current) {
            if (current === void 0) current = _this.state.current;
            _this.setState({
                status: status,
                current: current
            });
        };
        return _this;
    }
    var _proto = SwitchTransition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
        this.appeared = true;
    };
    SwitchTransition2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
        if (props.children == null) return {
            current: null
        };
        if (state.status === _transition.ENTERING && props.mode === modes.in) return {
            status: _transition.ENTERING
        };
        if (state.current && areChildrenDifferent(state.current, props.children)) return {
            status: _transition.EXITING
        };
        return {
            current: _reactDefault.default.cloneElement(props.children, {
                in: true
            })
        };
    };
    _proto.render = function render() {
        var _this$props = this.props, children = _this$props.children, mode = _this$props.mode, _this$state = this.state, status = _this$state.status, current = _this$state.current;
        var data = {
            children: children,
            current: current,
            changeState: this.changeState,
            status: status
        };
        var component;
        switch(status){
            case _transition.ENTERING:
                component = enterRenders[mode](data);
                break;
            case _transition.EXITING:
                component = leaveRenders[mode](data);
                break;
            case _transition.ENTERED:
                component = current;
        }
        return(/*#__PURE__*/ _reactDefault.default.createElement(_transitionGroupContextDefault.default.Provider, {
            value: {
                isMounting: !this.appeared
            }
        }, component));
    };
    return SwitchTransition2;
}(_reactDefault.default.Component);
SwitchTransition1.propTypes = {
    /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */ mode: _propTypesDefault.default.oneOf([
        modes.in,
        modes.out
    ]),
    /**
   * Any `Transition` or `CSSTransition` component.
   */ children: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.element.isRequired
    ])
};
SwitchTransition1.defaultProps = {
    mode: modes.out
};
exports.default = SwitchTransition1;

},{"@babel/runtime/helpers/esm/inheritsLoose":"bzy6T","react":"cKM0D","prop-types":"lYCp3","./Transition":"3rht9","./TransitionGroupContext":"ixNEj","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5rBJ1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "reflow", ()=>reflow
);
parcelHelpers.export(exports, "getTransitionProps", ()=>getTransitionProps
);
var reflow = function reflow1(node) {
    return node.scrollTop;
};
function getTransitionProps(props, options) {
    var timeout = props.timeout, _props$style = props.style, style = _props$style === void 0 ? {
    } : _props$style;
    return {
        duration: style.transitionDuration || typeof timeout === 'number' ? timeout : timeout[options.mode] || 0,
        delay: style.transitionDelay
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"ifp4E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_paperDefault.default
);
var _paper = require("./Paper");
var _paperDefault = parcelHelpers.interopDefault(_paper);

},{"./Paper":"4kj5f","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"4kj5f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var styles = function styles1(theme) {
    var elevations = {
    };
    theme.shadows.forEach(function(shadow, index) {
        elevations["elevation".concat(index)] = {
            boxShadow: shadow
        };
    });
    return _extendsDefault.default({
        /* Styles applied to the root element. */ root: {
            backgroundColor: theme.palette.background.paper,
            color: theme.palette.text.primary,
            transition: theme.transitions.create('box-shadow')
        },
        /* Styles applied to the root element if `square={false}`. */ rounded: {
            borderRadius: theme.shape.borderRadius
        },
        /* Styles applied to the root element if `variant="outlined"`. */ outlined: {
            border: "1px solid ".concat(theme.palette.divider)
        }
    }, elevations);
};
var Paper = /*#__PURE__*/ _react.forwardRef(function Paper1(props, ref) {
    var classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? 'div' : _props$component, _props$square = props.square, square = _props$square === void 0 ? false : _props$square, _props$elevation = props.elevation, elevation = _props$elevation === void 0 ? 1 : _props$elevation, _props$variant = props.variant, variant = _props$variant === void 0 ? 'elevation' : _props$variant, other = _objectWithoutPropertiesDefault.default(props, [
        "classes",
        "className",
        "component",
        "square",
        "elevation",
        "variant"
    ]);
    return(/*#__PURE__*/ _react.createElement(Component, _extendsDefault.default({
        className: _clsxDefault.default(classes.root, className, variant === 'outlined' ? classes.outlined : classes["elevation".concat(elevation)], !square && classes.rounded),
        ref: ref
    }, other)));
});
Paper.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * The content of the component.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */ component: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .elementType,
    /**
   * Shadow depth, corresponds to `dp` in the spec.
   * It accepts values between 0 and 24 inclusive.
   */ elevation: _utils.chainPropTypes(_propTypesDefault.default.number, function(props) {
        var classes = props.classes, elevation = props.elevation; // in case `withStyles` fails to inject we don't need this warning
        if (classes === undefined) return null;
        if (elevation != null && classes["elevation".concat(elevation)] === undefined) return new Error("Material-UI: This elevation `".concat(elevation, "` is not implemented."));
        return null;
    }),
    /**
   * If `true`, rounded corners are disabled.
   */ square: _propTypesDefault.default.bool,
    /**
   * The variant to use.
   */ variant: _propTypesDefault.default.oneOf([
        'elevation',
        'outlined'
    ])
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiPaper'
})(Paper);

},{"@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@babel/runtime/helpers/esm/extends":"esrVD","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","@material-ui/utils":"Uumnw","../styles/withStyles":"3pIr2","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"fhGGr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_menuListDefault.default
);
var _menuList = require("./MenuList");
var _menuListDefault = parcelHelpers.interopDefault(_menuList);

},{"./MenuList":"1n4eu","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"1n4eu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _reactIs = require("react-is");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _reactDom = require("react-dom");
var _ownerDocument = require("../utils/ownerDocument");
var _ownerDocumentDefault = parcelHelpers.interopDefault(_ownerDocument);
var _list = require("../List");
var _listDefault = parcelHelpers.interopDefault(_list);
var _getScrollbarSize = require("../utils/getScrollbarSize");
var _getScrollbarSizeDefault = parcelHelpers.interopDefault(_getScrollbarSize);
var _useForkRef = require("../utils/useForkRef");
var _useForkRefDefault = parcelHelpers.interopDefault(_useForkRef);
function nextItem(list, item, disableListWrap) {
    if (list === item) return list.firstChild;
    if (item && item.nextElementSibling) return item.nextElementSibling;
    return disableListWrap ? null : list.firstChild;
}
function previousItem(list, item, disableListWrap) {
    if (list === item) return disableListWrap ? list.firstChild : list.lastChild;
    if (item && item.previousElementSibling) return item.previousElementSibling;
    return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
    if (textCriteria === undefined) return true;
    var text = nextFocus.innerText;
    if (text === undefined) // jsdom doesn't support innerText
    text = nextFocus.textContent;
    text = text.trim().toLowerCase();
    if (text.length === 0) return false;
    if (textCriteria.repeating) return text[0] === textCriteria.keys[0];
    return text.indexOf(textCriteria.keys.join('')) === 0;
}
function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
    var wrappedOnce = false;
    var nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
    while(nextFocus){
        // Prevent infinite loop.
        if (nextFocus === list.firstChild) {
            if (wrappedOnce) return;
            wrappedOnce = true;
        } // Same logic as useAutocomplete.js
        var nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';
        if (!nextFocus.hasAttribute('tabindex') || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) // Move to the next element.
        nextFocus = traversalFunction(list, nextFocus, disableListWrap);
        else {
            nextFocus.focus();
            return;
        }
    }
}
var useEnhancedEffect = typeof window === 'undefined' ? _react.useEffect : _react.useLayoutEffect;
/**
 * A permanently displayed menu following https://www.w3.org/TR/wai-aria-practices/#menubutton.
 * It's exposed to help customization of the [`Menu`](/api/menu/) component. If you
 * use it separately you need to move focus into the component manually. Once
 * the focus is placed inside the component it is fully keyboard accessible.
 */ var MenuList = /*#__PURE__*/ _react.forwardRef(function MenuList1(props, ref) {
    var actions = props.actions, _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus, _props$autoFocusItem = props.autoFocusItem, autoFocusItem = _props$autoFocusItem === void 0 ? false : _props$autoFocusItem, children = props.children, className = props.className, _props$disabledItemsF = props.disabledItemsFocusable, disabledItemsFocusable = _props$disabledItemsF === void 0 ? false : _props$disabledItemsF, _props$disableListWra = props.disableListWrap, disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra, onKeyDown = props.onKeyDown, _props$variant = props.variant, variant = _props$variant === void 0 ? 'selectedMenu' : _props$variant, other = _objectWithoutPropertiesDefault.default(props, [
        "actions",
        "autoFocus",
        "autoFocusItem",
        "children",
        "className",
        "disabledItemsFocusable",
        "disableListWrap",
        "onKeyDown",
        "variant"
    ]);
    var listRef = _react.useRef(null);
    var textCriteriaRef = _react.useRef({
        keys: [],
        repeating: true,
        previousKeyMatched: true,
        lastTime: null
    });
    useEnhancedEffect(function() {
        if (autoFocus) listRef.current.focus();
    }, [
        autoFocus
    ]);
    _react.useImperativeHandle(actions, function() {
        return {
            adjustStyleForScrollbar: function adjustStyleForScrollbar(containerElement, theme) {
                // Let's ignore that piece of logic if users are already overriding the width
                // of the menu.
                var noExplicitWidth = !listRef.current.style.width;
                if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
                    var scrollbarSize = "".concat(_getScrollbarSizeDefault.default(true), "px");
                    listRef.current.style[theme.direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;
                    listRef.current.style.width = "calc(100% + ".concat(scrollbarSize, ")");
                }
                return listRef.current;
            }
        };
    }, []);
    var handleKeyDown = function handleKeyDown1(event) {
        var list = listRef.current;
        var key = event.key;
        /**
     * @type {Element} - will always be defined since we are in a keydown handler
     * attached to an element. A keydown event is either dispatched to the activeElement
     * or document.body or document.documentElement. Only the first case will
     * trigger this specific handler.
     */ var currentFocus = _ownerDocumentDefault.default(list).activeElement;
        if (key === 'ArrowDown') {
            // Prevent scroll of the page
            event.preventDefault();
            moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
        } else if (key === 'ArrowUp') {
            event.preventDefault();
            moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
        } else if (key === 'Home') {
            event.preventDefault();
            moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
        } else if (key === 'End') {
            event.preventDefault();
            moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
        } else if (key.length === 1) {
            var criteria = textCriteriaRef.current;
            var lowerKey = key.toLowerCase();
            var currTime = performance.now();
            if (criteria.keys.length > 0) {
                // Reset
                if (currTime - criteria.lastTime > 500) {
                    criteria.keys = [];
                    criteria.repeating = true;
                    criteria.previousKeyMatched = true;
                } else if (criteria.repeating && lowerKey !== criteria.keys[0]) criteria.repeating = false;
            }
            criteria.lastTime = currTime;
            criteria.keys.push(lowerKey);
            var keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
            if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) event.preventDefault();
            else criteria.previousKeyMatched = false;
        }
        if (onKeyDown) onKeyDown(event);
    };
    var handleOwnRef = _react.useCallback(function(instance) {
        // #StrictMode ready
        listRef.current = _reactDom.findDOMNode(instance);
    }, []);
    var handleRef = _useForkRefDefault.default(handleOwnRef, ref);
    /**
   * the index of the item should receive focus
   * in a `variant="selectedMenu"` it's the first `selected` item
   * otherwise it's the very first item.
   */ var activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead
    // to check if there is a `selected` item. We're looking for the last `selected`
    // item and use the first valid item as a fallback
    _react.Children.forEach(children, function(child, index) {
        if (!/*#__PURE__*/ _react.isValidElement(child)) return;
        if (_reactIs.isFragment(child)) console.error([
            "Material-UI: The Menu component doesn't accept a Fragment as a child.",
            'Consider providing an array instead.'
        ].join('\n'));
        if (!child.props.disabled) {
            if (variant === 'selectedMenu' && child.props.selected) activeItemIndex = index;
            else if (activeItemIndex === -1) activeItemIndex = index;
        }
    });
    var items = _react.Children.map(children, function(child, index) {
        if (index === activeItemIndex) {
            var newChildProps = {
            };
            if (autoFocusItem) newChildProps.autoFocus = true;
            if (child.props.tabIndex === undefined && variant === 'selectedMenu') newChildProps.tabIndex = 0;
            return(/*#__PURE__*/ _react.cloneElement(child, newChildProps));
        }
        return child;
    });
    return(/*#__PURE__*/ _react.createElement(_listDefault.default, _extendsDefault.default({
        role: "menu",
        ref: handleRef,
        className: className,
        onKeyDown: handleKeyDown,
        tabIndex: autoFocus ? 0 : -1
    }, other), items));
});
MenuList.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * If `true`, will focus the `[role="menu"]` container and move into tab order.
   */ autoFocus: _propTypesDefault.default.bool,
    /**
   * If `true`, will focus the first menuitem if `variant="menu"` or selected item
   * if `variant="selectedMenu"`.
   */ autoFocusItem: _propTypesDefault.default.bool,
    /**
   * MenuList contents, normally `MenuItem`s.
   */ children: _propTypesDefault.default.node,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * If `true`, will allow focus on disabled items.
   */ disabledItemsFocusable: _propTypesDefault.default.bool,
    /**
   * If `true`, the menu items will not wrap focus.
   */ disableListWrap: _propTypesDefault.default.bool,
    /**
   * @ignore
   */ onKeyDown: _propTypesDefault.default.func,
    /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   */ variant: _propTypesDefault.default.oneOf([
        'menu',
        'selectedMenu'
    ])
};
exports.default = MenuList;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","react-is":"gtJo0","prop-types":"lYCp3","react-dom":"ezGwg","../utils/ownerDocument":"jeIVD","../List":"5XqG4","../utils/getScrollbarSize":"7fSUR","../utils/useForkRef":"bLpHM","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5XqG4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_listDefault.default
);
var _list = require("./List");
var _listDefault = parcelHelpers.interopDefault(_list);

},{"./List":"kPKRo","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"kPKRo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _listContext = require("./ListContext");
var _listContextDefault = parcelHelpers.interopDefault(_listContext);
var styles = {
    /* Styles applied to the root element. */ root: {
        listStyle: 'none',
        margin: 0,
        padding: 0,
        position: 'relative'
    },
    /* Styles applied to the root element if `disablePadding={false}`. */ padding: {
        paddingTop: 8,
        paddingBottom: 8
    },
    /* Styles applied to the root element if dense. */ dense: {
    },
    /* Styles applied to the root element if a `subheader` is provided. */ subheader: {
        paddingTop: 0
    }
};
var List = /*#__PURE__*/ _react.forwardRef(function List1(props, ref) {
    var children = props.children, classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? 'ul' : _props$component, _props$dense = props.dense, dense = _props$dense === void 0 ? false : _props$dense, _props$disablePadding = props.disablePadding, disablePadding = _props$disablePadding === void 0 ? false : _props$disablePadding, subheader = props.subheader, other = _objectWithoutPropertiesDefault.default(props, [
        "children",
        "classes",
        "className",
        "component",
        "dense",
        "disablePadding",
        "subheader"
    ]);
    var context = _react.useMemo(function() {
        return {
            dense: dense
        };
    }, [
        dense
    ]);
    return(/*#__PURE__*/ _react.createElement(_listContextDefault.default.Provider, {
        value: context
    }, /*#__PURE__*/ _react.createElement(Component, _extendsDefault.default({
        className: _clsxDefault.default(classes.root, className, dense && classes.dense, !disablePadding && classes.padding, subheader && classes.subheader),
        ref: ref
    }, other), subheader, children)));
});
List.propTypes = {
    /**
   * The content of the component.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object.isRequired,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */ component: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .elementType,
    /**
   * If `true`, compact vertical padding designed for keyboard and mouse input will be used for
   * the list and list items.
   * The prop is available to descendant components as the `dense` context.
   */ dense: _propTypesDefault.default.bool,
    /**
   * If `true`, vertical padding will be removed from the list.
   */ disablePadding: _propTypesDefault.default.bool,
    /**
   * The content of the subheader, normally `ListSubheader`.
   */ subheader: _propTypesDefault.default.node
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiList'
})(List);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","../styles/withStyles":"3pIr2","./ListContext":"dRYfc","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"dRYfc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
/**
 * @ignore - internal component.
 */ var ListContext = _react.createContext({
});
ListContext.displayName = 'ListContext';
exports.default = ListContext;

},{"react":"cKM0D","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hpiZY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */ var _react = require("react");
function useControlled(_ref) {
    var controlled = _ref.controlled, defaultProp = _ref.default, name = _ref.name, _ref$state = _ref.state, state = _ref$state === void 0 ? 'value' : _ref$state;
    var _React$useRef = _react.useRef(controlled !== undefined), isControlled = _React$useRef.current;
    var _React$useState = _react.useState(defaultProp), valueState = _React$useState[0], setValue = _React$useState[1];
    var value = isControlled ? controlled : valueState;
    _react.useEffect(function() {
        if (isControlled !== (controlled !== undefined)) console.error([
            "Material-UI: A component is changing the ".concat(isControlled ? '' : 'un', "controlled ").concat(state, " state of ").concat(name, " to be ").concat(isControlled ? 'un' : '', "controlled."),
            'Elements should not switch from uncontrolled to controlled (or vice versa).',
            "Decide between using a controlled or uncontrolled ".concat(name, " ") + 'element for the lifetime of the component.',
            "The nature of the state is determined during the first render, it's considered controlled if the value is not `undefined`.",
            'More info: https://fb.me/react-controlled-components'
        ].join('\n'));
    }, [
        controlled
    ]);
    var _React$useRef2 = _react.useRef(defaultProp), defaultValue = _React$useRef2.current;
    _react.useEffect(function() {
        if (!isControlled && defaultValue !== defaultProp) console.error([
            "Material-UI: A component is changing the default ".concat(state, " state of an uncontrolled ").concat(name, " after being initialized. ") + "To suppress this warning opt to use a controlled ".concat(name, ".")
        ].join('\n'));
    }, [
        JSON.stringify(defaultProp)
    ]);
    var setValueIfUncontrolled = _react.useCallback(function(newValue) {
        if (!isControlled) setValue(newValue);
    }, []);
    return [
        value,
        setValueIfUncontrolled
    ];
}
exports.default = useControlled;

},{"react":"cKM0D","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8XFSg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _createSvgIcon = require("../../utils/createSvgIcon");
var _createSvgIconDefault = parcelHelpers.interopDefault(_createSvgIcon);
exports.default = _createSvgIconDefault.default(/*#__PURE__*/ _react.createElement("path", {
    d: "M7 10l5 5 5-5z"
}), 'ArrowDropDown');

},{"react":"cKM0D","../../utils/createSvgIcon":"78Y91","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"78Y91":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _svgIcon = require("../SvgIcon");
var _svgIconDefault = parcelHelpers.interopDefault(_svgIcon);
function createSvgIcon(path, displayName) {
    var Component = function Component1(props, ref) {
        return(/*#__PURE__*/ _reactDefault.default.createElement(_svgIconDefault.default, _extendsDefault.default({
            ref: ref
        }, props), path));
    };
    // Need to set `displayName` on the inner component for React.memo.
    // React prior to 16.14 ignores `displayName` on the wrapper.
    Component.displayName = "".concat(displayName, "Icon");
    Component.muiName = _svgIconDefault.default.muiName;
    return(/*#__PURE__*/ _reactDefault.default.memo(/*#__PURE__*/ _reactDefault.default.forwardRef(Component)));
}
exports.default = createSvgIcon;

},{"@babel/runtime/helpers/esm/extends":"esrVD","react":"cKM0D","../SvgIcon":"1RtIX","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"1RtIX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_svgIconDefault.default
);
var _svgIcon = require("./SvgIcon");
var _svgIconDefault = parcelHelpers.interopDefault(_svgIcon);

},{"./SvgIcon":"6Q9wk","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"6Q9wk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _capitalize = require("../utils/capitalize");
var _capitalizeDefault = parcelHelpers.interopDefault(_capitalize);
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            userSelect: 'none',
            width: '1em',
            height: '1em',
            display: 'inline-block',
            fill: 'currentColor',
            flexShrink: 0,
            fontSize: theme.typography.pxToRem(24),
            transition: theme.transitions.create('fill', {
                duration: theme.transitions.duration.shorter
            })
        },
        /* Styles applied to the root element if `color="primary"`. */ colorPrimary: {
            color: theme.palette.primary.main
        },
        /* Styles applied to the root element if `color="secondary"`. */ colorSecondary: {
            color: theme.palette.secondary.main
        },
        /* Styles applied to the root element if `color="action"`. */ colorAction: {
            color: theme.palette.action.active
        },
        /* Styles applied to the root element if `color="error"`. */ colorError: {
            color: theme.palette.error.main
        },
        /* Styles applied to the root element if `color="disabled"`. */ colorDisabled: {
            color: theme.palette.action.disabled
        },
        /* Styles applied to the root element if `fontSize="inherit"`. */ fontSizeInherit: {
            fontSize: 'inherit'
        },
        /* Styles applied to the root element if `fontSize="small"`. */ fontSizeSmall: {
            fontSize: theme.typography.pxToRem(20)
        },
        /* Styles applied to the root element if `fontSize="large"`. */ fontSizeLarge: {
            fontSize: theme.typography.pxToRem(35)
        }
    };
};
var SvgIcon = /*#__PURE__*/ _react.forwardRef(function SvgIcon1(props, ref) {
    var children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? 'inherit' : _props$color, _props$component = props.component, Component = _props$component === void 0 ? 'svg' : _props$component, _props$fontSize = props.fontSize, fontSize = _props$fontSize === void 0 ? 'medium' : _props$fontSize, htmlColor = props.htmlColor, titleAccess = props.titleAccess, _props$viewBox = props.viewBox, viewBox = _props$viewBox === void 0 ? '0 0 24 24' : _props$viewBox, other = _objectWithoutPropertiesDefault.default(props, [
        "children",
        "classes",
        "className",
        "color",
        "component",
        "fontSize",
        "htmlColor",
        "titleAccess",
        "viewBox"
    ]);
    return(/*#__PURE__*/ _react.createElement(Component, _extendsDefault.default({
        className: _clsxDefault.default(classes.root, className, color !== 'inherit' && classes["color".concat(_capitalizeDefault.default(color))], fontSize !== 'default' && fontSize !== 'medium' && classes["fontSize".concat(_capitalizeDefault.default(fontSize))]),
        focusable: "false",
        viewBox: viewBox,
        color: htmlColor,
        "aria-hidden": titleAccess ? undefined : true,
        role: titleAccess ? 'img' : undefined,
        ref: ref
    }, other), children, titleAccess ? /*#__PURE__*/ _react.createElement("title", null, titleAccess) : null));
});
SvgIcon.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * Node passed into the SVG element.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   */ color: _propTypesDefault.default.oneOf([
        'action',
        'disabled',
        'error',
        'inherit',
        'primary',
        'secondary'
    ]),
    /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */ component: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .elementType,
    /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   */ fontSize: _utils.chainPropTypes(_propTypesDefault.default.oneOf([
        'default',
        'inherit',
        'large',
        'medium',
        'small'
    ]), function(props) {
        var fontSize = props.fontSize;
        if (fontSize === 'default') throw new Error('Material-UI: `fontSize="default"` is deprecated. Use `fontSize="medium"` instead.');
        return null;
    }),
    /**
   * Applies a color attribute to the SVG element.
   */ htmlColor: _propTypesDefault.default.string,
    /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this property.
   */ shapeRendering: _propTypesDefault.default.string,
    /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */ titleAccess: _propTypesDefault.default.string,
    /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   */ viewBox: _propTypesDefault.default.string
};
SvgIcon.muiName = 'SvgIcon';
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiSvgIcon'
})(SvgIcon);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","@material-ui/utils":"Uumnw","../styles/withStyles":"3pIr2","../utils/capitalize":"4RyDE","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"6Dkyt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _nativeSelectInput = require("./NativeSelectInput");
var _nativeSelectInputDefault = parcelHelpers.interopDefault(_nativeSelectInput);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _formControlState = require("../FormControl/formControlState");
var _formControlStateDefault = parcelHelpers.interopDefault(_formControlState);
var _useFormControl = require("../FormControl/useFormControl");
var _useFormControlDefault = parcelHelpers.interopDefault(_useFormControl);
var _arrowDropDown = require("../internal/svg-icons/ArrowDropDown");
var _arrowDropDownDefault = parcelHelpers.interopDefault(_arrowDropDown);
var _input = require("../Input");
var _inputDefault = parcelHelpers.interopDefault(_input);
var styles = function styles1(theme) {
    return {
        /* Styles applied to the select component `root` class. */ root: {
        },
        /* Styles applied to the select component `select` class. */ select: {
            '-moz-appearance': 'none',
            // Reset
            '-webkit-appearance': 'none',
            // Reset
            // When interacting quickly, the text can end up selected.
            // Native select can't be selected either.
            userSelect: 'none',
            borderRadius: 0,
            // Reset
            minWidth: 16,
            // So it doesn't collapse.
            cursor: 'pointer',
            '&:focus': {
                // Show that it's not an text input
                backgroundColor: theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)',
                borderRadius: 0 // Reset Chrome style
            },
            // Remove IE 11 arrow
            '&::-ms-expand': {
                display: 'none'
            },
            '&$disabled': {
                cursor: 'default'
            },
            '&[multiple]': {
                height: 'auto'
            },
            '&:not([multiple]) option, &:not([multiple]) optgroup': {
                backgroundColor: theme.palette.background.paper
            },
            '&&': {
                paddingRight: 24
            }
        },
        /* Styles applied to the select component if `variant="filled"`. */ filled: {
            '&&': {
                paddingRight: 32
            }
        },
        /* Styles applied to the select component if `variant="outlined"`. */ outlined: {
            borderRadius: theme.shape.borderRadius,
            '&&': {
                paddingRight: 32
            }
        },
        /* Styles applied to the select component `selectMenu` class. */ selectMenu: {
            height: 'auto',
            // Resets for multpile select with chips
            minHeight: '1.1876em',
            // Required for select\text-field height consistency
            textOverflow: 'ellipsis',
            whiteSpace: 'nowrap',
            overflow: 'hidden'
        },
        /* Pseudo-class applied to the select component `disabled` class. */ disabled: {
        },
        /* Styles applied to the icon component. */ icon: {
            // We use a position absolute over a flexbox in order to forward the pointer events
            // to the input and to support wrapping tags..
            position: 'absolute',
            right: 0,
            top: 'calc(50% - 12px)',
            // Center vertically
            pointerEvents: 'none',
            // Don't block pointer events on the select under the icon.
            color: theme.palette.action.active,
            '&$disabled': {
                color: theme.palette.action.disabled
            }
        },
        /* Styles applied to the icon component if the popup is open. */ iconOpen: {
            transform: 'rotate(180deg)'
        },
        /* Styles applied to the icon component if `variant="filled"`. */ iconFilled: {
            right: 7
        },
        /* Styles applied to the icon component if `variant="outlined"`. */ iconOutlined: {
            right: 7
        },
        /* Styles applied to the underlying native input component. */ nativeInput: {
            bottom: 0,
            left: 0,
            position: 'absolute',
            opacity: 0,
            pointerEvents: 'none',
            width: '100%'
        }
    };
};
var defaultInput = /*#__PURE__*/ _react.createElement(_inputDefault.default, null);
/**
 * An alternative to `<Select native />` with a much smaller bundle size footprint.
 */ var NativeSelect = /*#__PURE__*/ _react.forwardRef(function NativeSelect1(props, ref) {
    var children = props.children, classes = props.classes, _props$IconComponent = props.IconComponent, IconComponent = _props$IconComponent === void 0 ? _arrowDropDownDefault.default : _props$IconComponent, _props$input = props.input, input = _props$input === void 0 ? defaultInput : _props$input, inputProps = props.inputProps, variant = props.variant, other = _objectWithoutPropertiesDefault.default(props, [
        "children",
        "classes",
        "IconComponent",
        "input",
        "inputProps",
        "variant"
    ]);
    var muiFormControl = _useFormControlDefault.default();
    var fcs = _formControlStateDefault.default({
        props: props,
        muiFormControl: muiFormControl,
        states: [
            'variant'
        ]
    });
    return(/*#__PURE__*/ _react.cloneElement(input, _extendsDefault.default({
        // Most of the logic is implemented in `NativeSelectInput`.
        // The `Select` component is a simple API wrapper to expose something better to play with.
        inputComponent: _nativeSelectInputDefault.default,
        inputProps: _extendsDefault.default({
            children: children,
            classes: classes,
            IconComponent: IconComponent,
            variant: fcs.variant,
            type: undefined
        }, inputProps, input ? input.props.inputProps : {
        }),
        ref: ref
    }, other)));
});
NativeSelect.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * The option elements to populate the select with.
   * Can be some `<option>` elements.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * The icon that displays the arrow.
   */ IconComponent: _propTypesDefault.default.elementType,
    /**
   * An `Input` element; does not have to be a material-ui specific `Input`.
   */ input: _propTypesDefault.default.element,
    /**
   * Attributes applied to the `select` element.
   */ inputProps: _propTypesDefault.default.object,
    /**
   * Callback function fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */ onChange: _propTypesDefault.default.func,
    /**
   * The input value. The DOM API casts this to a string.
   */ value: _propTypesDefault.default.any,
    /**
   * The variant to use.
   */ variant: _propTypesDefault.default.oneOf([
        'filled',
        'outlined',
        'standard'
    ])
};
NativeSelect.muiName = 'Select';
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiNativeSelect'
})(NativeSelect);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","./NativeSelectInput":"2mvpj","../styles/withStyles":"3pIr2","../FormControl/formControlState":"hHO4w","../FormControl/useFormControl":"hjPoI","../internal/svg-icons/ArrowDropDown":"8XFSg","../Input":"1b3pY","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"2mvpj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _capitalize = require("../utils/capitalize");
var _capitalizeDefault = parcelHelpers.interopDefault(_capitalize);
/**
 * @ignore - internal component.
 */ var NativeSelectInput = /*#__PURE__*/ _react.forwardRef(function NativeSelectInput1(props, ref) {
    var classes = props.classes, className = props.className, disabled = props.disabled, IconComponent = props.IconComponent, inputRef = props.inputRef, _props$variant = props.variant, variant = _props$variant === void 0 ? 'standard' : _props$variant, other = _objectWithoutPropertiesDefault.default(props, [
        "classes",
        "className",
        "disabled",
        "IconComponent",
        "inputRef",
        "variant"
    ]);
    return(/*#__PURE__*/ _react.createElement(_react.Fragment, null, /*#__PURE__*/ _react.createElement("select", _extendsDefault.default({
        className: _clsxDefault.default(classes.root, classes.select, classes[variant], className, disabled && classes.disabled),
        disabled: disabled,
        ref: inputRef || ref
    }, other)), props.multiple ? null : /*#__PURE__*/ _react.createElement(IconComponent, {
        className: _clsxDefault.default(classes.icon, classes["icon".concat(_capitalizeDefault.default(variant))], disabled && classes.disabled)
    })));
});
NativeSelectInput.propTypes = {
    /**
   * The option elements to populate the select with.
   * Can be some `<option>` elements.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object.isRequired,
    /**
   * The CSS class name of the select element.
   */ className: _propTypesDefault.default.string,
    /**
   * If `true`, the select will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * The icon that displays the arrow.
   */ IconComponent: _propTypesDefault.default.elementType.isRequired,
    /**
   * Use that prop to pass a ref to the native select element.
   * @deprecated
   */ inputRef: _utils.refType,
    /**
   * @ignore
   */ multiple: _propTypesDefault.default.bool,
    /**
   * Name attribute of the `select` or hidden `input` element.
   */ name: _propTypesDefault.default.string,
    /**
   * Callback function fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */ onChange: _propTypesDefault.default.func,
    /**
   * The input value.
   */ value: _propTypesDefault.default.any,
    /**
   * The variant to use.
   */ variant: _propTypesDefault.default.oneOf([
        'standard',
        'outlined',
        'filled'
    ])
};
exports.default = NativeSelectInput;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","@material-ui/utils":"Uumnw","../utils/capitalize":"4RyDE","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"lEQJw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_buttonDefault.default
);
var _button = require("./Button");
var _buttonDefault = parcelHelpers.interopDefault(_button);

},{"./Button":"hJOJY","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hJOJY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _colorManipulator = require("../styles/colorManipulator");
var _buttonBase = require("../ButtonBase");
var _buttonBaseDefault = parcelHelpers.interopDefault(_buttonBase);
var _capitalize = require("../utils/capitalize");
var _capitalizeDefault = parcelHelpers.interopDefault(_capitalize);
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: _extendsDefault.default({
        }, theme.typography.button, {
            boxSizing: 'border-box',
            minWidth: 64,
            padding: '6px 16px',
            borderRadius: theme.shape.borderRadius,
            color: theme.palette.text.primary,
            transition: theme.transitions.create([
                'background-color',
                'box-shadow',
                'border'
            ], {
                duration: theme.transitions.duration.short
            }),
            '&:hover': {
                textDecoration: 'none',
                backgroundColor: _colorManipulator.alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    backgroundColor: 'transparent'
                },
                '&$disabled': {
                    backgroundColor: 'transparent'
                }
            },
            '&$disabled': {
                color: theme.palette.action.disabled
            }
        }),
        /* Styles applied to the span element that wraps the children. */ label: {
            width: '100%',
            // Ensure the correct width for iOS Safari
            display: 'inherit',
            alignItems: 'inherit',
            justifyContent: 'inherit'
        },
        /* Styles applied to the root element if `variant="text"`. */ text: {
            padding: '6px 8px'
        },
        /* Styles applied to the root element if `variant="text"` and `color="primary"`. */ textPrimary: {
            color: theme.palette.primary.main,
            '&:hover': {
                backgroundColor: _colorManipulator.alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    backgroundColor: 'transparent'
                }
            }
        },
        /* Styles applied to the root element if `variant="text"` and `color="secondary"`. */ textSecondary: {
            color: theme.palette.secondary.main,
            '&:hover': {
                backgroundColor: _colorManipulator.alpha(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    backgroundColor: 'transparent'
                }
            }
        },
        /* Styles applied to the root element if `variant="outlined"`. */ outlined: {
            padding: '5px 15px',
            border: "1px solid ".concat(theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'),
            '&$disabled': {
                border: "1px solid ".concat(theme.palette.action.disabledBackground)
            }
        },
        /* Styles applied to the root element if `variant="outlined"` and `color="primary"`. */ outlinedPrimary: {
            color: theme.palette.primary.main,
            border: "1px solid ".concat(_colorManipulator.alpha(theme.palette.primary.main, 0.5)),
            '&:hover': {
                border: "1px solid ".concat(theme.palette.primary.main),
                backgroundColor: _colorManipulator.alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    backgroundColor: 'transparent'
                }
            }
        },
        /* Styles applied to the root element if `variant="outlined"` and `color="secondary"`. */ outlinedSecondary: {
            color: theme.palette.secondary.main,
            border: "1px solid ".concat(_colorManipulator.alpha(theme.palette.secondary.main, 0.5)),
            '&:hover': {
                border: "1px solid ".concat(theme.palette.secondary.main),
                backgroundColor: _colorManipulator.alpha(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    backgroundColor: 'transparent'
                }
            },
            '&$disabled': {
                border: "1px solid ".concat(theme.palette.action.disabled)
            }
        },
        /* Styles applied to the root element if `variant="contained"`. */ contained: {
            color: theme.palette.getContrastText(theme.palette.grey[300]),
            backgroundColor: theme.palette.grey[300],
            boxShadow: theme.shadows[2],
            '&:hover': {
                backgroundColor: theme.palette.grey.A100,
                boxShadow: theme.shadows[4],
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    boxShadow: theme.shadows[2],
                    backgroundColor: theme.palette.grey[300]
                },
                '&$disabled': {
                    backgroundColor: theme.palette.action.disabledBackground
                }
            },
            '&$focusVisible': {
                boxShadow: theme.shadows[6]
            },
            '&:active': {
                boxShadow: theme.shadows[8]
            },
            '&$disabled': {
                color: theme.palette.action.disabled,
                boxShadow: theme.shadows[0],
                backgroundColor: theme.palette.action.disabledBackground
            }
        },
        /* Styles applied to the root element if `variant="contained"` and `color="primary"`. */ containedPrimary: {
            color: theme.palette.primary.contrastText,
            backgroundColor: theme.palette.primary.main,
            '&:hover': {
                backgroundColor: theme.palette.primary.dark,
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    backgroundColor: theme.palette.primary.main
                }
            }
        },
        /* Styles applied to the root element if `variant="contained"` and `color="secondary"`. */ containedSecondary: {
            color: theme.palette.secondary.contrastText,
            backgroundColor: theme.palette.secondary.main,
            '&:hover': {
                backgroundColor: theme.palette.secondary.dark,
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    backgroundColor: theme.palette.secondary.main
                }
            }
        },
        /* Styles applied to the root element if `disableElevation={true}`. */ disableElevation: {
            boxShadow: 'none',
            '&:hover': {
                boxShadow: 'none'
            },
            '&$focusVisible': {
                boxShadow: 'none'
            },
            '&:active': {
                boxShadow: 'none'
            },
            '&$disabled': {
                boxShadow: 'none'
            }
        },
        /* Pseudo-class applied to the ButtonBase root element if the button is keyboard focused. */ focusVisible: {
        },
        /* Pseudo-class applied to the root element if `disabled={true}`. */ disabled: {
        },
        /* Styles applied to the root element if `color="inherit"`. */ colorInherit: {
            color: 'inherit',
            borderColor: 'currentColor'
        },
        /* Styles applied to the root element if `size="small"` and `variant="text"`. */ textSizeSmall: {
            padding: '4px 5px',
            fontSize: theme.typography.pxToRem(13)
        },
        /* Styles applied to the root element if `size="large"` and `variant="text"`. */ textSizeLarge: {
            padding: '8px 11px',
            fontSize: theme.typography.pxToRem(15)
        },
        /* Styles applied to the root element if `size="small"` and `variant="outlined"`. */ outlinedSizeSmall: {
            padding: '3px 9px',
            fontSize: theme.typography.pxToRem(13)
        },
        /* Styles applied to the root element if `size="large"` and `variant="outlined"`. */ outlinedSizeLarge: {
            padding: '7px 21px',
            fontSize: theme.typography.pxToRem(15)
        },
        /* Styles applied to the root element if `size="small"` and `variant="contained"`. */ containedSizeSmall: {
            padding: '4px 10px',
            fontSize: theme.typography.pxToRem(13)
        },
        /* Styles applied to the root element if `size="large"` and `variant="contained"`. */ containedSizeLarge: {
            padding: '8px 22px',
            fontSize: theme.typography.pxToRem(15)
        },
        /* Styles applied to the root element if `size="small"`. */ sizeSmall: {
        },
        /* Styles applied to the root element if `size="large"`. */ sizeLarge: {
        },
        /* Styles applied to the root element if `fullWidth={true}`. */ fullWidth: {
            width: '100%'
        },
        /* Styles applied to the startIcon element if supplied. */ startIcon: {
            display: 'inherit',
            marginRight: 8,
            marginLeft: -4,
            '&$iconSizeSmall': {
                marginLeft: -2
            }
        },
        /* Styles applied to the endIcon element if supplied. */ endIcon: {
            display: 'inherit',
            marginRight: -4,
            marginLeft: 8,
            '&$iconSizeSmall': {
                marginRight: -2
            }
        },
        /* Styles applied to the icon element if supplied and `size="small"`. */ iconSizeSmall: {
            '& > *:first-child': {
                fontSize: 18
            }
        },
        /* Styles applied to the icon element if supplied and `size="medium"`. */ iconSizeMedium: {
            '& > *:first-child': {
                fontSize: 20
            }
        },
        /* Styles applied to the icon element if supplied and `size="large"`. */ iconSizeLarge: {
            '& > *:first-child': {
                fontSize: 22
            }
        }
    };
};
var Button = /*#__PURE__*/ _react.forwardRef(function Button1(props, ref) {
    var children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? 'default' : _props$color, _props$component = props.component, component = _props$component === void 0 ? 'button' : _props$component, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableElevati = props.disableElevation, disableElevation = _props$disableElevati === void 0 ? false : _props$disableElevati, _props$disableFocusRi = props.disableFocusRipple, disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi, endIconProp = props.endIcon, focusVisibleClassName = props.focusVisibleClassName, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$size = props.size, size = _props$size === void 0 ? 'medium' : _props$size, startIconProp = props.startIcon, _props$type = props.type, type = _props$type === void 0 ? 'button' : _props$type, _props$variant = props.variant, variant = _props$variant === void 0 ? 'text' : _props$variant, other = _objectWithoutPropertiesDefault.default(props, [
        "children",
        "classes",
        "className",
        "color",
        "component",
        "disabled",
        "disableElevation",
        "disableFocusRipple",
        "endIcon",
        "focusVisibleClassName",
        "fullWidth",
        "size",
        "startIcon",
        "type",
        "variant"
    ]);
    var startIcon = startIconProp && /*#__PURE__*/ _react.createElement("span", {
        className: _clsxDefault.default(classes.startIcon, classes["iconSize".concat(_capitalizeDefault.default(size))])
    }, startIconProp);
    var endIcon = endIconProp && /*#__PURE__*/ _react.createElement("span", {
        className: _clsxDefault.default(classes.endIcon, classes["iconSize".concat(_capitalizeDefault.default(size))])
    }, endIconProp);
    return(/*#__PURE__*/ _react.createElement(_buttonBaseDefault.default, _extendsDefault.default({
        className: _clsxDefault.default(classes.root, classes[variant], className, color === 'inherit' ? classes.colorInherit : color !== 'default' && classes["".concat(variant).concat(_capitalizeDefault.default(color))], size !== 'medium' && [
            classes["".concat(variant, "Size").concat(_capitalizeDefault.default(size))],
            classes["size".concat(_capitalizeDefault.default(size))]
        ], disableElevation && classes.disableElevation, disabled && classes.disabled, fullWidth && classes.fullWidth),
        component: component,
        disabled: disabled,
        focusRipple: !disableFocusRipple,
        focusVisibleClassName: _clsxDefault.default(classes.focusVisible, focusVisibleClassName),
        ref: ref,
        type: type
    }, other), /*#__PURE__*/ _react.createElement("span", {
        className: classes.label
    }, startIcon, children, endIcon)));
});
Button.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * The content of the button.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */ color: _propTypesDefault.default.oneOf([
        'default',
        'inherit',
        'primary',
        'secondary'
    ]),
    /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */ component: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .elementType,
    /**
   * If `true`, the button will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * If `true`, no elevation is used.
   */ disableElevation: _propTypesDefault.default.bool,
    /**
   * If `true`, the  keyboard focus ripple will be disabled.
   */ disableFocusRipple: _propTypesDefault.default.bool,
    /**
   * If `true`, the ripple effect will be disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `focusVisibleClassName`.
   */ disableRipple: _propTypesDefault.default.bool,
    /**
   * Element placed after the children.
   */ endIcon: _propTypesDefault.default.node,
    /**
   * @ignore
   */ focusVisibleClassName: _propTypesDefault.default.string,
    /**
   * If `true`, the button will take up the full width of its container.
   */ fullWidth: _propTypesDefault.default.bool,
    /**
   * The URL to link to when the button is clicked.
   * If defined, an `a` element will be used as the root node.
   */ href: _propTypesDefault.default.string,
    /**
   * The size of the button.
   * `small` is equivalent to the dense button styling.
   */ size: _propTypesDefault.default.oneOf([
        'large',
        'medium',
        'small'
    ]),
    /**
   * Element placed before the children.
   */ startIcon: _propTypesDefault.default.node,
    /**
   * @ignore
   */ type: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.oneOf([
            'button',
            'reset',
            'submit'
        ]),
        _propTypesDefault.default.string
    ]),
    /**
   * The variant to use.
   */ variant: _propTypesDefault.default.oneOf([
        'contained',
        'outlined',
        'text'
    ])
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiButton'
})(Button);

},{"@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","@babel/runtime/helpers/esm/extends":"esrVD","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","../styles/withStyles":"3pIr2","../styles/colorManipulator":"4vQbC","../ButtonBase":"c7TvV","../utils/capitalize":"4RyDE","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"c7TvV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_buttonBaseDefault.default
);
var _buttonBase = require("./ButtonBase");
var _buttonBaseDefault = parcelHelpers.interopDefault(_buttonBase);

},{"./ButtonBase":"kqvay","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"kqvay":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _reactDom = require("react-dom");
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _useForkRef = require("../utils/useForkRef");
var _useForkRefDefault = parcelHelpers.interopDefault(_useForkRef);
var _useEventCallback = require("../utils/useEventCallback");
var _useEventCallbackDefault = parcelHelpers.interopDefault(_useEventCallback);
var _deprecatedPropType = require("../utils/deprecatedPropType");
var _deprecatedPropTypeDefault = parcelHelpers.interopDefault(_deprecatedPropType);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _useIsFocusVisible = require("../utils/useIsFocusVisible");
var _useIsFocusVisibleDefault = parcelHelpers.interopDefault(_useIsFocusVisible);
var _touchRipple = require("./TouchRipple");
var _touchRippleDefault = parcelHelpers.interopDefault(_touchRipple);
var styles = {
    /* Styles applied to the root element. */ root: {
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        position: 'relative',
        WebkitTapHighlightColor: 'transparent',
        backgroundColor: 'transparent',
        // Reset default value
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 0,
        border: 0,
        margin: 0,
        // Remove the margin in Safari
        borderRadius: 0,
        padding: 0,
        // Remove the padding in Firefox
        cursor: 'pointer',
        userSelect: 'none',
        verticalAlign: 'middle',
        '-moz-appearance': 'none',
        // Reset
        '-webkit-appearance': 'none',
        // Reset
        textDecoration: 'none',
        // So we take precedent over the style of a native <a /> element.
        color: 'inherit',
        '&::-moz-focus-inner': {
            borderStyle: 'none' // Remove Firefox dotted outline.
        },
        '&$disabled': {
            pointerEvents: 'none',
            // Disable link interactions
            cursor: 'default'
        },
        '@media print': {
            colorAdjust: 'exact'
        }
    },
    /* Pseudo-class applied to the root element if `disabled={true}`. */ disabled: {
    },
    /* Pseudo-class applied to the root element if keyboard focused. */ focusVisible: {
    }
};
/**
 * `ButtonBase` contains as few styles as possible.
 * It aims to be a simple building block for creating a button.
 * It contains a load of style reset and some focus/ripple logic.
 */ var ButtonBase = /*#__PURE__*/ _react.forwardRef(function ButtonBase1(props, ref) {
    var action = props.action, buttonRefProp = props.buttonRef, _props$centerRipple = props.centerRipple, centerRipple = _props$centerRipple === void 0 ? false : _props$centerRipple, children = props.children, classes = props.classes, className = props.className, _props$component = props.component, component = _props$component === void 0 ? 'button' : _props$component, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableRipple = props.disableRipple, disableRipple = _props$disableRipple === void 0 ? false : _props$disableRipple, _props$disableTouchRi = props.disableTouchRipple, disableTouchRipple = _props$disableTouchRi === void 0 ? false : _props$disableTouchRi, _props$focusRipple = props.focusRipple, focusRipple = _props$focusRipple === void 0 ? false : _props$focusRipple, focusVisibleClassName = props.focusVisibleClassName, onBlur = props.onBlur, onClick = props.onClick, onFocus = props.onFocus, onFocusVisible = props.onFocusVisible, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, onMouseDown = props.onMouseDown, onMouseLeave = props.onMouseLeave, onMouseUp = props.onMouseUp, onTouchEnd = props.onTouchEnd, onTouchMove = props.onTouchMove, onTouchStart = props.onTouchStart, onDragLeave = props.onDragLeave, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, TouchRippleProps = props.TouchRippleProps, _props$type = props.type, type = _props$type === void 0 ? 'button' : _props$type, other = _objectWithoutPropertiesDefault.default(props, [
        "action",
        "buttonRef",
        "centerRipple",
        "children",
        "classes",
        "className",
        "component",
        "disabled",
        "disableRipple",
        "disableTouchRipple",
        "focusRipple",
        "focusVisibleClassName",
        "onBlur",
        "onClick",
        "onFocus",
        "onFocusVisible",
        "onKeyDown",
        "onKeyUp",
        "onMouseDown",
        "onMouseLeave",
        "onMouseUp",
        "onTouchEnd",
        "onTouchMove",
        "onTouchStart",
        "onDragLeave",
        "tabIndex",
        "TouchRippleProps",
        "type"
    ]);
    var buttonRef = _react.useRef(null);
    function getButtonNode() {
        // #StrictMode ready
        return _reactDom.findDOMNode(buttonRef.current);
    }
    var rippleRef = _react.useRef(null);
    var _React$useState = _react.useState(false), focusVisible = _React$useState[0], setFocusVisible = _React$useState[1];
    if (disabled && focusVisible) setFocusVisible(false);
    var _useIsFocusVisible1 = _useIsFocusVisibleDefault.default(), isFocusVisible = _useIsFocusVisible1.isFocusVisible, onBlurVisible = _useIsFocusVisible1.onBlurVisible, focusVisibleRef = _useIsFocusVisible1.ref;
    _react.useImperativeHandle(action, function() {
        return {
            focusVisible: function focusVisible1() {
                setFocusVisible(true);
                buttonRef.current.focus();
            }
        };
    }, []);
    _react.useEffect(function() {
        if (focusVisible && focusRipple && !disableRipple) rippleRef.current.pulsate();
    }, [
        disableRipple,
        focusRipple,
        focusVisible
    ]);
    function useRippleHandler(rippleAction, eventCallback) {
        var skipRippleAction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : disableTouchRipple;
        return _useEventCallbackDefault.default(function(event) {
            if (eventCallback) eventCallback(event);
            var ignore = skipRippleAction;
            if (!ignore && rippleRef.current) rippleRef.current[rippleAction](event);
            return true;
        });
    }
    var handleMouseDown = useRippleHandler('start', onMouseDown);
    var handleDragLeave = useRippleHandler('stop', onDragLeave);
    var handleMouseUp = useRippleHandler('stop', onMouseUp);
    var handleMouseLeave = useRippleHandler('stop', function(event) {
        if (focusVisible) event.preventDefault();
        if (onMouseLeave) onMouseLeave(event);
    });
    var handleTouchStart = useRippleHandler('start', onTouchStart);
    var handleTouchEnd = useRippleHandler('stop', onTouchEnd);
    var handleTouchMove = useRippleHandler('stop', onTouchMove);
    var handleBlur = useRippleHandler('stop', function(event) {
        if (focusVisible) {
            onBlurVisible(event);
            setFocusVisible(false);
        }
        if (onBlur) onBlur(event);
    }, false);
    var handleFocus = _useEventCallbackDefault.default(function(event) {
        // Fix for https://github.com/facebook/react/issues/7769
        if (!buttonRef.current) buttonRef.current = event.currentTarget;
        if (isFocusVisible(event)) {
            setFocusVisible(true);
            if (onFocusVisible) onFocusVisible(event);
        }
        if (onFocus) onFocus(event);
    });
    var isNonNativeButton = function isNonNativeButton1() {
        var button = getButtonNode();
        return component && component !== 'button' && !(button.tagName === 'A' && button.href);
    };
    /**
   * IE 11 shim for https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat
   */ var keydownRef = _react.useRef(false);
    var handleKeyDown = _useEventCallbackDefault.default(function(event) {
        // Check if key is already down to avoid repeats being counted as multiple activations
        if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === ' ') {
            keydownRef.current = true;
            event.persist();
            rippleRef.current.stop(event, function() {
                rippleRef.current.start(event);
            });
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === ' ') event.preventDefault();
        if (onKeyDown) onKeyDown(event);
         // Keyboard accessibility for non interactive elements
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === 'Enter' && !disabled) {
            event.preventDefault();
            if (onClick) onClick(event);
        }
    });
    var handleKeyUp = _useEventCallbackDefault.default(function(event) {
        // calling preventDefault in keyUp on a <button> will not dispatch a click event if Space is pressed
        // https://codesandbox.io/s/button-keyup-preventdefault-dn7f0
        if (focusRipple && event.key === ' ' && rippleRef.current && focusVisible && !event.defaultPrevented) {
            keydownRef.current = false;
            event.persist();
            rippleRef.current.stop(event, function() {
                rippleRef.current.pulsate(event);
            });
        }
        if (onKeyUp) onKeyUp(event);
         // Keyboard accessibility for non interactive elements
        if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === ' ' && !event.defaultPrevented) onClick(event);
    });
    var ComponentProp = component;
    if (ComponentProp === 'button' && other.href) ComponentProp = 'a';
    var buttonProps = {
    };
    if (ComponentProp === 'button') {
        buttonProps.type = type;
        buttonProps.disabled = disabled;
    } else {
        if (ComponentProp !== 'a' || !other.href) buttonProps.role = 'button';
        buttonProps['aria-disabled'] = disabled;
    }
    var handleUserRef = _useForkRefDefault.default(buttonRefProp, ref);
    var handleOwnRef = _useForkRefDefault.default(focusVisibleRef, buttonRef);
    var handleRef = _useForkRefDefault.default(handleUserRef, handleOwnRef);
    var _React$useState2 = _react.useState(false), mountedState = _React$useState2[0], setMountedState = _React$useState2[1];
    _react.useEffect(function() {
        setMountedState(true);
    }, []);
    var enableTouchRipple = mountedState && !disableRipple && !disabled;
    // eslint-disable-next-line react-hooks/rules-of-hooks
    _react.useEffect(function() {
        if (enableTouchRipple && !rippleRef.current) console.error([
            'Material-UI: The `component` prop provided to ButtonBase is invalid.',
            'Please make sure the children prop is rendered in this custom component.'
        ].join('\n'));
    }, [
        enableTouchRipple
    ]);
    return(/*#__PURE__*/ _react.createElement(ComponentProp, _extendsDefault.default({
        className: _clsxDefault.default(classes.root, className, focusVisible && [
            classes.focusVisible,
            focusVisibleClassName
        ], disabled && classes.disabled),
        onBlur: handleBlur,
        onClick: onClick,
        onFocus: handleFocus,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        onMouseDown: handleMouseDown,
        onMouseLeave: handleMouseLeave,
        onMouseUp: handleMouseUp,
        onDragLeave: handleDragLeave,
        onTouchEnd: handleTouchEnd,
        onTouchMove: handleTouchMove,
        onTouchStart: handleTouchStart,
        ref: handleRef,
        tabIndex: disabled ? -1 : tabIndex
    }, buttonProps, other), children, enableTouchRipple ? /*#__PURE__*/ /* TouchRipple is only needed client-side, x2 boost on the server. */ _react.createElement(_touchRippleDefault.default, _extendsDefault.default({
        ref: rippleRef,
        center: centerRipple
    }, TouchRippleProps)) : null));
});
ButtonBase.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */ action: _utils.refType,
    /**
   * @ignore
   *
   * Use that prop to pass a ref to the native button component.
   * @deprecated Use `ref` instead.
   */ buttonRef: _deprecatedPropTypeDefault.default(_utils.refType, 'Use `ref` instead.'),
    /**
   * If `true`, the ripples will be centered.
   * They won't start at the cursor interaction position.
   */ centerRipple: _propTypesDefault.default.bool,
    /**
   * The content of the component.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */ component: _utils.elementTypeAcceptingRef,
    /**
   * If `true`, the base button will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * If `true`, the ripple effect will be disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `focusVisibleClassName`.
   */ disableRipple: _propTypesDefault.default.bool,
    /**
   * If `true`, the touch ripple effect will be disabled.
   */ disableTouchRipple: _propTypesDefault.default.bool,
    /**
   * If `true`, the base button will have a keyboard focus ripple.
   */ focusRipple: _propTypesDefault.default.bool,
    /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/master/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */ focusVisibleClassName: _propTypesDefault.default.string,
    /**
   * @ignore
   */ href: _propTypesDefault.default.string,
    /**
   * @ignore
   */ onBlur: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onClick: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onDragLeave: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onFocus: _propTypesDefault.default.func,
    /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */ onFocusVisible: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onKeyDown: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onKeyUp: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onMouseDown: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onMouseLeave: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onMouseUp: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onTouchEnd: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onTouchMove: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onTouchStart: _propTypesDefault.default.func,
    /**
   * @ignore
   */ tabIndex: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * Props applied to the `TouchRipple` element.
   */ TouchRippleProps: _propTypesDefault.default.object,
    /**
   * @ignore
   */ type: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.oneOf([
            'button',
            'reset',
            'submit'
        ]),
        _propTypesDefault.default.string
    ])
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiButtonBase'
})(ButtonBase);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","react-dom":"ezGwg","clsx":"cS959","@material-ui/utils":"Uumnw","../utils/useForkRef":"bLpHM","../utils/useEventCallback":"dZ8YH","../utils/deprecatedPropType":"6Zj6s","../styles/withStyles":"3pIr2","../utils/useIsFocusVisible":"fHQeb","./TouchRipple":"cpMwe","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"fHQeb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "teardown", ()=>teardown
);
// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js
var _react = require("react");
var _reactDom = require("react-dom");
var hadKeyboardEvent = true;
var hadFocusVisibleRecently = false;
var hadFocusVisibleRecentlyTimeout = null;
var inputTypesWhitelist = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    'datetime-local': true
};
/**
 * Computes whether the given element should automatically trigger the
 * `focus-visible` class being added, i.e. whether it should always match
 * `:focus-visible` when focused.
 * @param {Element} node
 * @return {boolean}
 */ function focusTriggersKeyboardModality(node) {
    var type = node.type, tagName = node.tagName;
    if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) return true;
    if (tagName === 'TEXTAREA' && !node.readOnly) return true;
    if (node.isContentEditable) return true;
    return false;
}
/**
 * Keep track of our keyboard modality state with `hadKeyboardEvent`.
 * If the most recent user interaction was via the keyboard;
 * and the key press did not include a meta, alt/option, or control key;
 * then the modality is keyboard. Otherwise, the modality is not keyboard.
 * @param {KeyboardEvent} event
 */ function handleKeyDown(event) {
    if (event.metaKey || event.altKey || event.ctrlKey) return;
    hadKeyboardEvent = true;
}
/**
 * If at any point a user clicks with a pointing device, ensure that we change
 * the modality away from keyboard.
 * This avoids the situation where a user presses a key on an already focused
 * element, and then clicks on a different element, focusing it with a
 * pointing device, while we still think we're in keyboard modality.
 */ function handlePointerDown() {
    hadKeyboardEvent = false;
}
function handleVisibilityChange() {
    if (this.visibilityState === 'hidden') // If the tab becomes active again, the browser will handle calling focus
    // on the element (Safari actually calls it twice).
    // If this tab change caused a blur on an element with focus-visible,
    // re-apply the class when the user switches back to the tab.
    {
        if (hadFocusVisibleRecently) hadKeyboardEvent = true;
    }
}
function prepare(doc) {
    doc.addEventListener('keydown', handleKeyDown, true);
    doc.addEventListener('mousedown', handlePointerDown, true);
    doc.addEventListener('pointerdown', handlePointerDown, true);
    doc.addEventListener('touchstart', handlePointerDown, true);
    doc.addEventListener('visibilitychange', handleVisibilityChange, true);
}
function teardown(doc) {
    doc.removeEventListener('keydown', handleKeyDown, true);
    doc.removeEventListener('mousedown', handlePointerDown, true);
    doc.removeEventListener('pointerdown', handlePointerDown, true);
    doc.removeEventListener('touchstart', handlePointerDown, true);
    doc.removeEventListener('visibilitychange', handleVisibilityChange, true);
}
function isFocusVisible(event) {
    var target = event.target;
    try {
        return target.matches(':focus-visible');
    } catch (error) {
    } // browsers not implementing :focus-visible will throw a SyntaxError
    // we use our own heuristic for those browsers
    // rethrow might be better if it's not the expected error but do we really
    // want to crash if focus-visible malfunctioned?
    // no need for validFocusTarget check. the user does that by attaching it to
    // focusable events only
    return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
/**
 * Should be called if a blur event is fired on a focus-visible element
 */ function handleBlurVisible() {
    // To detect a tab/window switch, we look for a blur event followed
    // rapidly by a visibility change.
    // If we don't see a visibility change within 100ms, it's probably a
    // regular focus change.
    hadFocusVisibleRecently = true;
    window.clearTimeout(hadFocusVisibleRecentlyTimeout);
    hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {
        hadFocusVisibleRecently = false;
    }, 100);
}
function useIsFocusVisible() {
    var ref = _react.useCallback(function(instance) {
        var node = _reactDom.findDOMNode(instance);
        if (node != null) prepare(node.ownerDocument);
    }, []);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    _react.useDebugValue(isFocusVisible);
    return {
        isFocusVisible: isFocusVisible,
        onBlurVisible: handleBlurVisible,
        ref: ref
    };
}
exports.default = useIsFocusVisible;

},{"react":"cKM0D","react-dom":"ezGwg","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"cpMwe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DELAY_RIPPLE", ()=>DELAY_RIPPLE
);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _toConsumableArray = require("@babel/runtime/helpers/esm/toConsumableArray");
var _toConsumableArrayDefault = parcelHelpers.interopDefault(_toConsumableArray);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _reactTransitionGroup = require("react-transition-group");
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _ripple = require("./Ripple");
var _rippleDefault = parcelHelpers.interopDefault(_ripple);
var DURATION = 550;
var DELAY_RIPPLE = 80;
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            overflow: 'hidden',
            pointerEvents: 'none',
            position: 'absolute',
            zIndex: 0,
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            borderRadius: 'inherit'
        },
        /* Styles applied to the internal `Ripple` components `ripple` class. */ ripple: {
            opacity: 0,
            position: 'absolute'
        },
        /* Styles applied to the internal `Ripple` components `rippleVisible` class. */ rippleVisible: {
            opacity: 0.3,
            transform: 'scale(1)',
            animation: "$enter ".concat(DURATION, "ms ").concat(theme.transitions.easing.easeInOut)
        },
        /* Styles applied to the internal `Ripple` components `ripplePulsate` class. */ ripplePulsate: {
            animationDuration: "".concat(theme.transitions.duration.shorter, "ms")
        },
        /* Styles applied to the internal `Ripple` components `child` class. */ child: {
            opacity: 1,
            display: 'block',
            width: '100%',
            height: '100%',
            borderRadius: '50%',
            backgroundColor: 'currentColor'
        },
        /* Styles applied to the internal `Ripple` components `childLeaving` class. */ childLeaving: {
            opacity: 0,
            animation: "$exit ".concat(DURATION, "ms ").concat(theme.transitions.easing.easeInOut)
        },
        /* Styles applied to the internal `Ripple` components `childPulsate` class. */ childPulsate: {
            position: 'absolute',
            left: 0,
            top: 0,
            animation: "$pulsate 2500ms ".concat(theme.transitions.easing.easeInOut, " 200ms infinite")
        },
        '@keyframes enter': {
            '0%': {
                transform: 'scale(0)',
                opacity: 0.1
            },
            '100%': {
                transform: 'scale(1)',
                opacity: 0.3
            }
        },
        '@keyframes exit': {
            '0%': {
                opacity: 1
            },
            '100%': {
                opacity: 0
            }
        },
        '@keyframes pulsate': {
            '0%': {
                transform: 'scale(1)'
            },
            '50%': {
                transform: 'scale(0.92)'
            },
            '100%': {
                transform: 'scale(1)'
            }
        }
    };
};
/**
 * @ignore - internal component.
 *
 * TODO v5: Make private
 */ var TouchRipple = /*#__PURE__*/ _react.forwardRef(function TouchRipple1(props, ref) {
    var _props$center = props.center, centerProp = _props$center === void 0 ? false : _props$center, classes = props.classes, className = props.className, other = _objectWithoutPropertiesDefault.default(props, [
        "center",
        "classes",
        "className"
    ]);
    var _React$useState = _react.useState([]), ripples = _React$useState[0], setRipples = _React$useState[1];
    var nextKey = _react.useRef(0);
    var rippleCallback = _react.useRef(null);
    _react.useEffect(function() {
        if (rippleCallback.current) {
            rippleCallback.current();
            rippleCallback.current = null;
        }
    }, [
        ripples
    ]); // Used to filter out mouse emulated events on mobile.
    var ignoringMouseDown = _react.useRef(false); // We use a timer in order to only show the ripples for touch "click" like events.
    // We don't want to display the ripple for touch scroll events.
    var startTimer = _react.useRef(null); // This is the hook called once the previous timeout is ready.
    var startTimerCommit = _react.useRef(null);
    var container = _react.useRef(null);
    _react.useEffect(function() {
        return function() {
            clearTimeout(startTimer.current);
        };
    }, []);
    var startCommit = _react.useCallback(function(params) {
        var pulsate = params.pulsate, rippleX = params.rippleX, rippleY = params.rippleY, rippleSize = params.rippleSize, cb = params.cb;
        setRipples(function(oldRipples) {
            return [].concat(_toConsumableArrayDefault.default(oldRipples), [
                /*#__PURE__*/ _react.createElement(_rippleDefault.default, {
                    key: nextKey.current,
                    classes: classes,
                    timeout: DURATION,
                    pulsate: pulsate,
                    rippleX: rippleX,
                    rippleY: rippleY,
                    rippleSize: rippleSize
                })
            ]);
        });
        nextKey.current += 1;
        rippleCallback.current = cb;
    }, [
        classes
    ]);
    var start = _react.useCallback(function() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        };
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        };
        var cb = arguments.length > 2 ? arguments[2] : undefined;
        var _options$pulsate = options.pulsate, pulsate = _options$pulsate === void 0 ? false : _options$pulsate, _options$center = options.center, center = _options$center === void 0 ? centerProp || options.pulsate : _options$center, _options$fakeElement = options.fakeElement, fakeElement = _options$fakeElement === void 0 ? false : _options$fakeElement;
        if (event.type === 'mousedown' && ignoringMouseDown.current) {
            ignoringMouseDown.current = false;
            return;
        }
        if (event.type === 'touchstart') ignoringMouseDown.current = true;
        var element = fakeElement ? null : container.current;
        var rect = element ? element.getBoundingClientRect() : {
            width: 0,
            height: 0,
            left: 0,
            top: 0
        }; // Get the size of the ripple
        var rippleX;
        var rippleY;
        var rippleSize;
        if (center || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
            rippleX = Math.round(rect.width / 2);
            rippleY = Math.round(rect.height / 2);
        } else {
            var _ref = event.touches ? event.touches[0] : event, clientX = _ref.clientX, clientY = _ref.clientY;
            rippleX = Math.round(clientX - rect.left);
            rippleY = Math.round(clientY - rect.top);
        }
        if (center) {
            rippleSize = Math.sqrt((2 * Math.pow(rect.width, 2) + Math.pow(rect.height, 2)) / 3); // For some reason the animation is broken on Mobile Chrome if the size if even.
            if (rippleSize % 2 === 0) rippleSize += 1;
        } else {
            var sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
            var sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
            rippleSize = Math.sqrt(Math.pow(sizeX, 2) + Math.pow(sizeY, 2));
        } // Touche devices
        if (event.touches) // check that this isn't another touchstart due to multitouch
        // otherwise we will only clear a single timer when unmounting while two
        // are running
        {
            if (startTimerCommit.current === null) {
                // Prepare the ripple effect.
                startTimerCommit.current = function() {
                    startCommit({
                        pulsate: pulsate,
                        rippleX: rippleX,
                        rippleY: rippleY,
                        rippleSize: rippleSize,
                        cb: cb
                    });
                }; // Delay the execution of the ripple effect.
                startTimer.current = setTimeout(function() {
                    if (startTimerCommit.current) {
                        startTimerCommit.current();
                        startTimerCommit.current = null;
                    }
                }, DELAY_RIPPLE); // We have to make a tradeoff with this value.
            }
        } else startCommit({
            pulsate: pulsate,
            rippleX: rippleX,
            rippleY: rippleY,
            rippleSize: rippleSize,
            cb: cb
        });
    }, [
        centerProp,
        startCommit
    ]);
    var pulsate = _react.useCallback(function() {
        start({
        }, {
            pulsate: true
        });
    }, [
        start
    ]);
    var stop = _react.useCallback(function(event, cb) {
        clearTimeout(startTimer.current); // The touch interaction occurs too quickly.
        // We still want to show ripple effect.
        if (event.type === 'touchend' && startTimerCommit.current) {
            event.persist();
            startTimerCommit.current();
            startTimerCommit.current = null;
            startTimer.current = setTimeout(function() {
                stop(event, cb);
            });
            return;
        }
        startTimerCommit.current = null;
        setRipples(function(oldRipples) {
            if (oldRipples.length > 0) return oldRipples.slice(1);
            return oldRipples;
        });
        rippleCallback.current = cb;
    }, []);
    _react.useImperativeHandle(ref, function() {
        return {
            pulsate: pulsate,
            start: start,
            stop: stop
        };
    }, [
        pulsate,
        start,
        stop
    ]);
    return(/*#__PURE__*/ _react.createElement("span", _extendsDefault.default({
        className: _clsxDefault.default(classes.root, className),
        ref: container
    }, other), /*#__PURE__*/ _react.createElement(_reactTransitionGroup.TransitionGroup, {
        component: null,
        exit: true
    }, ripples)));
});
TouchRipple.propTypes = {
    /**
   * If `true`, the ripple starts at the center of the component
   * rather than at the point of interaction.
   */ center: _propTypesDefault.default.bool,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object.isRequired,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string
};
exports.default = _withStylesDefault.default(styles, {
    flip: false,
    name: 'MuiTouchRipple'
})(/*#__PURE__*/ _react.memo(TouchRipple));

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/toConsumableArray":"fbqwi","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","react-transition-group":"4asrk","clsx":"cS959","../styles/withStyles":"3pIr2","./Ripple":"kjSEZ","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"kjSEZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _useEventCallback = require("../utils/useEventCallback");
var _useEventCallbackDefault = parcelHelpers.interopDefault(_useEventCallback);
var useEnhancedEffect = typeof window === 'undefined' ? _react.useEffect : _react.useLayoutEffect;
/**
 * @ignore - internal component.
 */ function Ripple(props) {
    var classes = props.classes, _props$pulsate = props.pulsate, pulsate = _props$pulsate === void 0 ? false : _props$pulsate, rippleX = props.rippleX, rippleY = props.rippleY, rippleSize = props.rippleSize, inProp = props.in, _props$onExited = props.onExited, onExited = _props$onExited === void 0 ? function() {
    } : _props$onExited, timeout = props.timeout;
    var _React$useState = _react.useState(false), leaving = _React$useState[0], setLeaving = _React$useState[1];
    var rippleClassName = _clsxDefault.default(classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
    var rippleStyles = {
        width: rippleSize,
        height: rippleSize,
        top: -(rippleSize / 2) + rippleY,
        left: -(rippleSize / 2) + rippleX
    };
    var childClassName = _clsxDefault.default(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
    var handleExited = _useEventCallbackDefault.default(onExited); // Ripple is used for user feedback (e.g. click or press) so we want to apply styles with the highest priority
    useEnhancedEffect(function() {
        if (!inProp) {
            // react-transition-group#onExit
            setLeaving(true); // react-transition-group#onExited
            var timeoutId = setTimeout(handleExited, timeout);
            return function() {
                clearTimeout(timeoutId);
            };
        }
        return undefined;
    }, [
        handleExited,
        inProp,
        timeout
    ]);
    return(/*#__PURE__*/ _react.createElement("span", {
        className: rippleClassName,
        style: rippleStyles
    }, /*#__PURE__*/ _react.createElement("span", {
        className: childClassName
    })));
}
Ripple.propTypes = {
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object.isRequired,
    /**
   * @ignore - injected from TransitionGroup
   */ in: _propTypesDefault.default.bool,
    /**
   * @ignore - injected from TransitionGroup
   */ onExited: _propTypesDefault.default.func,
    /**
   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
   */ pulsate: _propTypesDefault.default.bool,
    /**
   * Diameter of the ripple.
   */ rippleSize: _propTypesDefault.default.number,
    /**
   * Horizontal position of the ripple center.
   */ rippleX: _propTypesDefault.default.number,
    /**
   * Vertical position of the ripple center.
   */ rippleY: _propTypesDefault.default.number,
    /**
   * exit delay
   */ timeout: _propTypesDefault.default.number.isRequired
};
exports.default = Ripple;

},{"react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","../utils/useEventCallback":"dZ8YH","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"jOwmj":[function(require,module,exports) {
"use strict";
var Refresh = require('react-refresh/runtime');
function debounce(func, delay) {
    var args;
    var timeout = undefined;
    return function(args1) {
        clearTimeout(timeout);
        timeout = setTimeout(function() {
            timeout = undefined;
            func.call(null, args1);
        }, delay);
    };
}
var enqueueUpdate = debounce(function() {
    Refresh.performReactRefresh();
}, 30); // Everthing below is either adapted or copied from
// https://github.com/facebook/metro/blob/61de16bd1edd7e738dd0311c89555a644023ab2d/packages/metro/src/lib/polyfills/require.js
// MIT License - Copyright (c) Facebook, Inc. and its affiliates.
module.exports.prelude = function(module) {
    window.$RefreshReg$ = function(type, id) {
        Refresh.register(type, module.id + ' ' + id);
    };
    window.$RefreshSig$ = Refresh.createSignatureFunctionForTransform;
};
module.exports.postlude = function(module) {
    if (isReactRefreshBoundary(module.exports)) {
        registerExportsForReactRefresh(module);
        if (module.hot) {
            module.hot.dispose(function(data) {
                if (Refresh.hasUnrecoverableErrors()) window.location.reload();
                data.prevExports = module.exports;
            });
            module.hot.accept(function(getParents) {
                var prevExports = module.hot.data.prevExports;
                var nextExports = module.exports; // Since we just executed the code for it, it's possible
                // that the new exports make it ineligible for being a boundary.
                var isNoLongerABoundary = !isReactRefreshBoundary(nextExports); // It can also become ineligible if its exports are incompatible
                // with the previous exports.
                // For example, if you add/remove/change exports, we'll want
                // to re-execute the importing modules, and force those components
                // to re-render. Similarly, if you convert a class component
                // to a function, we want to invalidate the boundary.
                var didInvalidate = shouldInvalidateReactRefreshBoundary(prevExports, nextExports);
                if (isNoLongerABoundary || didInvalidate) {
                    // We'll be conservative. The only case in which we won't do a full
                    // reload is if all parent modules are also refresh boundaries.
                    // In that case we'll add them to the current queue.
                    var parents = getParents();
                    if (parents.length === 0) {
                        // Looks like we bubbled to the root. Can't recover from that.
                        window.location.reload();
                        return;
                    }
                    return parents;
                }
                enqueueUpdate();
            });
        }
    }
};
function isReactRefreshBoundary(exports) {
    if (Refresh.isLikelyComponentType(exports)) return true;
    if (exports == null || typeof exports !== 'object') // Exit if we can't iterate over exports.
    return false;
    var hasExports = false;
    var areAllExportsComponents = true;
    let isESM = '__esModule' in exports;
    for(var key in exports){
        hasExports = true;
        if (key === '__esModule') continue;
        var desc = Object.getOwnPropertyDescriptor(exports, key);
        if (desc && desc.get && !isESM) // Don't invoke getters for CJS as they may have side effects.
        return false;
        var exportValue = exports[key];
        if (!Refresh.isLikelyComponentType(exportValue)) areAllExportsComponents = false;
    }
    return hasExports && areAllExportsComponents;
}
function shouldInvalidateReactRefreshBoundary(prevExports, nextExports) {
    var prevSignature = getRefreshBoundarySignature(prevExports);
    var nextSignature = getRefreshBoundarySignature(nextExports);
    if (prevSignature.length !== nextSignature.length) return true;
    for(var i = 0; i < nextSignature.length; i++){
        if (prevSignature[i] !== nextSignature[i]) return true;
    }
    return false;
} // When this signature changes, it's unsafe to stop at this refresh boundary.
function getRefreshBoundarySignature(exports) {
    var signature = [];
    signature.push(Refresh.getFamilyByType(exports));
    if (exports == null || typeof exports !== 'object') // Exit if we can't iterate over exports.
    // (This is important for legacy environments.)
    return signature;
    let isESM = '__esModule' in exports;
    for(var key in exports){
        if (key === '__esModule') continue;
        var desc = Object.getOwnPropertyDescriptor(exports, key);
        if (desc && desc.get && !isESM) continue;
        var exportValue = exports[key];
        signature.push(key);
        signature.push(Refresh.getFamilyByType(exportValue));
    }
    return signature;
}
function registerExportsForReactRefresh(module) {
    var exports = module.exports, id = module.id;
    Refresh.register(exports, id + ' %exports%');
    if (exports == null || typeof exports !== 'object') // Exit if we can't iterate over exports.
    // (This is important for legacy environments.)
    return;
    let isESM = '__esModule' in exports;
    for(var key in exports){
        var desc = Object.getOwnPropertyDescriptor(exports, key);
        if (desc && desc.get && !isESM) continue;
        var exportValue = exports[key];
        Refresh.register(exportValue, id + ' %exports% ' + key);
    }
}

},{"react-refresh/runtime":"8nng3"}],"2MRVa":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$f5ef = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$f5ef.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxRuntime = require("react/jsx-runtime");
var _react = require("react");
var _textField = require("@material-ui/core/TextField");
var _textFieldDefault = parcelHelpers.interopDefault(_textField);
var _button = require("@material-ui/core/Button");
var _buttonDefault = parcelHelpers.interopDefault(_button);
var _radio = require("@material-ui/core/Radio");
var _radioDefault = parcelHelpers.interopDefault(_radio);
var _radioGroup = require("@material-ui/core/RadioGroup");
var _radioGroupDefault = parcelHelpers.interopDefault(_radioGroup);
var _formControlLabel = require("@material-ui/core/FormControlLabel");
var _formControlLabelDefault = parcelHelpers.interopDefault(_formControlLabel);
var _main = require("../main");
var _uigameModeStyleCss = require("./UIGameMode_style.css");
var _s = $RefreshSig$();
function UIGameMode(props) {
    _s();
    const [selection, setSelection] = _react.useState(_main.GameMode.singleplayer);
    const [validInput, setValidInput] = _react.useState(true);
    const submit = ()=>{
        if (selection === _main.GameMode.multiplayer) {
            const host = document.getElementById('host').value;
            if (host !== '') props.submit(_main.GameMode.multiplayer, host);
            else setValidInput(false);
        } else props.submit(_main.GameMode.singleplayer, null);
    };
    const handleChange = (event)=>{
        setSelection(parseInt(event.target.value));
    };
    return(/*#__PURE__*/ _jsxRuntime.jsxs("div", {
        className: "w3-row",
        __source: {
            fileName: "src/ui-components/UIGameMode.tsx",
            lineNumber: 33
        },
        __self: this,
        children: [
            /*#__PURE__*/ _jsxRuntime.jsx("span", {
                className: "game-ui-title",
                __source: {
                    fileName: "src/ui-components/UIGameMode.tsx",
                    lineNumber: 34
                },
                __self: this,
                children: "Choose the game-mode:"
            }),
            /*#__PURE__*/ _jsxRuntime.jsx("div", {
                className: "w3-row w3-padding",
                __source: {
                    fileName: "src/ui-components/UIGameMode.tsx",
                    lineNumber: 35
                },
                __self: this,
                children: /*#__PURE__*/ _jsxRuntime.jsxs(_radioGroupDefault.default, {
                    name: "gamemode",
                    value: selection,
                    onChange: handleChange,
                    __source: {
                        fileName: "src/ui-components/UIGameMode.tsx",
                        lineNumber: 36
                    },
                    __self: this,
                    children: [
                        /*#__PURE__*/ _jsxRuntime.jsx(_formControlLabelDefault.default, {
                            value: _main.GameMode.singleplayer,
                            control: /*#__PURE__*/ _jsxRuntime.jsx(_radioDefault.default, {
                            }),
                            label: "Lonewolf-mode (Singleplayer)",
                            __source: {
                                fileName: "src/ui-components/UIGameMode.tsx",
                                lineNumber: 37
                            },
                            __self: this
                        }),
                        /*#__PURE__*/ _jsxRuntime.jsx(_formControlLabelDefault.default, {
                            value: _main.GameMode.multiplayer,
                            control: /*#__PURE__*/ _jsxRuntime.jsx(_radioDefault.default, {
                            }),
                            label: "Party-mode (Multiplayer)",
                            __source: {
                                fileName: "src/ui-components/UIGameMode.tsx",
                                lineNumber: 42
                            },
                            __self: this
                        })
                    ]
                })
            }),
            selection === _main.GameMode.multiplayer && /*#__PURE__*/ _jsxRuntime.jsxs("div", {
                className: "w3-row w3-padding",
                __source: {
                    fileName: "src/ui-components/UIGameMode.tsx",
                    lineNumber: 50
                },
                __self: this,
                children: [
                    /*#__PURE__*/ _jsxRuntime.jsx("div", {
                        className: "w3-row w3-padding",
                        __source: {
                            fileName: "src/ui-components/UIGameMode.tsx",
                            lineNumber: 51
                        },
                        __self: this,
                        children: /*#__PURE__*/ _jsxRuntime.jsx("span", {
                            className: "game-ui-title",
                            __source: {
                                fileName: "src/ui-components/UIGameMode.tsx",
                                lineNumber: 51
                            },
                            __self: this,
                            children: "Define your battlefield:"
                        })
                    }),
                    validInput ? /*#__PURE__*/ _jsxRuntime.jsx(_textFieldDefault.default, {
                        className: "txtHost",
                        id: "host",
                        variant: "outlined",
                        defaultValue: "wss://commander.kektus.de:8080",
                        __source: {
                            fileName: "src/ui-components/UIGameMode.tsx",
                            lineNumber: 53
                        },
                        __self: this
                    }) : /*#__PURE__*/ _jsxRuntime.jsx(_textFieldDefault.default, {
                        className: "txtHost",
                        error: true,
                        id: "host",
                        label: "",
                        helperText: "Please enter a valid host-adress.",
                        variant: "outlined",
                        __source: {
                            fileName: "src/ui-components/UIGameMode.tsx",
                            lineNumber: 60
                        },
                        __self: this
                    })
                ]
            }),
            /*#__PURE__*/ _jsxRuntime.jsx("div", {
                className: "w3-row w3-padding",
                __source: {
                    fileName: "src/ui-components/UIGameMode.tsx",
                    lineNumber: 71
                },
                __self: this,
                children: /*#__PURE__*/ _jsxRuntime.jsx(_buttonDefault.default, {
                    variant: "contained",
                    color: "primary",
                    onClick: submit,
                    __source: {
                        fileName: "src/ui-components/UIGameMode.tsx",
                        lineNumber: 72
                    },
                    __self: this,
                    children: "enroll for battle"
                })
            })
        ]
    }));
}
exports.default = UIGameMode;
_s(UIGameMode, "0u8/J0q/zpbtELg4pMpoljRKhjg=");
_c = UIGameMode;
var _c;
$RefreshReg$(_c, "UIGameMode");

  $parcel$ReactRefreshHelpers$f5ef.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-runtime":"5F5p8","react":"cKM0D","@material-ui/core/TextField":"khQAh","@material-ui/core/Button":"lEQJw","@material-ui/core/Radio":"f2ncK","@material-ui/core/RadioGroup":"hfDeX","@material-ui/core/FormControlLabel":"j2QnF","../main":"bo1Qm","./UIGameMode_style.css":"7svBe","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"jOwmj"}],"f2ncK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_radioDefault.default
);
var _radio = require("./Radio");
var _radioDefault = parcelHelpers.interopDefault(_radio);

},{"./Radio":"8yR7s","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"8yR7s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _switchBase = require("../internal/SwitchBase");
var _switchBaseDefault = parcelHelpers.interopDefault(_switchBase);
var _radioButtonIcon = require("./RadioButtonIcon");
var _radioButtonIconDefault = parcelHelpers.interopDefault(_radioButtonIcon);
var _colorManipulator = require("../styles/colorManipulator");
var _capitalize = require("../utils/capitalize");
var _capitalizeDefault = parcelHelpers.interopDefault(_capitalize);
var _createChainedFunction = require("../utils/createChainedFunction");
var _createChainedFunctionDefault = parcelHelpers.interopDefault(_createChainedFunction);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _useRadioGroup = require("../RadioGroup/useRadioGroup");
var _useRadioGroupDefault = parcelHelpers.interopDefault(_useRadioGroup);
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            color: theme.palette.text.secondary
        },
        /* Pseudo-class applied to the root element if `checked={true}`. */ checked: {
        },
        /* Pseudo-class applied to the root element if `disabled={true}`. */ disabled: {
        },
        /* Styles applied to the root element if `color="primary"`. */ colorPrimary: {
            '&$checked': {
                color: theme.palette.primary.main,
                '&:hover': {
                    backgroundColor: _colorManipulator.alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity),
                    // Reset on touch devices, it doesn't add specificity
                    '@media (hover: none)': {
                        backgroundColor: 'transparent'
                    }
                }
            },
            '&$disabled': {
                color: theme.palette.action.disabled
            }
        },
        /* Styles applied to the root element if `color="secondary"`. */ colorSecondary: {
            '&$checked': {
                color: theme.palette.secondary.main,
                '&:hover': {
                    backgroundColor: _colorManipulator.alpha(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
                    // Reset on touch devices, it doesn't add specificity
                    '@media (hover: none)': {
                        backgroundColor: 'transparent'
                    }
                }
            },
            '&$disabled': {
                color: theme.palette.action.disabled
            }
        }
    };
};
var defaultCheckedIcon = /*#__PURE__*/ _react.createElement(_radioButtonIconDefault.default, {
    checked: true
});
var defaultIcon = /*#__PURE__*/ _react.createElement(_radioButtonIconDefault.default, null);
var Radio = /*#__PURE__*/ _react.forwardRef(function Radio1(props, ref) {
    var checkedProp = props.checked, classes = props.classes, _props$color = props.color, color = _props$color === void 0 ? 'secondary' : _props$color, nameProp = props.name, onChangeProp = props.onChange, _props$size = props.size, size = _props$size === void 0 ? 'medium' : _props$size, other = _objectWithoutPropertiesDefault.default(props, [
        "checked",
        "classes",
        "color",
        "name",
        "onChange",
        "size"
    ]);
    var radioGroup = _useRadioGroupDefault.default();
    var checked = checkedProp;
    var onChange = _createChainedFunctionDefault.default(onChangeProp, radioGroup && radioGroup.onChange);
    var name = nameProp;
    if (radioGroup) {
        if (typeof checked === 'undefined') checked = radioGroup.value === props.value;
        if (typeof name === 'undefined') name = radioGroup.name;
    }
    return(/*#__PURE__*/ _react.createElement(_switchBaseDefault.default, _extendsDefault.default({
        color: color,
        type: "radio",
        icon: /*#__PURE__*/ _react.cloneElement(defaultIcon, {
            fontSize: size === 'small' ? 'small' : 'medium'
        }),
        checkedIcon: /*#__PURE__*/ _react.cloneElement(defaultCheckedIcon, {
            fontSize: size === 'small' ? 'small' : 'medium'
        }),
        classes: {
            root: _clsxDefault.default(classes.root, classes["color".concat(_capitalizeDefault.default(color))]),
            checked: classes.checked,
            disabled: classes.disabled
        },
        name: name,
        checked: checked,
        onChange: onChange,
        ref: ref
    }, other)));
});
Radio.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * If `true`, the component is checked.
   */ checked: _propTypesDefault.default.bool,
    /**
   * The icon to display when the component is checked.
   */ checkedIcon: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */ color: _propTypesDefault.default.oneOf([
        'default',
        'primary',
        'secondary'
    ]),
    /**
   * If `true`, the radio will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * If `true`, the ripple effect will be disabled.
   */ disableRipple: _propTypesDefault.default.bool,
    /**
   * The icon to display when the component is unchecked.
   */ icon: _propTypesDefault.default.node,
    /**
   * The id of the `input` element.
   */ id: _propTypesDefault.default.string,
    /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */ inputProps: _propTypesDefault.default.object,
    /**
   * Pass a ref to the `input` element.
   */ inputRef: _utils.refType,
    /**
   * Name attribute of the `input` element.
   */ name: _propTypesDefault.default.string,
    /**
   * Callback fired when the state is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   * You can pull out the new checked state by accessing `event.target.checked` (boolean).
   */ onChange: _propTypesDefault.default.func,
    /**
   * If `true`, the `input` element will be required.
   */ required: _propTypesDefault.default.bool,
    /**
   * The size of the radio.
   * `small` is equivalent to the dense radio styling.
   */ size: _propTypesDefault.default.oneOf([
        'medium',
        'small'
    ]),
    /**
   * The value of the component. The DOM API casts this to a string.
   */ value: _propTypesDefault.default.any
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiRadio'
})(Radio);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","@material-ui/utils":"Uumnw","../internal/SwitchBase":"i924Q","./RadioButtonIcon":"apRBH","../styles/colorManipulator":"4vQbC","../utils/capitalize":"4RyDE","../utils/createChainedFunction":"annRX","../styles/withStyles":"3pIr2","../RadioGroup/useRadioGroup":"j4zWh","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"i924Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _slicedToArray = require("@babel/runtime/helpers/esm/slicedToArray");
var _slicedToArrayDefault = parcelHelpers.interopDefault(_slicedToArray);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _useControlled = require("../utils/useControlled");
var _useControlledDefault = parcelHelpers.interopDefault(_useControlled);
var _useFormControl = require("../FormControl/useFormControl");
var _useFormControlDefault = parcelHelpers.interopDefault(_useFormControl);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _iconButton = require("../IconButton");
var _iconButtonDefault = parcelHelpers.interopDefault(_iconButton);
var styles = {
    root: {
        padding: 9
    },
    checked: {
    },
    disabled: {
    },
    input: {
        cursor: 'inherit',
        position: 'absolute',
        opacity: 0,
        width: '100%',
        height: '100%',
        top: 0,
        left: 0,
        margin: 0,
        padding: 0,
        zIndex: 1
    }
};
/**
 * @ignore - internal component.
 */ var SwitchBase = /*#__PURE__*/ _react.forwardRef(function SwitchBase1(props, ref) {
    var autoFocus = props.autoFocus, checkedProp = props.checked, checkedIcon = props.checkedIcon, classes = props.classes, className = props.className, defaultChecked = props.defaultChecked, disabledProp = props.disabled, icon = props.icon, id = props.id, inputProps = props.inputProps, inputRef = props.inputRef, name = props.name, onBlur = props.onBlur, onChange = props.onChange, onFocus = props.onFocus, readOnly = props.readOnly, required = props.required, tabIndex = props.tabIndex, type = props.type, value = props.value, other = _objectWithoutPropertiesDefault.default(props, [
        "autoFocus",
        "checked",
        "checkedIcon",
        "classes",
        "className",
        "defaultChecked",
        "disabled",
        "icon",
        "id",
        "inputProps",
        "inputRef",
        "name",
        "onBlur",
        "onChange",
        "onFocus",
        "readOnly",
        "required",
        "tabIndex",
        "type",
        "value"
    ]);
    var _useControlled1 = _useControlledDefault.default({
        controlled: checkedProp,
        default: Boolean(defaultChecked),
        name: 'SwitchBase',
        state: 'checked'
    }), _useControlled2 = _slicedToArrayDefault.default(_useControlled1, 2), checked = _useControlled2[0], setCheckedState = _useControlled2[1];
    var muiFormControl = _useFormControlDefault.default();
    var handleFocus = function handleFocus1(event) {
        if (onFocus) onFocus(event);
        if (muiFormControl && muiFormControl.onFocus) muiFormControl.onFocus(event);
    };
    var handleBlur = function handleBlur1(event) {
        if (onBlur) onBlur(event);
        if (muiFormControl && muiFormControl.onBlur) muiFormControl.onBlur(event);
    };
    var handleInputChange = function handleInputChange1(event) {
        var newChecked = event.target.checked;
        setCheckedState(newChecked);
        if (onChange) // TODO v5: remove the second argument.
        onChange(event, newChecked);
    };
    var disabled = disabledProp;
    if (muiFormControl) {
        if (typeof disabled === 'undefined') disabled = muiFormControl.disabled;
    }
    var hasLabelFor = type === 'checkbox' || type === 'radio';
    return(/*#__PURE__*/ _react.createElement(_iconButtonDefault.default, _extendsDefault.default({
        component: "span",
        className: _clsxDefault.default(classes.root, className, checked && classes.checked, disabled && classes.disabled),
        disabled: disabled,
        tabIndex: null,
        role: undefined,
        onFocus: handleFocus,
        onBlur: handleBlur,
        ref: ref
    }, other), /*#__PURE__*/ _react.createElement("input", _extendsDefault.default({
        autoFocus: autoFocus,
        checked: checkedProp,
        defaultChecked: defaultChecked,
        className: classes.input,
        disabled: disabled,
        id: hasLabelFor && id,
        name: name,
        onChange: handleInputChange,
        readOnly: readOnly,
        ref: inputRef,
        required: required,
        tabIndex: tabIndex,
        type: type,
        value: value
    }, inputProps)), checked ? checkedIcon : icon));
}); // NB: If changed, please update Checkbox, Switch and Radio
SwitchBase.propTypes = {
    /**
   * If `true`, the `input` element will be focused during the first mount.
   */ autoFocus: _propTypesDefault.default.bool,
    /**
   * If `true`, the component is checked.
   */ checked: _propTypesDefault.default.bool,
    /**
   * The icon to display when the component is checked.
   */ checkedIcon: _propTypesDefault.default.node.isRequired,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object.isRequired,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * @ignore
   */ defaultChecked: _propTypesDefault.default.bool,
    /**
   * If `true`, the switch will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * The icon to display when the component is unchecked.
   */ icon: _propTypesDefault.default.node.isRequired,
    /**
   * The id of the `input` element.
   */ id: _propTypesDefault.default.string,
    /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */ inputProps: _propTypesDefault.default.object,
    /**
   * Pass a ref to the `input` element.
   */ inputRef: _utils.refType,
    /*
   * @ignore
   */ name: _propTypesDefault.default.string,
    /**
   * @ignore
   */ onBlur: _propTypesDefault.default.func,
    /**
   * Callback fired when the state is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new checked state by accessing `event.target.checked` (boolean).
   */ onChange: _propTypesDefault.default.func,
    /**
   * @ignore
   */ onFocus: _propTypesDefault.default.func,
    /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */ readOnly: _propTypesDefault.default.bool,
    /**
   * If `true`, the `input` element will be required.
   */ required: _propTypesDefault.default.bool,
    /**
   * @ignore
   */ tabIndex: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * The input component prop `type`.
   */ type: _propTypesDefault.default.string.isRequired,
    /**
   * The value of the component.
   */ value: _propTypesDefault.default.any
};
exports.default = _withStylesDefault.default(styles, {
    name: 'PrivateSwitchBase'
})(SwitchBase);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/slicedToArray":"cT2nX","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","@material-ui/utils":"Uumnw","../utils/useControlled":"hpiZY","../FormControl/useFormControl":"hjPoI","../styles/withStyles":"3pIr2","../IconButton":"5WdSS","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5WdSS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_iconButtonDefault.default
);
var _iconButton = require("./IconButton");
var _iconButtonDefault = parcelHelpers.interopDefault(_iconButton);

},{"./IconButton":"5hblH","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5hblH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _colorManipulator = require("../styles/colorManipulator");
var _buttonBase = require("../ButtonBase");
var _buttonBaseDefault = parcelHelpers.interopDefault(_buttonBase);
var _capitalize = require("../utils/capitalize");
var _capitalizeDefault = parcelHelpers.interopDefault(_capitalize);
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            textAlign: 'center',
            flex: '0 0 auto',
            fontSize: theme.typography.pxToRem(24),
            padding: 12,
            borderRadius: '50%',
            overflow: 'visible',
            // Explicitly set the default value to solve a bug on IE 11.
            color: theme.palette.action.active,
            transition: theme.transitions.create('background-color', {
                duration: theme.transitions.duration.shortest
            }),
            '&:hover': {
                backgroundColor: _colorManipulator.alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    backgroundColor: 'transparent'
                }
            },
            '&$disabled': {
                backgroundColor: 'transparent',
                color: theme.palette.action.disabled
            }
        },
        /* Styles applied to the root element if `edge="start"`. */ edgeStart: {
            marginLeft: -12,
            '$sizeSmall&': {
                marginLeft: -3
            }
        },
        /* Styles applied to the root element if `edge="end"`. */ edgeEnd: {
            marginRight: -12,
            '$sizeSmall&': {
                marginRight: -3
            }
        },
        /* Styles applied to the root element if `color="inherit"`. */ colorInherit: {
            color: 'inherit'
        },
        /* Styles applied to the root element if `color="primary"`. */ colorPrimary: {
            color: theme.palette.primary.main,
            '&:hover': {
                backgroundColor: _colorManipulator.alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    backgroundColor: 'transparent'
                }
            }
        },
        /* Styles applied to the root element if `color="secondary"`. */ colorSecondary: {
            color: theme.palette.secondary.main,
            '&:hover': {
                backgroundColor: _colorManipulator.alpha(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                '@media (hover: none)': {
                    backgroundColor: 'transparent'
                }
            }
        },
        /* Pseudo-class applied to the root element if `disabled={true}`. */ disabled: {
        },
        /* Styles applied to the root element if `size="small"`. */ sizeSmall: {
            padding: 3,
            fontSize: theme.typography.pxToRem(18)
        },
        /* Styles applied to the children container element. */ label: {
            width: '100%',
            display: 'flex',
            alignItems: 'inherit',
            justifyContent: 'inherit'
        }
    };
};
/**
 * Refer to the [Icons](/components/icons/) section of the documentation
 * regarding the available icon options.
 */ var IconButton = /*#__PURE__*/ _react.forwardRef(function IconButton1(props, ref) {
    var _props$edge = props.edge, edge = _props$edge === void 0 ? false : _props$edge, children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? 'default' : _props$color, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableFocusRi = props.disableFocusRipple, disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi, _props$size = props.size, size = _props$size === void 0 ? 'medium' : _props$size, other = _objectWithoutPropertiesDefault.default(props, [
        "edge",
        "children",
        "classes",
        "className",
        "color",
        "disabled",
        "disableFocusRipple",
        "size"
    ]);
    return(/*#__PURE__*/ _react.createElement(_buttonBaseDefault.default, _extendsDefault.default({
        className: _clsxDefault.default(classes.root, className, color !== 'default' && classes["color".concat(_capitalizeDefault.default(color))], disabled && classes.disabled, size === "small" && classes["size".concat(_capitalizeDefault.default(size))], {
            'start': classes.edgeStart,
            'end': classes.edgeEnd
        }[edge]),
        centerRipple: true,
        focusRipple: !disableFocusRipple,
        disabled: disabled,
        ref: ref
    }, other), /*#__PURE__*/ _react.createElement("span", {
        className: classes.label
    }, children)));
});
IconButton.propTypes = {
    /**
   * The icon element.
   */ children: _utils.chainPropTypes(_propTypesDefault.default.node, function(props) {
        var found = _react.Children.toArray(props.children).some(function(child) {
            return(/*#__PURE__*/ _react.isValidElement(child) && child.props.onClick);
        });
        if (found) return new Error([
            "Material-UI: You are providing an onClick event listener to a child of a button element.",
            'Firefox will never trigger the event.',
            'You should move the onClick listener to the parent button element.',
            'https://github.com/mui-org/material-ui/issues/13957'
        ].join('\n'));
        return null;
    }),
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object.isRequired,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */ color: _propTypesDefault.default.oneOf([
        'default',
        'inherit',
        'primary',
        'secondary'
    ]),
    /**
   * If `true`, the button will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * If `true`, the  keyboard focus ripple will be disabled.
   */ disableFocusRipple: _propTypesDefault.default.bool,
    /**
   * If `true`, the ripple effect will be disabled.
   */ disableRipple: _propTypesDefault.default.bool,
    /**
   * If given, uses a negative margin to counteract the padding on one
   * side (this is often helpful for aligning the left or right
   * side of the icon with content above or below, without ruining the border
   * size and shape).
   */ edge: _propTypesDefault.default.oneOf([
        'start',
        'end',
        false
    ]),
    /**
   * The size of the button.
   * `small` is equivalent to the dense button styling.
   */ size: _propTypesDefault.default.oneOf([
        'small',
        'medium'
    ])
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiIconButton'
})(IconButton);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","@material-ui/utils":"Uumnw","../styles/withStyles":"3pIr2","../styles/colorManipulator":"4vQbC","../ButtonBase":"c7TvV","../utils/capitalize":"4RyDE","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"apRBH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _radioButtonUnchecked = require("../internal/svg-icons/RadioButtonUnchecked");
var _radioButtonUncheckedDefault = parcelHelpers.interopDefault(_radioButtonUnchecked);
var _radioButtonChecked = require("../internal/svg-icons/RadioButtonChecked");
var _radioButtonCheckedDefault = parcelHelpers.interopDefault(_radioButtonChecked);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var styles = function styles1(theme) {
    return {
        root: {
            position: 'relative',
            display: 'flex',
            '&$checked $layer': {
                transform: 'scale(1)',
                transition: theme.transitions.create('transform', {
                    easing: theme.transitions.easing.easeOut,
                    duration: theme.transitions.duration.shortest
                })
            }
        },
        layer: {
            left: 0,
            position: 'absolute',
            transform: 'scale(0)',
            transition: theme.transitions.create('transform', {
                easing: theme.transitions.easing.easeIn,
                duration: theme.transitions.duration.shortest
            })
        },
        checked: {
        }
    };
};
/**
 * @ignore - internal component.
 */ function RadioButtonIcon(props) {
    var checked = props.checked, classes = props.classes, fontSize = props.fontSize;
    return(/*#__PURE__*/ _react.createElement("div", {
        className: _clsxDefault.default(classes.root, checked && classes.checked)
    }, /*#__PURE__*/ _react.createElement(_radioButtonUncheckedDefault.default, {
        fontSize: fontSize
    }), /*#__PURE__*/ _react.createElement(_radioButtonCheckedDefault.default, {
        fontSize: fontSize,
        className: classes.layer
    })));
}
RadioButtonIcon.propTypes = {
    /**
   * If `true`, the component is checked.
   */ checked: _propTypesDefault.default.bool,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object.isRequired,
    /**
   * The size of the radio.
   * `small` is equivalent to the dense radio styling.
   */ fontSize: _propTypesDefault.default.oneOf([
        'small',
        'medium'
    ])
};
exports.default = _withStylesDefault.default(styles, {
    name: 'PrivateRadioButtonIcon'
})(RadioButtonIcon);

},{"react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","../internal/svg-icons/RadioButtonUnchecked":"hbzJt","../internal/svg-icons/RadioButtonChecked":"bKXhX","../styles/withStyles":"3pIr2","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hbzJt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _createSvgIcon = require("../../utils/createSvgIcon");
var _createSvgIconDefault = parcelHelpers.interopDefault(_createSvgIcon);
exports.default = _createSvgIconDefault.default(/*#__PURE__*/ _react.createElement("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), 'RadioButtonUnchecked');

},{"react":"cKM0D","../../utils/createSvgIcon":"78Y91","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"bKXhX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _createSvgIcon = require("../../utils/createSvgIcon");
var _createSvgIconDefault = parcelHelpers.interopDefault(_createSvgIcon);
exports.default = _createSvgIconDefault.default(/*#__PURE__*/ _react.createElement("path", {
    d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
}), 'RadioButtonChecked');

},{"react":"cKM0D","../../utils/createSvgIcon":"78Y91","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"j4zWh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _radioGroupContext = require("./RadioGroupContext");
var _radioGroupContextDefault = parcelHelpers.interopDefault(_radioGroupContext);
function useRadioGroup() {
    return _react.useContext(_radioGroupContextDefault.default);
}
exports.default = useRadioGroup;

},{"react":"cKM0D","./RadioGroupContext":"9lDOf","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"9lDOf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
/**
 * @ignore - internal component.
 */ var RadioGroupContext = _react.createContext();
RadioGroupContext.displayName = 'RadioGroupContext';
exports.default = RadioGroupContext;

},{"react":"cKM0D","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hfDeX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_radioGroupDefault.default
);
parcelHelpers.export(exports, "useRadioGroup", ()=>_useRadioGroupDefault.default
);
var _radioGroup = require("./RadioGroup");
var _radioGroupDefault = parcelHelpers.interopDefault(_radioGroup);
var _useRadioGroup = require("./useRadioGroup");
var _useRadioGroupDefault = parcelHelpers.interopDefault(_useRadioGroup);

},{"./RadioGroup":"2UvIW","./useRadioGroup":"j4zWh","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"2UvIW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _slicedToArray = require("@babel/runtime/helpers/esm/slicedToArray");
var _slicedToArrayDefault = parcelHelpers.interopDefault(_slicedToArray);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _formGroup = require("../FormGroup");
var _formGroupDefault = parcelHelpers.interopDefault(_formGroup);
var _useForkRef = require("../utils/useForkRef");
var _useForkRefDefault = parcelHelpers.interopDefault(_useForkRef);
var _useControlled = require("../utils/useControlled");
var _useControlledDefault = parcelHelpers.interopDefault(_useControlled);
var _radioGroupContext = require("./RadioGroupContext");
var _radioGroupContextDefault = parcelHelpers.interopDefault(_radioGroupContext);
var _unstableUseId = require("../utils/unstable_useId");
var _unstableUseIdDefault = parcelHelpers.interopDefault(_unstableUseId);
var RadioGroup = /*#__PURE__*/ _react.forwardRef(function RadioGroup1(props, ref) {
    var actions = props.actions, children = props.children, nameProp = props.name, valueProp = props.value, onChange = props.onChange, other = _objectWithoutPropertiesDefault.default(props, [
        "actions",
        "children",
        "name",
        "value",
        "onChange"
    ]);
    var rootRef = _react.useRef(null);
    var _useControlled1 = _useControlledDefault.default({
        controlled: valueProp,
        default: props.defaultValue,
        name: 'RadioGroup'
    }), _useControlled2 = _slicedToArrayDefault.default(_useControlled1, 2), value = _useControlled2[0], setValue = _useControlled2[1];
    _react.useImperativeHandle(actions, function() {
        return {
            focus: function focus() {
                var input = rootRef.current.querySelector('input:not(:disabled):checked');
                if (!input) input = rootRef.current.querySelector('input:not(:disabled)');
                if (input) input.focus();
            }
        };
    }, []);
    var handleRef = _useForkRefDefault.default(ref, rootRef);
    var handleChange = function handleChange1(event) {
        setValue(event.target.value);
        if (onChange) onChange(event, event.target.value);
    };
    var name = _unstableUseIdDefault.default(nameProp);
    return(/*#__PURE__*/ _react.createElement(_radioGroupContextDefault.default.Provider, {
        value: {
            name: name,
            onChange: handleChange,
            value: value
        }
    }, /*#__PURE__*/ _react.createElement(_formGroupDefault.default, _extendsDefault.default({
        role: "radiogroup",
        ref: handleRef
    }, other), children)));
});
RadioGroup.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * The content of the component.
   */ children: _propTypesDefault.default.node,
    /**
   * The default `input` element value. Use when the component is not controlled.
   */ defaultValue: _propTypesDefault.default.oneOfType([
        _propTypesDefault.default.arrayOf(_propTypesDefault.default.string),
        _propTypesDefault.default.number,
        _propTypesDefault.default.string
    ]),
    /**
   * The name used to reference the value of the control.
   * If you don't provide this prop, it falls back to a randomly generated name.
   */ name: _propTypesDefault.default.string,
    /**
   * Callback fired when a radio button is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */ onChange: _propTypesDefault.default.func,
    /**
   * Value of the selected radio button. The DOM API casts this to a string.
   */ value: _propTypesDefault.default.any
};
exports.default = RadioGroup;

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/slicedToArray":"cT2nX","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","../FormGroup":"3tFCr","../utils/useForkRef":"bLpHM","../utils/useControlled":"hpiZY","./RadioGroupContext":"9lDOf","../utils/unstable_useId":"1dqK3","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"3tFCr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_formGroupDefault.default
);
var _formGroup = require("./FormGroup");
var _formGroupDefault = parcelHelpers.interopDefault(_formGroup);

},{"./FormGroup":"aKUwt","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"aKUwt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var styles = {
    /* Styles applied to the root element. */ root: {
        display: 'flex',
        flexDirection: 'column',
        flexWrap: 'wrap'
    },
    /* Styles applied to the root element if `row={true}`. */ row: {
        flexDirection: 'row'
    }
};
/**
 * `FormGroup` wraps controls such as `Checkbox` and `Switch`.
 * It provides compact row layout.
 * For the `Radio`, you should be using the `RadioGroup` component instead of this one.
 */ var FormGroup = /*#__PURE__*/ _react.forwardRef(function FormGroup1(props, ref) {
    var classes = props.classes, className = props.className, _props$row = props.row, row = _props$row === void 0 ? false : _props$row, other = _objectWithoutPropertiesDefault.default(props, [
        "classes",
        "className",
        "row"
    ]);
    return(/*#__PURE__*/ _react.createElement("div", _extendsDefault.default({
        className: _clsxDefault.default(classes.root, className, row && classes.row),
        ref: ref
    }, other)));
});
FormGroup.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * The content of the component.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * Display group of elements in a compact row.
   */ row: _propTypesDefault.default.bool
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiFormGroup'
})(FormGroup);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","../styles/withStyles":"3pIr2","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"1dqK3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
function useId(idOverride) {
    var _React$useState = _react.useState(idOverride), defaultId = _React$useState[0], setDefaultId = _React$useState[1];
    var id = idOverride || defaultId;
    _react.useEffect(function() {
        if (defaultId == null) // Fallback to this default id when possible.
        // Use the random value for client-side rendering only.
        // We can't use it server-side.
        setDefaultId("mui-".concat(Math.round(Math.random() * 100000)));
    }, [
        defaultId
    ]);
    return id;
}
exports.default = useId;

},{"react":"cKM0D","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"j2QnF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_formControlLabelDefault.default
);
var _formControlLabel = require("./FormControlLabel");
var _formControlLabelDefault = parcelHelpers.interopDefault(_formControlLabel);

},{"./FormControlLabel":"5MRYq","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"5MRYq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _utils = require("@material-ui/utils");
var _formControl = require("../FormControl");
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _typography = require("../Typography");
var _typographyDefault = parcelHelpers.interopDefault(_typography);
var _capitalize = require("../utils/capitalize");
var _capitalizeDefault = parcelHelpers.interopDefault(_capitalize);
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            display: 'inline-flex',
            alignItems: 'center',
            cursor: 'pointer',
            // For correct alignment with the text.
            verticalAlign: 'middle',
            WebkitTapHighlightColor: 'transparent',
            marginLeft: -11,
            marginRight: 16,
            // used for row presentation of radio/checkbox
            '&$disabled': {
                cursor: 'default'
            }
        },
        /* Styles applied to the root element if `labelPlacement="start"`. */ labelPlacementStart: {
            flexDirection: 'row-reverse',
            marginLeft: 16,
            // used for row presentation of radio/checkbox
            marginRight: -11
        },
        /* Styles applied to the root element if `labelPlacement="top"`. */ labelPlacementTop: {
            flexDirection: 'column-reverse',
            marginLeft: 16
        },
        /* Styles applied to the root element if `labelPlacement="bottom"`. */ labelPlacementBottom: {
            flexDirection: 'column',
            marginLeft: 16
        },
        /* Pseudo-class applied to the root element if `disabled={true}`. */ disabled: {
        },
        /* Styles applied to the label's Typography component. */ label: {
            '&$disabled': {
                color: theme.palette.text.disabled
            }
        }
    };
};
/**
 * Drop in replacement of the `Radio`, `Switch` and `Checkbox` component.
 * Use this component if you want to display an extra label.
 */ var FormControlLabel = /*#__PURE__*/ _react.forwardRef(function FormControlLabel1(props, ref) {
    var checked = props.checked, classes = props.classes, className = props.className, control = props.control, disabledProp = props.disabled, inputRef = props.inputRef, label = props.label, _props$labelPlacement = props.labelPlacement, labelPlacement = _props$labelPlacement === void 0 ? 'end' : _props$labelPlacement, name = props.name, onChange = props.onChange, value = props.value, other = _objectWithoutPropertiesDefault.default(props, [
        "checked",
        "classes",
        "className",
        "control",
        "disabled",
        "inputRef",
        "label",
        "labelPlacement",
        "name",
        "onChange",
        "value"
    ]);
    var muiFormControl = _formControl.useFormControl();
    var disabled = disabledProp;
    if (typeof disabled === 'undefined' && typeof control.props.disabled !== 'undefined') disabled = control.props.disabled;
    if (typeof disabled === 'undefined' && muiFormControl) disabled = muiFormControl.disabled;
    var controlProps = {
        disabled: disabled
    };
    [
        'checked',
        'name',
        'onChange',
        'value',
        'inputRef'
    ].forEach(function(key) {
        if (typeof control.props[key] === 'undefined' && typeof props[key] !== 'undefined') controlProps[key] = props[key];
    });
    return(/*#__PURE__*/ _react.createElement("label", _extendsDefault.default({
        className: _clsxDefault.default(classes.root, className, labelPlacement !== 'end' && classes["labelPlacement".concat(_capitalizeDefault.default(labelPlacement))], disabled && classes.disabled),
        ref: ref
    }, other), /*#__PURE__*/ _react.cloneElement(control, controlProps), /*#__PURE__*/ _react.createElement(_typographyDefault.default, {
        component: "span",
        className: _clsxDefault.default(classes.label, disabled && classes.disabled)
    }, label)));
});
FormControlLabel.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------
    /**
   * If `true`, the component appears selected.
   */ checked: _propTypesDefault.default.bool,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * A control element. For instance, it can be be a `Radio`, a `Switch` or a `Checkbox`.
   */ control: _propTypesDefault.default.element.isRequired,
    /**
   * If `true`, the control will be disabled.
   */ disabled: _propTypesDefault.default.bool,
    /**
   * Pass a ref to the `input` element.
   */ inputRef: _utils.refType,
    /**
   * The text to be used in an enclosing label element.
   */ label: _propTypesDefault.default.node,
    /**
   * The position of the label.
   */ labelPlacement: _propTypesDefault.default.oneOf([
        'bottom',
        'end',
        'start',
        'top'
    ]),
    /**
   * @ignore
   */ name: _propTypesDefault.default.string,
    /**
   * Callback fired when the state is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new checked state by accessing `event.target.checked` (boolean).
   */ onChange: _propTypesDefault.default.func,
    /**
   * The value of the component.
   */ value: _propTypesDefault.default.any
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiFormControlLabel'
})(FormControlLabel);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","@material-ui/utils":"Uumnw","../FormControl":"8200A","../styles/withStyles":"3pIr2","../Typography":"9wg0U","../utils/capitalize":"4RyDE","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"9wg0U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_typographyDefault.default
);
var _typography = require("./Typography");
var _typographyDefault = parcelHelpers.interopDefault(_typography);

},{"./Typography":"gHsJi","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"gHsJi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styles", ()=>styles
);
var _extends = require("@babel/runtime/helpers/esm/extends");
var _extendsDefault = parcelHelpers.interopDefault(_extends);
var _objectWithoutProperties = require("@babel/runtime/helpers/esm/objectWithoutProperties");
var _objectWithoutPropertiesDefault = parcelHelpers.interopDefault(_objectWithoutProperties);
var _react = require("react");
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _clsx = require("clsx");
var _clsxDefault = parcelHelpers.interopDefault(_clsx);
var _withStyles = require("../styles/withStyles");
var _withStylesDefault = parcelHelpers.interopDefault(_withStyles);
var _capitalize = require("../utils/capitalize");
var _capitalizeDefault = parcelHelpers.interopDefault(_capitalize);
var styles = function styles1(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            margin: 0
        },
        /* Styles applied to the root element if `variant="body2"`. */ body2: theme.typography.body2,
        /* Styles applied to the root element if `variant="body1"`. */ body1: theme.typography.body1,
        /* Styles applied to the root element if `variant="caption"`. */ caption: theme.typography.caption,
        /* Styles applied to the root element if `variant="button"`. */ button: theme.typography.button,
        /* Styles applied to the root element if `variant="h1"`. */ h1: theme.typography.h1,
        /* Styles applied to the root element if `variant="h2"`. */ h2: theme.typography.h2,
        /* Styles applied to the root element if `variant="h3"`. */ h3: theme.typography.h3,
        /* Styles applied to the root element if `variant="h4"`. */ h4: theme.typography.h4,
        /* Styles applied to the root element if `variant="h5"`. */ h5: theme.typography.h5,
        /* Styles applied to the root element if `variant="h6"`. */ h6: theme.typography.h6,
        /* Styles applied to the root element if `variant="subtitle1"`. */ subtitle1: theme.typography.subtitle1,
        /* Styles applied to the root element if `variant="subtitle2"`. */ subtitle2: theme.typography.subtitle2,
        /* Styles applied to the root element if `variant="overline"`. */ overline: theme.typography.overline,
        /* Styles applied to the root element if `variant="srOnly"`. Only accessible to screen readers. */ srOnly: {
            position: 'absolute',
            height: 1,
            width: 1,
            overflow: 'hidden'
        },
        /* Styles applied to the root element if `align="left"`. */ alignLeft: {
            textAlign: 'left'
        },
        /* Styles applied to the root element if `align="center"`. */ alignCenter: {
            textAlign: 'center'
        },
        /* Styles applied to the root element if `align="right"`. */ alignRight: {
            textAlign: 'right'
        },
        /* Styles applied to the root element if `align="justify"`. */ alignJustify: {
            textAlign: 'justify'
        },
        /* Styles applied to the root element if `nowrap={true}`. */ noWrap: {
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            whiteSpace: 'nowrap'
        },
        /* Styles applied to the root element if `gutterBottom={true}`. */ gutterBottom: {
            marginBottom: '0.35em'
        },
        /* Styles applied to the root element if `paragraph={true}`. */ paragraph: {
            marginBottom: 16
        },
        /* Styles applied to the root element if `color="inherit"`. */ colorInherit: {
            color: 'inherit'
        },
        /* Styles applied to the root element if `color="primary"`. */ colorPrimary: {
            color: theme.palette.primary.main
        },
        /* Styles applied to the root element if `color="secondary"`. */ colorSecondary: {
            color: theme.palette.secondary.main
        },
        /* Styles applied to the root element if `color="textPrimary"`. */ colorTextPrimary: {
            color: theme.palette.text.primary
        },
        /* Styles applied to the root element if `color="textSecondary"`. */ colorTextSecondary: {
            color: theme.palette.text.secondary
        },
        /* Styles applied to the root element if `color="error"`. */ colorError: {
            color: theme.palette.error.main
        },
        /* Styles applied to the root element if `display="inline"`. */ displayInline: {
            display: 'inline'
        },
        /* Styles applied to the root element if `display="block"`. */ displayBlock: {
            display: 'block'
        }
    };
};
var defaultVariantMapping = {
    h1: 'h1',
    h2: 'h2',
    h3: 'h3',
    h4: 'h4',
    h5: 'h5',
    h6: 'h6',
    subtitle1: 'h6',
    subtitle2: 'h6',
    body1: 'p',
    body2: 'p'
};
var Typography = /*#__PURE__*/ _react.forwardRef(function Typography1(props, ref) {
    var _props$align = props.align, align = _props$align === void 0 ? 'inherit' : _props$align, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? 'initial' : _props$color, component = props.component, _props$display = props.display, display = _props$display === void 0 ? 'initial' : _props$display, _props$gutterBottom = props.gutterBottom, gutterBottom = _props$gutterBottom === void 0 ? false : _props$gutterBottom, _props$noWrap = props.noWrap, noWrap = _props$noWrap === void 0 ? false : _props$noWrap, _props$paragraph = props.paragraph, paragraph = _props$paragraph === void 0 ? false : _props$paragraph, _props$variant = props.variant, variant = _props$variant === void 0 ? 'body1' : _props$variant, _props$variantMapping = props.variantMapping, variantMapping = _props$variantMapping === void 0 ? defaultVariantMapping : _props$variantMapping, other = _objectWithoutPropertiesDefault.default(props, [
        "align",
        "classes",
        "className",
        "color",
        "component",
        "display",
        "gutterBottom",
        "noWrap",
        "paragraph",
        "variant",
        "variantMapping"
    ]);
    var Component = component || (paragraph ? 'p' : variantMapping[variant] || defaultVariantMapping[variant]) || 'span';
    return(/*#__PURE__*/ _react.createElement(Component, _extendsDefault.default({
        className: _clsxDefault.default(classes.root, className, variant !== 'inherit' && classes[variant], color !== 'initial' && classes["color".concat(_capitalizeDefault.default(color))], noWrap && classes.noWrap, gutterBottom && classes.gutterBottom, paragraph && classes.paragraph, align !== 'inherit' && classes["align".concat(_capitalizeDefault.default(align))], display !== 'initial' && classes["display".concat(_capitalizeDefault.default(display))]),
        ref: ref
    }, other)));
});
Typography.propTypes = {
    /**
   * Set the text-align on the component.
   */ align: _propTypesDefault.default.oneOf([
        'inherit',
        'left',
        'center',
        'right',
        'justify'
    ]),
    /**
   * The content of the component.
   */ children: _propTypesDefault.default.node,
    /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */ classes: _propTypesDefault.default.object.isRequired,
    /**
   * @ignore
   */ className: _propTypesDefault.default.string,
    /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */ color: _propTypesDefault.default.oneOf([
        'initial',
        'inherit',
        'primary',
        'secondary',
        'textPrimary',
        'textSecondary',
        'error'
    ]),
    /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   * Overrides the behavior of the `variantMapping` prop.
   */ component: _propTypesDefault.default/* @typescript-to-proptypes-ignore */ .elementType,
    /**
   * Controls the display type
   */ display: _propTypesDefault.default.oneOf([
        'initial',
        'block',
        'inline'
    ]),
    /**
   * If `true`, the text will have a bottom margin.
   */ gutterBottom: _propTypesDefault.default.bool,
    /**
   * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
   *
   * Note that text overflow can only happen with block or inline-block level elements
   * (the element needs to have a width in order to overflow).
   */ noWrap: _propTypesDefault.default.bool,
    /**
   * If `true`, the text will have a bottom margin.
   */ paragraph: _propTypesDefault.default.bool,
    /**
   * Applies the theme typography styles.
   */ variant: _propTypesDefault.default.oneOf([
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'subtitle1',
        'subtitle2',
        'body1',
        'body2',
        'caption',
        'button',
        'overline',
        'srOnly',
        'inherit'
    ]),
    /**
   * The component maps the variant prop to a range of different HTML element types.
   * For instance, subtitle1 to `<h6>`.
   * If you wish to change that mapping, you can provide your own.
   * Alternatively, you can use the `component` prop.
   */ variantMapping: _propTypesDefault.default.object
};
exports.default = _withStylesDefault.default(styles, {
    name: 'MuiTypography'
})(Typography);

},{"@babel/runtime/helpers/esm/extends":"esrVD","@babel/runtime/helpers/esm/objectWithoutProperties":"kasvP","react":"cKM0D","prop-types":"lYCp3","clsx":"cS959","../styles/withStyles":"3pIr2","../utils/capitalize":"4RyDE","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"7svBe":[function() {},{}],"iF6Xe":[function(require,module,exports) {
var $parcel$ReactRefreshHelpers$ad84 = require("@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
$parcel$ReactRefreshHelpers$ad84.prelude(module);

try {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsxRuntime = require("react/jsx-runtime");
var _react = require("react");
var _textField = require("@material-ui/core/TextField");
var _textFieldDefault = parcelHelpers.interopDefault(_textField);
var _button = require("@material-ui/core/Button");
var _buttonDefault = parcelHelpers.interopDefault(_button);
var _uichatStyleCss = require("./UIChat_style.css");
var _s = $RefreshSig$();
function UIChat(props) {
    _s();
    const [chatData, setChatData] = _react.useState([]);
    const [members, setMembers] = _react.useState([]);
    const [gameRequest, setGameRequest] = _react.useState(null);
    const [messageBox, setMessageBox] = _react.useState(null);
    const netCom = props.netCom;
    const onChatDataReceived = (data)=>{
        let tmpChatMessage = {
            from: data.from,
            content: data.content,
            time: data.time
        };
        if (chatData.length === 0) {
            setChatData([
                tmpChatMessage
            ]);
            return 0;
        }
        let tmpChatData = [
            ...chatData
        ];
        tmpChatData.push(tmpChatMessage);
        setChatData(tmpChatData);
    };
    const onChatMembersReceived = (data)=>{
        setMembers(data);
    };
    const onGameRequestReceived = (opponentId, data)=>{
        setGameRequest({
            opponentId: opponentId,
            opponentName: data.opponentName
        });
    };
    const onGameRequestRejectReceived = (opponentId, data)=>{
        setMessageBox(data.opponentName + ' does not want to mess with you. Look out for another buddy.');
    };
    const onGameRequestAckReceived = (opponentId, data)=>{
        opponentId !== undefined && netCom.doGameInitiation(opponentId);
    };
    netCom.onChatDataReceived = onChatDataReceived;
    netCom.onPlayersDataReceived = onChatMembersReceived;
    netCom.onGameRequestReceived = onGameRequestReceived;
    netCom.onGameRequestRejectReceived = onGameRequestRejectReceived;
    netCom.onGameRequestAckReceived = onGameRequestAckReceived;
    const renderChat = ()=>{
        let chatMessages = chatData.map((element)=>{
            return(/*#__PURE__*/ _jsxRuntime.jsxs("li", {
                __source: {
                    fileName: "src/ui-components/UIChat.tsx",
                    lineNumber: 52
                },
                __self: this,
                children: [
                    /*#__PURE__*/ _jsxRuntime.jsxs("b", {
                        __source: {
                            fileName: "src/ui-components/UIChat.tsx",
                            lineNumber: 53
                        },
                        __self: this,
                        children: [
                            element.from,
                            ": "
                        ]
                    }),
                    " ",
                    element.content
                ]
            }));
        });
        return chatMessages.reverse();
    };
    const doGameRequest = (opponentId)=>{
        netCom.doGameRequest(props.playerName, opponentId);
    };
    const renderPlayers = ()=>{
        let players = members.map((element)=>{
            return(/*#__PURE__*/ _jsxRuntime.jsx("li", {
                onClick: ()=>{
                    doGameRequest(element.id);
                },
                __source: {
                    fileName: "src/ui-components/UIChat.tsx",
                    lineNumber: 68
                },
                __self: this,
                children: element.name
            }));
        });
        return players;
    };
    const send = ()=>{
        const txtMessage = document.getElementById('txtMessage');
        const message = txtMessage.value;
        if (message !== '') {
            props.netCom.exchangeChatData({
                content: message,
                from: props.playerName,
                time: ''
            });
            txtMessage.value = '';
        }
    };
    const accept = ()=>{
        netCom.doGameRequestAck(props.playerName, gameRequest.opponentId);
        setGameRequest(null);
    };
    const reject = ()=>{
        netCom.doGameRequestReject(props.playerName, gameRequest.opponentId);
        setGameRequest(null);
    };
    return(/*#__PURE__*/ _jsxRuntime.jsxs("div", {
        __source: {
            fileName: "src/ui-components/UIChat.tsx",
            lineNumber: 102
        },
        __self: this,
        children: [
            /*#__PURE__*/ _jsxRuntime.jsxs("div", {
                className: "w3-row",
                __source: {
                    fileName: "src/ui-components/UIChat.tsx",
                    lineNumber: 103
                },
                __self: this,
                children: [
                    /*#__PURE__*/ _jsxRuntime.jsx("div", {
                        className: "w3-padding-small w3-green",
                        __source: {
                            fileName: "src/ui-components/UIChat.tsx",
                            lineNumber: 104
                        },
                        __self: this,
                        children: /*#__PURE__*/ _jsxRuntime.jsx("span", {
                            className: "game-ui-title",
                            __source: {
                                fileName: "src/ui-components/UIChat.tsx",
                                lineNumber: 105
                            },
                            __self: this,
                            children: "Available Warriors"
                        })
                    }),
                    /*#__PURE__*/ _jsxRuntime.jsx("div", {
                        id: "playerList",
                        className: "w3-col w3-container",
                        __source: {
                            fileName: "src/ui-components/UIChat.tsx",
                            lineNumber: 107
                        },
                        __self: this,
                        children: /*#__PURE__*/ _jsxRuntime.jsx("ul", {
                            __source: {
                                fileName: "src/ui-components/UIChat.tsx",
                                lineNumber: 108
                            },
                            __self: this,
                            children: renderPlayers()
                        })
                    }),
                    /*#__PURE__*/ _jsxRuntime.jsx("div", {
                        className: "w3-padding-small w3-green",
                        __source: {
                            fileName: "src/ui-components/UIChat.tsx",
                            lineNumber: 110
                        },
                        __self: this,
                        children: /*#__PURE__*/ _jsxRuntime.jsx("span", {
                            className: "game-ui-title",
                            __source: {
                                fileName: "src/ui-components/UIChat.tsx",
                                lineNumber: 111
                            },
                            __self: this,
                            children: "Chat"
                        })
                    }),
                    /*#__PURE__*/ _jsxRuntime.jsx("div", {
                        id: "chatList",
                        className: "w3-col w3-container",
                        __source: {
                            fileName: "src/ui-components/UIChat.tsx",
                            lineNumber: 113
                        },
                        __self: this,
                        children: /*#__PURE__*/ _jsxRuntime.jsx("ul", {
                            __source: {
                                fileName: "src/ui-components/UIChat.tsx",
                                lineNumber: 114
                            },
                            __self: this,
                            children: renderChat()
                        })
                    })
                ]
            }),
            /*#__PURE__*/ _jsxRuntime.jsx("div", {
                className: "w3-row w3-padding w3-padding-top-24",
                __source: {
                    fileName: "src/ui-components/UIChat.tsx",
                    lineNumber: 117
                },
                __self: this,
                children: /*#__PURE__*/ _jsxRuntime.jsx(_textFieldDefault.default, {
                    className: "txtMessage",
                    id: "txtMessage",
                    label: "your message",
                    multiline: true,
                    minRows: 2,
                    variant: "outlined",
                    __source: {
                        fileName: "src/ui-components/UIChat.tsx",
                        lineNumber: 118
                    },
                    __self: this
                })
            }),
            /*#__PURE__*/ _jsxRuntime.jsx("div", {
                className: "w3-row w3-padding",
                __source: {
                    fileName: "src/ui-components/UIChat.tsx",
                    lineNumber: 127
                },
                __self: this,
                children: /*#__PURE__*/ _jsxRuntime.jsx(_buttonDefault.default, {
                    variant: "contained",
                    color: "primary",
                    onClick: send,
                    __source: {
                        fileName: "src/ui-components/UIChat.tsx",
                        lineNumber: 128
                    },
                    __self: this,
                    children: "Send"
                })
            }),
            gameRequest !== null && /*#__PURE__*/ _jsxRuntime.jsx("div", {
                className: "w3-overlay w3-show",
                __source: {
                    fileName: "src/ui-components/UIChat.tsx",
                    lineNumber: 133
                },
                __self: this,
                children: /*#__PURE__*/ _jsxRuntime.jsxs("div", {
                    className: "w3-panel 2-card w3-white w3-auto w3-display-middle",
                    __source: {
                        fileName: "src/ui-components/UIChat.tsx",
                        lineNumber: 134
                    },
                    __self: this,
                    children: [
                        /*#__PURE__*/ _jsxRuntime.jsxs("div", {
                            className: "w3-row w3-padding",
                            __source: {
                                fileName: "src/ui-components/UIChat.tsx",
                                lineNumber: 135
                            },
                            __self: this,
                            children: [
                                gameRequest.opponentName,
                                " wants to mess with you. Accept?"
                            ]
                        }),
                        /*#__PURE__*/ _jsxRuntime.jsxs("div", {
                            className: "w3-row w3-padding",
                            __source: {
                                fileName: "src/ui-components/UIChat.tsx",
                                lineNumber: 138
                            },
                            __self: this,
                            children: [
                                /*#__PURE__*/ _jsxRuntime.jsx("div", {
                                    className: "w3-container w3-half w3-padding",
                                    __source: {
                                        fileName: "src/ui-components/UIChat.tsx",
                                        lineNumber: 139
                                    },
                                    __self: this,
                                    children: /*#__PURE__*/ _jsxRuntime.jsx(_buttonDefault.default, {
                                        variant: "contained",
                                        color: "primary",
                                        onClick: accept,
                                        __source: {
                                            fileName: "src/ui-components/UIChat.tsx",
                                            lineNumber: 140
                                        },
                                        __self: this,
                                        children: "Accept"
                                    })
                                }),
                                /*#__PURE__*/ _jsxRuntime.jsx("div", {
                                    className: "w3-container w3-half w3-padding",
                                    __source: {
                                        fileName: "src/ui-components/UIChat.tsx",
                                        lineNumber: 144
                                    },
                                    __self: this,
                                    children: /*#__PURE__*/ _jsxRuntime.jsx(_buttonDefault.default, {
                                        variant: "contained",
                                        color: "secondary",
                                        onClick: reject,
                                        __source: {
                                            fileName: "src/ui-components/UIChat.tsx",
                                            lineNumber: 145
                                        },
                                        __self: this,
                                        children: "Reject"
                                    })
                                })
                            ]
                        })
                    ]
                })
            }),
            messageBox !== null && /*#__PURE__*/ _jsxRuntime.jsx("div", {
                className: "w3-overlay w3-show",
                __source: {
                    fileName: "src/ui-components/UIChat.tsx",
                    lineNumber: 154
                },
                __self: this,
                children: /*#__PURE__*/ _jsxRuntime.jsxs("div", {
                    className: "w3-panel 2-card w3-white w3-auto w3-display-middle",
                    __source: {
                        fileName: "src/ui-components/UIChat.tsx",
                        lineNumber: 155
                    },
                    __self: this,
                    children: [
                        /*#__PURE__*/ _jsxRuntime.jsx("div", {
                            className: "w3-row w3-padding",
                            __source: {
                                fileName: "src/ui-components/UIChat.tsx",
                                lineNumber: 156
                            },
                            __self: this,
                            children: messageBox
                        }),
                        /*#__PURE__*/ _jsxRuntime.jsx("div", {
                            className: "w3-row w3-padding",
                            __source: {
                                fileName: "src/ui-components/UIChat.tsx",
                                lineNumber: 159
                            },
                            __self: this,
                            children: /*#__PURE__*/ _jsxRuntime.jsx("div", {
                                className: "w3-container",
                                __source: {
                                    fileName: "src/ui-components/UIChat.tsx",
                                    lineNumber: 160
                                },
                                __self: this,
                                children: /*#__PURE__*/ _jsxRuntime.jsx(_buttonDefault.default, {
                                    variant: "contained",
                                    color: "primary",
                                    onClick: ()=>{
                                        setMessageBox(null);
                                    },
                                    __source: {
                                        fileName: "src/ui-components/UIChat.tsx",
                                        lineNumber: 161
                                    },
                                    __self: this,
                                    children: "Ok"
                                })
                            })
                        })
                    ]
                })
            })
        ]
    }));
}
exports.default = UIChat;
_s(UIChat, "cx3EB2l8ir28csaEMsg4+/Z7YGQ=");
_c = UIChat;
var _c;
$RefreshReg$(_c, "UIChat");

  $parcel$ReactRefreshHelpers$ad84.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
},{"react/jsx-runtime":"5F5p8","react":"cKM0D","@material-ui/core/TextField":"khQAh","@material-ui/core/Button":"lEQJw","./UIChat_style.css":"hAcbh","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7","@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js":"jOwmj"}],"hAcbh":[function() {},{}],"c4E5M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// this script is the bridge between our tsx-frontend and good old fashioned js-game
parcelHelpers.export(exports, "startGame", ()=>startGame
);
var _melonjs = require("melonjs");
var _melonjsDefault = parcelHelpers.interopDefault(_melonjs);
var _game = require("./game");
var _gameDefault = parcelHelpers.interopDefault(_game);
var _resources = require("./resources");
var _resourcesDefault = parcelHelpers.interopDefault(_resources);
var _title = require("./screens/title");
var _titleDefault = parcelHelpers.interopDefault(_title);
var _play = require("./screens/play");
var _playDefault = parcelHelpers.interopDefault(_play);
var _enemies = require("./entities/enemies");
var _enemiesDefault = parcelHelpers.interopDefault(_enemies);
var _hero = require("./entities/hero");
var _heroDefault = parcelHelpers.interopDefault(_hero);
var _retep = require("./entities/retep");
var _retepDefault = parcelHelpers.interopDefault(_retep);
var _obstacles = require("./entities/obstacles");
var _obstaclesDefault = parcelHelpers.interopDefault(_obstacles);
var _goodies = require("./entities/goodies");
var _goodiesDefault = parcelHelpers.interopDefault(_goodies);
function startGame(startParams) {
    console.log(startParams);
    _gameDefault.default.setPlayerName(startParams.playerName);
    if (startParams.gameMode === 1) {
        _gameDefault.default.setMode("multiplayer");
        _gameDefault.default.setNetCom(startParams.netCommunicator);
    } else _gameDefault.default.setMode("singleplayer");
    _gameDefault.default.onload();
}

},{"melonjs":"dghKs","./game":"gQ0md","./resources":"hvrzO","./screens/title":"1HPyh","./screens/play":"kS1di","./entities/enemies":"9aMV9","./entities/hero":"asKw9","./entities/retep":"ghQWU","./entities/obstacles":"821Be","./entities/goodies":"8b08R","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"dghKs":[function(require,module,exports) {
var global = arguments[3];
(function() {
    /* eslint-disable no-undef */ (function(global1) {
        /**
      * (<b>m</b>)elonJS (<b>e</b>)ngine : All melonJS functions are defined inside
      * of this namespace.
      * <p>You generally should not add new properties to this namespace as it may be
      * overwritten in future versions.</p>
      * @name me
      * @namespace
      */ var me = {
        }; // support for AMD (Asynchronous Module Definition) libraries
        if (typeof define === "function" && define.amd) define([], function() {
            return {
                me: me
            };
        });
        else if (typeof exports !== "undefined") {
            // Support Node.js specific `module.exports` (which can be a function)
            if (typeof module !== "undefined" && module.exports) exports = module.exports = me;
             // CommonJS module 1.1.1 spec (`exports` cannot be a function)
            exports.me = me;
        } // in case AMD not available or unused
        if (typeof window !== "undefined") window.me = me;
        else if (typeof global1 !== "undefined") // Add to global in Node.js (for testing, etc).
        global1.me = me;
    })(window);
    /* eslint-enable no-undef */ /* eslint-disable no-global-assign, no-native-reassign */ (function() {
        if (typeof console === "undefined") /**
        * Dummy console.log to avoid crash
        * in case the browser does not support it
        * @ignore
        */ console = {
            log: function log() {
            },
            info: function info() {
            },
            error: function error() {
                alert(Array.prototype.slice.call(arguments).join(", "));
            }
        };
         // based on the requestAnimationFrame polyfill by Erik Möller
        (function() {
            var lastTime = 0;
            var vendors = [
                "ms",
                "moz",
                "webkit",
                "o"
            ];
            var x; // standardized functions
            // https://developer.mozilla.org/fr/docs/Web/API/Window/requestAnimationFrame
            var requestAnimationFrame = window.requestAnimationFrame;
            var cancelAnimationFrame = window.cancelAnimationFrame; // get prefixed rAF and cAF is standard one not supported
            for(x = 0; x < vendors.length && !requestAnimationFrame; ++x)requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
            for(x = 0; x < vendors.length && !cancelAnimationFrame; ++x)cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
            if (!requestAnimationFrame || !cancelAnimationFrame) {
                requestAnimationFrame = function requestAnimationFrame1(callback) {
                    var currTime = window.performance.now();
                    var timeToCall = Math.max(0, 1000 / me.timer.maxfps - (currTime - lastTime));
                    var id = window.setTimeout(function() {
                        callback(currTime + timeToCall);
                    }, timeToCall);
                    lastTime = currTime + timeToCall;
                    return id;
                };
                cancelAnimationFrame = function cancelAnimationFrame1(id) {
                    window.clearTimeout(id);
                }; // put back in global namespace
                window.requestAnimationFrame = requestAnimationFrame;
                window.cancelAnimationFrame = cancelAnimationFrame;
            }
        })();
    })();
    /* eslint-enable no-global-assign, no-native-reassign */ var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {
    };
    function createCommonjsModule(fn, basedir, module) {
        return module = {
            path: basedir,
            exports: {
            },
            require: function(path, base) {
                return commonjsRequire(path, base === undefined || base === null ? module.path : base);
            }
        }, fn(module, module.exports), module.exports;
    }
    function commonjsRequire() {
        throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }
    var jayExtend = createCommonjsModule(function(module) {
        /**
    * Extend a class prototype with the provided mixin descriptors.
    * Designed as a faster replacement for John Resig's Simple Inheritance.
    * @name extend
    * @memberOf Jay
    * @function
    * @param {Object[]} mixins... Each mixin is a dictionary of functions, or a
    * previously extended class whose methods will be applied to the target class
    * prototype.
    * @return {Object}
    * @example
    * var Person = Jay.extend({
    *     "init" : function (isDancing) {
    *         this.dancing = isDancing;
    *     },
    *     "dance" : function () {
    *         return this.dancing;
    *     }
    * });
    *
    * var Ninja = Person.extend({
    *     "init" : function () {
    *         // Call the super constructor, passing a single argument
    *         this._super(Person, "init", [false]);
    *     },
    *     "dance" : function () {
    *         // Call the overridden dance() method
    *         return this._super(Person, "dance");
    *     },
    *     "swingSword" : function () {
    *         return true;
    *     }
    * });
    *
    * var Pirate = Person.extend(Ninja, {
    *     "init" : function () {
    *         // Call the super constructor, passing a single argument
    *         this._super(Person, "init", [true]);
    *     }
    * });
    *
    * var p = new Person(true);
    * console.log(p.dance()); // => true
    *
    * var n = new Ninja();
    * console.log(n.dance()); // => false
    * console.log(n.swingSword()); // => true
    *
    * var r = new Pirate();
    * console.log(r.dance()); // => true
    * console.log(r.swingSword()); // => true
    *
    * console.log(
    *     p instanceof Person &&
    *     n instanceof Ninja &&
    *     n instanceof Person &&
    *     r instanceof Pirate &&
    *     r instanceof Person
    * ); // => true
    *
    * console.log(r instanceof Ninja); // => false
    */ (function() {
            function extend() {
                var methods = {
                };
                var mixins = new Array(arguments.length);
                for(var i = 0; i < arguments.length; i++)mixins.push(arguments[i]);
                /**
            * The class constructor which calls the user `init` constructor.
            * @ignore
            */ function Class() {
                    // Call the user constructor
                    this.init.apply(this, arguments);
                    return this;
                }
                // Apply superClass
                Class.prototype = Object.create(this.prototype);
                // Apply all mixin methods to the class prototype
                mixins.forEach(function(mixin) {
                    apply_methods(Class, methods, mixin.__methods__ || mixin);
                });
                // Verify constructor exists
                if (!("init" in Class.prototype)) throw new TypeError("extend: Class is missing a constructor named `init`");
                // Apply syntactic sugar for accessing methods on super classes
                Object.defineProperty(Class.prototype, "_super", {
                    "value": _super
                });
                // Create a hidden property on the class itself
                // List of methods, used for applying classes as mixins
                Object.defineProperty(Class, "__methods__", {
                    "value": methods
                });
                // Make this class extendable
                Class.extend = extend;
                return Class;
            }
            /**
        * Apply methods to the class prototype.
        * @ignore
        */ function apply_methods(Class, methods, descriptor) {
                Object.keys(descriptor).forEach(function(method) {
                    methods[method] = descriptor[method];
                    if (typeof descriptor[method] !== "function") throw new TypeError("extend: Method `" + method + "` is not a function");
                    Object.defineProperty(Class.prototype, method, {
                        "configurable": true,
                        "value": descriptor[method]
                    });
                });
            }
            /**
        * Special method that acts as a proxy to the super class.
        * @name _super
        * @ignore
        */ function _super(superClass, method, args) {
                return superClass.prototype[method].apply(this, args);
            }
            /**
        * The base class from which all jay-extend classes inherit.
        * @ignore
        */ var Jay = function() {
                Object.apply(this, arguments);
            };
            Jay.prototype = Object.create(Object.prototype);
            Jay.prototype.constructor = Jay;
            Object.defineProperty(Jay, "extend", {
                "value": extend
            });
            /**
        * Export the extend method.
        * @ignore
        */ if (typeof window !== "undefined") window.Jay = Jay;
            else module.exports = Jay;
        })();
    });
    /**
    * The base class from which all melonJS objects inherit.
    * See: {@link https://github.com/parasyte/jay-extend}
    * @class
    * @memberOf me
    */ me.Object = window.Jay;
    (function() {
        /**
      * A collection of utilities to ease porting between different user agents.
      * @namespace me.agent
      * @memberOf me
      */ me.agent = (function() {
            var api = {
            };
            /**
        * Known agent vendors
        * @ignore
        */ var vendors = [
                "ms",
                "MS",
                "moz",
                "webkit",
                "o"
            ];
            /**
        * Get a vendor-prefixed property
        * @public
        * @name prefixed
        * @function
        * @param {String} name Property name
        * @param {Object} [obj=window] Object or element reference to access
        * @return {Mixed} Value of property
        * @memberOf me.agent
        */ api.prefixed = function(name, obj) {
                obj = obj || window;
                if (name in obj) return obj[name];
                var uc_name = me.utils.string.capitalize(name);
                var result;
                vendors.some(function(vendor) {
                    var name1 = vendor + uc_name;
                    return result = name1 in obj ? obj[name1] : undefined;
                });
                return result;
            };
            /**
        * Set a vendor-prefixed property
        * @public
        * @name setPrefixed
        * @function
        * @param {String} name Property name
        * @param {Mixed} value Property value
        * @param {Object} [obj=window] Object or element reference to access
        * @return true if one of the vendor-prefixed property was found
        * @memberOf me.agent
        */ api.setPrefixed = function(name, value, obj) {
                obj = obj || window;
                if (name in obj) {
                    obj[name] = value;
                    return;
                }
                var uc_name = me.utils.string.capitalize(name);
                vendors.some(function(vendor) {
                    var name1 = vendor + uc_name;
                    if (name1 in obj) {
                        obj[name1] = value;
                        return true;
                    }
                    return false;
                });
            };
            return api;
        })();
    })();
    function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function(obj1) {
            return typeof obj1;
        };
        else _typeof = function(obj1) {
            return obj1 && typeof Symbol === "function" && obj1.constructor === Symbol && obj1 !== Symbol.prototype ? "symbol" : typeof obj1;
        };
        return _typeof(obj);
    }
    function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                if (it) o = it;
                var i = 0;
                var F = function() {
                };
                return {
                    s: F,
                    n: function() {
                        if (i >= o.length) return {
                            done: true
                        };
                        return {
                            done: false,
                            value: o[i++]
                        };
                    },
                    e: function(e) {
                        throw e;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return {
            s: function() {
                it = o[Symbol.iterator]();
            },
            n: function() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
            },
            e: function(e) {
                didErr = true;
                err = e;
            },
            f: function() {
                try {
                    if (!normalCompletion && it.return != null) it.return();
                } finally{
                    if (didErr) throw err;
                }
            }
        };
    }
    (function() {
        /**
      * A singleton object representing the device capabilities and specific events
      * @namespace me.device
      * @memberOf me
      */ me.device = (function() {
            // defines object for holding public information/functionality.
            var api = {
            }; // private properties
            var accelInitialized = false;
            var deviceOrientationInitialized = false; // swipe utility fn & flag
            var swipeEnabled = true;
            var disableSwipeFn = function disableSwipeFn1(e) {
                e.preventDefault();
                if (typeof window.scroll === "function") window.scroll(0, 0);
                return false;
            };
            /*
        * DOM loading stuff
        */ var readyBound = false, isReady = false, readyList = [];
            /**
        * called to check if the device is ready
        * @ignore
        */ api._domReady = function(fn) {
                // Make sure that the DOM is not already loaded
                if (!isReady) {
                    // be sure document.body is there
                    if (!document.body) return setTimeout(me.device._domReady, 13);
                     // clean up loading event
                    if (document.removeEventListener) document.removeEventListener("DOMContentLoaded", me.device._domReady, false);
                     // remove the event on window.onload (always added in `onReady`)
                    window.removeEventListener("load", me.device._domReady, false); // execute all callbacks
                    while(readyList.length)readyList.shift().call(window, []);
                     // Remember that the DOM is ready
                    isReady = true;
                }
            }; // a cache DOMRect object
            var _domRect = {
                left: 0,
                top: 0,
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                right: 0,
                bottom: 0
            };
            /**
        * check the device capapbilities
        * @ignore
        */ api._check = function() {
                // detect device type/platform
                me.device._detectDevice(); // Mobile browser hacks
                if (me.device.isMobile) // Prevent the webview from moving on a swipe
                api.enableSwipe(false);
                 // Touch/Gesture Event feature detection
                me.device.TouchEvent = !!("ontouchstart" in window);
                me.device.PointerEvent = !!window.PointerEvent;
                window.gesture = me.agent.prefixed("gesture"); // detect touch capabilities
                me.device.touch = me.device.TouchEvent || me.device.PointerEvent; // max amount of touch points ; always at least return 1 (e.g. headless chrome will return 0)
                me.device.maxTouchPoints = me.device.touch ? me.device.PointerEvent ? navigator.maxTouchPoints || 1 : 10 : 1; // detect wheel event support
                // Modern browsers support "wheel", Webkit and IE support at least "mousewheel
                me.device.wheel = "onwheel" in document.createElement("div"); // pointerlock detection
                this.hasPointerLockSupport = me.agent.prefixed("pointerLockElement", document);
                if (this.hasPointerLockSupport) document.exitPointerLock = me.agent.prefixed("exitPointerLock", document);
                 // device orientation and motion detection
                me.device.hasDeviceOrientation = !!window.DeviceOrientationEvent;
                me.device.hasAccelerometer = !!window.DeviceMotionEvent; // fullscreen api detection & polyfill when possible
                this.hasFullscreenSupport = me.agent.prefixed("fullscreenEnabled", document) || document.mozFullScreenEnabled;
                document.exitFullscreen = me.agent.prefixed("cancelFullScreen", document) || me.agent.prefixed("exitFullscreen", document); // vibration API poyfill
                navigator.vibrate = me.agent.prefixed("vibrate", navigator); // web Audio detection
                this.hasWebAudio = !!(window.AudioContext || window.webkitAudioContext);
                try {
                    api.localStorage = !!window.localStorage;
                } catch (e) {
                    // the above generates an exception when cookies are blocked
                    api.localStorage = false;
                } // set pause/stop action on losing focus
                window.addEventListener("blur", function() {
                    if (me.sys.stopOnBlur) me.state.stop(true);
                    if (me.sys.pauseOnBlur) me.state.pause(true);
                }, false); // set restart/resume action on gaining focus
                window.addEventListener("focus", function() {
                    if (me.sys.stopOnBlur) me.state.restart(true);
                    if (me.sys.resumeOnFocus) me.state.resume(true);
                     // force focus if autofocus is on
                    if (me.sys.autoFocus) me.device.focus();
                }, false); // Set the name of the hidden property and the change event for visibility
                var hidden, visibilityChange;
                if (typeof document.hidden !== "undefined") {
                    // Opera 12.10 and Firefox 18 and later support
                    hidden = "hidden";
                    visibilityChange = "visibilitychange";
                } else if (typeof document.mozHidden !== "undefined") {
                    hidden = "mozHidden";
                    visibilityChange = "mozvisibilitychange";
                } else if (typeof document.msHidden !== "undefined") {
                    hidden = "msHidden";
                    visibilityChange = "msvisibilitychange";
                } else if (typeof document.webkitHidden !== "undefined") {
                    hidden = "webkitHidden";
                    visibilityChange = "webkitvisibilitychange";
                } // register on the event if supported
                if (typeof visibilityChange === "string") // add the corresponding event listener
                document.addEventListener(visibilityChange, function() {
                    if (document[hidden]) {
                        if (me.sys.stopOnBlur) me.state.stop(true);
                        if (me.sys.pauseOnBlur) me.state.pause(true);
                    } else {
                        if (me.sys.stopOnBlur) me.state.restart(true);
                        if (me.sys.resumeOnFocus) me.state.resume(true);
                    }
                }, false);
            };
            /**
        * detect the device type
        * @ignore
        */ api._detectDevice = function() {
                // iOS Device ?
                me.device.iOS = /iPhone|iPad|iPod/i.test(me.device.ua); // Android Device ?
                me.device.android = /Android/i.test(me.device.ua);
                me.device.android2 = /Android 2/i.test(me.device.ua); // Linux platform
                me.device.linux = /Linux/i.test(me.device.ua); // Chrome OS ?
                me.device.chromeOS = /CrOS/.test(me.device.ua); // Windows Device ?
                me.device.wp = /Windows Phone/i.test(me.device.ua); // Blackberry device ?
                me.device.BlackBerry = /BlackBerry/i.test(me.device.ua); // Kindle device ?
                me.device.Kindle = /Kindle|Silk.*Mobile Safari/i.test(me.device.ua); // Mobile platform
                me.device.isMobile = /Mobi/i.test(me.device.ua) || me.device.iOS || me.device.android || me.device.wp || me.device.BlackBerry || me.device.Kindle || false; // ejecta
                me.device.ejecta = typeof window.ejecta !== "undefined"; // Wechat
                me.device.isWeixin = /MicroMessenger/i.test(me.device.ua);
            };
            /*
        * PUBLIC Properties & Functions
        */ // Browser capabilities
            /**
        * the `ua` read-only property returns the user agent string for the current browser.
        * @type String
        * @readonly
        * @name ua
        * @memberOf me.device
        */ api.ua = navigator.userAgent;
            /**
        * Browser Local Storage capabilities <br>
        * (this flag will be set to false if cookies are blocked)
        * @type Boolean
        * @readonly
        * @name localStorage
        * @memberOf me.device
        */ api.localStorage = false;
            /**
        * Browser accelerometer capabilities
        * @type Boolean
        * @readonly
        * @name hasAccelerometer
        * @memberOf me.device
        */ api.hasAccelerometer = false;
            /**
        * Browser device orientation
        * @type Boolean
        * @readonly
        * @name hasDeviceOrientation
        * @memberOf me.device
        */ api.hasDeviceOrientation = false;
            /**
        * Browser full screen support
        * @type Boolean
        * @readonly
        * @name hasFullscreenSupport
        * @memberOf me.device
        */ api.hasFullscreenSupport = false;
            /**
       * Browser pointerlock api support
       * @type Boolean
       * @readonly
       * @name hasPointerLockSupport
       * @memberOf me.device
       */ api.hasPointerLockSupport = false;
            /**
       * Device WebAudio Support
       * @type Boolean
       * @readonly
       * @name hasWebAudio
       * @memberOf me.device
       */ api.hasWebAudio = false;
            /**
        * Browser Base64 decoding capability
        * @type Boolean
        * @readonly
        * @name nativeBase64
        * @memberOf me.device
        */ api.nativeBase64 = typeof window.atob === "function";
            /**
        * Return the maximum number of simultaneous touch contact points are supported by the current device.
        * @type Number
        * @readonly
        * @name maxTouchPoints
        * @memberOf me.device
        * @example
        * if (me.device.maxTouchPoints > 1) {
        *     // device supports multi-touch
        * }
        */ api.maxTouchPoints = 1;
            /**
        * Touch capabilities
        * @type Boolean
        * @readonly
        * @name touch
        * @memberOf me.device
        */ api.touch = false;
            /**
        * W3C standard wheel events
        * @type Boolean
        * @readonly
        * @name wheel
        * @memberOf me.device
        */ api.wheel = false;
            /**
        * equals to true if a mobile device <br>
        * (Android | iPhone | iPad | iPod | BlackBerry | Windows Phone | Kindle)
        * @type Boolean
        * @readonly
        * @name isMobile
        * @memberOf me.device
        */ api.isMobile = false;
            /**
        * equals to true if the device is an iOS platform.
        * @type Boolean
        * @readonly
        * @name iOS
        * @memberOf me.device
        */ api.iOS = false;
            /**
        * equals to true if the device is an Android platform.
        * @type Boolean
        * @readonly
        * @name android
        * @memberOf me.device
        */ api.android = false;
            /**
        * equals to true if the device is an Android 2.x platform.
        * @type Boolean
        * @readonly
        * @name android2
        * @memberOf me.device
        */ api.android2 = false;
            /**
        * equals to true if the device is a Linux platform.
        * @type Boolean
        * @readonly
        * @name linux
        * @memberOf me.device
        */ api.linux = false;
            /**
        * equals to true if the game is running under Ejecta.
        * @type Boolean
        * @readonly
        * @see http://impactjs.com/ejecta
        * @name ejecta
        * @memberOf me.device
        */ api.ejecta = false;
            /**
        * equals to true if the game is running under Wechat.
        * @type Boolean
        * @readonly
        * @name isWeixin
        * @memberOf me.device
        */ api.isWeixin = false;
            /**
        * equals to true if the device is running on ChromeOS.
        * @type Boolean
        * @readonly
        * @name chromeOS
        * @memberOf me.device
        */ api.chromeOS = false;
            /**
       * equals to true if the device is a Windows Phone platform.
       * @type Boolean
       * @readonly
       * @name wp
       * @memberOf me.device
       */ api.wp = false;
            /**
        * equals to true if the device is a BlackBerry platform.
        * @type Boolean
        * @readonly
        * @name BlackBerry
        * @memberOf me.device
        */ api.BlackBerry = false;
            /**
        * equals to true if the device is a Kindle platform.
        * @type Boolean
        * @readonly
        * @name Kindle
        * @memberOf me.device
        */ api.Kindle = false;
            /**
        * contains the g-force acceleration along the x-axis.
        * @public
        * @type Number
        * @readonly
        * @name accelerationX
        * @see me.device.watchAccelerometer
        * @memberOf me.device
        */ api.accelerationX = 0;
            /**
        * contains the g-force acceleration along the y-axis.
        * @public
        * @type Number
        * @readonly
        * @name accelerationY
        * @see me.device.watchAccelerometer
        * @memberOf me.device
        */ api.accelerationY = 0;
            /**
        * contains the g-force acceleration along the z-axis.
        * @public
        * @type Number
        * @readonly
        * @name accelerationZ
        * @see me.device.watchAccelerometer
        * @memberOf me.device
        */ api.accelerationZ = 0;
            /**
        * Device orientation Gamma property. Gives angle on tilting a portrait held phone left or right
        * @public
        * @type Number
        * @readonly
        * @name gamma
        * @see me.device.watchDeviceOrientation
        * @memberOf me.device
        */ api.gamma = 0;
            /**
        * Device orientation Beta property. Gives angle on tilting a portrait held phone forward or backward
        * @public
        * @type Number
        * @readonly
        * @name beta
        * @see me.device.watchDeviceOrientation
        * @memberOf me.device
        */ api.beta = 0;
            /**
        * Device orientation Alpha property. Gives angle based on the rotation of the phone around its z axis.
        * The z-axis is perpendicular to the phone, facing out from the center of the screen.
        * @public
        * @type Number
        * @readonly
        * @name alpha
        * @see me.device.watchDeviceOrientation
        * @memberOf me.device
        */ api.alpha = 0;
            /**
        * a string representing the preferred language of the user, usually the language of the browser UI.
        * (will default to "en" if the information is not available)
        * @public
        * @type String
        * @readonly
        * @see http://www.w3schools.com/tags/ref_language_codes.asp
        * @name language
        * @memberOf me.device
        */ api.language = navigator.language || navigator.browserLanguage || navigator.userLanguage || "en";
            /**
        * equals to true if the device browser supports OffScreenCanvas.
        * @type Boolean
        * @readonly
        * @name OffScreenCanvas
        * @memberOf me.device
        */ try {
                // some browser (e.g. Safari) implements WebGL1 and WebGL2 contexts only
                // https://bugzilla.mozilla.org/show_bug.cgi?id=801176
                api.OffscreenCanvas = typeof window.OffscreenCanvas !== "undefined" && new OffscreenCanvas(0, 0).getContext("2d") !== null;
            } catch (e) {
                api.OffscreenCanvas = false;
            }
            /**
         * specify a function to execute when the Device is fully loaded and ready
         * @name onReady
         * @memberOf me.device
         * @function
         * @param {Function} fn the function to be executed
         * @example
         * // small game skeleton
         * var game = {
         *    // called by the me.device.onReady function
         *    onload : function () {
         *       // init video
         *       if (!me.video.init('screen', 640, 480, true)) {
         *          alert("Sorry but your browser does not support html 5 canvas.");
         *          return;
         *       }
         *
         *       // initialize the "audio"
         *       me.audio.init("mp3,ogg");
         *
         *       // set callback for ressources loaded event
         *       me.loader.onload = this.loaded.bind(this);
         *
         *       // set all ressources to be loaded
         *       me.loader.preload(game.assets);
         *
         *       // load everything & display a loading screen
         *       me.state.change(me.state.LOADING);
         *    },
         *
         *    // callback when everything is loaded
         *    loaded : function () {
         *       // define stuff
         *       // ....
         *
         *       // change to the menu screen
         *       me.state.change(me.state.PLAY);
         *    }
         * }; // game
         *
         * // "bootstrap"
         * me.device.onReady(function () {
         *    game.onload();
         * });
         */ api.onReady = function(fn) {
                // If the DOM is already ready
                if (isReady) // Execute the function immediately
                fn.call(window, []);
                else {
                    // Add the function to the wait list
                    readyList.push(fn); // attach listeners if not yet done
                    if (!readyBound) {
                        // directly call domReady if document is already "ready"
                        if (document.readyState === "complete") // defer the fn call to ensure our script is fully loaded
                        window.setTimeout(me.device._domReady, 0);
                        else {
                            if (document.addEventListener) // Use the handy event callback
                            document.addEventListener("DOMContentLoaded", me.device._domReady, false);
                             // A fallback to window.onload, that will always work
                            window.addEventListener("load", me.device._domReady, false);
                        }
                        readyBound = true;
                    }
                }
            };
            /**
        * enable/disable swipe on WebView.
        * @name enableSwipe
        * @memberOf me.device
        * @function
        * @param {boolean} [enable=true] enable or disable swipe.
        */ api.enableSwipe = function(enable) {
                if (enable !== false) {
                    if (swipeEnabled === false) {
                        window.document.removeEventListener("touchmove", disableSwipeFn, false);
                        swipeEnabled = true;
                    }
                } else if (swipeEnabled === true) {
                    window.document.addEventListener("touchmove", disableSwipeFn, false);
                    swipeEnabled = false;
                }
            };
            /**
        * Triggers a fullscreen request. Requires fullscreen support from the browser/device.
        * @name requestFullscreen
        * @memberOf me.device
        * @function
        * @param {Object} [element=default canvas object] the element to be set in full-screen mode.
        * @example
        * // add a keyboard shortcut to toggle Fullscreen mode on/off
        * me.input.bindKey(me.input.KEY.F, "toggleFullscreen");
        * me.event.subscribe(me.event.KEYDOWN, function (action, keyCode, edge) {
        *    // toggle fullscreen on/off
        *    if (action === "toggleFullscreen") {
        *       if (!me.device.isFullscreen) {
        *          me.device.requestFullscreen();
        *       } else {
        *          me.device.exitFullscreen();
        *       }
        *    }
        * });
        */ api.requestFullscreen = function(element) {
                if (this.hasFullscreenSupport) {
                    element = element || me.video.getParent();
                    element.requestFullscreen = me.agent.prefixed("requestFullscreen", element) || element.mozRequestFullScreen;
                    element.requestFullscreen();
                }
            };
            /**
        * Exit fullscreen mode. Requires fullscreen support from the browser/device.
        * @name exitFullscreen
        * @memberOf me.device
        * @function
        */ api.exitFullscreen = function() {
                if (this.hasFullscreenSupport) document.exitFullscreen();
            };
            /**
        * Return a string representing the orientation of the device screen.
        * It can be "any", "natural", "landscape", "portrait", "portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary"
        * @name getScreenOrientation
        * @memberOf me.device
        * @see https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation
        * @function
        * @return {String} the screen orientation
        */ api.getScreenOrientation = function() {
                var PORTRAIT = "portrait";
                var LANDSCAPE = "landscape";
                var screen = window.screen; // first try using "standard" values
                if (typeof screen !== "undefined") {
                    var orientation = me.agent.prefixed("orientation", screen);
                    if (typeof orientation !== "undefined" && typeof orientation.type === "string") // Screen Orientation API specification
                    return orientation.type;
                    else if (typeof orientation === "string") // moz/ms-orientation are strings
                    return orientation;
                } // check using the deprecated API
                if (typeof window.orientation === "number") return Math.abs(window.orientation) === 90 ? LANDSCAPE : PORTRAIT;
                 // fallback to window size check
                return window.outerWidth > window.outerHeight ? LANDSCAPE : PORTRAIT;
            };
            /**
        * locks the device screen into the specified orientation.<br>
        * This method only works for installed Web apps or for Web pages in full-screen mode.
        * @name lockOrientation
        * @memberOf me.device
        * @see https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation
        * @function
        * @return {Boolean} true if the orientation was unsuccessfully locked
        */ api.lockOrientation = function(orientation) {
                var screen = window.screen;
                if (typeof screen !== "undefined") {
                    var lockOrientation = me.agent.prefixed("lockOrientation", screen);
                    if (typeof lockOrientation !== "undefined") return lockOrientation(orientation);
                }
                return false;
            };
            /**
        * unlocks the device screen into the specified orientation.<br>
        * This method only works for installed Web apps or for Web pages in full-screen mode.
        * @name unlockOrientation
        * @memberOf me.device
        * @see https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation
        * @function
        * @return {Boolean} true if the orientation was unsuccessfully unlocked
        */ api.unlockOrientation = function(orientation) {
                var screen = window.screen;
                if (typeof screen !== "undefined") {
                    var unlockOrientation = me.agent.prefixed("unlockOrientation", screen);
                    if (typeof unlockOrientation !== "undefined") return unlockOrientation(orientation);
                }
                return false;
            };
            /**
        * return true if the device screen orientation is in Portrait mode
        * @name isPortrait
        * @memberOf me.device
        * @function
        * @return {Boolean}
        */ api.isPortrait = function() {
                return me.device.getScreenOrientation().includes("portrait");
            };
            /**
        * return true if the device screen orientation is in Portrait mode
        * @name isLandscape
        * @memberOf me.device
        * @function
        * @return {Boolean}
        */ api.isLandscape = function() {
                return me.device.getScreenOrientation().includes("landscape");
            };
            /**
        * return the device storage
        * @name getStorage
        * @memberOf me.device
        * @function
        * @param {String} [type="local"]
        * @return me.save object
        */ api.getStorage = function(type) {
                type = type || "local";
                switch(type){
                    case "local":
                        return me.save;
                    default:
                        throw new Error("storage type " + type + " not supported");
                }
            };
            /**
        * return the parent DOM element for the given parent name or HTMLElement object
        * @name getParentElement
        * @memberOf me.device
        * @function
        * @param {String|HTMLElement} element the parent element name or a HTMLElement object
        * @return {HTMLElement} the parent Element
        */ api.getParentElement = function(element) {
                var target = me.device.getElement(element);
                if (target.parentNode !== null) target = target.parentNode;
                return target;
            };
            /**
        * return the DOM element for the given element name or HTMLElement object
        * @name getElement
        * @memberOf me.device
        * @function
        * @param {String|HTMLElement} element the parent element name or a HTMLElement object
        * @return {HTMLElement} the corresponding DOM Element or null if not existing
        */ api.getElement = function(element) {
                var target = null;
                if (element !== "undefined") {
                    if (typeof element === "string") target = document.getElementById(element);
                    else if (_typeof(element) === "object" && element.nodeType === Node.ELEMENT_NODE) target = element;
                } // fallback, if invalid target or non HTMLElement object
                if (!target) //default to document.body
                target = document.body;
                return target;
            };
            /**
        * returns the size of the given HTMLElement and its position relative to the viewport
        * <br><img src="images/element-box-diagram.png"/>
        * @name getElementBounds
        * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMRect
        * @memberOf me.device
        * @function
        * @param {String|HTMLElement} element an HTMLElement object
        * @return {DOMRect} the size and position of the element relatively to the viewport
        */ api.getElementBounds = function(element) {
                if (_typeof(element) === "object" && element !== document.body && typeof element.getBoundingClientRect !== "undefined") return element.getBoundingClientRect();
                else {
                    _domRect.width = _domRect.right = window.innerWidth;
                    _domRect.height = _domRect.bottom = window.innerHeight;
                    return _domRect;
                }
            };
            /**
        * returns the size of the given HTMLElement Parent and its position relative to the viewport
        * <br><img src="images/element-box-diagram.png"/>
        * @name getParentBounds
        * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMRect
        * @memberOf me.device
        * @function
        * @param {String|HTMLElement} element an HTMLElement object
        * @return {DOMRect} the size and position of the given element parent relative to the viewport
        */ api.getParentBounds = function(element) {
                return me.device.getElementBounds(me.device.getParentElement(element));
            };
            /**
        * returns true if the device supports WebGL
        * @name isWebGLSupported
        * @memberOf me.device
        * @function
        * @param {Object} [options] context creation options
        * @param {Boolean} [options.failIfMajorPerformanceCaveat=true] If true, the renderer will switch to CANVAS mode if the performances of a WebGL context would be dramatically lower than that of a native application making equivalent OpenGL calls.
        * @return {Boolean} true if WebGL is supported
        */ api.isWebGLSupported = function(options) {
                try {
                    var canvas = document.createElement("canvas");
                    var ctxOptions = {
                        stencil: true,
                        failIfMajorPerformanceCaveat: options.failIfMajorPerformanceCaveat
                    };
                    return !!(window.WebGLRenderingContext && (canvas.getContext("webgl", ctxOptions) || canvas.getContext("experimental-webgl", ctxOptions)));
                } catch (e) {
                    return false;
                }
            }, /**
        * return the highest precision format supported by this device for GL Shaders
        * @name getMaxShaderPrecision
        * @memberOf me.device
        * @function
        * @param {WebGLRenderingContext} gl
        * @return {Boolean} "lowp", "mediump", or "highp"
        */ api.getMaxShaderPrecision = function(gl) {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) return "highp";
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) return "mediump";
                return "lowp";
            };
            /**
        * Makes a request to bring this device window to the front.
        * @name focus
        * @memberOf me.device
        * @function
        * @example
        *  if (clicked) {
        *    me.device.focus();
        *  }
        */ api.focus = function() {
                if (typeof window.focus === "function") window.focus();
            };
            /**
        * event management (Accelerometer)
        * http://www.mobilexweb.com/samples/ball.html
        * http://www.mobilexweb.com/blog/safari-ios-accelerometer-websockets-html5
        * @ignore
        */ function onDeviceMotion(e) {
                // Accelerometer information
                api.accelerationX = e.accelerationIncludingGravity.x;
                api.accelerationY = e.accelerationIncludingGravity.y;
                api.accelerationZ = e.accelerationIncludingGravity.z;
            }
            function onDeviceRotate(e) {
                api.gamma = e.gamma;
                api.beta = e.beta;
                api.alpha = e.alpha;
            }
            /**
        * Enters pointer lock, requesting it from the user first. Works on supported devices & browsers
        * Must be called in a click event or an event that requires user interaction.
        * If you need to run handle events for errors or change of the pointer lock, see below.
        * @name turnOnPointerLock
        * @memberOf me.device
        * @function
        * @example
        * document.addEventListener("pointerlockchange", pointerlockchange, false);
        * document.addEventListener("mozpointerlockchange", pointerlockchange, false);
        * document.addEventListener("webkitpointerlockchange", pointerlockchange, false);
        *
        * document.addEventListener("pointerlockerror", pointerlockerror, false);
        * document.addEventListener("mozpointerlockerror", pointerlockerror, false);
        * document.addEventListener("webkitpointerlockerror", pointerlockerror, false);
        */ api.turnOnPointerLock = function() {
                if (this.hasPointerLockSupport) {
                    var element = me.video.getParent();
                    if (me.device.ua.match(/Firefox/i)) {
                        var fullscreenchange = function fullscreenchange1() {
                            if ((me.agent.prefixed("fullscreenElement", document) || document.mozFullScreenElement) === element) {
                                document.removeEventListener("fullscreenchange", fullscreenchange1);
                                document.removeEventListener("mozfullscreenchange", fullscreenchange1);
                                element.requestPointerLock = me.agent.prefixed("requestPointerLock", element);
                                element.requestPointerLock();
                            }
                        };
                        document.addEventListener("fullscreenchange", fullscreenchange, false);
                        document.addEventListener("mozfullscreenchange", fullscreenchange, false);
                        me.device.requestFullscreen();
                    } else element.requestPointerLock();
                }
            };
            /**
        * Exits pointer lock. Works on supported devices & browsers
        * @name turnOffPointerLock
        * @memberOf me.device
        * @function
        */ api.turnOffPointerLock = function() {
                if (this.hasPointerLockSupport) document.exitPointerLock();
            };
            /**
        * Enable monitor of the device accelerator to detect the amount of physical force of acceleration the device is receiving.
        * (one some device a first user gesture will be required before calling this function)
        * @name watchAccelerometer
        * @memberOf me.device
        * @public
        * @function
        * @see me.device.accelerationX
        * @see me.device.accelerationY
        * @see me.device.accelerationZ
        * @return {Boolean} false if not supported or permission not granted by the user
        * @example
        * // try to enable device accelerometer event on user gesture
        * me.input.registerPointerEvent("pointerleave", me.game.viewport, function() {
        *     if (me.device.watchAccelerometer() === true) {
        *         // Success
        *         me.input.releasePointerEvent("pointerleave", me.game.viewport);
        *     } else {
        *         // ... fail at enabling the device accelerometer event
        *     }
        * });
        */ api.watchAccelerometer = function() {
                if (me.device.hasAccelerometer && !accelInitialized) {
                    if (DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === "function") DeviceOrientationEvent.requestPermission().then(function(response) {
                        if (response === "granted") {
                            // add a listener for the devicemotion event
                            window.addEventListener("devicemotion", onDeviceMotion, false);
                            accelInitialized = true;
                        }
                    })["catch"](console.error);
                    else {
                        // add a listener for the devicemotion event
                        window.addEventListener("devicemotion", onDeviceMotion, false);
                        accelInitialized = true;
                    }
                }
                return accelInitialized;
            };
            /**
        * unwatch Accelerometor event
        * @name unwatchAccelerometer
        * @memberOf me.device
        * @public
        * @function
        */ api.unwatchAccelerometer = function() {
                if (accelInitialized) {
                    // remove the listener for the devicemotion event
                    window.removeEventListener("devicemotion", onDeviceMotion, false);
                    accelInitialized = false;
                }
            };
            /**
        * Enable monitor of the device orientation to detect the current orientation of the device as compared to the Earth coordinate frame.
        * (one some device a first user gesture will be required before calling this function)
        * @name watchDeviceOrientation
        * @memberOf me.device
        * @public
        * @function
        * @see me.device.alpha
        * @see me.device.beta
        * @see me.device.gamma
        * @return {Boolean} false if not supported or permission not granted by the user
        * @example
        * // try to enable device orientation event on user gesture
        * me.input.registerPointerEvent("pointerleave", me.game.viewport, function() {
        *     if (me.device.watchDeviceOrientation() === true) {
        *         // Success
        *         me.input.releasePointerEvent("pointerleave", me.game.viewport);
        *     } else {
        *         // ... fail at enabling the device orientation event
        *     }
        * });
        */ api.watchDeviceOrientation = function() {
                if (me.device.hasDeviceOrientation && !deviceOrientationInitialized) {
                    if (typeof DeviceOrientationEvent.requestPermission === "function") DeviceOrientationEvent.requestPermission().then(function(response) {
                        if (response === "granted") {
                            window.addEventListener("deviceorientation", onDeviceRotate, false);
                            deviceOrientationInitialized = true;
                        }
                    })["catch"](console.error);
                    else {
                        window.addEventListener("deviceorientation", onDeviceRotate, false);
                        deviceOrientationInitialized = true;
                    }
                }
                return deviceOrientationInitialized;
            };
            /**
        * unwatch Device orientation event
        * @name unwatchDeviceOrientation
        * @memberOf me.device
        * @public
        * @function
        */ api.unwatchDeviceOrientation = function() {
                if (deviceOrientationInitialized) {
                    window.removeEventListener("deviceorientation", onDeviceRotate, false);
                    deviceOrientationInitialized = false;
                }
            };
            /**
        * the vibrate method pulses the vibration hardware on the device, <br>
        * If the device doesn't support vibration, this method has no effect. <br>
        * If a vibration pattern is already in progress when this method is called,
        * the previous pattern is halted and the new one begins instead.
        * @name vibrate
        * @memberOf me.device
        * @public
        * @function
        * @param {Number|Number[]} pattern pattern of vibration and pause intervals
        * @example
        * // vibrate for 1000 ms
        * me.device.vibrate(1000);
        * // or alternatively
        * me.device.vibrate([1000]);
        * // vibrate for 50 ms, be still for 100 ms, and then vibrate for 150 ms:
        * me.device.vibrate([50, 100, 150]);
        * // cancel any existing vibrations
        * me.device.vibrate(0);
        */ api.vibrate = function(pattern) {
                if (navigator.vibrate) navigator.vibrate(pattern);
            };
            return api;
        })();
        /**
      * Ratio of the resolution in physical pixels to the resolution in CSS pixels for the current display device.
      * @name devicePixelRatio
      * @memberOf me.device
      * @public
      * @type Number
      * @readonly
      * @return {Number}
      */ Object.defineProperty(me.device, "devicePixelRatio", {
            /**
        * @ignore
        */ get: function get() {
                return window.devicePixelRatio || 1;
            }
        });
        /**
      * Returns true if the browser/device is in full screen mode.
      * @name isFullscreen
      * @memberOf me.device
      * @public
      * @type Boolean
      * @readonly
      * @return {boolean}
      */ Object.defineProperty(me.device, "isFullscreen", {
            /**
        * @ignore
        */ get: function get() {
                if (me.device.hasFullscreenSupport) return !!(me.agent.prefixed("fullscreenElement", document) || document.mozFullScreenElement);
                else return false;
            }
        });
        /**
      * Returns true if the browser/device has audio capabilities.
      * @name sound
      * @memberOf me.device
      * @public
      * @type Boolean
      * @readonly
      * @return {boolean}
      */ Object.defineProperty(me.device, "sound", {
            /**
        * @ignore
        */ get: function get() {
                return me.audio.hasAudio();
            }
        });
    })();
    var minpubsub_src = createCommonjsModule(function(module, exports) {
        /*!
    * MinPubSub
    * Copyright(c) 2011 Daniel Lamb <daniellmb.com>
    * MIT Licensed
    */ (function(context) {
            var MinPubSub = {
            };
            // the topic/subscription hash
            var cache = context.c_ || {
            }; //check for 'c_' cache for unit testing
            MinPubSub.publish = function(/* String */ topic, /* Array? */ args) {
                // summary: 
                //    Publish some data on a named topic.
                // topic: String
                //    The channel to publish on
                // args: Array?
                //    The data to publish. Each array item is converted into an ordered
                //    arguments on the subscribed functions. 
                //
                // example:
                //    Publish stuff on '/some/topic'. Anything subscribed will be called
                //    with a function signature like: function(a,b,c){ ... }
                //
                //    publish('/some/topic', ['a','b','c']);
                var subs = cache[topic], len = subs ? subs.length : 0;
                //can change loop or reverse array if the order matters
                while(len--)subs[len].apply(context, args || []);
            };
            MinPubSub.subscribe = function(/* String */ topic, /* Function */ callback) {
                // summary:
                //    Register a callback on a named topic.
                // topic: String
                //    The channel to subscribe to
                // callback: Function
                //    The handler event. Anytime something is publish'ed on a 
                //    subscribed channel, the callback will be called with the
                //    published array as ordered arguments.
                //
                // returns: Array
                //    A handle which can be used to unsubscribe this particular subscription.
                //        
                // example:
                //    subscribe('/some/topic', function(a, b, c){ /* handle data */ });
                if (!cache[topic]) cache[topic] = [];
                cache[topic].push(callback);
                return [
                    topic,
                    callback
                ]; // Array
            };
            MinPubSub.unsubscribe = function(/* Array */ handle, /* Function? */ callback) {
                // summary:
                //    Disconnect a subscribed function for a topic.
                // handle: Array
                //    The return value from a subscribe call.
                // example:
                //    var handle = subscribe('/some/topic', function(){});
                //    unsubscribe(handle);
                var subs = cache[callback ? handle : handle[0]], callback = callback || handle[1], len = subs ? subs.length : 0;
                while(len--)if (subs[len] === callback) subs.splice(len, 1);
            };
            // UMD definition to allow for CommonJS, AMD and legacy window
            if (module.exports) // CommonJS, just export
            module.exports = exports = MinPubSub;
            else if (typeof context === 'object') {
                // If no AMD and we are in the browser, attach to window
                context.publish = MinPubSub.publish;
                context.subscribe = MinPubSub.subscribe;
                context.unsubscribe = MinPubSub.unsubscribe;
            }
        })(commonjsGlobal.window);
    });
    // external import
    (function() {
        /**
      * an event system based on a micro publish/subscribe messaging framework
      * @namespace event
      * @memberOf me
      */ me.event = (function() {
            // hold public stuff inside the singleton
            var api = {
            };
            /*
        * PUBLIC
        */ /**
        * Channel Constant when the game is paused <br>
        * Data passed : none <br>
        * @public
        * @constant
        * @type String
        * @name STATE_PAUSE
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.STATE_PAUSE = "me.state.onPause";
            /**
        * Channel Constant for when the game is resumed <br>
        * Data passed : {Number} time in ms the game was paused
        * @public
        * @constant
        * @type String
        * @name STATE_RESUME
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.STATE_RESUME = "me.state.onResume";
            /**
        * Channel Constant when the game is stopped <br>
        * Data passed : none <br>
        * @public
        * @constant
        * @type String
        * @name STATE_STOP
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.STATE_STOP = "me.state.onStop";
            /**
        * Channel Constant for when the game is restarted <br>
        * Data passed : {Number} time in ms the game was stopped
        * @public
        * @constant
        * @type String
        * @name STATE_RESTART
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.STATE_RESTART = "me.state.onRestart";
            /**
        * Channel Constant for when the video is initialized<br>
        * Data passed : none <br>
        * @public
        * @constant
        * @type String
        * @name VIDEO_INIT
        * @memberOf me.event
        * @see me.video.init
        * @see me.event.subscribe
        */ api.VIDEO_INIT = "me.video.onInit";
            /**
        * Channel Constant for when the game manager is initialized <br>
        * Data passed : none <br>
        * @public
        * @constant
        * @type String
        * @name GAME_INIT
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.GAME_INIT = "me.game.onInit";
            /**
        * Channel Constant for when the game manager is resetted <br>
        * Data passed : none <br>
        * @public
        * @constant
        * @type String
        * @name GAME_RESET
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.GAME_RESET = "me.game.onReset";
            /**
        * Channel Constant for when the game manager is updated (start of the update loop) <br>
        * Data passed : {Number} time the current time stamp
        * @public
        * @constant
        * @type String
        * @name GAME_UPDATE
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.GAME_UPDATE = "me.game.onUpdate";
            /**
        * Channel Constant for when a level is loaded <br>
        * Data passed : {String} Level Name
        * @public
        * @constant
        * @type String
        * @name LEVEL_LOADED
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.LEVEL_LOADED = "me.game.onLevelLoaded";
            /**
        * Channel Constant for when everything has loaded <br>
        * Data passed : none <br>
        * @public
        * @constant
        * @type String
        * @name LOADER_COMPLETE
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.LOADER_COMPLETE = "me.loader.onload";
            /**
        * Channel Constant for displaying a load progress indicator <br>
        * Data passed : {Number} [0 .. 1], {Resource} resource object<br>
        * @public
        * @constant
        * @type String
        * @name LOADER_PROGRESS
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.LOADER_PROGRESS = "me.loader.onProgress";
            /**
        * Channel Constant for pressing a binded key <br>
        * Data passed : {String} user-defined action, {Number} keyCode,
        * {Boolean} edge state <br>
        * Edge-state is for detecting "locked" key bindings. When a locked key
        * is pressed and held, the first event will have the third argument
        * set true. Subsequent events will continue firing with the third
        * argument set false.
        * @public
        * @constant
        * @type String
        * @name KEYDOWN
        * @memberOf me.event
        * @see me.event.subscribe
        * @example
        * me.input.bindKey(me.input.KEY.X, "jump", true); // Edge-triggered
        * me.input.bindKey(me.input.KEY.Z, "shoot"); // Level-triggered
        * me.event.subscribe(me.event.KEYDOWN, function (action, keyCode, edge) {
        *   // Checking bound keys
        *   if (action === "jump") {
        *       if (edge) {
        *           this.doJump();
        *       }
        *
        *       // Make character fall slower when holding the jump key
        *       this.vel.y = this.body.gravity;
        *   }
        * });
        */ api.KEYDOWN = "me.input.keydown";
            /**
        * Channel Constant for releasing a binded key <br>
        * Data passed : {String} user-defined action, {Number} keyCode
        * @public
        * @constant
        * @type String
        * @name KEYUP
        * @memberOf me.event
        * @see me.event.subscribe
        * @example
        * me.event.subscribe(me.event.KEYUP, function (action, keyCode) {
        *   // Checking unbound keys
        *   if (keyCode == me.input.KEY.ESC) {
        *       if (me.state.isPaused()) {
        *           me.state.resume();
        *       }
        *       else {
        *           me.state.pause();
        *       }
        *   }
        * });
        */ api.KEYUP = "me.input.keyup";
            /**
        * Channel Constant for when a gamepad is connected <br>
        * Data passed : {Object} gamepad object
        * @public
        * @constant
        * @type String
        * @name GAMEPAD_CONNECTED
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.GAMEPAD_CONNECTED = "gamepad.connected";
            /**
        * Channel Constant for when a gamepad is disconnected <br>
        * Data passed : {Object} gamepad object
        * @public
        * @constant
        * @type String
        * @name GAMEPAD_DISCONNECTED
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.GAMEPAD_DISCONNECTED = "gamepad.disconnected";
            /**
        * Channel Constant for when gamepad button/axis state is updated <br>
        * Data passed : {Number} index <br>
        * Data passed : {String} type : "axes" or "buttons" <br>
        * Data passed : {Number} button <br>
        * Data passed : {Number} current.value <br>
        * Data passed : {Boolean} current.pressed
        * @public
        * @constant
        * @type String
        * @name GAMEPAD_UPDATE
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.GAMEPAD_UPDATE = "gamepad.update";
            /**
        * Channel Constant for pointermove events on the screen area <br>
        * Data passed : {me.Pointer} a Pointer object
        * @public
        * @constant
        * @type String
        * @name POINTERMOVE
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.POINTERMOVE = "me.event.pointermove";
            /**
        * Channel Constant for dragstart events on a Draggable entity <br>
        * Data passed:
        * {Object} the drag event <br>
        * {Object} the Draggable entity
        * @public
        * @constant
        * @type String
        * @name DRAGSTART
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.DRAGSTART = "me.game.dragstart";
            /**
        * Channel Constant for dragend events on a Draggable entity <br>
        * Data passed:
        * {Object} the drag event <br>
        * {Object} the Draggable entity
        * @public
        * @constant
        * @type String
        * @name DRAGEND
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.DRAGEND = "me.game.dragend";
            /**
        * Channel Constant for when the (browser) window is resized <br>
        * Data passed : {Event} Event object
        * @public
        * @constant
        * @type String
        * @name WINDOW_ONRESIZE
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.WINDOW_ONRESIZE = "window.onresize";
            /**
        * Channel Constant for when the canvas is resized <br>
        * (this usually follows a WINDOW_ONRESIZE event).<br>
        * Data passed : {Number} canvas width <br>
        * Data passed : {Number} canvas height
        * @public
        * @constant
        * @type String
        * @name CANVAS_ONRESIZE
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.CANVAS_ONRESIZE = "canvas.onresize";
            /**
        * Channel Constant for when the viewport is resized <br>
        * (this usually follows a WINDOW_ONRESIZE event, when using the `flex` scaling mode is used and after the viewport was updated).<br>
        * Data passed : {Number} viewport width <br>
        * Data passed : {Number} viewport height
        * @public
        * @constant
        * @type String
        * @name VIEWPORT_ONRESIZE
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.VIEWPORT_ONRESIZE = "viewport.onresize";
            /**
        * Channel Constant for when the device is rotated <br>
        * Data passed : {Event} Event object <br>
        * @public
        * @constant
        * @type String
        * @name WINDOW_ONORIENTATION_CHANGE
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.WINDOW_ONORIENTATION_CHANGE = "window.orientationchange";
            /**
        * Channel Constant for when the (browser) window is scrolled <br>
        * Data passed : {Event} Event object
        * @public
        * @constant
        * @type String
        * @name WINDOW_ONSCROLL
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.WINDOW_ONSCROLL = "window.onscroll";
            /**
        * Channel Constant for when the viewport position is updated <br>
        * Data passed : {me.Vector2d} viewport position vector
        * @public
        * @constant
        * @type String
        * @name VIEWPORT_ONCHANGE
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.VIEWPORT_ONCHANGE = "viewport.onchange";
            /**
        * Channel Constant for when WebGL context is lost <br>
        * Data passed : {me.WebGLRenderer} the current webgl renderer instance`
        * @public
        * @constant
        * @type String
        * @name WEBGL_ONCONTEXT_LOST
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.WEBGL_ONCONTEXT_LOST = "renderer.webglcontextlost";
            /**
        * Channel Constant for when WebGL context is restored <br>
        * Data passed : {me.WebGLRenderer} the current webgl renderer instance`
        * @public
        * @constant
        * @type String
        * @name WEBGL_ONCONTEXT_RESTORED
        * @memberOf me.event
        * @see me.event.subscribe
        */ api.WEBGL_ONCONTEXT_RESTORED = "renderer.webglcontextrestored";
            /**
        * Publish some data on a channel
        * @name publish
        * @memberOf me.event
        * @public
        * @function
        * @param {String} channel The channel to publish on
        * @param {Array} arguments The data to publish
        *
        * @example Publish stuff on '/some/channel'.
        * Anything subscribed will be called with a function
        * signature like: function (a,b,c){ ... }
        *
        * me.event.publish("/some/channel", ["a","b","c"]);
        *
        */ api.publish = minpubsub_src.publish;
            /**
        * Register a callback on a named channel.
        * @name subscribe
        * @memberOf me.event
        * @public
        * @function
        * @param {String} channel The channel to subscribe to
        * @param {Function} callback The event handler, any time something is
        * published on a subscribed channel, the callback will be called
        * with the published array as ordered arguments
        * @return {handle} A handle which can be used to unsubscribe this
        * particular subscription
        * @example
        * me.event.subscribe("/some/channel", function (a, b, c){ doSomething(); });
        */ api.subscribe = minpubsub_src.subscribe;
            /**
        * Disconnect a subscribed function for a channel.
        * @name unsubscribe
        * @memberOf me.event
        * @see me.event.subscribe
        * @public
        * @function
        * @param {Array|String} handle The return value from a subscribe call or the
        * name of a channel as a String
        * @param {Function} [callback] The callback to be unsubscribed.
        * @example
        * var handle = me.event.subscribe("/some/channel", function (){});
        * me.event.unsubscribe(handle);
        *
        * // Or alternatively ...
        *
        * var callback = function (){};
        * me.event.subscribe("/some/channel", callback);
        * me.event.unsubscribe("/some/channel", callback);
        */ api.unsubscribe = minpubsub_src.unsubscribe; // return our object
            return api;
        })();
    })();
    (function() {
        /**
      * me.game represents your current game, it contains all the objects,
      * tilemap layers, current viewport, collision map, etc...<br>
      * me.game is also responsible for updating (each frame) the object status
      * and draw them<br>
      * @namespace me.game
      * @memberOf me
      */ me.game = (function() {
            // hold public stuff in our singleton
            var api = {
            };
            /*
        * PRIVATE STUFF
        */ // to know when we have to refresh the display
            var isDirty = true; // always refresh the display when updatesPerSecond are lower than fps
            var isAlwaysDirty = false; // frame counter for frameSkipping
            // reset the frame counter
            var frameCounter = 0;
            var frameRate = 1; // time accumulation for multiple update calls
            var accumulator = 0;
            var accumulatorMax = 0;
            var accumulatorUpdateDelta = 0; // min update step size
            var stepSize = 1000 / 60;
            var updateDelta = 0;
            var lastUpdateStart = null;
            var updateAverageDelta = 0;
            /*
        * PUBLIC STUFF
        */ /**
        * a reference to the current active stage "default" camera
        * @public
        * @type {me.Camera2d}
        * @name viewport
        * @memberOf me.game
        */ api.viewport = undefined;
            /**
        * a reference to the game world, <br>
        * a world is a virtual environment containing all the game objects
        * @public
        * @type {me.World}
        * @name world
        * @memberOf me.game
        */ api.world = null;
            /**
        * when true, all objects will be added under the root world container.<br>
        * When false, a `me.Container` object will be created for each corresponding groups
        * @public
        * @type {boolean}
        * @default true
        * @name mergeGroup
        * @memberOf me.game
        */ api.mergeGroup = true;
            /**
        * Specify the property to be used when sorting entities.
        * Accepted values : "x", "y", "z"
        * @public
        * @type {string}
        * @default "z"
        * @name sortOn
        * @memberOf me.game
        */ api.sortOn = "z";
            /**
        * Fired when a level is fully loaded and <br>
        * and all entities instantiated. <br>
        * Additionnaly the level id will also be passed
        * to the called function.
        * @public
        * @function
        * @name onLevelLoaded
        * @memberOf me.game
        * @example
        * // call myFunction () everytime a level is loaded
        * me.game.onLevelLoaded = this.myFunction.bind(this);
        */ api.onLevelLoaded = function() {
            };
            /**
        * Initialize the game manager
        * @name init
        * @memberOf me.game
        * @ignore
        * @function
        */ api.init = function() {
                // the root object of our world is an entity container
                api.world = new me.World(); // publish init notification
                me.event.publish(me.event.GAME_INIT); // make display dirty by default
                isDirty = true;
            };
            /**
        * reset the game Object manager<br>
        * destroy all current objects
        * @name reset
        * @memberOf me.game
        * @public
        * @function
        */ api.reset = function() {
                // point to the current active stage "default" camera
                var current = me.state.current();
                if (typeof current !== "undefined") api.viewport = me.state.current().cameras.get("default");
                 // publish reset notification
                me.event.publish(me.event.GAME_RESET); // Refresh internal variables for framerate  limiting
                api.updateFrameRate();
            };
            /**
        * Update the renderer framerate using the system config variables.
        * @name updateFrameRate
        * @memberOf me.game
        * @public
        * @function
        * @see me.timer.maxfps
        * @see me.game.world.fps
        */ api.updateFrameRate = function() {
                // reset the frame counter
                frameCounter = 0;
                frameRate = ~~(0.5 + 60 / me.timer.maxfps); // set step size based on the updatesPerSecond
                stepSize = 1000 / api.world.fps;
                accumulator = 0;
                accumulatorMax = stepSize * 10; // display should always re-draw when update speed doesn't match fps
                // this means the user intends to write position prediction drawing logic
                isAlwaysDirty = me.timer.maxfps > api.world.fps;
            };
            /**
        * Returns the parent container of the specified Child in the game world
        * @name getParentContainer
        * @memberOf me.game
        * @function
        * @param {me.Renderable} child
        * @return {me.Container}
        */ api.getParentContainer = function(child) {
                return child.ancestor;
            };
            /**
        * force the redraw (not update) of all objects
        * @name repaint
        * @memberOf me.game
        * @public
        * @function
        */ api.repaint = function() {
                isDirty = true;
            };
            /**
        * update all objects of the game manager
        * @name update
        * @memberOf me.game
        * @ignore
        * @function
        * @param {Number} time current timestamp as provided by the RAF callback
        * @param {me.Stage} stage the current stage
        */ api.update = function(time, stage) {
                // handle frame skipping if required
                if ((++frameCounter) % frameRate === 0) {
                    // reset the frame counter
                    frameCounter = 0; // game update event
                    me.event.publish(me.event.GAME_UPDATE, [
                        time
                    ]);
                    accumulator += me.timer.getDelta();
                    accumulator = Math.min(accumulator, accumulatorMax);
                    updateDelta = me.timer.interpolation ? me.timer.getDelta() : stepSize;
                    accumulatorUpdateDelta = me.timer.interpolation ? updateDelta : Math.max(updateDelta, updateAverageDelta);
                    while(accumulator >= accumulatorUpdateDelta || me.timer.interpolation){
                        lastUpdateStart = window.performance.now(); // update all objects (and pass the elapsed time since last frame)
                        isDirty = stage.update(updateDelta) || isDirty;
                        me.timer.lastUpdate = window.performance.now();
                        updateAverageDelta = me.timer.lastUpdate - lastUpdateStart;
                        accumulator -= accumulatorUpdateDelta;
                        if (me.timer.interpolation) {
                            accumulator = 0;
                            break;
                        }
                    }
                }
            };
            /**
        * draw the current scene/stage
        * @name draw
        * @memberOf me.game
        * @ignore
        * @function
        * @param {me.Stage} stage the current stage
        */ api.draw = function(stage) {
                var renderer = me.video.renderer;
                if (renderer.isContextValid === true && (isDirty || isAlwaysDirty)) {
                    // prepare renderer to draw a new frame
                    renderer.clear(); // render the stage
                    stage.draw(renderer); // set back to flag
                    isDirty = false; // flush/render our frame
                    renderer.flush();
                }
            }; // return our object
            return api;
        })();
    })();
    (function() {
        /**
      * current melonJS version
      * @static
      * @constant
      * @memberof me
      * @name version
      * @type {string}
      */ me.version = "8.0.1";
        /**
      * global system settings and browser capabilities
      * @namespace
      */ me.sys = {
            /**
        * Specify either to stop on audio loading error or not<br>
        * if true, melonJS will throw an exception and stop loading<br>
        * if false, melonJS will disable sounds and output a warning message
        * in the console<br>
        * @type {Boolean}
        * @default true
        * @memberOf me.sys
        */ stopOnAudioError: true,
            /**
        * Specify whether to pause the game when losing focus.<br>
        * @type {Boolean}
        * @default true
        * @memberOf me.sys
        */ pauseOnBlur: true,
            /**
        * Specify whether to unpause the game when gaining focus.<br>
        * @type {Boolean}
        * @default true
        * @memberOf me.sys
        */ resumeOnFocus: true,
            /**
        * Specify whether to automatically bring the window to the front.<br>
        * @type {Boolean}
        * @default true
        * @memberOf me.sys
        */ autoFocus: true,
            /**
        * Specify whether to stop the game when losing focus or not<br>
        * The engine restarts on focus if this is enabled.
        * @type {boolean}
        * @default false
        * @memberOf me.sys
        */ stopOnBlur: false,
            /**
        * Specify the rendering method for layers <br>
        * if false, visible part of the layers are rendered dynamically<br>
        * if true, the entire layers are first rendered into an offscreen
        * canvas<br>
        * the "best" rendering method depends of your game<br>
        * (amount of layer, layer size, amount of tiles per layer, etc.)<br>
        * note : rendering method is also configurable per layer by adding this
        * property to your layer (in Tiled)<br>
        * @type {Boolean}
        * @default false
        * @memberOf me.sys
        */ preRender: false
        };
        /**
      * a flag indicating that melonJS is fully initialized
      * @type {Boolean}
      * @default false
      * @readonly
      * @memberOf me
      */ me.initialized = false;
        /**
      * disable melonJS auto-initialization
      * @type {Boolean}
      * @default false
      * @see me.boot
      * @memberOf me
      */ me.skipAutoInit = false;
        /**
      * initialize the melonJS library.
      * this is automatically called unless me.skipAutoInit is set to true,
      * to allow asynchronous loaders to work.
      * @name boot
      * @memberOf me
      * @see me.skipAutoInit
      * @public
      * @function
      */ me.boot = function() {
            // don't do anything if already initialized (should not happen anyway)
            if (me.initialized === true) return;
             // check the device capabilites
            me.device._check(); // init the object Pool
            me.pool.init(); // initialize me.save
            me.save.init(); // init the FPS counter if needed
            me.timer.init(); // enable/disable the cache
            me.loader.setNocache(me.utils.getUriFragment().nocache || false); // init the App Manager
            me.state.init(); // automatically enable keyboard events
            me.input.initKeyboardEvent(); // init the level Director
            me.levelDirector.init(); // game instance init
            me.game.init(); // mark melonJS as initialized
            me.initialized = true; /// if auto init is disable and this function was called manually
            if (me.skipAutoInit === true) me.device._domReady();
        }; // call the library init function when ready
        me.device.onReady(function() {
            if (me.skipAutoInit === false) me.boot();
        });
    })();
    (function() {
        /**
      * a Timer object to manage timing related function (FPS, Game Tick, Time...)<p>
      * There is no constructor function for me.timer
      * @namespace me.timer
      * @memberOf me
      */ me.timer = (function() {
            // hold public stuff in our api
            var api = {
            };
            /*
        * PRIVATE STUFF
        */ //hold element to display fps
            var framecount = 0;
            var framedelta = 0;
            /* fps count stuff */ var last = 0;
            var now = 0;
            var delta = 0; // for timeout/interval update
            var step = 0;
            var minstep = 0; // list of defined timer function
            var timers = [];
            var timerId = 0;
            /**
        * @ignore
        */ var clearTimer = function clearTimer1(timerId1) {
                for(var i = 0, len = timers.length; i < len; i++)if (timers[i].timerId === timerId1) {
                    timers.splice(i, 1);
                    break;
                }
            };
            /**
        * update timers
        * @ignore
        */ var updateTimers = function updateTimers1(time) {
                last = now;
                now = time;
                delta = now - last; // fix for negative timestamp returned by wechat or chrome on startup
                if (delta < 0) delta = 0;
                 // get the game tick
                api.tick = delta > minstep && me.timer.interpolation ? delta / step : 1;
                for(var i = 0, len = timers.length; i < len; i++){
                    var _timer = timers[i];
                    if (!(_timer.pauseable && me.state.isPaused())) _timer.elapsed += delta;
                    if (_timer.elapsed >= _timer.delay) {
                        _timer.fn.apply(null, _timer.args);
                        if (_timer.repeat === true) _timer.elapsed -= _timer.delay;
                        else me.timer.clearTimeout(_timer.timerId);
                    }
                }
            };
            /*
        * PUBLIC STUFF
        */ /**
        * Last game tick value.<br/>
        * Use this value to scale velocities during frame drops due to slow
        * hardware or when setting an FPS limit. (See {@link me.timer.maxfps})
        * This feature is disabled by default. Enable me.timer.interpolation to
        * use it.
        * @public
        * @see me.timer.interpolation
        * @type {Number}
        * @name tick
        * @memberOf me.timer
        */ api.tick = 1;
            /**
        * Last measured fps rate.<br/>
        * This feature is disabled by default, unless the debugPanel is enabled/visible
        * @public
        * @type {Number}
        * @name fps
        * @memberOf me.timer
        */ api.fps = 0;
            /**
        * Set the maximum target display frame per second
        * @public
        * @see me.timer.tick
        * @type {Number}
        * @name maxfps
        * @default 60
        * @memberOf me.timer
        */ api.maxfps = 60;
            /**
        * Enable/disable frame interpolation
        * @see me.timer.tick
        * @type {Boolean}
        * @default false
        * @name interpolation
        * @memberOf me.timer
        */ api.interpolation = false;
            /**
        * Last update time.<br/>
        * Use this value to implement frame prediction in drawing events,
        * for creating smooth motion while running game update logic at
        * a lower fps.
        * @public
        * @type Date
        * @name lastUpdate
        * @memberOf me.timer
        */ api.lastUpdate = window.performance.now();
            /**
        * init the timer
        * @ignore
        */ api.init = function() {
                // reset variables to initial state
                api.reset();
                now = last = 0; // register to the game update event
                me.event.subscribe(me.event.GAME_UPDATE, updateTimers);
            };
            /**
        * reset time (e.g. usefull in case of pause)
        * @name reset
        * @memberOf me.timer
        * @ignore
        * @function
        */ api.reset = function() {
                // set to "now"
                last = now = window.performance.now();
                delta = 0; // reset delta counting variables
                framedelta = 0;
                framecount = 0;
                step = Math.ceil(1000 / api.maxfps); // ROUND IT ?
                // define some step with some margin
                minstep = 1000 / api.maxfps * 1.25; // IS IT NECESSARY?\
            };
            /**
        * Calls a function once after a specified delay. See me.timer.setInterval to repeativly call a function.
        * @name setTimeout
        * @memberOf me.timer
        * @param {Function} fn the function you want to execute after delay milliseconds.
        * @param {Number} delay the number of milliseconds (thousandths of a second) that the function call should be delayed by.
        * @param {Boolean} [pauseable=true] respects the pause state of the engine.
        * @param {...*} [param] optional parameters which are passed through to the function specified by fn once the timer expires.
        * @return {Number} The numerical ID of the timer, which can be used later with me.timer.clearTimeout().
        * @function
        * @example
        * // set a timer to call "myFunction" after 1000ms
        * me.timer.setTimeout(myFunction, 1000);
        * // set a timer to call "myFunction" after 1000ms (respecting the pause state) and passing param1 and param2
        * me.timer.setTimeout(myFunction, 1000, true, param1, param2);
        */ api.setTimeout = function(fn, delay, pauseable) {
                timers.push({
                    fn: fn,
                    delay: delay,
                    elapsed: 0,
                    repeat: false,
                    timerId: ++timerId,
                    pauseable: pauseable === true || true,
                    args: arguments.length > 3 ? Array.prototype.slice.call(arguments, 3) : undefined
                });
                return timerId;
            };
            /**
        * Calls a function continously at the specified interval.  See setTimeout to call function a single time.
        * @name setInterval
        * @memberOf me.timer
        * @param {Function} fn the function to execute
        * @param {Number} delay the number of milliseconds (thousandths of a second) on how often to execute the function
        * @param {Boolean} [pauseable=true] respects the pause state of the engine.
        * @param {...*} [param] optional parameters which are passed through to the function specified by fn once the timer expires.
        * @return {Number} The numerical ID of the timer, which can be used later with me.timer.clearInterval().
        * @function
        * @example
        * // set a timer to call "myFunction" every 1000ms
        * me.timer.setInterval(myFunction, 1000);
        * // set a timer to call "myFunction" every 1000ms (respecting the pause state) and passing param1 and param2
        * me.timer.setInterval(myFunction, 1000, true, param1, param2);
        */ api.setInterval = function(fn, delay, pauseable) {
                timers.push({
                    fn: fn,
                    delay: delay,
                    elapsed: 0,
                    repeat: true,
                    timerId: ++timerId,
                    pauseable: pauseable === true || true,
                    args: arguments.length > 3 ? Array.prototype.slice.call(arguments, 3) : undefined
                });
                return timerId;
            };
            /**
        * Clears the delay set by me.timer.setTimeout().
        * @name clearTimeout
        * @memberOf me.timer
        * @function
        * @param {Number} timeoutID ID of the timeout to be cleared
        */ api.clearTimeout = function(timeoutID) {
                me.utils["function"].defer(clearTimer, this, timeoutID);
            };
            /**
        * Clears the Interval set by me.timer.setInterval().
        * @name clearInterval
        * @memberOf me.timer
        * @function
        * @param {Number} intervalID ID of the interval to be cleared
        */ api.clearInterval = function(intervalID) {
                me.utils["function"].defer(clearTimer, this, intervalID);
            };
            /**
        * Return the current timestamp in milliseconds <br>
        * since the game has started or since linux epoch (based on browser support for High Resolution Timer)
        * @name getTime
        * @memberOf me.timer
        * @return {Number}
        * @function
        */ api.getTime = function() {
                return now;
            };
            /**
        * Return elapsed time in milliseconds since the last update
        * @name getDelta
        * @memberOf me.timer
        * @return {Number}
        * @function
        */ api.getDelta = function() {
                return delta;
            };
            /**
        * compute the actual frame time and fps rate
        * @name computeFPS
        * @ignore
        * @memberOf me.timer
        * @function
        */ api.countFPS = function() {
                framecount++;
                framedelta += delta;
                if (framecount % 10 === 0) {
                    api.fps = me.Math.clamp(Math.round(1000 * framecount / framedelta), 0, api.maxfps);
                    framedelta = 0;
                    framecount = 0;
                }
            }; // return our api
            return api;
        })();
    })();
    (function() {
        /**
      * This object is used for object pooling - a technique that might speed up your game if used properly.<br>
      * If some of your classes will be instantiated and removed a lot at a time, it is a
      * good idea to add the class to this object pool. A separate pool for that class
      * will be created, which will reuse objects of the class. That way they won't be instantiated
      * each time you need a new one (slowing your game), but stored into that pool and taking one
      * already instantiated when you need it.<br><br>
      * This object is also used by the engine to instantiate objects defined in the map,
      * which means, that on level loading the engine will try to instantiate every object
      * found in the map, based on the user defined name in each Object Properties<br>
      * <img src="images/object_properties.png"/><br>
      * @namespace me.pool
      * @memberOf me
      */ me.pool = (function() {
            // hold public stuff in our singleton
            var api = {
            };
            var objectClass = {
            };
            var instance_counter = 0;
            /*
        * PUBLIC STUFF
        */ /**
        * Constructor
        * @ignore
        */ api.init = function() {
                api.register("me.Entity", me.Entity);
                api.register("me.CollectableEntity", me.CollectableEntity);
                api.register("me.LevelEntity", me.LevelEntity);
                api.register("me.Tween", me.Tween, true);
                api.register("me.Color", me.Color, true);
                api.register("me.Particle", me.Particle, true);
                api.register("me.Sprite", me.Sprite);
                api.register("me.Text", me.Text, true);
                api.register("me.BitmapText", me.BitmapText, true);
                api.register("me.BitmapTextData", me.BitmapTextData, true);
                api.register("me.ImageLayer", me.ImageLayer, true);
                api.register("me.ColorLayer", me.ColorLayer, true);
                api.register("me.Vector2d", me.Vector2d, true);
                api.register("me.Vector3d", me.Vector3d, true);
                api.register("me.ObservableVector2d", me.ObservableVector2d, true);
                api.register("me.ObservableVector3d", me.ObservableVector3d, true);
                api.register("me.Matrix2d", me.Matrix2d, true);
                api.register("me.Matrix3d", me.Matrix3d, true);
                api.register("me.Rect", me.Rect, true);
                api.register("me.Polygon", me.Polygon, true);
                api.register("me.Line", me.Line, true);
                api.register("me.Ellipse", me.Ellipse, true);
            };
            /**
        * register an object to the pool. <br>
        * Pooling must be set to true if more than one such objects will be created. <br>
        * (note) If pooling is enabled, you shouldn't instantiate objects with `new`.
        * See examples in {@link me.pool#pull}
        * @name register
        * @memberOf me.pool
        * @public
        * @function
        * @param {String} className as defined in the Name field of the Object Properties (in Tiled)
        * @param {Object} class corresponding Class to be instantiated
        * @param {Boolean} [objectPooling=false] enables object pooling for the specified class
        * - speeds up the game by reusing existing objects
        * @example
        * // add our users defined entities in the object pool
        * me.pool.register("playerspawnpoint", PlayerEntity);
        * me.pool.register("cherryentity", CherryEntity, true);
        * me.pool.register("heartentity", HeartEntity, true);
        * me.pool.register("starentity", StarEntity, true);
        */ api.register = function(className, classObj, pooling) {
                if (typeof classObj !== "undefined") objectClass[className] = {
                    "class": classObj,
                    "pool": pooling ? [] : undefined
                };
                else throw new Error("Cannot register object '" + className + "', invalid class");
            };
            /**
        * Pull a new instance of the requested object (if added into the object pool)
        * @name pull
        * @memberOf me.pool
        * @public
        * @function
        * @param {String} className as used in {@link me.pool.register}
        * @param {} [arguments...] arguments to be passed when instantiating/reinitializing the object
        * @return {Object} the instance of the requested object
        * @example
        * me.pool.register("player", PlayerEntity);
        * var player = me.pool.pull("player");
        * @example
        * me.pool.register("bullet", BulletEntity, true);
        * me.pool.register("enemy", EnemyEntity, true);
        * // ...
        * // when we need to manually create a new bullet:
        * var bullet = me.pool.pull("bullet", x, y, direction);
        * // ...
        * // params aren't a fixed number
        * // when we need new enemy we can add more params, that the object construct requires:
        * var enemy = me.pool.pull("enemy", x, y, direction, speed, power, life);
        * // ...
        * // when we want to destroy existing object, the remove
        * // function will ensure the object can then be reallocated later
        * me.game.world.removeChild(enemy);
        * me.game.world.removeChild(bullet);
        */ api.pull = function(name) {
                var args = new Array(arguments.length);
                for(var i = 0; i < arguments.length; i++)args[i] = arguments[i];
                var entity = objectClass[name];
                if (entity) {
                    var proto = entity["class"], pool = entity.pool, obj;
                    if (pool && (obj = pool.pop())) {
                        args.shift(); // call the object onResetEvent function if defined
                        if (typeof obj.onResetEvent === "function") obj.onResetEvent.apply(obj, args);
                        else obj.init.apply(obj, args);
                        instance_counter--;
                    } else {
                        args[0] = proto;
                        obj = new (proto.bind.apply(proto, args))();
                        if (pool) obj.className = name;
                    }
                    return obj;
                }
                throw new Error("Cannot instantiate object of type '" + name + "'");
            };
            /**
        * purge the object pool from any inactive object <br>
        * Object pooling must be enabled for this function to work<br>
        * note: this will trigger the garbage collector
        * @name purge
        * @memberOf me.pool
        * @public
        * @function
        */ api.purge = function() {
                for(var className in objectClass)if (objectClass[className]) objectClass[className].pool = [];
                instance_counter = 0;
            };
            /**
        * Push back an object instance into the object pool <br>
        * Object pooling for the object class must be enabled,
        * and object must have been instantiated using {@link me.pool#pull},
        * otherwise this function won't work
        * @name push
        * @memberOf me.pool
        * @public
        * @function
        * @param {Object} instance to be recycled
        */ api.push = function(obj) {
                var name = obj.className;
                if (typeof name === "undefined" || !objectClass[name]) // object is not registered, don't do anything
                return;
                 // store back the object instance for later recycling
                objectClass[name].pool.push(obj);
                instance_counter++;
            };
            /**
        * Check if an object with the provided name is registered
        * @name exists
        * @memberOf me.pool
        * @public
        * @function
        * @param {String} name of the registered object
        * @return {Boolean} true if the classname is registered
        */ api.exists = function(name) {
                return name in objectClass;
            };
            /**
        * returns the amount of object instance currently in the pool
        * @name getInstanceCount
        * @memberOf me.pool
        * @public
        * @function
        * @return {Number} amount of object instance
        */ api.getInstanceCount = function(name) {
                return instance_counter;
            }; // return our object
            return api;
        })();
    })();
    (function() {
        /**
      * a collection of math utility functions
      * @namespace Math
      * @memberOf me
      */ me.Math = (function() {
            // hold public stuff in our singleton
            var api = {
            };
            /*
        * PUBLIC STUFF
        */ /**
        * constant to convert from degrees to radians
        * @public
        * @type {Number}
        * @name DEG_TO_RAD
        * @memberOf me.Math
        */ api.DEG_TO_RAD = Math.PI / 180;
            /**
        * constant to convert from radians to degrees
        * @public
        * @type {Number}
        * @name RAD_TO_DEG
        * @memberOf me.Math
        */ api.RAD_TO_DEG = 180 / Math.PI;
            /**
        * constant equals to 2 times pi
        * @public
        * @type {Number}
        * @name TAU
        * @memberOf me.Math
        */ api.TAU = Math.PI * 2;
            /**
        * constant equals to half pi
        * @public
        * @type {Number}
        * @name ETA
        * @memberOf me.Math
        */ api.ETA = Math.PI * 0.5;
            /**
        * the difference between 1 and the smallest floating point number greater than 1
        * @public
        * @type {Number}
        * @name EPSILON
        * @memberOf me.Math
        */ api.EPSILON = 0.000001;
            /**
        * returns true if the given value is a power of two
        * @public
        * @function
        * @memberOf me.Math
        * @name isPowerOfTwo
        * @param {Number} val
        * @return {boolean}
        */ api.isPowerOfTwo = function(val) {
                return (val & val - 1) === 0;
            };
            /**
        * returns the next power of two for the given value
        * @public
        * @function
        * @memberOf me.Math
        * @name nextPowerOfTwo
        * @param {Number} val
        * @return {boolean}
        */ api.nextPowerOfTwo = function(val) {
                val--;
                val |= val >> 1;
                val |= val >> 2;
                val |= val >> 4;
                val |= val >> 8;
                val |= val >> 16;
                val++;
                return val;
            };
            /**
        * Converts an angle in degrees to an angle in radians
        * @public
        * @function
        * @memberOf me.Math
        * @name degToRad
        * @param {number} angle angle in degrees
        * @return {number} corresponding angle in radians
        * @example
        * // convert a specific angle
        * me.Math.degToRad(60); // return 1.0471...
        */ api.degToRad = function(angle) {
                return angle * api.DEG_TO_RAD;
            };
            /**
        * Converts an angle in radians to an angle in degrees.
        * @public
        * @function
        * @memberOf me.Math
        * @name radToDeg
        * @param {number} radians angle in radians
        * @return {number} corresponding angle in degrees
        * @example
        * // convert a specific angle
        * me.Math.radToDeg(1.0471975511965976); // return 60
        */ api.radToDeg = function(radians) {
                return radians * api.RAD_TO_DEG;
            };
            /**
        * clamp the given value
        * @public
        * @function
        * @memberOf me.Math
        * @name clamp
        * @param {number} val the value to clamp
        * @param {number} low lower limit
        * @param {number} high higher limit
        * @return {number} clamped value
        */ api.clamp = function(val, low, high) {
                return val < low ? low : val > high ? high : +val;
            };
            /**
        * return a random integer between min (included) and max (excluded)
        * @public
        * @function
        * @memberOf me.Math
        * @name random
        * @param {number} min minimum value.
        * @param {number} max maximum value.
        * @return {number} random value
        * @example
        * // Print a random number; one of 5, 6, 7, 8, 9
        * console.log(me.Math.random(5, 10) );
        */ api.random = function(min, max) {
                return ~~(Math.random() * (max - min)) + min;
            };
            /**
        * return a random float between min, max (exclusive)
        * @public
        * @function
        * @memberOf me.Math
        * @name randomFloat
        * @param {number} min minimum value.
        * @param {number} max maximum value.
        * @return {number} random value
        * @example
        * // Print a random number; one of 5, 6, 7, 8, 9
        * console.log(me.Math.randomFloat(5, 10) );
        */ api.randomFloat = function(min, max) {
                return Math.random() * (max - min) + min;
            };
            /**
        * return a weighted random between min, max (exclusive)
        * @public
        * @function
        * @memberOf me.Math
        * @name weightedRandom
        * @param {number} min minimum value.
        * @param {number} max maximum value.
        * @return {number} random value
        * @example
        * // Print a random number; one of 5, 6, 7, 8, 9
        * console.log(me.Math.weightedRandom(5, 10) );
        */ api.weightedRandom = function(min, max) {
                return ~~(Math.pow(Math.random(), 2) * (max - min)) + min;
            };
            /**
        * round a value to the specified number of digit
        * @public
        * @function
        * @memberOf me.Math
        * @name round
        * @param {number} num value to be rounded.
        * @param {number} [dec=0] number of decimal digit to be rounded to.
        * @return {number} rounded value
        * @example
        * // round a specific value to 2 digits
        * me.Math.round(10.33333, 2); // return 10.33
        */ api.round = function(num, dec) {
                // if only one argument use the object value
                var powres = Math.pow(10, dec || 0);
                return ~~(0.5 + num * powres) / powres;
            };
            /**
        * check if the given value is close to the expected one
        * @public
        * @function
        * @memberOf me.Math
        * @name toBeCloseTo
        * @param {number} expected value to be compared with.
        * @param {number} actual actual value to compare
        * @param {number} [precision=2] float precision for the comparison
        * @return {boolean} if close to
        * @example
        * // test if the given value is close to 10
        * if (me.Math.toBeCloseTo(10, value)) {
        *     // do something
        * }
        */ api.toBeCloseTo = function(expected, actual, precision) {
                if (typeof precision !== "number") precision = 2;
                return Math.abs(expected - actual) < Math.pow(10, -precision) / 2;
            }; // return our object
            return api;
        })();
    })();
    (function() {
        /**
      * a generic 2D Vector Object
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      * @param {Number} [x=0] x value of the vector
      * @param {Number} [y=0] y value of the vector
      */ me.Vector2d = me.Object.extend({
            /**
        * @ignore
        */ init: function init(x, y) {
                return this.set(x || 0, y || 0);
            },
            /**
        * @ignore */ _set: function _set(x, y) {
                this.x = x;
                this.y = y;
                return this;
            },
            /**
        * set the Vector x and y properties to the given values<br>
        * @name set
        * @memberOf me.Vector2d
        * @function
        * @param {Number} x
        * @param {Number} y
        * @return {me.Vector2d} Reference to this object for method chaining
        */ set: function set(x, y) {
                if (x !== +x || y !== +y) throw new Error("invalid x,y parameters (not a number)");
                /**
          * x value of the vector
          * @public
          * @type Number
          * @name x
          * @memberOf me.Vector2d
          */ //this.x = x;
                /**
          * y value of the vector
          * @public
          * @type Number
          * @name y
          * @memberOf me.Vector2d
          */ //this.y = y;
                return this._set(x, y);
            },
            /**
        * set the Vector x and y properties to 0
        * @name setZero
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} Reference to this object for method chaining
        */ setZero: function setZero() {
                return this.set(0, 0);
            },
            /**
        * set the Vector x and y properties using the passed vector
        * @name setV
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v
        * @return {me.Vector2d} Reference to this object for method chaining
        */ setV: function setV(v) {
                return this._set(v.x, v.y);
            },
            /**
        * Add the passed vector to this vector
        * @name add
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v
        * @return {me.Vector2d} Reference to this object for method chaining
        */ add: function add(v) {
                return this._set(this.x + v.x, this.y + v.y);
            },
            /**
        * Substract the passed vector to this vector
        * @name sub
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v
        * @return {me.Vector2d} Reference to this object for method chaining
        */ sub: function sub(v) {
                return this._set(this.x - v.x, this.y - v.y);
            },
            /**
        * Multiply this vector values by the given scalar
        * @name scale
        * @memberOf me.Vector2d
        * @function
        * @param {Number} x
        * @param {Number} [y=x]
        * @return {me.Vector2d} Reference to this object for method chaining
        */ scale: function scale(x, y) {
                return this._set(this.x * x, this.y * (typeof y !== "undefined" ? y : x));
            },
            /**
        * Convert this vector into isometric coordinate space
        * @name toIso
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} Reference to this object for method chaining
        */ toIso: function toIso() {
                return this._set(this.x - this.y, (this.x + this.y) * 0.5);
            },
            /**
        * Convert this vector into 2d coordinate space
        * @name to2d
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} Reference to this object for method chaining
        */ to2d: function to2d() {
                return this._set(this.y + this.x / 2, this.y - this.x / 2);
            },
            /**
        * Multiply this vector values by the passed vector
        * @name scaleV
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v
        * @return {me.Vector2d} Reference to this object for method chaining
        */ scaleV: function scaleV(v) {
                return this._set(this.x * v.x, this.y * v.y);
            },
            /**
        * Divide this vector values by the passed value
        * @name div
        * @memberOf me.Vector2d
        * @function
        * @param {Number} value
        * @return {me.Vector2d} Reference to this object for method chaining
        */ div: function div(n) {
                return this._set(this.x / n, this.y / n);
            },
            /**
        * Update this vector values to absolute values
        * @name abs
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} Reference to this object for method chaining
        */ abs: function abs() {
                return this._set(this.x < 0 ? -this.x : this.x, this.y < 0 ? -this.y : this.y);
            },
            /**
        * Clamp the vector value within the specified value range
        * @name clamp
        * @memberOf me.Vector2d
        * @function
        * @param {Number} low
        * @param {Number} high
        * @return {me.Vector2d} new me.Vector2d
        */ clamp: function clamp(low, high) {
                return new me.Vector2d(me.Math.clamp(this.x, low, high), me.Math.clamp(this.y, low, high));
            },
            /**
        * Clamp this vector value within the specified value range
        * @name clampSelf
        * @memberOf me.Vector2d
        * @function
        * @param {Number} low
        * @param {Number} high
        * @return {me.Vector2d} Reference to this object for method chaining
        */ clampSelf: function clampSelf(low, high) {
                return this._set(me.Math.clamp(this.x, low, high), me.Math.clamp(this.y, low, high));
            },
            /**
        * Update this vector with the minimum value between this and the passed vector
        * @name minV
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v
        * @return {me.Vector2d} Reference to this object for method chaining
        */ minV: function minV(v) {
                return this._set(this.x < v.x ? this.x : v.x, this.y < v.y ? this.y : v.y);
            },
            /**
        * Update this vector with the maximum value between this and the passed vector
        * @name maxV
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v
        * @return {me.Vector2d} Reference to this object for method chaining
        */ maxV: function maxV(v) {
                return this._set(this.x > v.x ? this.x : v.x, this.y > v.y ? this.y : v.y);
            },
            /**
        * Floor the vector values
        * @name floor
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} new me.Vector2d
        */ floor: function floor() {
                return new me.Vector2d(Math.floor(this.x), Math.floor(this.y));
            },
            /**
        * Floor this vector values
        * @name floorSelf
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} Reference to this object for method chaining
        */ floorSelf: function floorSelf() {
                return this._set(Math.floor(this.x), Math.floor(this.y));
            },
            /**
        * Ceil the vector values
        * @name ceil
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} new me.Vector2d
        */ ceil: function ceil() {
                return new me.Vector2d(Math.ceil(this.x), Math.ceil(this.y));
            },
            /**
        * Ceil this vector values
        * @name ceilSelf
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} Reference to this object for method chaining
        */ ceilSelf: function ceilSelf() {
                return this._set(Math.ceil(this.x), Math.ceil(this.y));
            },
            /**
        * Negate the vector values
        * @name negate
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} new me.Vector2d
        */ negate: function negate() {
                return new me.Vector2d(-this.x, -this.y);
            },
            /**
        * Negate this vector values
        * @name negateSelf
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} Reference to this object for method chaining
        */ negateSelf: function negateSelf() {
                return this._set(-this.x, -this.y);
            },
            /**
        * Copy the x,y values of the passed vector to this one
        * @name copy
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v
        * @return {me.Vector2d} Reference to this object for method chaining
        */ copy: function copy(v) {
                return this._set(v.x, v.y);
            },
            /**
        * return true if the two vectors are the same
        * @name equals
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v
        * @return {Boolean}
        */ equals: function equals(v) {
                return this.x === v.x && this.y === v.y;
            },
            /**
        * normalize this vector (scale the vector so that its magnitude is 1)
        * @name normalize
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} Reference to this object for method chaining
        */ normalize: function normalize() {
                return this.div(this.length() || 1);
            },
            /**
        * change this vector to be perpendicular to what it was before.<br>
        * (Effectively rotates it 90 degrees in a clockwise direction)
        * @name perp
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} Reference to this object for method chaining
        */ perp: function perp() {
                return this._set(this.y, -this.x);
            },
            /**
        * Rotate this vector (counter-clockwise) by the specified angle (in radians).
        * @name rotate
        * @memberOf me.Vector2d
        * @function
        * @param {number} angle The angle to rotate (in radians)
        * @param {me.Vector2d|me.ObservableVector2d} [v] an optional point to rotate around
        * @return {me.Vector2d} Reference to this object for method chaining
        */ rotate: function rotate(angle, v) {
                var cx = 0;
                var cy = 0;
                if (_typeof(v) === "object") {
                    cx = v.x;
                    cy = v.y;
                }
                var x = this.x - cx;
                var y = this.y - cy;
                var c = Math.cos(angle);
                var s = Math.sin(angle);
                return this._set(x * c - y * s + cx, x * s + y * c + cy);
            },
            /**
        * return the dot product of this vector and the passed one
        * @name dotProduct
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v
        * @return {Number} The dot product.
        */ dotProduct: function dotProduct(v) {
                return this.x * v.x + this.y * v.y;
            },
            /**
         * return the square length of this vector
         * @name length2
         * @memberOf me.Vector2d
         * @function
         * @return {Number} The length^2 of this vector.
         */ length2: function length2() {
                return this.dotProduct(this);
            },
            /**
        * return the length (magnitude) of this vector
        * @name length
        * @memberOf me.Vector2d
        * @function
        * @return {Number} the length of this vector
        */ length: function length() {
                return Math.sqrt(this.length2());
            },
            /**
        * Linearly interpolate between this vector and the given one.
        * @name lerp
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v
        * @param {Number} alpha distance along the line (alpha = 0 will be this vector, and alpha = 1 will be the given one).
        * @return {me.Vector2d} Reference to this object for method chaining
        */ lerp: function lerp(v, alpha) {
                this.x += (v.x - this.x) * alpha;
                this.y += (v.y - this.y) * alpha;
                return this;
            },
            /**
        * return the distance between this vector and the passed one
        * @name distance
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v
        * @return {Number}
        */ distance: function distance(v) {
                var dx = this.x - v.x, dy = this.y - v.y;
                return Math.sqrt(dx * dx + dy * dy);
            },
            /**
        * return the angle between this vector and the passed one
        * @name angle
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v
        * @return {Number} angle in radians
        */ angle: function angle(v) {
                return Math.acos(me.Math.clamp(this.dotProduct(v) / (this.length() * v.length()), -1, 1));
            },
            /**
        * project this vector on to another vector.
        * @name project
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v The vector to project onto.
        * @return {me.Vector2d} Reference to this object for method chaining
        */ project: function project(v) {
                return this.scale(this.dotProduct(v) / v.length2());
            },
            /**
        * Project this vector onto a vector of unit length.<br>
        * This is slightly more efficient than `project` when dealing with unit vectors.
        * @name projectN
        * @memberOf me.Vector2d
        * @function
        * @param {me.Vector2d} v The unit vector to project onto.
        * @return {me.Vector2d} Reference to this object for method chaining
        */ projectN: function projectN(v) {
                return this.scale(this.dotProduct(v));
            },
            /**
        * return a clone copy of this vector
        * @name clone
        * @memberOf me.Vector2d
        * @function
        * @return {me.Vector2d} new me.Vector2d
        */ clone: function clone() {
                return me.pool.pull("me.Vector2d", this.x, this.y);
            },
            /**
        * convert the object to a string representation
        * @name toString
        * @memberOf me.Vector2d
        * @function
        * @return {String}
        */ toString: function toString() {
                return "x:" + this.x + ",y:" + this.y;
            }
        });
    })();
    (function() {
        /**
      * a generic 3D Vector Object
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      * @param {Number} [x=0] x value of the vector
      * @param {Number} [y=0] y value of the vector
      * @param {Number} [z=0] z value of the vector
      */ me.Vector3d = me.Object.extend({
            /**
        * @ignore
        */ init: function init(x, y, z) {
                return this.set(x || 0, y || 0, z || 0);
            },
            /**
        * @ignore */ _set: function _set(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z || 0;
                return this;
            },
            /**
        * set the Vector x and y properties to the given values<br>
        * @name set
        * @memberOf me.Vector3d
        * @function
        * @param {Number} x
        * @param {Number} y
        * @param {Number} [z=0]
        * @return {me.Vector3d} Reference to this object for method chaining
        */ set: function set(x, y, z) {
                if (x !== +x || y !== +y || typeof z !== "undefined" && z !== +z) throw new Error("invalid x, y, z parameters (not a number)");
                /**
          * x value of the vector
          * @public
          * @type Number
          * @name x
          * @memberOf me.Vector3d
          */ //this.x = x;
                /**
          * y value of the vector
          * @public
          * @type Number
          * @name y
          * @memberOf me.Vector3d
          */ //this.y = y;
                /**
          * z value of the vector
          * @public
          * @type Number
          * @name z
          * @memberOf me.Vector3d
          */ //this.z = z;
                return this._set(x, y, z);
            },
            /**
        * set the Vector x and y properties to 0
        * @name setZero
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} Reference to this object for method chaining
        */ setZero: function setZero() {
                return this.set(0, 0, 0);
            },
            /**
        * set the Vector x and y properties using the passed vector
        * @name setV
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v
        * @return {me.Vector3d} Reference to this object for method chaining
        */ setV: function setV(v) {
                return this._set(v.x, v.y, v.z);
            },
            /**
        * Add the passed vector to this vector
        * @name add
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v
        * @return {me.Vector3d} Reference to this object for method chaining
        */ add: function add(v) {
                return this._set(this.x + v.x, this.y + v.y, this.z + (v.z || 0));
            },
            /**
        * Substract the passed vector to this vector
        * @name sub
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v
        * @return {me.Vector3d} Reference to this object for method chaining
        */ sub: function sub(v) {
                return this._set(this.x - v.x, this.y - v.y, this.z - (v.z || 0));
            },
            /**
        * Multiply this vector values by the given scalar
        * @name scale
        * @memberOf me.Vector3d
        * @function
        * @param {Number} x
        * @param {Number} [y=x]
        * @param {Number} [z=1]
        * @return {me.Vector3d} Reference to this object for method chaining
        */ scale: function scale(x, y, z) {
                y = typeof y !== "undefined" ? y : x;
                return this._set(this.x * x, this.y * y, this.z * (z || 1));
            },
            /**
        * Multiply this vector values by the passed vector
        * @name scaleV
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v
        * @return {me.Vector3d} Reference to this object for method chaining
        */ scaleV: function scaleV(v) {
                return this.scale(v.x, v.y, v.z);
            },
            /**
        * Convert this vector into isometric coordinate space
        * @name toIso
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} Reference to this object for method chaining
        */ toIso: function toIso() {
                return this._set(this.x - this.y, (this.x + this.y) * 0.5, this.z);
            },
            /**
        * Convert this vector into 2d coordinate space
        * @name to2d
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} Reference to this object for method chaining
        */ to2d: function to2d() {
                return this._set(this.y + this.x / 2, this.y - this.x / 2, this.z);
            },
            /**
        * Divide this vector values by the passed value
        * @name div
        * @memberOf me.Vector3d
        * @function
        * @param {Number} value
        * @return {me.Vector3d} Reference to this object for method chaining
        */ div: function div(n) {
                return this._set(this.x / n, this.y / n, this.z / n);
            },
            /**
        * Update this vector values to absolute values
        * @name abs
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} Reference to this object for method chaining
        */ abs: function abs() {
                return this._set(this.x < 0 ? -this.x : this.x, this.y < 0 ? -this.y : this.y, this.z < 0 ? -this.z : this.z);
            },
            /**
        * Clamp the vector value within the specified value range
        * @name clamp
        * @memberOf me.Vector3d
        * @function
        * @param {Number} low
        * @param {Number} high
        * @return {me.Vector3d} new me.Vector3d
        */ clamp: function clamp(low, high) {
                return new me.Vector3d(me.Math.clamp(this.x, low, high), me.Math.clamp(this.y, low, high), me.Math.clamp(this.z, low, high));
            },
            /**
        * Clamp this vector value within the specified value range
        * @name clampSelf
        * @memberOf me.Vector3d
        * @function
        * @param {Number} low
        * @param {Number} high
        * @return {me.Vector3d} Reference to this object for method chaining
        */ clampSelf: function clampSelf(low, high) {
                return this._set(me.Math.clamp(this.x, low, high), me.Math.clamp(this.y, low, high), me.Math.clamp(this.z, low, high));
            },
            /**
        * Update this vector with the minimum value between this and the passed vector
        * @name minV
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v
        * @return {me.Vector3d} Reference to this object for method chaining
        */ minV: function minV(v) {
                var _vz = v.z || 0;
                return this._set(this.x < v.x ? this.x : v.x, this.y < v.y ? this.y : v.y, this.z < _vz ? this.z : _vz);
            },
            /**
        * Update this vector with the maximum value between this and the passed vector
        * @name maxV
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v
        * @return {me.Vector3d} Reference to this object for method chaining
        */ maxV: function maxV(v) {
                var _vz = v.z || 0;
                return this._set(this.x > v.x ? this.x : v.x, this.y > v.y ? this.y : v.y, this.z > _vz ? this.z : _vz);
            },
            /**
        * Floor the vector values
        * @name floor
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} new me.Vector3d
        */ floor: function floor() {
                return new me.Vector3d(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));
            },
            /**
        * Floor this vector values
        * @name floorSelf
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} Reference to this object for method chaining
        */ floorSelf: function floorSelf() {
                return this._set(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));
            },
            /**
        * Ceil the vector values
        * @name ceil
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} new me.Vector3d
        */ ceil: function ceil() {
                return new me.Vector3d(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));
            },
            /**
        * Ceil this vector values
        * @name ceilSelf
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} Reference to this object for method chaining
        */ ceilSelf: function ceilSelf() {
                return this._set(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));
            },
            /**
        * Negate the vector values
        * @name negate
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} new me.Vector3d
        */ negate: function negate() {
                return new me.Vector3d(-this.x, -this.y, -this.z);
            },
            /**
        * Negate this vector values
        * @name negateSelf
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} Reference to this object for method chaining
        */ negateSelf: function negateSelf() {
                return this._set(-this.x, -this.y, -this.z);
            },
            /**
        * Copy the components of the given vector into this one
        * @name copy
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v
        * @return {me.Vector3d} Reference to this object for method chaining
        */ copy: function copy(v) {
                return this._set(v.x, v.y, v.z || 0);
            },
            /**
        * return true if the two vectors are the same
        * @name equals
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v
        * @return {Boolean}
        */ equals: function equals(v) {
                return this.x === v.x && this.y === v.y && this.z === (v.z || this.z);
            },
            /**
        * normalize this vector (scale the vector so that its magnitude is 1)
        * @name normalize
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} Reference to this object for method chaining
        */ normalize: function normalize() {
                return this.div(this.length() || 1);
            },
            /**
        * change this vector to be perpendicular to what it was before.<br>
        * (Effectively rotates it 90 degrees in a clockwise direction around the z axis)
        * @name perp
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} Reference to this object for method chaining
        */ perp: function perp() {
                return this._set(this.y, -this.x, this.z);
            },
            /**
        * Rotate this vector (counter-clockwise) by the specified angle (in radians) around the z axis
        * @name rotate
        * @memberOf me.Vector3d
        * @function
        * @param {number} angle The angle to rotate (in radians)
        * @param {me.Vector2d|me.ObservableVector2d} [v] an optional point to rotate around (on the same z axis)
        * @return {me.Vector3d} Reference to this object for method chaining
        */ rotate: function rotate(angle, v) {
                var cx = 0;
                var cy = 0;
                if (_typeof(v) === "object") {
                    cx = v.x;
                    cy = v.y;
                } // TODO also rotate on the z axis if the given vector is a 3d one
                var x = this.x - cx;
                var y = this.y - cy;
                var c = Math.cos(angle);
                var s = Math.sin(angle);
                return this._set(x * c - y * s + cx, x * s + y * c + cy, this.z);
            },
            /**
        * return the dot product of this vector and the passed one
        * @name dotProduct
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v
        * @return {Number} The dot product.
        */ dotProduct: function dotProduct(v) {
                return this.x * v.x + this.y * v.y + this.z * (typeof v.z !== "undefined" ? v.z : this.z);
            },
            /**
         * return the square length of this vector
         * @name length2
         * @memberOf me.Vector3d
         * @function
         * @return {Number} The length^2 of this vector.
         */ length2: function length2() {
                return this.dotProduct(this);
            },
            /**
        * return the length (magnitude) of this vector
        * @name length
        * @memberOf me.Vector3d
        * @function
        * @return {Number} the length of this vector
        */ length: function length() {
                return Math.sqrt(this.length2());
            },
            /**
        * Linearly interpolate between this vector and the given one.
        * @name lerp
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector3d} v
        * @param {Number} alpha distance along the line (alpha = 0 will be this vector, and alpha = 1 will be the given one).
        * @return {me.Vector3d} Reference to this object for method chaining
        */ lerp: function lerp(v, alpha) {
                this.x += (v.x - this.x) * alpha;
                this.y += (v.y - this.y) * alpha;
                this.z += (v.z - this.z) * alpha;
                return this;
            },
            /**
        * return the distance between this vector and the passed one
        * @name distance
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v
        * @return {Number}
        */ distance: function distance(v) {
                var dx = this.x - v.x;
                var dy = this.y - v.y;
                var dz = this.z - (v.z || 0);
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            },
            /**
        * return the angle between this vector and the passed one
        * @name angle
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v
        * @return {Number} angle in radians
        */ angle: function angle(v) {
                return Math.acos(me.Math.clamp(this.dotProduct(v) / (this.length() * v.length()), -1, 1));
            },
            /**
        * project this vector on to another vector.
        * @name project
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v The vector to project onto.
        * @return {me.Vector3d} Reference to this object for method chaining
        */ project: function project(v) {
                var ratio = this.dotProduct(v) / v.length2();
                return this.scale(ratio, ratio, ratio);
            },
            /**
        * Project this vector onto a vector of unit length.<br>
        * This is slightly more efficient than `project` when dealing with unit vectors.
        * @name projectN
        * @memberOf me.Vector3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v The unit vector to project onto.
        * @return {me.Vector3d} Reference to this object for method chaining
        */ projectN: function projectN(v) {
                var ratio = this.dotProduct(v) / v.length2();
                return this.scale(ratio, ratio, ratio);
            },
            /**
        * return a clone copy of this vector
        * @name clone
        * @memberOf me.Vector3d
        * @function
        * @return {me.Vector3d} new me.Vector3d
        */ clone: function clone() {
                return me.pool.pull("me.Vector3d", this.x, this.y, this.z);
            },
            /**
        * convert the object to a string representation
        * @name toString
        * @memberOf me.Vector3d
        * @function
        * @return {String}
        */ toString: function toString() {
                return "x:" + this.x + ",y:" + this.y + ",z:" + this.z;
            }
        });
    })();
    (function() {
        /**
      * A Vector2d object that provide notification by executing the given callback when the vector is changed.
      * @class
      * @extends me.Vector2d
      * @constructor
      * @param {Number} [x=0] x value of the vector
      * @param {Number} [y=0] y value of the vector
      * @param {Object} settings additional required parameters
      * @param {Function} settings.onUpdate the callback to be executed when the vector is changed
      */ me.ObservableVector2d = me.Vector2d.extend({
            /**
        * @ignore
        */ init: function init(x, y, settings) {
                /**
          * x value of the vector
          * @public
          * @type Number
          * @name x
          * @memberOf me.ObservableVector2d
          */ Object.defineProperty(this, "x", {
                    /**
            * @ignore
            */ get: function get() {
                        return this._x;
                    },
                    /**
            * @ignore
            */ set: function set(value) {
                        var ret = this.onUpdate(value, this._y, this._x, this._y);
                        if (ret && "x" in ret) this._x = ret.x;
                        else this._x = value;
                    },
                    configurable: true
                });
                /**
          * y value of the vector
          * @public
          * @type Number
          * @name y
          * @memberOf me.ObservableVector2d
          */ Object.defineProperty(this, "y", {
                    /**
            * @ignore
            */ get: function get() {
                        return this._y;
                    },
                    /**
            * @ignore
            */ set: function set(value) {
                        var ret = this.onUpdate(this._x, value, this._x, this._y);
                        if (ret && "y" in ret) this._y = ret.y;
                        else this._y = value;
                    },
                    configurable: true
                });
                if (typeof settings === "undefined") throw new Error("undefined `onUpdate` callback");
                this.setCallback(settings.onUpdate);
                this._x = x || 0;
                this._y = y || 0;
            },
            /** @ignore */ _set: function _set(x, y) {
                var ret = this.onUpdate(x, y, this._x, this._y);
                if (ret && "x" in ret && "y" in ret) {
                    this._x = ret.x;
                    this._y = ret.y;
                } else {
                    this._x = x;
                    this._y = y;
                }
                return this;
            },
            /**
        * set the vector value without triggering the callback
        * @name setMuted
        * @memberOf me.ObservableVector2d
        * @function
        * @param {Number} x x value of the vector
        * @param {Number} y y value of the vector
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ setMuted: function setMuted(x, y) {
                this._x = x;
                this._y = y;
                return this;
            },
            /**
        * set the callback to be executed when the vector is changed
        * @name setCallback
        * @memberOf me.ObservableVector2d
        * @function
        * @param {function} onUpdate callback
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ setCallback: function setCallback(fn) {
                if (typeof fn !== "function") throw new Error("invalid `onUpdate` callback");
                this.onUpdate = fn;
                return this;
            },
            /**
        * Add the passed vector to this vector
        * @name add
        * @memberOf me.ObservableVector2d
        * @function
        * @param {me.ObservableVector2d} v
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ add: function add(v) {
                return this._set(this._x + v.x, this._y + v.y);
            },
            /**
        * Substract the passed vector to this vector
        * @name sub
        * @memberOf me.ObservableVector2d
        * @function
        * @param {me.ObservableVector2d} v
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ sub: function sub(v) {
                return this._set(this._x - v.x, this._y - v.y);
            },
            /**
        * Multiply this vector values by the given scalar
        * @name scale
        * @memberOf me.ObservableVector2d
        * @function
        * @param {Number} x
        * @param {Number} [y=x]
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ scale: function scale(x, y) {
                return this._set(this._x * x, this._y * (typeof y !== "undefined" ? y : x));
            },
            /**
        * Multiply this vector values by the passed vector
        * @name scaleV
        * @memberOf me.ObservableVector2d
        * @function
        * @param {me.ObservableVector2d} v
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ scaleV: function scaleV(v) {
                return this._set(this._x * v.x, this._y * v.y);
            },
            /**
        * Divide this vector values by the passed value
        * @name div
        * @memberOf me.ObservableVector2d
        * @function
        * @param {Number} value
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ div: function div(n) {
                return this._set(this._x / n, this._y / n);
            },
            /**
        * Update this vector values to absolute values
        * @name abs
        * @memberOf me.ObservableVector2d
        * @function
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ abs: function abs() {
                return this._set(this._x < 0 ? -this._x : this._x, this._y < 0 ? -this._y : this._y);
            },
            /**
        * Clamp the vector value within the specified value range
        * @name clamp
        * @memberOf me.ObservableVector2d
        * @function
        * @param {Number} low
        * @param {Number} high
        * @return {me.ObservableVector2d} new me.ObservableVector2d
        */ clamp: function clamp(low, high) {
                return new me.ObservableVector2d(me.Math.clamp(this.x, low, high), me.Math.clamp(this.y, low, high), {
                    onUpdate: this.onUpdate
                });
            },
            /**
        * Clamp this vector value within the specified value range
        * @name clampSelf
        * @memberOf me.ObservableVector2d
        * @function
        * @param {Number} low
        * @param {Number} high
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ clampSelf: function clampSelf(low, high) {
                return this._set(me.Math.clamp(this._x, low, high), me.Math.clamp(this._y, low, high));
            },
            /**
        * Update this vector with the minimum value between this and the passed vector
        * @name minV
        * @memberOf me.ObservableVector2d
        * @function
        * @param {me.ObservableVector2d} v
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ minV: function minV(v) {
                return this._set(this._x < v.x ? this._x : v.x, this._y < v.y ? this._y : v.y);
            },
            /**
        * Update this vector with the maximum value between this and the passed vector
        * @name maxV
        * @memberOf me.ObservableVector2d
        * @function
        * @param {me.ObservableVector2d} v
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ maxV: function maxV(v) {
                return this._set(this._x > v.x ? this._x : v.x, this._y > v.y ? this._y : v.y);
            },
            /**
        * Floor the vector values
        * @name floor
        * @memberOf me.ObservableVector2d
        * @function
        * @return {me.ObservableVector2d} new me.ObservableVector2d
        */ floor: function floor() {
                return new me.ObservableVector2d(Math.floor(this._x), Math.floor(this._y), {
                    onUpdate: this.onUpdate
                });
            },
            /**
        * Floor this vector values
        * @name floorSelf
        * @memberOf me.ObservableVector2d
        * @function
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ floorSelf: function floorSelf() {
                return this._set(Math.floor(this._x), Math.floor(this._y));
            },
            /**
        * Ceil the vector values
        * @name ceil
        * @memberOf me.ObservableVector2d
        * @function
        * @return {me.ObservableVector2d} new me.ObservableVector2d
        */ ceil: function ceil() {
                return new me.ObservableVector2d(Math.ceil(this._x), Math.ceil(this._y), {
                    onUpdate: this.onUpdate
                });
            },
            /**
        * Ceil this vector values
        * @name ceilSelf
        * @memberOf me.ObservableVector2d
        * @function
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ ceilSelf: function ceilSelf() {
                return this._set(Math.ceil(this._x), Math.ceil(this._y));
            },
            /**
        * Negate the vector values
        * @name negate
        * @memberOf me.ObservableVector2d
        * @function
        * @return {me.ObservableVector2d} new me.ObservableVector2d
        */ negate: function negate() {
                return new me.ObservableVector2d(-this._x, -this._y, {
                    onUpdate: this.onUpdate
                });
            },
            /**
        * Negate this vector values
        * @name negateSelf
        * @memberOf me.ObservableVector2d
        * @function
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ negateSelf: function negateSelf() {
                return this._set(-this._x, -this._y);
            },
            /**
        * Copy the x,y values of the passed vector to this one
        * @name copy
        * @memberOf me.ObservableVector2d
        * @function
        * @param {me.ObservableVector2d} v
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ copy: function copy(v) {
                return this._set(v.x, v.y);
            },
            /**
        * return true if the two vectors are the same
        * @name equals
        * @memberOf me.ObservableVector2d
        * @function
        * @param {me.ObservableVector2d} v
        * @return {Boolean}
        */ equals: function equals(v) {
                return this._x === v.x && this._y === v.y;
            },
            /**
        * change this vector to be perpendicular to what it was before.<br>
        * (Effectively rotates it 90 degrees in a clockwise direction)
        * @name perp
        * @memberOf me.ObservableVector2d
        * @function
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ perp: function perp() {
                return this._set(this._y, -this._x);
            },
            /**
        * Rotate this vector (counter-clockwise) by the specified angle (in radians).
        * @name rotate
        * @memberOf me.ObservableVector2d
        * @function
        * @param {number} angle The angle to rotate (in radians)
        * @param {me.Vector2d|me.ObservableVector2d} [v] an optional point to rotate around
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ rotate: function rotate(angle, v) {
                var cx = 0;
                var cy = 0;
                if (_typeof(v) === "object") {
                    cx = v.x;
                    cy = v.y;
                }
                var x = this._x - cx;
                var y = this._y - cy;
                var c = Math.cos(angle);
                var s = Math.sin(angle);
                return this._set(x * c - y * s + cx, x * s + y * c + cy);
            },
            /**
        * return the dot product of this vector and the passed one
        * @name dotProduct
        * @memberOf me.ObservableVector2d
        * @function
        * @param {me.Vector2d|me.ObservableVector2d} v
        * @return {Number} The dot product.
        */ dotProduct: function dotProduct(v) {
                return this._x * v.x + this._y * v.y;
            },
            /**
        * Linearly interpolate between this vector and the given one.
        * @name lerp
        * @memberOf me.ObservableVector2d
        * @function
        * @param {me.Vector2d|me.ObservableVector2d} v
        * @param {Number} alpha distance along the line (alpha = 0 will be this vector, and alpha = 1 will be the given one).
        * @return {me.ObservableVector2d} Reference to this object for method chaining
        */ lerp: function lerp(v, alpha) {
                this._x += (v.x - this._x) * alpha;
                this._y += (v.y - this._y) * alpha;
                return this;
            },
            /**
        * return the distance between this vector and the passed one
        * @name distance
        * @memberOf me.ObservableVector2d
        * @function
        * @param {me.ObservableVector2d} v
        * @return {Number}
        */ distance: function distance(v) {
                return Math.sqrt((this._x - v.x) * (this._x - v.x) + (this._y - v.y) * (this._y - v.y));
            },
            /**
        * return a clone copy of this vector
        * @name clone
        * @memberOf me.ObservableVector2d
        * @function
        * @return {me.ObservableVector2d} new me.ObservableVector2d
        */ clone: function clone() {
                return me.pool.pull("me.ObservableVector2d", this._x, this._y, {
                    onUpdate: this.onUpdate
                });
            },
            /**
        * return a `me.Vector2d` copy of this `me.ObservableVector2d` object
        * @name toVector2d
        * @memberOf me.ObservableVector2d
        * @function
        * @return {me.Vector2d} new me.Vector2d
        */ toVector2d: function toVector2d() {
                return me.pool.pull("me.Vector2d", this._x, this._y);
            },
            /**
        * convert the object to a string representation
        * @name toString
        * @memberOf me.ObservableVector2d
        * @function
        * @return {String}
        */ toString: function toString() {
                return "x:" + this._x + ",y:" + this._y;
            }
        });
    })();
    (function() {
        /**
      * A Vector3d object that provide notification by executing the given callback when the vector is changed.
      * @class
      * @extends me.Vector3d
      * @constructor
      * @param {Number} [x=0] x value of the vector
      * @param {Number} [y=0] y value of the vector
      * @param {Number} [z=0] z value of the vector
      * @param {Object} settings additional required parameters
      * @param {Function} settings.onUpdate the callback to be executed when the vector is changed
      */ me.ObservableVector3d = me.Vector3d.extend({
            /**
        * @ignore
        */ init: function init(x, y, z, settings) {
                /**
          * x value of the vector
          * @public
          * @type Number
          * @name x
          * @memberOf me.ObservableVector3d
          */ Object.defineProperty(this, "x", {
                    /**
            * @ignore
            */ get: function get() {
                        return this._x;
                    },
                    /**
            * @ignore
            */ set: function set(value) {
                        var ret = this.onUpdate(value, this._y, this._z, this._x, this._y, this._z);
                        if (ret && "x" in ret) this._x = ret.x;
                        else this._x = value;
                    },
                    configurable: true
                });
                /**
          * y value of the vector
          * @public
          * @type Number
          * @name y
          * @memberOf me.ObservableVector3d
          */ Object.defineProperty(this, "y", {
                    /**
            * @ignore
            */ get: function get() {
                        return this._y;
                    },
                    /**
            * @ignore
            */ set: function set(value) {
                        var ret = this.onUpdate(this._x, value, this._z, this._x, this._y, this._z);
                        if (ret && "y" in ret) this._y = ret.y;
                        else this._y = value;
                    },
                    configurable: true
                });
                /**
          * z value of the vector
          * @public
          * @type Number
          * @name z
          * @memberOf me.ObservableVector3d
          */ Object.defineProperty(this, "z", {
                    /**
            * @ignore
            */ get: function get() {
                        return this._z;
                    },
                    /**
            * @ignore
            */ set: function set(value) {
                        var ret = this.onUpdate(this._x, this._y, value, this._x, this._y, this._z);
                        if (ret && "z" in ret) this._z = ret.z;
                        else this._z = value;
                    },
                    configurable: true
                });
                if (typeof settings === "undefined") throw new Error("undefined `onUpdate` callback");
                this.setCallback(settings.onUpdate);
                this._x = x || 0;
                this._y = y || 0;
                this._z = z || 0;
            },
            /**
        * @ignore */ _set: function _set(x, y, z) {
                var ret = this.onUpdate(x, y, z, this._x, this._y, this._z);
                if (ret && "x" in ret && "y" in ret && "z" in ret) {
                    this._x = ret.x;
                    this._y = ret.y;
                    this._z = ret.z;
                } else {
                    this._x = x;
                    this._y = y;
                    this._z = z || 0;
                }
                return this;
            },
            /**
        * set the vector value without triggering the callback
        * @name setMuted
        * @memberOf me.ObservableVector3d
        * @function
        * @param {Number} x x value of the vector
        * @param {Number} y y value of the vector
        * @param {Number} [z=0] z value of the vector
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ setMuted: function setMuted(x, y, z) {
                this._x = x;
                this._y = y;
                this._z = z || 0;
                return this;
            },
            /**
        * set the callback to be executed when the vector is changed
        * @name setCallback
        * @memberOf me.ObservableVector3d
        * @function
        * @param {function} onUpdate callback
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ setCallback: function setCallback(fn) {
                if (typeof fn !== "function") throw new Error("invalid `onUpdate` callback");
                this.onUpdate = fn;
                return this;
            },
            /**
        * Add the passed vector to this vector
        * @name add
        * @memberOf me.ObservableVector3d
        * @function
        * @param {me.Vector2d|me.Vector3d|me.ObservableVector2d|me.ObservableVector3d} v
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ add: function add(v) {
                return this._set(this._x + v.x, this._y + v.y, this._z + (v.z || 0));
            },
            /**
        * Substract the passed vector to this vector
        * @name sub
        * @memberOf me.ObservableVector3d
        * @function
        * @param {me.Vector2d|me.Vector3d|me.ObservableVector2d|me.ObservableVector3d} v
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ sub: function sub(v) {
                return this._set(this._x - v.x, this._y - v.y, this._z - (v.z || 0));
            },
            /**
        * Multiply this vector values by the given scalar
        * @name scale
        * @memberOf me.ObservableVector3d
        * @function
        * @param {Number} x
        * @param {Number} [y=x]
        * @param {Number} [z=1]
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ scale: function scale(x, y, z) {
                y = typeof y !== "undefined" ? y : x;
                return this._set(this._x * x, this._y * y, this._z * (z || 1));
            },
            /**
        * Multiply this vector values by the passed vector
        * @name scaleV
        * @memberOf me.ObservableVector3d
        * @function
        * @param {me.Vector2d|me.Vector3d|me.ObservableVector2d|me.ObservableVector3d} v
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ scaleV: function scaleV(v) {
                return this._set(this._x * v.x, this._y * v.y, this._z * (v.z || 1));
            },
            /**
        * Divide this vector values by the passed value
        * @name div
        * @memberOf me.ObservableVector3d
        * @function
        * @param {Number} value
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ div: function div(n) {
                return this._set(this._x / n, this._y / n, this._z / n);
            },
            /**
        * Update this vector values to absolute values
        * @name abs
        * @memberOf me.ObservableVector3d
        * @function
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ abs: function abs() {
                return this._set(this._x < 0 ? -this._x : this._x, this._y < 0 ? -this._y : this._y, this._Z < 0 ? -this._z : this._z);
            },
            /**
        * Clamp the vector value within the specified value range
        * @name clamp
        * @memberOf me.ObservableVector3d
        * @function
        * @param {Number} low
        * @param {Number} high
        * @return {me.ObservableVector3d} new me.ObservableVector3d
        */ clamp: function clamp(low, high) {
                return new me.ObservableVector3d(me.Math.clamp(this._x, low, high), me.Math.clamp(this._y, low, high), me.Math.clamp(this._z, low, high), {
                    onUpdate: this.onUpdate
                });
            },
            /**
        * Clamp this vector value within the specified value range
        * @name clampSelf
        * @memberOf me.ObservableVector3d
        * @function
        * @param {Number} low
        * @param {Number} high
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ clampSelf: function clampSelf(low, high) {
                return this._set(me.Math.clamp(this._x, low, high), me.Math.clamp(this._y, low, high), me.Math.clamp(this._z, low, high));
            },
            /**
        * Update this vector with the minimum value between this and the passed vector
        * @name minV
        * @memberOf me.ObservableVector3d
        * @function
        * @param {me.Vector2d|me.Vector3d|me.ObservableVector2d|me.ObservableVector3d} v
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ minV: function minV(v) {
                var _vz = v.z || 0;
                return this._set(this._x < v.x ? this._x : v.x, this._y < v.y ? this._y : v.y, this._z < _vz ? this._z : _vz);
            },
            /**
        * Update this vector with the maximum value between this and the passed vector
        * @name maxV
        * @memberOf me.ObservableVector3d
        * @function
        * @param {me.Vector2d|me.Vector3d|me.ObservableVector2d|me.ObservableVector3d} v
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ maxV: function maxV(v) {
                var _vz = v.z || 0;
                return this._set(this._x > v.x ? this._x : v.x, this._y > v.y ? this._y : v.y, this._z > _vz ? this._z : _vz);
            },
            /**
        * Floor the vector values
        * @name floor
        * @memberOf me.ObservableVector3d
        * @function
        * @return {me.ObservableVector3d} new me.ObservableVector3d
        */ floor: function floor() {
                return new me.ObservableVector3d(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z), {
                    onUpdate: this.onUpdate
                });
            },
            /**
        * Floor this vector values
        * @name floorSelf
        * @memberOf me.ObservableVector3d
        * @function
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ floorSelf: function floorSelf() {
                return this._set(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
            },
            /**
        * Ceil the vector values
        * @name ceil
        * @memberOf me.ObservableVector3d
        * @function
        * @return {me.ObservableVector3d} new me.ObservableVector3d
        */ ceil: function ceil() {
                return new me.ObservableVector3d(Math.ceil(this._x), Math.ceil(this._y), Math.ceil(this._z), {
                    onUpdate: this.onUpdate
                });
            },
            /**
        * Ceil this vector values
        * @name ceilSelf
        * @memberOf me.ObservableVector3d
        * @function
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ ceilSelf: function ceilSelf() {
                return this._set(Math.ceil(this._x), Math.ceil(this._y), Math.ceil(this._z));
            },
            /**
        * Negate the vector values
        * @name negate
        * @memberOf me.ObservableVector3d
        * @function
        * @return {me.ObservableVector3d} new me.ObservableVector3d
        */ negate: function negate() {
                return new me.ObservableVector3d(-this._x, -this._y, -this._z, {
                    onUpdate: this.onUpdate
                });
            },
            /**
        * Negate this vector values
        * @name negateSelf
        * @memberOf me.ObservableVector3d
        * @function
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ negateSelf: function negateSelf() {
                return this._set(-this._x, -this._y, -this._z);
            },
            /**
        * Copy the components of the given vector into this one
        * @name copy
        * @memberOf me.ObservableVector3d
        * @function
        * @param {me.Vector2d|me.Vector3d|me.ObservableVector2d|me.ObservableVector3d} v
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ copy: function copy(v) {
                return this._set(v.x, v.y, v.z || 0);
            },
            /**
        * return true if the two vectors are the same
        * @name equals
        * @memberOf me.ObservableVector3d
        * @function
        * @param {me.Vector2d|me.Vector3d|me.ObservableVector2d|me.ObservableVector3d} v
        * @return {Boolean}
        */ equals: function equals(v) {
                return this._x === v.x && this._y === v.y && this._z === (v.z || this._z);
            },
            /**
        * change this vector to be perpendicular to what it was before.<br>
        * (Effectively rotates it 90 degrees in a clockwise direction)
        * @name perp
        * @memberOf me.ObservableVector3d
        * @function
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ perp: function perp() {
                return this._set(this._y, -this._x, this._z);
            },
            /**
        * Rotate this vector (counter-clockwise) by the specified angle (in radians).
        * @name rotate
        * @memberOf me.ObservableVector3d
        * @function
        * @param {number} angle The angle to rotate (in radians)
        * @param {me.Vector2d|me.ObservableVector2d} [v] an optional point to rotate around (on the same z axis)
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ rotate: function rotate(angle, v) {
                var cx = 0;
                var cy = 0;
                if (_typeof(v) === "object") {
                    cx = v.x;
                    cy = v.y;
                } // TODO also rotate on the z axis if the given vector is a 3d one
                var x = this.x - cx;
                var y = this.y - cy;
                var c = Math.cos(angle);
                var s = Math.sin(angle);
                return this._set(x * c - y * s + cx, x * s + y * c + cy, this.z);
            },
            /**
        * return the dot product of this vector and the passed one
        * @name dotProduct
        * @memberOf me.ObservableVector3d
        * @function
        * @param {me.Vector2d|me.Vector3d|me.ObservableVector2d|me.ObservableVector3d} v
        * @return {Number} The dot product.
        */ dotProduct: function dotProduct(v) {
                return this._x * v.x + this._y * v.y + this._z * (v.z || 1);
            },
            /**
        * Linearly interpolate between this vector and the given one.
        * @name lerp
        * @memberOf me.ObservableVector3d
        * @function
        * @param {me.Vector3d|me.ObservableVector3d} v
        * @param {Number} alpha distance along the line (alpha = 0 will be this vector, and alpha = 1 will be the given one).
        * @return {me.ObservableVector3d} Reference to this object for method chaining
        */ lerp: function lerp(v, alpha) {
                this._x += (v.x - this._x) * alpha;
                this._y += (v.y - this._y) * alpha;
                this._z += (v.z - this._z) * alpha;
                return this;
            },
            /**
        * return the distance between this vector and the passed one
        * @name distance
        * @memberOf me.ObservableVector3d
        * @function
        * @param {me.Vector2d|me.Vector3d|me.ObservableVector2d|me.ObservableVector3d} v
        * @return {Number}
        */ distance: function distance(v) {
                var dx = this._x - v.x;
                var dy = this._y - v.y;
                var dz = this._z - (v.z || 0);
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            },
            /**
        * return a clone copy of this vector
        * @name clone
        * @memberOf me.ObservableVector3d
        * @function
        * @return {me.ObservableVector3d} new me.ObservableVector3d
        */ clone: function clone() {
                return me.pool.pull("me.ObservableVector3d", this._x, this._y, this._z, {
                    onUpdate: this.onUpdate
                });
            },
            /**
        * return a `me.Vector3d` copy of this `me.ObservableVector3d` object
        * @name toVector3d
        * @memberOf me.ObservableVector3d
        * @function
        * @return {me.Vector3d} new me.Vector3d
        */ toVector3d: function toVector3d() {
                return me.pool.pull("me.Vector3d", this._x, this._y, this._z);
            },
            /**
        * convert the object to a string representation
        * @name toString
        * @memberOf me.ObservableVector3d
        * @function
        * @return {String}
        */ toString: function toString() {
                return "x:" + this._x + ",y:" + this._y + ",z:" + this._z;
            }
        });
    })();
    (function() {
        /**
      * a Matrix2d Object.<br>
      * the identity matrix and parameters position : <br>
      * <img src="images/identity-matrix_2x.png"/>
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      * @param {me.Matrix2d} [mat2d] An instance of me.Matrix2d to copy from
      * @param {Number[]} [arguments...] Matrix elements. See {@link me.Matrix2d.setTransform}
      */ me.Matrix2d = me.Object.extend({
            /**
        * @ignore
        */ init: function init() {
                if (typeof this.val === "undefined") this.val = new Float32Array(9);
                if (arguments.length && arguments[0] instanceof me.Matrix2d) this.copy(arguments[0]);
                else if (arguments.length && arguments[0] instanceof me.Matrix3d) this.fromMat3d(arguments[0]);
                else if (arguments.length >= 6) this.setTransform.apply(this, arguments);
                else this.identity();
            },
            /**
        * reset the transformation matrix to the identity matrix (no transformation).<br>
        * the identity matrix and parameters position : <br>
        * <img src="images/identity-matrix_2x.png"/>
        * @name identity
        * @memberOf me.Matrix2d
        * @function
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ identity: function identity() {
                this.setTransform(1, 0, 0, 0, 1, 0, 0, 0, 1);
                return this;
            },
            /**
        * set the matrix to the specified value
        * @name setTransform
        * @memberOf me.Matrix2d
        * @function
        * @param {Number} a
        * @param {Number} b
        * @param {Number} c
        * @param {Number} d
        * @param {Number} e
        * @param {Number} f
        * @param {Number} [g=0]
        * @param {Number} [h=0]
        * @param {Number} [i=1]
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ setTransform: function setTransform() {
                var a = this.val;
                if (arguments.length === 9) {
                    a[0] = arguments[0]; // a - m00
                    a[1] = arguments[1]; // b - m10
                    a[2] = arguments[2]; // c - m20
                    a[3] = arguments[3]; // d - m01
                    a[4] = arguments[4]; // e - m11
                    a[5] = arguments[5]; // f - m21
                    a[6] = arguments[6]; // g - m02
                    a[7] = arguments[7]; // h - m12
                    a[8] = arguments[8]; // i - m22
                } else if (arguments.length === 6) {
                    a[0] = arguments[0]; // a
                    a[1] = arguments[2]; // c
                    a[2] = arguments[4]; // e
                    a[3] = arguments[1]; // b
                    a[4] = arguments[3]; // d
                    a[5] = arguments[5]; // f
                    a[6] = 0; // g
                    a[7] = 0; // h
                    a[8] = 1; // i
                }
                return this;
            },
            /**
        * Copies over the values from another me.Matrix2d.
        * @name copy
        * @memberOf me.Matrix2d
        * @function
        * @param {me.Matrix2d} m the matrix object to copy from
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ copy: function copy(b) {
                this.val.set(b.val);
                return this;
            },
            /**
        * Copies over the upper-left 3x3 values from the given me.Matrix3d
        * @name fromMat3d
        * @memberOf me.Matrix2d
        * @function
        * @param {me.Matrix3d} m the matrix object to copy from
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ fromMat3d: function fromMat3d(b) {
                b = b.val;
                var a = this.val;
                a[0] = b[0];
                a[1] = b[1];
                a[2] = b[2];
                a[3] = b[4];
                a[4] = b[5];
                a[5] = b[6];
                a[6] = b[8];
                a[7] = b[9];
                a[8] = b[10];
                return this;
            },
            /**
        * multiply both matrix
        * @name multiply
        * @memberOf me.Matrix2d
        * @function
        * @param {me.Matrix2d} b Other matrix
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ multiply: function multiply(b) {
                b = b.val;
                var a = this.val, a0 = a[0], a1 = a[1], a3 = a[3], a4 = a[4], b0 = b[0], b1 = b[1], b3 = b[3], b4 = b[4], b6 = b[6], b7 = b[7];
                a[0] = a0 * b0 + a3 * b1;
                a[1] = a1 * b0 + a4 * b1;
                a[3] = a0 * b3 + a3 * b4;
                a[4] = a1 * b3 + a4 * b4;
                a[6] += a0 * b6 + a3 * b7;
                a[7] += a1 * b6 + a4 * b7;
                return this;
            },
            /**
        * Transpose the value of this matrix.
        * @name transpose
        * @memberOf me.Matrix2d
        * @function
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ transpose: function transpose() {
                var a = this.val, a1 = a[1], a2 = a[2], a5 = a[5];
                a[1] = a[3];
                a[2] = a[6];
                a[3] = a1;
                a[5] = a[7];
                a[6] = a2;
                a[7] = a5;
                return this;
            },
            /**
        * invert this matrix, causing it to apply the opposite transformation.
        * @name invert
        * @memberOf me.Matrix2d
        * @function
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ invert: function invert() {
                var val = this.val;
                var a = val[0], b = val[1], c = val[2], d = val[3], e = val[4], f = val[5], g = val[6], h = val[7], i = val[8];
                var ta = i * e - f * h, td = f * g - i * d, tg = h * d - e * g;
                var n = a * ta + b * td + c * tg;
                val[0] = ta / n;
                val[1] = (c * h - i * b) / n;
                val[2] = (f * b - c * e) / n;
                val[3] = td / n;
                val[4] = (i * a - c * g) / n;
                val[5] = (c * d - f * a) / n;
                val[6] = tg / n;
                val[7] = (b * g - h * a) / n;
                val[8] = (e * a - b * d) / n;
                return this;
            },
            /**
        * apply the current transform to the given 2d vector
        * @name apply
        * @memberOf me.Matrix2d
        * @function
        * @param {me.Vector2d} vector the vector object to be transformed
        * @return {me.Vector2d} result vector object.
        */ apply: function apply(v) {
                var a = this.val, x = v.x, y = v.y;
                v.x = x * a[0] + y * a[3] + a[6];
                v.y = x * a[1] + y * a[4] + a[7];
                return v;
            },
            /**
        * apply the inverted current transform to the given 2d vector
        * @name applyInverse
        * @memberOf me.Matrix2d
        * @function
        * @param {me.Vector2d} vector the vector object to be transformed
        * @return {me.Vector2d} result vector object.
        */ applyInverse: function applyInverse(v) {
                var a = this.val, x = v.x, y = v.y;
                var invD = 1 / (a[0] * a[4] + a[3] * -a[1]);
                v.x = a[4] * invD * x + -a[3] * invD * y + (a[7] * a[3] - a[6] * a[4]) * invD;
                v.y = a[0] * invD * y + -a[1] * invD * x + (-a[7] * a[0] + a[6] * a[1]) * invD;
                return v;
            },
            /**
        * scale the matrix
        * @name scale
        * @memberOf me.Matrix2d
        * @function
        * @param {Number} x a number representing the abscissa of the scaling vector.
        * @param {Number} [y=x] a number representing the ordinate of the scaling vector.
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ scale: function scale(x, y) {
                var a = this.val, _x = x, _y = typeof y === "undefined" ? _x : y;
                a[0] *= _x;
                a[1] *= _x;
                a[3] *= _y;
                a[4] *= _y;
                return this;
            },
            /**
        * adds a 2D scaling transformation.
        * @name scaleV
        * @memberOf me.Matrix2d
        * @function
        * @param {me.Vector2d} vector scaling vector
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ scaleV: function scaleV(v) {
                return this.scale(v.x, v.y);
            },
            /**
        * specifies a 2D scale operation using the [sx, 1] scaling vector
        * @name scaleX
        * @memberOf me.Matrix2d
        * @function
        * @param {Number} x x scaling vector
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ scaleX: function scaleX(x) {
                return this.scale(x, 1);
            },
            /**
        * specifies a 2D scale operation using the [1,sy] scaling vector
        * @name scaleY
        * @memberOf me.Matrix2d
        * @function
        * @param {Number} y y scaling vector
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ scaleY: function scaleY(y) {
                return this.scale(1, y);
            },
            /**
        * rotate the matrix (counter-clockwise) by the specified angle (in radians).
        * @name rotate
        * @memberOf me.Matrix2d
        * @function
        * @param {Number} angle Rotation angle in radians.
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ rotate: function rotate(angle) {
                if (angle !== 0) {
                    var a = this.val, a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], s = Math.sin(angle), c = Math.cos(angle);
                    a[0] = c * a00 + s * a10;
                    a[1] = c * a01 + s * a11;
                    a[2] = c * a02 + s * a12;
                    a[3] = c * a10 - s * a00;
                    a[4] = c * a11 - s * a01;
                    a[5] = c * a12 - s * a02;
                }
                return this;
            },
            /**
        * translate the matrix position on the horizontal and vertical axis
        * @name translate
        * @memberOf me.Matrix2d
        * @function
        * @param {Number} x the x coordindates to translate the matrix by
        * @param {Number} y the y coordindates to translate the matrix by
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ translate: function translate(x, y) {
                var a = this.val;
                a[6] += a[0] * x + a[3] * y;
                a[7] += a[1] * x + a[4] * y;
                return this;
            },
            /**
        * translate the matrix by a vector on the horizontal and vertical axis
        * @name translateV
        * @memberOf me.Matrix2d
        * @function
        * @param {me.Vector2d} v the vector to translate the matrix by
        * @return {me.Matrix2d} Reference to this object for method chaining
        */ translateV: function translateV(v) {
                return this.translate(v.x, v.y);
            },
            /**
        * returns true if the matrix is an identity matrix.
        * @name isIdentity
        * @memberOf me.Matrix2d
        * @function
        * @return {Boolean}
        **/ isIdentity: function isIdentity() {
                var a = this.val;
                return a[0] === 1 && a[1] === 0 && a[2] === 0 && a[3] === 0 && a[4] === 1 && a[5] === 0 && a[6] === 0 && a[7] === 0 && a[8] === 1;
            },
            /**
        * return true if the two matrices are identical
        * @name equals
        * @memberOf me.Matrix2d
        * @function
        * @param {me.Matrix2d} b the other matrix
        * @return {Boolean} true if both are equals
        */ equals: function equals(b) {
                b = b.val;
                var a = this.val;
                return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
            },
            /**
        * Clone the Matrix
        * @name clone
        * @memberOf me.Matrix2d
        * @function
        * @return {me.Matrix2d}
        */ clone: function clone() {
                return me.pool.pull("me.Matrix2d", this);
            },
            /**
        * return an array representation of this Matrix
        * @name toArray
        * @memberOf me.Matrix2d
        * @function
        * @return {Float32Array}
        */ toArray: function toArray() {
                return this.val;
            },
            /**
        * convert the object to a string representation
        * @name toString
        * @memberOf me.Matrix2d
        * @function
        * @return {String}
        */ toString: function toString() {
                var a = this.val;
                return "me.Matrix2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
            }
        });
        /**
      * tx component of the matrix
      * @public
      * @type {Number}
      * @readonly
      * @see me.Matrix2d.translate
      * @name tx
      * @memberOf me.Matrix2d
      */ Object.defineProperty(me.Matrix2d.prototype, "tx", {
            /**
        * @ignore
        */ get: function get() {
                return this.val[6];
            },
            configurable: true
        });
        /**
      * ty component of the matrix
      * @public
      * @type {Number}
      * @readonly
      * @see me.Matrix2d.translate
      * @name ty
      * @memberOf me.Matrix2d
      */ Object.defineProperty(me.Matrix2d.prototype, "ty", {
            /**
        * @ignore
        */ get: function get() {
                return this.val[7];
            },
            configurable: true
        });
    })();
    (function() {
        /**
      * a 4x4 Matrix3d Object<br>
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      * @param {me.Matrix3d} [mat3d] An instance of me.Matrix3d to copy from
      * @param {Number[]} [arguments...] Matrix elements. See {@link me.Matrix3d.setTransform}
      */ me.Matrix3d = me.Object.extend({
            /**
        * @ignore
        */ init: function init() {
                if (typeof this.val === "undefined") this.val = new Float32Array(16);
                if (arguments.length && arguments[0] instanceof me.Matrix3d) this.copy(arguments[0]);
                else if (arguments.length === 16) this.setTransform.apply(this, arguments);
                else this.identity();
            },
            /**
        * reset the transformation matrix to the identity matrix (no transformation).<br>
        * the identity matrix and parameters position : <br>
        * <img src="images/identity-matrix_2x.png"/>
        * @name identity
        * @memberOf me.Matrix3d
        * @function
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ identity: function identity() {
                return this.setTransform(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            },
            /**
        * set the matrix to the specified value
        * @name setTransform
        * @memberOf me.Matrix3d
        * @function
        * @param {Number} m00
        * @param {Number} m01
        * @param {Number} m02
        * @param {Number} m03
        * @param {Number} m10
        * @param {Number} m11
        * @param {Number} m12
        * @param {Number} m13
        * @param {Number} m20
        * @param {Number} m21
        * @param {Number} m22
        * @param {Number} m23
        * @param {Number} m30
        * @param {Number} m31
        * @param {Number} m32
        * @param {Number} m33
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ setTransform: function setTransform(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
                var a = this.val;
                a[0] = m00;
                a[1] = m01;
                a[2] = m02;
                a[3] = m03;
                a[4] = m10;
                a[5] = m11;
                a[6] = m12;
                a[7] = m13;
                a[8] = m20;
                a[9] = m21;
                a[10] = m22;
                a[11] = m23;
                a[12] = m30;
                a[13] = m31;
                a[14] = m32;
                a[15] = m33;
                return this;
            },
            /**
        * Copies over the values from another me.Matrix3d.
        * @name copy
        * @memberOf me.Matrix3d
        * @function
        * @param {me.Matrix3d} m the matrix object to copy from
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ copy: function copy(b) {
                this.val.set(b.val);
                return this;
            },
            /**
        * multiply both matrix
        * @name multiply
        * @memberOf me.Matrix3d
        * @function
        * @param {me.Matrix3d} b Other matrix
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ multiply: function multiply(b) {
                var a = this.val;
                var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                b = b.val;
                var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b[4];
                b1 = b[5];
                b2 = b[6];
                b3 = b[7];
                a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b[8];
                b1 = b[9];
                b2 = b[10];
                b3 = b[11];
                a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b[12];
                b1 = b[13];
                b2 = b[14];
                b3 = b[15];
                a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                return this;
            },
            /**
        * Transpose the value of this matrix.
        * @name transpose
        * @memberOf me.Matrix3d
        * @function
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ transpose: function transpose() {
                var a = this.val, a01 = a[1], a02 = a[2], a03 = a[3], a12 = a[6], a13 = a[7], a23 = a[11];
                a[1] = a[4];
                a[2] = a[8];
                a[3] = a[12];
                a[4] = a01;
                a[6] = a[9];
                a[7] = a[13];
                a[8] = a02;
                a[9] = a12;
                a[11] = a[14];
                a[12] = a03;
                a[13] = a13;
                a[14] = a23;
                return this;
            },
            /**
        * invert this matrix, causing it to apply the opposite transformation.
        * @name invert
        * @memberOf me.Matrix3d
        * @function
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ invert: function invert() {
                var a = this.val;
                var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                var b00 = a00 * a11 - a01 * a10;
                var b01 = a00 * a12 - a02 * a10;
                var b02 = a00 * a13 - a03 * a10;
                var b03 = a01 * a12 - a02 * a11;
                var b04 = a01 * a13 - a03 * a11;
                var b05 = a02 * a13 - a03 * a12;
                var b06 = a20 * a31 - a21 * a30;
                var b07 = a20 * a32 - a22 * a30;
                var b08 = a20 * a33 - a23 * a30;
                var b09 = a21 * a32 - a22 * a31;
                var b10 = a21 * a33 - a23 * a31;
                var b11 = a22 * a33 - a23 * a32; // Calculate the determinant
                var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) return null;
                det = 1 / det;
                a[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                a[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                a[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                a[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                a[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                a[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                a[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                a[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                a[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                a[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                a[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                a[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                a[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                a[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                a[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                a[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                return this;
            },
            /**
        * apply the current transform to the given 3d vector
        * @name apply
        * @memberOf me.Matrix3d
        * @function
        * @param {me.Vector3d} vector the vector object to be transformed
        * @return {me.Vector3d} result vector object.
        */ apply: function apply(v) {
                var a = this.val, x = v.x, y = v.y, z = v.z;
                var w = a[3] * x + a[7] * y + a[11] * z + a[15] || 1;
                v.x = (a[0] * x + a[4] * y + a[8] * z + a[12]) / w;
                v.y = (a[1] * x + a[5] * y + a[9] * z + a[13]) / w;
                v.z = (a[2] * x + a[6] * y + a[10] * z + a[14]) / w;
                return v;
            },
            /**
        * apply the inverted current transform to the given 3d vector
        * @name applyInverse
        * @memberOf me.Matrix3d
        * @function
        * @param {me.Vector3d} vector the vector object to be transformed
        * @return {me.Vector3d} result vector object.
        */ applyInverse: function applyInverse(v) {
                // XXX : TODO
                return v;
            },
            /**
        * generate an orthogonal projection matrix, with the result replacing the current matrix
        * <img src="images/glOrtho.gif"/><br>
        * @name ortho
        * @memberOf me.Matrix3d
        * @function
        * @param {Number} left farthest left on the x-axis
        * @param {Number} right farthest right on the x-axis
        * @param {Number} bottom farthest down on the y-axis
        * @param {Number} top farthest up on the y-axis
        * @param {Number} near distance to the near clipping plane along the -Z axis
        * @param {Number} far distance to the far clipping plane along the -Z axis
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ ortho: function ortho(left, right, bottom, top, near, far) {
                var a = this.val;
                var leftRight = 1 / (left - right);
                var bottomTop = 1 / (bottom - top);
                var nearFar = 1 / (near - far);
                a[0] = -2 * leftRight;
                a[1] = 0;
                a[2] = 0;
                a[3] = 0;
                a[4] = 0;
                a[5] = -2 * bottomTop;
                a[6] = 0;
                a[7] = 0;
                a[8] = 0;
                a[9] = 0;
                a[10] = 2 * nearFar;
                a[11] = 0;
                a[12] = (left + right) * leftRight;
                a[13] = (top + bottom) * bottomTop;
                a[14] = (far + near) * nearFar;
                a[15] = 1;
                return this;
            },
            /**
        * scale the matrix
        * @name scale
        * @memberOf me.Matrix3d
        * @function
        * @param {Number} x a number representing the abscissa of the scaling vector.
        * @param {Number} [y=x] a number representing the ordinate of the scaling vector.
        * @param {Number} [z=0] a number representing the depth vector
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ scale: function scale(x, y, z) {
                var a = this.val, _x = x, _y = typeof y === "undefined" ? _x : y, _z = typeof z === "undefined" ? 0 : z;
                a[0] = a[0] * _x;
                a[1] = a[1] * _x;
                a[2] = a[2] * _x;
                a[3] = a[3] * _x;
                a[4] = a[4] * _y;
                a[5] = a[5] * _y;
                a[6] = a[6] * _y;
                a[7] = a[7] * _y;
                a[8] = a[8] * _z;
                a[9] = a[9] * _z;
                a[10] = a[10] * _z;
                a[11] = a[11] * _z;
                return this;
            },
            /**
        * adds a 2D scaling transformation.
        * @name scaleV
        * @memberOf me.Matrix3d
        * @function
        * @param {me.Vector2d|me.Vector3d} vector scaling vector
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ scaleV: function scaleV(v) {
                return this.scale(v.x, v.y, v.z);
            },
            /**
        * specifies a 2D scale operation using the [sx, 1] scaling vector
        * @name scaleX
        * @memberOf me.Matrix3d
        * @function
        * @param {Number} x x scaling vector
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ scaleX: function scaleX(x) {
                return this.scale(x, 1);
            },
            /**
        * specifies a 2D scale operation using the [1,sy] scaling vector
        * @name scaleY
        * @memberOf me.Matrix3d
        * @function
        * @param {Number} y y scaling vector
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ scaleY: function scaleY(y) {
                return this.scale(1, y);
            },
            /**
        * rotate this matrix (counter-clockwise) by the specified angle (in radians).
        * @name rotate
        * @memberOf me.Matrix3d
        * @function
        * @param {Number} angle Rotation angle in radians.
        * @param {me.Vector3d} axis the axis to rotate around
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ rotate: function rotate(angle, v) {
                var a = this.val, x = v.x, y = v.y, z = v.z;
                var len = Math.sqrt(x * x + y * y + z * z);
                var s, c, t;
                var a00, a01, a02, a03;
                var a10, a11, a12, a13;
                var a20, a21, a22, a23;
                var b00, b01, b02;
                var b10, b11, b12;
                var b20, b21, b22;
                if (len < me.Math.EPSILON) return null;
                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                s = Math.sin(angle);
                c = Math.cos(angle);
                t = 1 - c;
                a00 = a[0];
                a01 = a[1];
                a02 = a[2];
                a03 = a[3];
                a10 = a[4];
                a11 = a[5];
                a12 = a[6];
                a13 = a[7];
                a20 = a[8];
                a21 = a[9];
                a22 = a[10];
                a23 = a[11]; // Construct the elements of the rotation matrix
                b00 = x * x * t + c;
                b01 = y * x * t + z * s;
                b02 = z * x * t - y * s;
                b10 = x * y * t - z * s;
                b11 = y * y * t + c;
                b12 = z * y * t + x * s;
                b20 = x * z * t + y * s;
                b21 = y * z * t - x * s;
                b22 = z * z * t + c; // Perform rotation-specific matrix multiplication
                a[0] = a00 * b00 + a10 * b01 + a20 * b02;
                a[1] = a01 * b00 + a11 * b01 + a21 * b02;
                a[2] = a02 * b00 + a12 * b01 + a22 * b02;
                a[3] = a03 * b00 + a13 * b01 + a23 * b02;
                a[4] = a00 * b10 + a10 * b11 + a20 * b12;
                a[5] = a01 * b10 + a11 * b11 + a21 * b12;
                a[6] = a02 * b10 + a12 * b11 + a22 * b12;
                a[7] = a03 * b10 + a13 * b11 + a23 * b12;
                a[8] = a00 * b20 + a10 * b21 + a20 * b22;
                a[9] = a01 * b20 + a11 * b21 + a21 * b22;
                a[10] = a02 * b20 + a12 * b21 + a22 * b22;
                a[11] = a03 * b20 + a13 * b21 + a23 * b22;
                return this;
            },
            /**
        * translate the matrix position using the given vector
        * @name translate
        * @memberOf me.Matrix3d
        * @function
        * @param {Number} x a number representing the abscissa of the vector.
        * @param {Number} [y=x] a number representing the ordinate of the vector.
        * @param {Number} [z=0] a number representing the depth of the vector
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ translate: function translate(x, y, z) {
                var a = this.val, _x = x, _y = typeof y === "undefined" ? _x : y, _z = typeof z === "undefined" ? 0 : z;
                a[12] = a[0] * _x + a[4] * _y + a[8] * _z + a[12];
                a[13] = a[1] * _x + a[5] * _y + a[9] * _z + a[13];
                a[14] = a[2] * _x + a[6] * _y + a[10] * _z + a[14];
                a[15] = a[3] * _x + a[7] * _y + a[11] * _z + a[15];
                return this;
            },
            /**
        * translate the matrix by a vector on the horizontal and vertical axis
        * @name translateV
        * @memberOf me.Matrix3d
        * @function
        * @param {me.Vector2d|me.Vector3d} v the vector to translate the matrix by
        * @return {me.Matrix3d} Reference to this object for method chaining
        */ translateV: function translateV(v) {
                return this.translate(v.x, v.y, v.z);
            },
            /**
        * returns true if the matrix is an identity matrix.
        * @name isIdentity
        * @memberOf me.Matrix3d
        * @function
        * @return {Boolean}
        **/ isIdentity: function isIdentity() {
                var a = this.val;
                return a[0] === 1 && a[1] === 0 && a[2] === 0 && a[3] === 0 && a[4] === 0 && a[5] === 1 && a[6] === 0 && a[7] === 0 && a[8] === 0 && a[9] === 0 && a[10] === 1 && a[11] === 0 && a[12] === 0 && a[13] === 0 && a[14] === 0 && a[15] === 1;
            },
            /**
        * return true if the two matrices are identical
        * @name equals
        * @memberOf me.Matrix3d
        * @function
        * @param {me.Matrix3d} b the other matrix
        * @return {Boolean} true if both are equals
        */ equals: function equals(b) {
                b = b.val;
                var a = this.val;
                return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
            },
            /**
        * Clone the Matrix
        * @name clone
        * @memberOf me.Matrix3d
        * @function
        * @return {me.Matrix3d}
        */ clone: function clone() {
                return me.pool.pull("me.Matrix3d", this);
            },
            /**
        * return an array representation of this Matrix
        * @name toArray
        * @memberOf me.Matrix3d
        * @function
        * @return {Float32Array}
        */ toArray: function toArray() {
                return this.val;
            },
            /**
        * convert the object to a string representation
        * @name toString
        * @memberOf me.Matrix3d
        * @function
        * @return {String}
        */ toString: function toString() {
                var a = this.val;
                return "me.Matrix3d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
            }
        });
        /**
      * tx component of the matrix
      * @public
      * @type {Number}
      * @readonly
      * @name tx
      * @memberOf me.Matrix3d
      */ Object.defineProperty(me.Matrix3d.prototype, "tx", {
            /**
        * @ignore
        */ get: function get() {
                return this.val[12];
            },
            configurable: true
        });
        /**
      * ty component of the matrix
      * @public
      * @type {Number}
      * @readonly
      * @name ty
      * @memberOf me.Matrix3d
      */ Object.defineProperty(me.Matrix3d.prototype, "ty", {
            /**
        * @ignore
        */ get: function get() {
                return this.val[13];
            },
            configurable: true
        });
        /**
      * ty component of the matrix
      * @public
      * @type {Number}
      * @readonly
      * @name tz
      * @memberOf me.Matrix3d
      */ Object.defineProperty(me.Matrix3d.prototype, "tz", {
            /**
        * @ignore
        */ get: function get() {
                return this.val[14];
            },
            configurable: true
        });
    })();
    (function() {
        /**
      * an ellipse Object
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      * @param {Number} x the center x coordinate of the ellipse
      * @param {Number} y the center y coordinate of the ellipse
      * @param {Number} w width (diameter) of the ellipse
      * @param {Number} h height (diameter) of the ellipse
      */ me.Ellipse = me.Object.extend({
            /**
        * @ignore
        */ init: function init(x, y, w, h) {
                /**
          * the center coordinates of the ellipse
          * @public
          * @type {me.Vector2d}
          * @name pos
          * @memberOf me.Ellipse#
          */ this.pos = new me.Vector2d();
                /**
          * The bounding rectangle for this shape
          * @private
          * @type {me.Rect}
          * @name _bounds
          * @memberOf me.Ellipse#
          */ this._bounds = undefined;
                /**
          * Maximum radius of the ellipse
          * @public
          * @type {Number}
          * @name radius
          * @memberOf me.Ellipse
          */ this.radius = NaN;
                /**
          * Pre-scaled radius vector for ellipse
          * @public
          * @type {me.Vector2d}
          * @name radiusV
          * @memberOf me.Ellipse#
          */ this.radiusV = new me.Vector2d();
                /**
          * Radius squared, for pythagorean theorom
          * @public
          * @type {me.Vector2d}
          * @name radiusSq
          * @memberOf me.Ellipse#
          */ this.radiusSq = new me.Vector2d();
                /**
          * x/y scaling ratio for ellipse
          * @public
          * @type {me.Vector2d}
          * @name ratio
          * @memberOf me.Ellipse#
          */ this.ratio = new me.Vector2d(); // the shape type
                this.shapeType = "Ellipse";
                this.setShape(x, y, w, h);
            },
            /** @ignore */ onResetEvent: function onResetEvent(x, y, w, h) {
                this.setShape(x, y, w, h);
            },
            /**
        * set new value to the Ellipse shape
        * @name setShape
        * @memberOf me.Ellipse.prototype
        * @function
        * @param {Number} x the center x coordinate of the ellipse
        * @param {Number} y the center y coordinate of the ellipse
        * @param {Number} w width (diameter) of the ellipse
        * @param {Number} h height (diameter) of the ellipse
        */ setShape: function setShape(x, y, w, h) {
                var hW = w / 2;
                var hH = h / 2;
                this.pos.set(x, y);
                this.radius = Math.max(hW, hH);
                this.ratio.set(hW / this.radius, hH / this.radius);
                this.radiusV.set(this.radius, this.radius).scaleV(this.ratio);
                var r = this.radius * this.radius;
                this.radiusSq.set(r, r).scaleV(this.ratio);
                this.updateBounds();
                return this;
            },
            /**
        * Rotate this Ellipse (counter-clockwise) by the specified angle (in radians).
        * @name rotate
        * @memberOf me.Ellipse.prototype
        * @function
        * @param {Number} angle The angle to rotate (in radians)
        * @param {me.Vector2d|me.ObservableVector2d} [v] an optional point to rotate around
        * @return {me.Ellipse} Reference to this object for method chaining
        */ rotate: function rotate(angle, v) {
                // TODO : only works for circle
                this.pos.rotate(angle, v);
                this.updateBounds();
                return this;
            },
            /**
        * Scale this Ellipse by the specified scalar.
        * @name scale
        * @memberOf me.Ellipse.prototype
        * @function
        * @param {Number} x
        * @param {Number} [y=x]
        * @return {me.Ellipse} Reference to this object for method chaining
        */ scale: function scale(x, y) {
                y = typeof y !== "undefined" ? y : x;
                return this.setShape(this.pos.x, this.pos.y, this.radiusV.x * 2 * x, this.radiusV.y * 2 * y);
            },
            /**
        * Scale this Ellipse by the specified vector.
        * @name scale
        * @memberOf me.Ellipse.prototype
        * @function
        * @param {me.Vector2d} v
        * @return {me.Ellipse} Reference to this object for method chaining
        */ scaleV: function scaleV(v) {
                return this.scale(v.x, v.y);
            },
            /**
        * apply the given transformation matrix to this ellipse
        * @name transform
        * @memberOf me.Ellipse.prototype
        * @function
        * @param {me.Matrix2d} matrix the transformation matrix
        * @return {me.Polygon} Reference to this object for method chaining
        */ transform: function transform() /* m */ {
                // TODO
                return this;
            },
            /**
        * translate the circle/ellipse by the specified offset
        * @name translate
        * @memberOf me.Ellipse.prototype
        * @function
        * @param {Number} x x offset
        * @param {Number} y y offset
        * @return {me.Ellipse} this ellipse
        */ translate: function translate(x, y) {
                this.pos.x += x;
                this.pos.y += y;
                this._bounds.translate(x, y);
                return this;
            },
            /**
        * translate the circle/ellipse by the specified vector
        * @name translateV
        * @memberOf me.Ellipse.prototype
        * @function
        * @param {me.Vector2d} v vector offset
        * @return {me.Rect} this ellipse
        */ translateV: function translateV(v) {
                this.pos.add(v);
                this._bounds.translateV(v);
                return this;
            },
            /**
        * check if this circle/ellipse contains the specified point
        * @name containsPointV
        * @memberOf me.Ellipse.prototype
        * @function
        * @param  {me.Vector2d} point
        * @return {boolean} true if contains
        */ containsPointV: function containsPointV(v) {
                return this.containsPoint(v.x, v.y);
            },
            /**
        * check if this circle/ellipse contains the specified point
        * @name containsPoint
        * @memberOf me.Ellipse.prototype
        * @function
        * @param  {Number} x x coordinate
        * @param  {Number} y y coordinate
        * @return {boolean} true if contains
        */ containsPoint: function containsPoint(x, y) {
                // Make position relative to object center point.
                x -= this.pos.x;
                y -= this.pos.y; // Pythagorean theorem.
                return x * x / this.radiusSq.x + y * y / this.radiusSq.y <= 1;
            },
            /**
        * returns the bounding box for this shape, the smallest Rectangle object completely containing this shape.
        * @name getBounds
        * @memberOf me.Ellipse.prototype
        * @function
        * @return {me.Rect} this shape bounding box Rectangle object
        */ getBounds: function getBounds() {
                return this._bounds;
            },
            /**
        * update the bounding box for this shape.
        * @name updateBounds
        * @memberOf me.Ellipse.prototype
        * @function
        * @return {me.Rect} this shape bounding box Rectangle object
        */ updateBounds: function updateBounds() {
                var rx = this.radiusV.x, ry = this.radiusV.y, x = this.pos.x - rx, y = this.pos.y - ry, w = rx * 2, h = ry * 2;
                if (!this._bounds) this._bounds = new me.Rect(x, y, w, h);
                else this._bounds.setShape(x, y, w, h);
                return this._bounds;
            },
            /**
        * clone this Ellipse
        * @name clone
        * @memberOf me.Ellipse.prototype
        * @function
        * @return {me.Ellipse} new Ellipse
        */ clone: function clone() {
                return new me.Ellipse(this.pos.x, this.pos.y, this.radiusV.x * 2, this.radiusV.y * 2);
            }
        });
    })();
    var earcut_1 = earcut;
    var _default = earcut;
    function earcut(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        var minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for(var i = dim; i < outerLen; i += dim){
                x = data[i];
                y = data[i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
    // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) for(i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last);
        else for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i], data[i + 1], last);
        if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
        }
        return last;
    }
    // eliminate colinear or duplicate points
    function filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;
        var p = start, again;
        do {
            again = false;
            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next) break;
                again = true;
            } else p = p.next;
        }while (again || p !== end)
        return end;
    }
    // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear) return;
        // interlink polygon nodes in z-order
        if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        // iterate through ears, slicing them one by one
        while(ear.prev !== ear.next){
            prev = ear.prev;
            next = ear.next;
            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                removeNode(ear);
                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next;
            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                else if (pass === 1) {
                    ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                // as a last resort, try splitting the remaining polygon into two
                } else if (pass === 2) splitEarcut(ear, triangles, dim, minX, minY, invSize);
                break;
            }
        }
    }
    // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;
        while(p !== ear.prev){
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.next;
        }
        return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
        // z-order range for the current triangle bbox;
        var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        // look for points inside the triangle in both directions
        while(p && p.z >= minZ && n && n.z <= maxZ){
            if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
            if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
        }
        // look for remaining points in decreasing z-order
        while(p && p.z >= minZ){
            if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
        }
        // look for remaining points in increasing z-order
        while(n && n.z <= maxZ){
            if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
        }
        return true;
    }
    // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev, b = p.next.next;
            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
                // remove two nodes involved
                removeNode(p);
                removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        }while (p !== start)
        return filterPoints(p);
    }
    // try splitting polygon into two and triangulate them independently
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while(b !== a.prev){
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = splitPolygon(a, b);
                    // filter colinear points around the cuts
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
                    // run earcut on each half
                    earcutLinked(a, triangles, dim, minX, minY, invSize);
                    earcutLinked(c, triangles, dim, minX, minY, invSize);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        }while (a !== start)
    }
    // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for(i = 0, len = holeIndices.length; i < len; i++){
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next) list.steiner = true;
            queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        // process holes from left to right
        for(i = 0; i < queue.length; i++){
            eliminateHole(queue[i], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
    }
    function compareX(a, b) {
        return a.x - b.x;
    }
    // find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = splitPolygon(outerNode, hole);
            // filter collinear points around the cuts
            filterPoints(outerNode, outerNode.next);
            filterPoints(b, b.next);
        }
    }
    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y) return p;
                        if (hy === p.next.y) return p.next;
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        }while (p !== outerNode)
        if (!m) return null;
        if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
        p = m;
        do {
            if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.next;
        }while (p !== stop)
        return m;
    }
    // whether sector in vertex m contains sector in vertex p in the same coordinates
    function sectorContainsSector(m, p) {
        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }
    // interlink polygon nodes in z-order
    function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        }while (p !== start)
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
    }
    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
            while(p){
                numMerges++;
                q = p;
                pSize = 0;
                for(i = 0; i < inSize; i++){
                    pSize++;
                    q = q.nextZ;
                    if (!q) break;
                }
                qSize = inSize;
                while(pSize > 0 || qSize > 0 && q){
                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail) tail.nextZ = e;
                    else list = e;
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
        }while (numMerges > 1)
        return list;
    }
    // z-order of a point given coords and inverse of the longer side of data bbox
    function zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | x << 8) & 16711935;
        x = (x | x << 4) & 252645135;
        x = (x | x << 2) & 858993459;
        x = (x | x << 1) & 1431655765;
        y = (y | y << 8) & 16711935;
        y = (y | y << 4) & 252645135;
        y = (y | y << 2) & 858993459;
        y = (y | y << 1) & 1431655765;
        return x | y << 1;
    }
    // find the leftmost node of a polygon ring
    function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
            if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
            p = p.next;
        }while (p !== start)
        return leftmost;
    }
    // check if a point lies within a convex triangle
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
    }
    // signed area of a triangle
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    // check if two points are equal
    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    // check if two segments intersect
    function intersects(p1, q1, p2, q2) {
        var o1 = sign(area(p1, q1, p2));
        var o2 = sign(area(p1, q1, q2));
        var o3 = sign(area(p2, q2, p1));
        var o4 = sign(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4) return true; // general case
        if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
        if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
        if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
        if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
        return false;
    }
    // for collinear points p, q, r, check if point q lies on segment pr
    function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
            p = p.next;
        }while (p !== a)
        return false;
    }
    // check if a polygon diagonal is locally inside the polygon
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
            if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
            p = p.next;
        }while (p !== a)
        return inside;
    }
    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon(a, b) {
        var a2 = new Node$1(a.i, a.x, a.y), b2 = new Node$1(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
    }
    // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode(i, x, y, last) {
        var p = new Node$1(i, x, y);
        if (!last) {
            p.prev = p;
            p.next = p;
        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }
    function Node$1(i, x, y) {
        // vertex index in coordinates array
        this.i = i;
        // vertex coordinates
        this.x = x;
        this.y = y;
        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;
        // z-order curve value
        this.z = null;
        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;
        // indicates whether this is a steiner point
        this.steiner = false;
    }
    // return a percentage difference between the polygon area and its triangulation area;
    // used to verify correctness of triangulation
    earcut.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) for(var i = 0, len = holeIndices.length; i < len; i++){
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
        var trianglesArea = 0;
        for(i = 0; i < triangles.length; i += 3){
            var a = triangles[i] * dim;
            var b = triangles[i + 1] * dim;
            var c = triangles[i + 2] * dim;
            trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
        var sum = 0;
        for(var i = start, j = end - dim; i < end; i += dim){
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }
    // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
    earcut.flatten = function(data) {
        var dim = data[0][0].length, result = {
            vertices: [],
            holes: [],
            dimensions: dim
        }, holeIndex = 0;
        for(var i = 0; i < data.length; i++){
            for(var j = 0; j < data[i].length; j++)for(var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);
            if (i > 0) {
                holeIndex += data[i - 1].length;
                result.holes.push(holeIndex);
            }
        }
        return result;
    };
    earcut_1.default = _default;
    (function() {
        /**
      * a polygon Object.<br>
      * Please do note that melonJS implements a simple Axis-Aligned Boxes collision algorithm, which requires all polygons used for collision to be convex with all vertices defined with clockwise winding.
      * A polygon is convex when all line segments connecting two points in the interior do not cross any edge of the polygon
      * (which means that all angles are less than 180 degrees), as described here below : <br>
      * <center><img src="images/convex_polygon.png"/></center><br>
      * A polygon's `winding` is clockwise iff its vertices (points) are declared turning to the right. The image above shows COUNTERCLOCKWISE winding.
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      * @param {Number} x origin point of the Polygon
      * @param {Number} y origin point of the Polygon
      * @param {me.Vector2d[]} points array of vector defining the Polygon
      */ me.Polygon = me.Object.extend({
            /**
        * @ignore
        */ init: function init(x, y, points) {
                /**
          * origin point of the Polygon
          * @public
          * @type {me.Vector2d}
          * @name pos
          * @memberof me.Polygon#
          */ this.pos = new me.Vector2d();
                /**
          * The bounding rectangle for this shape
          * @ignore
          * @type {me.Rect}
          * @name _bounds
          * @memberOf me.Polygon#
          */ this._bounds = undefined;
                /**
          * Array of points defining the Polygon <br>
          * Note: If you manually change `points`, you **must** call `recalc`afterwards so that the changes get applied correctly.
          * @public
          * @type {me.Vector2d[]}
          * @name points
          * @memberOf me.Polygon#
          */ this.points = null;
                /**
          * The edges here are the direction of the `n`th edge of the polygon, relative to
          * the `n`th point. If you want to draw a given edge from the edge value, you must
          * first translate to the position of the starting point.
          * @ignore
          */ this.edges = [];
                /**
          * a list of indices for all vertices composing this polygon (@see earcut)
          * @ignore
          */ this.indices = [];
                /**
          * The normals here are the direction of the normal for the `n`th edge of the polygon, relative
          * to the position of the `n`th point. If you want to draw an edge normal, you must first
          * translate to the position of the starting point.
          * @ignore
          */ this.normals = []; // the shape type
                this.shapeType = "Polygon";
                this.setShape(x, y, points);
            },
            /** @ignore */ onResetEvent: function onResetEvent(x, y, points) {
                this.setShape(x, y, points);
            },
            /**
        * set new value to the Polygon
        * @name setShape
        * @memberOf me.Polygon.prototype
        * @function
        * @param {Number} x position of the Polygon
        * @param {Number} y position of the Polygon
        * @param {me.Vector2d[]|Number[]} points array of vector or vertice defining the Polygon
        */ setShape: function setShape(x, y, points) {
                this.pos.set(x, y);
                if (!Array.isArray(points)) return this;
                 // convert given points to me.Vector2d if required
                if (!(points[0] instanceof me.Vector2d)) {
                    var _points = this.points = [];
                    if (_typeof(points[0]) === "object") // array of {x,y} object
                    points.forEach(function(point) {
                        _points.push(new me.Vector2d(point.x, point.y));
                    });
                    else // it's a flat array
                    for(var p = 0; p < points.length; p += 2)_points.push(new me.Vector2d(points[p], points[p + 1]));
                } else // array of me.Vector2d
                this.points = points;
                this.recalc();
                this.updateBounds();
                return this;
            },
            /**
        * apply the given transformation matrix to this Polygon
        * @name transform
        * @memberOf me.Polygon.prototype
        * @function
        * @param {me.Matrix2d} matrix the transformation matrix
        * @return {me.Polygon} Reference to this object for method chaining
        */ transform: function transform(m) {
                var points = this.points;
                var len = points.length;
                for(var i = 0; i < len; i++)m.apply(points[i]);
                this.recalc();
                this.updateBounds();
                return this;
            },
            /**
        * apply an isometric projection to this shape
        * @name toIso
        * @memberOf me.Polygon.prototype
        * @function
        * @return {me.Polygon} Reference to this object for method chaining
        */ toIso: function toIso() {
                return this.rotate(Math.PI / 4).scale(Math.SQRT2, Math.SQRT1_2);
            },
            /**
        * apply a 2d projection to this shape
        * @name to2d
        * @memberOf me.Polygon.prototype
        * @function
        * @return {me.Polygon} Reference to this object for method chaining
        */ to2d: function to2d() {
                return this.scale(Math.SQRT1_2, Math.SQRT2).rotate(-Math.PI / 4);
            },
            /**
        * Rotate this Polygon (counter-clockwise) by the specified angle (in radians).
        * @name rotate
        * @memberOf me.Polygon.prototype
        * @function
        * @param {Number} angle The angle to rotate (in radians)
        * @param {me.Vector2d|me.ObservableVector2d} [v] an optional point to rotate around
        * @return {me.Polygon} Reference to this object for method chaining
        */ rotate: function rotate(angle, v) {
                if (angle !== 0) {
                    var points = this.points;
                    var len = points.length;
                    for(var i = 0; i < len; i++)points[i].rotate(angle, v);
                    this.recalc();
                    this.updateBounds();
                }
                return this;
            },
            /**
        * Scale this Polygon by the given scalar.
        * @name scale
        * @memberOf me.Polygon.prototype
        * @function
        * @param {Number} x
        * @param {Number} [y=x]
        * @return {me.Polygon} Reference to this object for method chaining
        */ scale: function scale(x, y) {
                y = typeof y !== "undefined" ? y : x;
                var points = this.points;
                var len = points.length;
                for(var i = 0; i < len; i++)points[i].scale(x, y);
                this.recalc();
                this.updateBounds();
                return this;
            },
            /**
        * Scale this Polygon by the given vector
        * @name scaleV
        * @memberOf me.Polygon.prototype
        * @function
        * @param {me.Vector2d} v
        * @return {me.Polygon} Reference to this object for method chaining
        */ scaleV: function scaleV(v) {
                return this.scale(v.x, v.y);
            },
            /**
        * Computes the calculated collision polygon.
        * This **must** be called if the `points` array, `angle`, or `offset` is modified manually.
        * @name recalc
        * @memberOf me.Polygon.prototype
        * @function
        * @return {me.Polygon} Reference to this object for method chaining
        */ recalc: function recalc() {
                var i;
                var edges = this.edges;
                var normals = this.normals;
                var indices = this.indices; // Copy the original points array and apply the offset/angle
                var points = this.points;
                var len = points.length;
                if (len < 3) throw new Error("Requires at least 3 points");
                 // Calculate the edges/normals
                for(i = 0; i < len; i++){
                    if (edges[i] === undefined) edges[i] = new me.Vector2d();
                    edges[i].copy(points[(i + 1) % len]).sub(points[i]);
                    if (normals[i] === undefined) normals[i] = new me.Vector2d();
                    normals[i].copy(edges[i]).perp().normalize();
                } // trunc array
                edges.length = len;
                normals.length = len; // do not do anything here, indices will be computed by
                // toIndices if array is empty upon function call
                indices.length = 0;
                return this;
            },
            /**
        * returns a list of indices for all triangles defined in this polygon
        * @name getIndices
        * @memberOf me.Polygon.prototype
        * @function
        * @param {Vector2d[]} a list of vector
        * @return {me.Polygon} this Polygon
        */ getIndices: function getIndices(x, y) {
                if (this.indices.length === 0) this.indices = earcut_1(this.points.flatMap(function(p) {
                    return [
                        p.x,
                        p.y
                    ];
                }));
                return this.indices;
            },
            /**
        * translate the Polygon by the specified offset
        * @name translate
        * @memberOf me.Polygon.prototype
        * @function
        * @param {Number} x x offset
        * @param {Number} y y offset
        * @return {me.Polygon} this Polygon
        */ translate: function translate(x, y) {
                this.pos.x += x;
                this.pos.y += y;
                this._bounds.translate(x, y);
                return this;
            },
            /**
        * translate the Polygon by the specified vector
        * @name translateV
        * @memberOf me.Polygon.prototype
        * @function
        * @param {me.Vector2d} v vector offset
        * @return {me.Polygon} Reference to this object for method chaining
        */ translateV: function translateV(v) {
                this.pos.add(v);
                this._bounds.translateV(v);
                return this;
            },
            /**
        * check if this Polygon contains the specified point
        * @name containsPointV
        * @memberOf me.Polygon.prototype
        * @function
        * @param  {me.Vector2d} point
        * @return {boolean} true if contains
        */ containsPointV: function containsPointV(v) {
                return this.containsPoint(v.x, v.y);
            },
            /**
        * check if this Polygon contains the specified point <br>
        * (Note: it is highly recommended to first do a hit test on the corresponding <br>
        *  bounding rect, as the function can be highly consuming with complex shapes)
        * @name containsPoint
        * @memberOf me.Polygon.prototype
        * @function
        * @param  {Number} x x coordinate
        * @param  {Number} y y coordinate
        * @return {boolean} true if contains
        */ containsPoint: function containsPoint(x, y) {
                var intersects1 = false;
                var posx = this.pos.x, posy = this.pos.y;
                var points = this.points;
                var len = points.length; //http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
                for(var i = 0, j = len - 1; i < len; j = i++){
                    var iy = points[i].y + posy, ix = points[i].x + posx, jy = points[j].y + posy, jx = points[j].x + posx;
                    if (iy > y !== jy > y && x < (jx - ix) * (y - iy) / (jy - iy) + ix) intersects1 = !intersects1;
                }
                return intersects1;
            },
            /**
        * returns the bounding box for this shape, the smallest Rectangle object completely containing this shape.
        * @name getBounds
        * @memberOf me.Polygon.prototype
        * @function
        * @return {me.Rect} this shape bounding box Rectangle object
        */ getBounds: function getBounds() {
                return this._bounds;
            },
            /**
        * update the bounding box for this shape.
        * @name updateBounds
        * @memberOf me.Polygon.prototype
        * @function
        * @return {me.Rect} this shape bounding box Rectangle object
        */ updateBounds: function updateBounds() {
                if (!this._bounds) this._bounds = new me.Rect(0, 0, 0, 0);
                this._bounds.setPoints(this.points);
                this._bounds.translateV(this.pos);
                return this._bounds;
            },
            /**
        * clone this Polygon
        * @name clone
        * @memberOf me.Polygon.prototype
        * @function
        * @return {me.Polygon} new Polygon
        */ clone: function clone() {
                var copy = [];
                this.points.forEach(function(point) {
                    copy.push(point.clone());
                });
                return new me.Polygon(this.pos.x, this.pos.y, copy);
            }
        });
    })();
    (function() {
        /**
      * a rectangle Object
      * @class
      * @extends me.Polygon
      * @memberOf me
      * @constructor
      * @param {Number} x position of the Rectangle
      * @param {Number} y position of the Rectangle
      * @param {Number} w width of the rectangle
      * @param {Number} h height of the rectangle
      */ me.Rect = me.Polygon.extend({
            /**
        * @ignore
        */ init: function init(x, y, w, h) {
                /**
          * the center point of this rectangle
          * @public
          * @type me.Vector2d
          * @name center
          * @memberOf me.Rect
          */ if (typeof this.center === "undefined") this.center = new me.Vector2d();
                this.center.set(0, 0); // parent constructor
                this._super(me.Polygon, "init", [
                    x,
                    y,
                    [
                        new me.Vector2d(0, 0),
                        new me.Vector2d(w, 0),
                        new me.Vector2d(w, h),
                        new me.Vector2d(0, h) // 0, 1
                    ]
                ]);
                this.shapeType = "Rectangle";
            },
            /** @ignore */ onResetEvent: function onResetEvent(x, y, w, h) {
                this.setShape(x, y, w, h);
            },
            /**
        * set new value to the rectangle shape
        * @name setShape
        * @memberOf me.Rect.prototype
        * @function
        * @param {Number} x position of the Rectangle
        * @param {Number} y position of the Rectangle
        * @param {Number|Array} w|points width of the rectangle, or an array of vector defining the rectangle
        * @param {Number} [h] height of the rectangle, if a numeral width parameter is specified
        * @return {me.Rect} this rectangle
        */ setShape: function setShape(x, y, w, h) {
                var points = w; // assume w is an array by default
                if (arguments.length === 4) {
                    points = this.points;
                    points[0].set(0, 0); // 0, 0
                    points[1].set(w, 0); // 1, 0
                    points[2].set(w, h); // 1, 1
                    points[3].set(0, h); // 0, 1
                }
                this._super(me.Polygon, "setShape", [
                    x,
                    y,
                    points
                ]);
                return this;
            },
            /**
        * resize the rectangle
        * @name resize
        * @memberOf me.Rect.prototype
        * @function
        * @param {Number} w new width of the rectangle
        * @param {Number} h new height of the rectangle
        * @return {me.Rect} this rectangle
        */ resize: function resize(w, h) {
                this.width = w;
                this.height = h;
                return this;
            },
            /**
        * returns the bounding box for this shape, the smallest rectangle object completely containing this shape.
        * @name getBounds
        * @memberOf me.Rect.prototype
        * @function
        * @return {me.Rect} this shape bounding box Rectangle object
        */ getBounds: function getBounds() {
                return this;
            },
            /**
        * resize the rectangle to contain all the given points coordinates.
        * @name setPoints
        * @memberOf me.Rect.prototype
        * @function
        * @param {me.Vector2d[]} points array of vector defining a shape
        * @return {me.Rect} this shape bounding box Rectangle object
        */ setPoints: function setPoints(points) {
                var x = Infinity, y = Infinity, right = -Infinity, bottom = -Infinity;
                points.forEach(function(point) {
                    x = Math.min(x, point.x);
                    y = Math.min(y, point.y);
                    right = Math.max(right, point.x);
                    bottom = Math.max(bottom, point.y);
                });
                this.setShape(x, y, right - x, bottom - y);
                return this;
            },
            /**
        * Computes the calculated collision polygon.
        * This **must** be called if the `points` array is modified manually.
        * @ignore
        * @name recalc
        * @memberOf me.Rect.prototype
        * @function
        */ recalc: function recalc() {
                this._super(me.Polygon, "recalc");
                this._width = this.points[2].x;
                this._height = this.points[2].y;
                this.center.set(this.centerX, this.centerY);
                return this;
            },
            /**
        * update the bounding box for this shape.
        * @name updateBounds
        * @memberOf me.Rect.prototype
        * @function
        * @return {me.Rect} this shape bounding box Rectangle object
        */ updateBounds: function updateBounds() {
                this.center.set(this.centerX, this.centerY);
                return this;
            },
            /**
        * clone this rectangle
        * @name clone
        * @memberOf me.Rect.prototype
        * @function
        * @return {me.Rect} new rectangle
        */ clone: function clone() {
                return new me.Rect(this.pos.x, this.pos.y, this._width, this._height);
            },
            /**
        * copy the position and size of the given rectangle into this one
        * @name copy
        * @memberOf me.Rect.prototype
        * @function
        * @param {me.Rect} rect Source rectangle
        * @return {me.Rect} new rectangle
        */ copy: function copy(rect) {
                return this.setShape(rect.pos.x, rect.pos.y, rect._width, rect._height);
            },
            /**
        * translate the rect by the specified offset
        * @name translate
        * @memberOf me.Rect.prototype
        * @function
        * @param {Number} x x offset
        * @param {Number} y y offset
        * @return {me.Rect} this rectangle
        */ translate: function translate(x, y) {
                this.pos.x += x;
                this.pos.y += y;
                return this;
            },
            /**
        * translate the rect by the specified vector
        * @name translateV
        * @memberOf me.Rect.prototype
        * @function
        * @param {me.Vector2d} v vector offset
        * @return {me.Rect} this rectangle
        */ translateV: function translateV(v) {
                return this.translate(v.x, v.y);
            },
            /**
        * merge this rectangle with another one
        * @name union
        * @memberOf me.Rect.prototype
        * @function
        * @param {me.Rect} rect other rectangle to union with
        * @return {me.Rect} the union(ed) rectangle
        */ union: function union(/** {me.Rect} */ r) {
                var x1 = Math.min(this.left, r.left);
                var y1 = Math.min(this.top, r.top);
                this.resize(Math.max(this.right, r.right) - x1, Math.max(this.bottom, r.bottom) - y1);
                this.pos.set(x1, y1);
                return this;
            },
            /**
        * check if this rectangle is intersecting with the specified one
        * @name overlaps
        * @memberOf me.Rect.prototype
        * @function
        * @param  {me.Rect} rect
        * @return {boolean} true if overlaps
        */ overlaps: function overlaps(r) {
                return this.left < r.right && r.left < this.right && this.top < r.bottom && r.top < this.bottom;
            },
            /**
        * check if this rectangle contains the specified one
        * @name contains
        * @memberOf me.Rect.prototype
        * @function
        * @param  {me.Rect} rect
        * @return {boolean} true if contains
        */ contains: function contains(r) {
                return r.left >= this.left && r.right <= this.right && r.top >= this.top && r.bottom <= this.bottom;
            },
            /**
        * check if this rectangle contains the specified point
        * @name containsPoint
        * @memberOf me.Rect.prototype
        * @function
        * @param  {Number} x x coordinate
        * @param  {Number} y y coordinate
        * @return {boolean} true if contains
        */ containsPoint: function containsPoint(x, y) {
                return x >= this.left && x <= this.right && y >= this.top && y <= this.bottom;
            },
            /**
        * check if this rectangle is identical to the specified one
        * @name equals
        * @memberOf me.Rect.prototype
        * @function
        * @param  {me.Rect} rect
        * @return {boolean} true if equals
        */ equals: function equals1(r) {
                return r.left === this.left && r.right === this.right && r.top === this.top && r.bottom === this.bottom;
            },
            /**
        * determines whether all coordinates of this rectangle are finite numbers.
        * @name isFinite
        * @memberOf me.Rect.prototype
        * @function
        * @return {boolean} false if all coordinates are positive or negative Infinity or NaN; otherwise, true.
        */ isFinite: function(_isFinite) {
                function isFinite() {
                    return _isFinite.apply(this, arguments);
                }
                isFinite.toString = function() {
                    return _isFinite.toString();
                };
                return isFinite;
            }(function() {
                return isFinite(this.pos.x) && isFinite(this.pos.y) && isFinite(this._width) && isFinite(this._height);
            }),
            /**
        * Returns a polygon whose edges are the same as this box.
        * @name toPolygon
        * @memberOf me.Rect.prototype
        * @function
        * @return {me.Polygon} a new Polygon that represents this rectangle.
        */ toPolygon: function toPolygon() {
                return new me.Polygon(this.pos.x, this.pos.y, this.points);
            }
        }); // redefine some properties to ease our life when getting the rectangle coordinates
        /**
      * left coordinate of the Rectangle
      * @public
      * @type {Number}
      * @name left
      * @memberOf me.Rect
      */ Object.defineProperty(me.Rect.prototype, "left", {
            /**
        * @ignore
        */ get: function get() {
                return this.pos.x;
            },
            configurable: true
        });
        /**
      * right coordinate of the Rectangle
      * @public
      * @type {Number}
      * @name right
      * @memberOf me.Rect
      */ Object.defineProperty(me.Rect.prototype, "right", {
            /**
        * @ignore
        */ get: function get() {
                var w = this._width;
                return this.pos.x + w || w;
            },
            configurable: true
        });
        /**
      * top coordinate of the Rectangle
      * @public
      * @type {Number}
      * @name top
      * @memberOf me.Rect
      */ Object.defineProperty(me.Rect.prototype, "top", {
            /**
        * @ignore
        */ get: function get() {
                return this.pos.y;
            },
            configurable: true
        });
        /**
      * bottom coordinate of the Rectangle
      * @public
      * @type {Number}
      * @name bottom
      * @memberOf me.Rect
      */ Object.defineProperty(me.Rect.prototype, "bottom", {
            /**
        * @ignore
        */ get: function get() {
                var h = this._height;
                return this.pos.y + h || h;
            },
            configurable: true
        });
        /**
      * width of the Rectangle
      * @public
      * @type {Number}
      * @name width
      * @memberOf me.Rect
      */ Object.defineProperty(me.Rect.prototype, "width", {
            /**
        * @ignore
        */ get: function get() {
                return this._width;
            },
            /**
        * @ignore
        */ set: function set(value) {
                if (this._width !== value) {
                    this.points[1].x = this.points[2].x = value; // _width updated in recalc
                    this.recalc();
                }
            },
            configurable: true
        });
        /**
      * height of the Rectangle
      * @public
      * @type {Number}
      * @name height
      * @memberOf me.Rect
      */ Object.defineProperty(me.Rect.prototype, "height", {
            /**
        * @ignore
        */ get: function get() {
                return this._height;
            },
            /**
        * @ignore
        */ set: function set(value) {
                if (this._height !== value) {
                    this.points[2].y = this.points[3].y = value; // _height updated in recalc
                    this.recalc();
                }
            },
            configurable: true
        });
        /**
      * absolute center of this rectangle on the horizontal axis
      * @public
      * @type {Number}
      * @name centerX
      * @memberOf me.Rect
      */ Object.defineProperty(me.Rect.prototype, "centerX", {
            /**
        * @ignore
        */ get: function get() {
                if (isFinite(this._width)) return this.pos.x + this._width / 2;
                else return this._width;
            },
            /**
        * @ignore
        */ set: function set(value) {
                this.pos.x = value - this._width / 2;
                this.center.x = value;
            },
            configurable: true
        });
        /**
      * absolute center of this rectangle on the vertical axis
      * @public
      * @type {Number}
      * @name centerY
      * @memberOf me.Rect
      */ Object.defineProperty(me.Rect.prototype, "centerY", {
            /**
        * @ignore
        */ get: function get() {
                if (isFinite(this._height)) return this.pos.y + this._height / 2;
                else return this._height;
            },
            /**
        * @ignore
        */ set: function set(value) {
                this.pos.y = value - this._height / 2;
                this.center.y = value;
            },
            configurable: true
        });
    })();
    (function() {
        /**
      * a line segment Object.<br>
      * @class
      * @extends me.Polygon
      * @memberOf me
      * @constructor
      * @param {Number} x origin point of the Line
      * @param {Number} y origin point of the Line
      * @param {me.Vector2d[]} points array of vectors defining the Line
      */ me.Line = me.Polygon.extend({
            /**
        * check if this line segment contains the specified point
        * @name containsPointV
        * @memberOf me.Line.prototype
        * @function
        * @param  {me.Vector2d} point
        * @return {boolean} true if contains
        */ containsPointV: function containsPointV(v) {
                return this.containsPoint(v.x, v.y);
            },
            /**
        * check if this line segment contains the specified point
        * @name containsPoint
        * @memberOf me.Line.prototype
        * @function
        * @param  {Number} x x coordinate
        * @param  {Number} y y coordinate
        * @return {boolean} true if contains
        */ containsPoint: function containsPoint(x, y) {
                // translate the given coordinates,
                // rather than creating temp translated vectors
                x -= this.pos.x; // Cx
                y -= this.pos.y; // Cy
                var start = this.points[0]; // Ax/Ay
                var end = this.points[1]; // Bx/By
                //(Cy - Ay) * (Bx - Ax) = (By - Ay) * (Cx - Ax)
                return (y - start.y) * (end.x - start.x) === (end.y - start.y) * (x - start.x);
            },
            /**
        * Computes the calculated collision edges and normals.
        * This **must** be called if the `points` array, `angle`, or `offset` is modified manually.
        * @name recalc
        * @memberOf me.Line.prototype
        * @function
        */ recalc: function recalc() {
                var edges = this.edges;
                var normals = this.normals;
                var indices = this.indices; // Copy the original points array and apply the offset/angle
                var points = this.points;
                if (points.length !== 2) throw new Error("Requires exactly 2 points");
                 // Calculate the edges/normals
                if (edges[0] === undefined) edges[0] = new me.Vector2d();
                edges[0].copy(points[1]).sub(points[0]);
                if (normals[0] === undefined) normals[0] = new me.Vector2d();
                normals[0].copy(edges[0]).perp().normalize(); // do not do anything here, indices will be computed by
                // toIndices if array is empty upon function call
                indices.length = 0;
                return this;
            },
            /**
        * clone this line segment
        * @name clone
        * @memberOf me.Line.prototype
        * @function
        * @return {me.Line} new Line
        */ clone: function clone() {
                var copy = [];
                this.points.forEach(function(point) {
                    copy.push(point.clone());
                });
                return new me.Line(this.pos.x, this.pos.y, copy);
            }
        });
    })();
    (function() {
        /**
      * A base class for renderable objects.
      * @class
      * @extends me.Rect
      * @memberOf me
      * @constructor
      * @param {Number} x position of the renderable object (accessible through inherited pos.x property)
      * @param {Number} y position of the renderable object (accessible through inherited pos.y property)
      * @param {Number} width object width
      * @param {Number} height object height
      */ me.Renderable = me.Rect.extend({
            /**
        * @ignore
        */ init: function init(x, y, width, height) {
                /**
          * to identify the object as a renderable object
          * @ignore
          */ this.isRenderable = true;
                /**
          * If true then physic collision and input events will not impact this renderable
          * @public
          * @type Boolean
          * @default true
          * @name isKinematic
          * @memberOf me.Renderable
          */ this.isKinematic = true;
                /**
          * the renderable physic body
          * @public
          * @type {me.Body}
          * @see me.Body
          * @see me.collision#check
          * @name body
          * @memberOf me.Renderable#
          * @example
          *  // define a new Player Class
          *  game.PlayerEntity = me.Sprite.extend({
          *      // constructor
          *      init:function (x, y, settings) {
          *          // call the parent constructor
          *          this._super(me.Sprite, 'init', [x, y , settings]);
          *
          *          // define a basic walking animation
          *          this.addAnimation("walk",  [...]);
          *          // define a standing animation (using the first frame)
          *          this.addAnimation("stand",  [...]);
          *          // set the standing animation as default
          *          this.setCurrentAnimation("stand");
          *
          *          // add a physic body
          *          this.body = new me.Body(this);
          *          // add a default collision shape
          *          this.body.addShape(new me.Rect(0, 0, this.width, this.height));
          *          // configure max speed and friction
          *          this.body.setMaxVelocity(3, 15);
          *          this.body.setFriction(0.4, 0);
          *
          *          // enable physic collision (off by default for basic me.Renderable)
          *          this.isKinematic = false;
          *
          *          // set the display to follow our position on both axis
          *          me.game.viewport.follow(this.pos, me.game.viewport.AXIS.BOTH);
          *      },
          *
          *      ...
          *
          * }
          */ this.body = undefined;
                /**
          * the renderable default transformation matrix
          * @public
          * @type me.Matrix2d
          * @name currentTransform
          * @memberOf me.Renderable#
          */ if (typeof this.currentTransform === "undefined") this.currentTransform = me.pool.pull("me.Matrix2d");
                this.currentTransform.identity();
                /**
          * (G)ame (U)nique (Id)entifier" <br>
          * a GUID will be allocated for any renderable object added <br>
          * to an object container (including the `me.game.world` container)
          * @public
          * @type String
          * @name GUID
          * @memberOf me.Renderable
          */ this.GUID = undefined;
                /**
          * an event handler that is called when the renderable leave or enter a camera viewport
          * @public
          * @type function
          * @default undefined
          * @name onVisibilityChange
          * @memberOf me.Renderable#
          * @example
          * this.onVisibilityChange = function(inViewport) {
          *     if (inViewport === true) {
          *         console.log("object has entered the in a camera viewport!");
          *     }
          * };
          */ this.onVisibilityChange = undefined;
                /**
          * Whether the renderable object will always update, even when outside of the viewport<br>
          * @public
          * @type Boolean
          * @default false
          * @name alwaysUpdate
          * @memberOf me.Renderable
          */ this.alwaysUpdate = false;
                /**
          * Whether to update this object when the game is paused.
          * @public
          * @type Boolean
          * @default false
          * @name updateWhenPaused
          * @memberOf me.Renderable
          */ this.updateWhenPaused = false;
                /**
          * make the renderable object persistent over level changes<br>
          * @public
          * @type Boolean
          * @default false
          * @name isPersistent
          * @memberOf me.Renderable
          */ this.isPersistent = false;
                /**
          * If true, this renderable will be rendered using screen coordinates,
          * as opposed to world coordinates. Use this, for example, to define UI elements.
          * @public
          * @type Boolean
          * @default false
          * @name floating
          * @memberOf me.Renderable
          */ this.floating = false;
                /**
          * The anchor point is used for attachment behavior, and/or when applying transformations.<br>
          * The coordinate system places the origin at the top left corner of the frame (0, 0) and (1, 1) means the bottom-right corner<br>
          * <img src="images/anchor_point.png"/> :<br>
          * a Renderable's anchor point defaults to (0.5,0.5), which corresponds to the center position.<br>
          * @public
          * @type me.ObservableVector2d
          * @default <0.5,0.5>
          * @name anchorPoint
          * @memberOf me.Renderable#
          */ if (this.anchorPoint instanceof me.ObservableVector2d) this.anchorPoint.setMuted(0.5, 0.5).setCallback(this.onAnchorUpdate.bind(this));
                else this.anchorPoint = me.pool.pull("me.ObservableVector2d", 0.5, 0.5, {
                    onUpdate: this.onAnchorUpdate.bind(this)
                });
                /**
          * When enabled, an object container will automatically apply
          * any defined transformation before calling the child draw method.
          * @public
          * @type Boolean
          * @default true
          * @name autoTransform
          * @memberOf me.Renderable
          * @example
          * // enable "automatic" transformation when the object is activated
          * onActivateEvent: function () {
          *     // reset the transformation matrix
          *     this.currentTransform.identity();
          *     // ensure the anchor point is the renderable center
          *     this.anchorPoint.set(0.5, 0.5);
          *     // enable auto transform
          *     this.autoTransform = true;
          *     ....
          * }
          */ this.autoTransform = true;
                /**
          * Define the renderable opacity<br>
          * Set to zero if you do not wish an object to be drawn
          * @see me.Renderable#setOpacity
          * @see me.Renderable#getOpacity
          * @public
          * @type Number
          * @default 1.0
          * @name me.Renderable#alpha
          */ this.alpha = 1;
                /**
          * a reference to the parent object that contains this renderable
          * @public
          * @type me.Container|me.Entity
          * @default undefined
          * @name me.Renderable#ancestor
          */ this.ancestor = undefined;
                /**
          * The bounding rectangle for this renderable
          * @ignore
          * @type {me.Rect}
          * @name _bounds
          * @memberOf me.Renderable
          */ if (this._bounds instanceof me.Rect) this._bounds.setShape(x, y, width, height);
                else this._bounds = me.pool.pull("me.Rect", x, y, width, height);
                /**
          * A mask limits rendering elements to the shape and position of the given mask object.
          * So, if the renderable is larger than the mask, only the intersecting part of the renderable will be visible.
          * @public
          * @type {me.Rect|me.Polygon|me.Line|me.Ellipse}
          * @name mask
          * @default undefined
          * @memberOf me.Renderable#
          * @example
          * // apply a mask in the shape of a Star
          * myNPCSprite.mask = new me.Polygon(myNPCSprite.width / 2, 0, [
          *    // draw a star
          *    {x: 0, y: 0},
          *    {x: 14, y: 30},
          *    {x: 47, y: 35},
          *    {x: 23, y: 57},
          *    {x: 44, y: 90},
          *    {x: 0, y: 62},
          *    {x: -44, y: 90},
          *    {x: -23, y: 57},
          *    {x: -47, y: 35},
          *    {x: -14, y: 30}
          * ]);
          */ this.mask = undefined;
                /**
          * define a tint for this renderable. a (255, 255, 255) r, g, b value will remove the tint effect.
          * @public
          * @type {me.Color}
          * @name tint
          * @default (255, 255, 255)
          * @memberOf me.Renderable#
          * @example
          * // add a red tint to this renderable
          * this.tint.setColor(255, 128, 128);
          * // remove the tint
          * this.tint.setColor(255, 255, 255);
          */ this.tint = me.pool.pull("me.Color", 255, 255, 255, 1);
                /**
          * The name of the renderable
          * @public
          * @type {String}
          * @name name
          * @default ""
          * @memberOf me.Renderable
          */ this.name = "";
                /**
          * Absolute position in the game world
          * @ignore
          * @type {me.Vector2d}
          * @name _absPos
          * @memberOf me.Renderable#
          */ if (this._absPos instanceof me.Vector2d) this._absPos.set(x, y);
                else this._absPos = me.pool.pull("me.Vector2d", x, y);
                /**
          * Position of the Renderable relative to its parent container
          * @public
          * @type {me.ObservableVector3d}
          * @name pos
          * @memberOf me.Renderable#
          */ if (this.pos instanceof me.ObservableVector3d) this.pos.setMuted(x, y, 0).setCallback(this.updateBoundsPos.bind(this));
                else this.pos = me.pool.pull("me.ObservableVector3d", x, y, 0, {
                    onUpdate: this.updateBoundsPos.bind(this)
                });
                /**
          * when true the renderable will be redrawn during the next update cycle
          * @type {Boolean}
          * @name isDirty
          * @default false
          * @memberOf me.Renderable#
          */ this.isDirty = false;
                this._width = width;
                this._height = height; // keep track of when we flip
                this._flip = {
                    x: false,
                    y: false
                }; // viewport flag
                this._inViewport = false;
                this.shapeType = "Rectangle"; // ensure it's fully opaque by default
                this.setOpacity(1);
            },
            /** @ignore */ onResetEvent: function onResetEvent() {
                this.init.apply(this, arguments);
            },
            /**
        * returns the bounding box for this renderable
        * @name getBounds
        * @memberOf me.Renderable.prototype
        * @function
        * @return {me.Rect} bounding box Rectangle object
        */ getBounds: function getBounds() {
                return this._bounds;
            },
            /**
        * get the renderable alpha channel value<br>
        * @name getOpacity
        * @memberOf me.Renderable.prototype
        * @function
        * @return {Number} current opacity value between 0 and 1
        */ getOpacity: function getOpacity() {
                return this.alpha;
            },
            /**
        * set the renderable alpha channel value<br>
        * @name setOpacity
        * @memberOf me.Renderable.prototype
        * @function
        * @param {Number} alpha opacity value between 0.0 and 1.0
        */ setOpacity: function setOpacity(alpha) {
                if (typeof alpha === "number") {
                    this.alpha = me.Math.clamp(alpha, 0, 1); // Set to 1 if alpha is NaN
                    if (isNaN(this.alpha)) this.alpha = 1;
                }
            },
            /**
        * flip the renderable on the horizontal axis (around the center of the renderable)
        * @see me.Matrix2d#scaleX
        * @name flipX
        * @memberOf me.Renderable.prototype
        * @function
        * @param {Boolean} [flip=false] `true` to flip this renderable.
        * @return {me.Renderable} Reference to this object for method chaining
        */ flipX: function flipX(flip) {
                this._flip.x = !!flip;
                this.isDirty = true;
                return this;
            },
            /**
        * flip the renderable on the vertical axis (around the center of the renderable)
        * @see me.Matrix2d#scaleY
        * @name flipY
        * @memberOf me.Renderable.prototype
        * @function
        * @param {Boolean} [flip=false] `true` to flip this renderable.
        * @return {me.Renderable} Reference to this object for method chaining
        */ flipY: function flipY(flip) {
                this._flip.y = !!flip;
                this.isDirty = true;
                return this;
            },
            /**
        * multiply the renderable currentTransform with the given matrix
        * @name transform
        * @memberOf me.Renderable.prototype
        * @see me.Renderable#currentTransform
        * @function
        * @param {me.Matrix2d} matrix the transformation matrix
        * @return {me.Renderable} Reference to this object for method chaining
        */ transform: function transform(m) {
                var bounds = this.getBounds();
                this.currentTransform.multiply(m);
                bounds.setPoints(bounds.transform(m).points);
                bounds.pos.setV(this.pos);
                this.isDirty = true;
                return this;
            },
            /**
        * return the angle to the specified target
        * @name angleTo
        * @memberOf me.Renderable
        * @function
        * @param {me.Renderable|me.Vector2d|me.Vector3d} target
        * @return {Number} angle in radians
        */ angleTo: function angleTo(target) {
                var a = this.getBounds();
                var ax, ay;
                if (target instanceof me.Renderable) {
                    var b = target.getBounds();
                    ax = b.centerX - a.centerX;
                    ay = b.centerY - a.centerY;
                } else {
                    // vector object
                    ax = target.x - a.centerX;
                    ay = target.y - a.centerY;
                }
                return Math.atan2(ay, ax);
            },
            /**
        * return the distance to the specified target
        * @name distanceTo
        * @memberOf me.Renderable
        * @function
        * @param {me.Renderable|me.Vector2d|me.Vector3d} target
        * @return {Number} distance
        */ distanceTo: function distanceTo(target) {
                var a = this.getBounds();
                var dx, dy;
                if (target instanceof me.Renderable) {
                    var b = target.getBounds();
                    dx = a.centerX - b.centerX;
                    dy = a.centerY - b.centerY;
                } else {
                    // vector object
                    dx = a.centerX - target.x;
                    dy = a.centerY - target.y;
                }
                return Math.sqrt(dx * dx + dy * dy);
            },
            /**
        * Rotate this renderable towards the given target.
        * @name lookAt
        * @memberOf me.Renderable.prototype
        * @function
        * @param {me.Renderable|me.Vector2d|me.Vector3d} target the renderable or position to look at
        * @return {me.Renderable} Reference to this object for method chaining
        */ lookAt: function lookAt(target) {
                var position;
                if (target instanceof me.Renderable) position = target.pos;
                else position = target;
                var angle = this.angleTo(position);
                this.rotate(angle);
                return this;
            },
            /**
        * Rotate this renderable by the specified angle (in radians).
        * @name rotate
        * @memberOf me.Renderable.prototype
        * @function
        * @param {Number} angle The angle to rotate (in radians)
        * @return {me.Renderable} Reference to this object for method chaining
        */ rotate: function rotate(angle) {
                if (!isNaN(angle)) {
                    this.currentTransform.rotate(angle);
                    this.isDirty = true;
                }
                return this;
            },
            /**
        * scale the renderable around his anchor point.  Scaling actually applies changes
        * to the currentTransform member wich is used by the renderer to scale the object
        * when rendering.  It does not scale the object itself.  For example if the renderable
        * is an image, the image.width and image.height properties are unaltered but the currentTransform
        * member will be changed.
        * @name scale
        * @memberOf me.Renderable.prototype
        * @function
        * @param {Number} x a number representing the abscissa of the scaling vector.
        * @param {Number} [y=x] a number representing the ordinate of the scaling vector.
        * @return {me.Renderable} Reference to this object for method chaining
        */ scale: function scale(x, y) {
                var _x = x, _y = typeof y === "undefined" ? _x : y; // set the scaleFlag
                this.currentTransform.scale(_x, _y); // corresponding bounding box to be set
                // through the width and height setters
                this.width = this.width * _x;
                this.height = this.height * _y;
                this.isDirty = true;
                return this;
            },
            /**
        * scale the renderable around his anchor point
        * @name scaleV
        * @memberOf me.Renderable.prototype
        * @function
        * @param {me.Vector2d} vector scaling vector
        * @return {me.Renderable} Reference to this object for method chaining
        */ scaleV: function scaleV(v) {
                this.scale(v.x, v.y);
                return this;
            },
            /**
        * update function. <br>
        * automatically called by the game manager {@link me.game}
        * @name update
        * @memberOf me.Renderable.prototype
        * @function
        * @protected
        * @param {Number} dt time since the last update in milliseconds.
        * @return false
        **/ update: function update() /* dt */ {
                return this.isDirty;
            },
            /**
        * update the renderable's bounding rect (private)
        * @ignore
        * @name updateBoundsPos
        * @memberOf me.Renderable.prototype
        * @function
        */ updateBoundsPos: function updateBoundsPos(newX, newY) {
                var bounds = this.getBounds();
                bounds.pos.set(newX, newY, bounds.pos.z); // XXX: This is called from the constructor, before it gets an ancestor
                if (this.ancestor instanceof me.Container && !this.floating) bounds.pos.add(this.ancestor._absPos);
                return bounds;
            },
            /**
        * called when the anchor point value is changed
        * @private
        * @name onAnchorUpdate
        * @memberOf me.Renderable.prototype
        * @function
        */ onAnchorUpdate: function onAnchorUpdate() {
            },
            /**
        * update the bounds
        * @private
        * @deprecated
        * @name updateBounds
        * @memberOf me.Renderable.prototype
        * @function
        */ updateBounds: function updateBounds() {
                console.warn("Deprecated: me.Renderable.updateBounds");
                return this._super(me.Rect, "updateBounds");
            },
            /**
        * prepare the rendering context before drawing
        * (apply defined transforms, anchor point). <br>
        * automatically called by the game manager {@link me.game}
        * @name preDraw
        * @memberOf me.Renderable.prototype
        * @function
        * @protected
        * @param {me.CanvasRenderer|me.WebGLRenderer} renderer a renderer object
        **/ preDraw: function preDraw(renderer) {
                var bounds = this.getBounds();
                var ax = bounds.width * this.anchorPoint.x, ay = bounds.height * this.anchorPoint.y; // save context
                renderer.save(); // apply the defined alpha value
                renderer.setGlobalAlpha(renderer.globalAlpha() * this.getOpacity()); // apply flip
                if (this._flip.x || this._flip.y) {
                    var dx = this._flip.x ? this.centerX - ax : 0, dy = this._flip.y ? this.centerY - ay : 0;
                    renderer.translate(dx, dy);
                    renderer.scale(this._flip.x ? -1 : 1, this._flip.y ? -1 : 1);
                    renderer.translate(-dx, -dy);
                }
                if (this.autoTransform === true && !this.currentTransform.isIdentity()) {
                    // apply the renderable transformation matrix
                    renderer.translate(this.pos.x, this.pos.y);
                    renderer.transform(this.currentTransform);
                    renderer.translate(-this.pos.x, -this.pos.y);
                } // offset by the anchor point
                renderer.translate(-ax, -ay);
                if (typeof this.mask !== "undefined") renderer.setMask(this.mask);
                 // apply the defined tint, if any
                renderer.setTint(this.tint);
            },
            /**
        * object draw. <br>
        * automatically called by the game manager {@link me.game}
        * @name draw
        * @memberOf me.Renderable.prototype
        * @function
        * @protected
        * @param {me.CanvasRenderer|me.WebGLRenderer} renderer a renderer object
        **/ draw: function draw() /*renderer*/ {
            },
            /**
        * restore the rendering context after drawing. <br>
        * automatically called by the game manager {@link me.game}
        * @name postDraw
        * @memberOf me.Renderable.prototype
        * @function
        * @protected
        * @param {me.CanvasRenderer|me.WebGLRenderer} renderer a renderer object
        **/ postDraw: function postDraw(renderer) {
                if (typeof this.mask !== "undefined") renderer.clearMask();
                 // remove the previously applied tint
                renderer.clearTint(); // reset the dirty flag
                this.isDirty = false; // restore the context
                renderer.restore();
            },
            /**
        * Destroy function<br>
        * @ignore
        */ destroy: function destroy() {
                // allow recycling object properties
                me.pool.push(this.currentTransform);
                this.currentTransform = undefined;
                me.pool.push(this.anchorPoint);
                this.anchorPoint = undefined;
                me.pool.push(this.pos);
                this.pos = undefined;
                me.pool.push(this._absPos);
                this._absPos = undefined;
                me.pool.push(this._bounds);
                this._bounds = undefined;
                this.onVisibilityChange = undefined;
                if (typeof this.mask !== "undefined") {
                    me.pool.push(this.mask);
                    this.mask = undefined;
                }
                if (typeof this.tint !== "undefined") {
                    me.pool.push(this.tint);
                    this.tint = undefined;
                }
                this.ancestor = undefined; // destroy the physic body if defined
                if (typeof this.body !== "undefined") {
                    this.body.destroy.apply(this.body, arguments);
                    this.body = undefined;
                } // release all registered events
                me.input.releaseAllPointerEvents(this); // call the user defined destroy method
                this.onDestroyEvent.apply(this, arguments);
            },
            /**
        * OnDestroy Notification function<br>
        * Called by engine before deleting the object
        * @name onDestroyEvent
        * @memberOf me.Renderable
        * @function
        */ onDestroyEvent: function onDestroyEvent() {
            }
        });
        /**
      * Whether the renderable object is visible and within the viewport
      * @public
      * @readonly
      * @type Boolean
      * @default false
      * @name inViewport
      * @memberOf me.Renderable
      */ Object.defineProperty(me.Renderable.prototype, "inViewport", {
            /**
        * @ignore
        */ get: function get() {
                return this._inViewport;
            },
            /**
        * @ignore
        */ set: function set(value) {
                if (this._inViewport !== value) {
                    this._inViewport = value;
                    if (typeof this.onVisibilityChange === "function") this.onVisibilityChange.call(this, value);
                }
            },
            configurable: true
        });
        /**
      * returns true if this renderable is flipped on the horizontal axis
      * @public
      * @see me.Renderable#flipX
      * @type {Boolean}
      * @name isFlippedX
      * @memberOf me.Renderable
      */ Object.defineProperty(me.Renderable.prototype, "isFlippedX", {
            /**
        * @ignore
        */ get: function get() {
                return this._flip.x === true;
            },
            configurable: true
        });
        /**
      * returns true if this renderable is flipped on the vertical axis
      * @public
      * @see me.Renderable#flipY
      * @type {Boolean}
      * @name isFlippedY
      * @memberOf me.Renderable
      */ Object.defineProperty(me.Renderable.prototype, "isFlippedY", {
            /**
        * @ignore
        */ get: function get() {
                return this._flip.y === true;
            },
            configurable: true
        });
        /**
      * width of the Renderable bounding box
      * @public
      * @type {Number}
      * @name width
      * @memberOf me.Renderable
      */ Object.defineProperty(me.Renderable.prototype, "width", {
            /**
        * @ignore
        */ get: function get() {
                return this._width;
            },
            /**
        * @ignore
        */ set: function set(value) {
                if (this._width !== value) {
                    this.getBounds().width = value;
                    this._width = value;
                }
            },
            configurable: true
        });
        /**
      * height of the Renderable bounding box
      * @public
      * @type {Number}
      * @name height
      * @memberOf me.Renderable
      */ Object.defineProperty(me.Renderable.prototype, "height", {
            /**
        * @ignore
        */ get: function get() {
                return this._height;
            },
            /**
        * @ignore
        */ set: function set(value) {
                if (this._height !== value) {
                    this.getBounds().height = value;
                    this._height = value;
                }
            },
            configurable: true
        });
    })();
    (function() {
        /**
      * a generic Color Layer Object.  Fills the entire Canvas with the color not just the container the object belongs to.
      * @class
      * @extends me.Renderable
      * @memberOf me
      * @constructor
      * @param {String} name Layer name
      * @param {me.Color|String} color CSS color
      * @param {Number} z z-index position
      */ me.ColorLayer = me.Renderable.extend({
            /**
        * @ignore
        */ init: function init(name, color, z) {
                // parent constructor
                this._super(me.Renderable, "init", [
                    0,
                    0,
                    Infinity,
                    Infinity
                ]); // apply given parameters
                this.name = name;
                this.pos.z = z;
                this.floating = true;
                /**
          * the layer color component
          * @public
          * @type me.Color
          * @name color
          * @memberOf me.ColorLayer#
          */ // parse the given color
                if (color instanceof me.Color) this.color = color;
                else // string (#RGB, #ARGB, #RRGGBB, #AARRGGBB)
                this.color = me.pool.pull("me.Color").parseCSS(color);
                this.anchorPoint.set(0, 0);
            },
            /**
        * draw the color layer
        * @ignore
        */ draw: function draw(renderer, rect) {
                var color = renderer.getColor();
                var vpos = me.game.viewport.pos;
                renderer.setColor(this.color);
                renderer.fillRect(rect.left - vpos.x, rect.top - vpos.y, rect.width, rect.height);
                renderer.setColor(color);
            },
            /**
        * Destroy function
        * @ignore
        */ destroy: function destroy() {
                me.pool.push(this.color);
                this.color = undefined;
                this._super(me.Renderable, "destroy");
            }
        });
    })();
    (function() {
        /**
      * a generic Image Layer Object
      * @class
      * @extends me.Renderable
      * @memberOf me
      * @constructor
      * @param {Number} x x coordinate
      * @param {Number} y y coordinate
      * @param {Object} settings ImageLayer properties
      * @param {HTMLImageElement|HTMLCanvasElement|String} settings.image Image reference. See {@link me.loader.getImage}
      * @param {String} [settings.name="me.ImageLayer"] layer name
      * @param {Number} [settings.z=0] z-index position
      * @param {Number|me.Vector2d} [settings.ratio=1.0] Scrolling ratio to be applied. See {@link me.ImageLayer#ratio}
      * @param {String} [settings.repeat='repeat'] define if and how an Image Layer should be repeated (accepted values are 'repeat',
     'repeat-x', 'repeat-y', 'no-repeat'). See {@link me.ImageLayer#repeat}
      * @param {Number|me.Vector2d} [settings.anchorPoint=0.0] Image origin. See {@link me.ImageLayer#anchorPoint}
      * @example
      * // create a repetitive background pattern on the X axis using the citycloud image asset
      * me.game.world.addChild(new me.ImageLayer(0, 0, {
      *     image:"citycloud",
      *     repeat :"repeat-x"
      * }), 1);
      */ me.ImageLayer = me.Renderable.extend({
            /**
        * @ignore
        */ init: function init(x, y, settings) {
                // call the constructor
                this._super(me.Renderable, "init", [
                    x,
                    y,
                    Infinity,
                    Infinity
                ]); // get the corresponding image
                this.image = _typeof(settings.image) === "object" ? settings.image : me.loader.getImage(settings.image); // throw an error if image is null/undefined
                if (!this.image) throw new Error((typeof settings.image === "string" ? "'" + settings.image + "'" : "Image") + " file for Image Layer '" + this.name + "' not found!");
                this.imagewidth = this.image.width;
                this.imageheight = this.image.height; // set the sprite name if specified
                if (typeof settings.name === "string") this.name = settings.name;
                 // render in screen coordinates
                this.floating = true; // displaying order
                this.pos.z = settings.z || 0;
                this.offset = me.pool.pull("me.Vector2d", x, y);
                /**
          * Define the image scrolling ratio<br>
          * Scrolling speed is defined by multiplying the viewport delta position (e.g. followed entity) by the specified ratio.
          * Setting this vector to &lt;0.0,0.0&gt; will disable automatic scrolling.<br>
          * To specify a value through Tiled, use one of the following format : <br>
          * - a number, to change the value for both axis <br>
          * - a json expression like `json:{"x":0.5,"y":0.5}` if you wish to specify a different value for both x and y
          * @public
          * @type me.Vector2d
          * @default <1.0,1.0>
          * @name me.ImageLayer#ratio
          */ this.ratio = me.pool.pull("me.Vector2d", 1, 1);
                if (typeof settings.ratio !== "undefined") {
                    // little hack for backward compatiblity
                    if (typeof settings.ratio === "number") this.ratio.set(settings.ratio, settings.ratio);
                    else this.ratio.setV(settings.ratio);
                }
                if (typeof settings.anchorPoint === "undefined") /**
            * Define how the image is anchored to the viewport bounds<br>
            * By default, its upper-left corner is anchored to the viewport bounds upper left corner.<br>
            * The anchorPoint is a unit vector where each component falls in range [0.0,1.0].<br>
            * Some common examples:<br>
            * * &lt;0.0,0.0&gt; : (Default) Anchor image to the upper-left corner of viewport bounds
            * * &lt;0.5,0.5&gt; : Center the image within viewport bounds
            * * &lt;1.0,1.0&gt; : Anchor image to the lower-right corner of viewport bounds
            * To specify a value through Tiled, use one of the following format : <br>
            * - a number, to change the value for both axis <br>
            * - a json expression like `json:{"x":0.5,"y":0.5}` if you wish to specify a different value for both x and y
            * @public
            * @type me.Vector2d
            * @default <0.0,0.0>
            * @name me.ImageLayer#anchorPoint
            */ this.anchorPoint.set(0, 0);
                else if (typeof settings.anchorPoint === "number") this.anchorPoint.set(settings.anchorPoint, settings.anchorPoint);
                else this.anchorPoint.setV(settings.anchorPoint);
                /**
          * Define if and how an Image Layer should be repeated.<br>
          * By default, an Image Layer is repeated both vertically and horizontally.<br>
          * Acceptable values : <br>
          * * 'repeat' - The background image will be repeated both vertically and horizontally <br>
          * * 'repeat-x' - The background image will be repeated only horizontally.<br>
          * * 'repeat-y' - The background image will be repeated only vertically.<br>
          * * 'no-repeat' - The background-image will not be repeated.<br>
          * @public
          * @type String
          * @default 'repeat'
          * @name me.ImageLayer#repeat
          */ Object.defineProperty(this, "repeat", {
                    /**
            * @ignore
            */ get: function get() {
                        return this._repeat;
                    },
                    /**
            * @ignore
            */ set: function set(val) {
                        this._repeat = val;
                        switch(this._repeat){
                            case "no-repeat":
                                this.repeatX = false;
                                this.repeatY = false;
                                break;
                            case "repeat-x":
                                this.repeatX = true;
                                this.repeatY = false;
                                break;
                            case "repeat-y":
                                this.repeatX = false;
                                this.repeatY = true;
                                break;
                            default:
                                // "repeat"
                                this.repeatX = true;
                                this.repeatY = true;
                                break;
                        }
                        this.resize(me.game.viewport.width, me.game.viewport.height);
                        this.createPattern();
                    },
                    configurable: true
                });
                this.repeat = settings.repeat || "repeat"; // on context lost, all previous textures are destroyed
                me.event.subscribe(me.event.WEBGL_ONCONTEXT_RESTORED, this.createPattern.bind(this));
            },
            // called when the layer is added to the game world or a container
            onActivateEvent: function onActivateEvent() {
                var _updateLayerFn = this.updateLayer.bind(this); // register to the viewport change notification
                this.vpChangeHdlr = me.event.subscribe(me.event.VIEWPORT_ONCHANGE, _updateLayerFn);
                this.vpResizeHdlr = me.event.subscribe(me.event.VIEWPORT_ONRESIZE, this.resize.bind(this));
                this.vpLoadedHdlr = me.event.subscribe(me.event.LEVEL_LOADED, function() {
                    // force a first refresh when the level is loaded
                    _updateLayerFn(me.game.viewport.pos);
                }); // in case the level is not added to the root container,
                // the onActivateEvent call happens after the LEVEL_LOADED event
                // so we need to force a first update
                if (this.ancestor.root !== true) this.updateLayer(me.game.viewport.pos);
            },
            /**
        * resize the Image Layer to match the given size
        * @name resize
        * @memberOf me.ImageLayer.prototype
        * @function
        * @param {Number} w new width
        * @param {Number} h new height
       */ resize: function resize(w, h) {
                this._super(me.Renderable, "resize", [
                    this.repeatX ? Infinity : w,
                    this.repeatY ? Infinity : h
                ]);
            },
            /**
        * createPattern function
        * @ignore
        * @function
        */ createPattern: function createPattern() {
                this._pattern = me.video.renderer.createPattern(this.image, this._repeat);
            },
            /**
        * updateLayer function
        * @ignore
        * @function
        */ updateLayer: function updateLayer(vpos) {
                var rx = this.ratio.x, ry = this.ratio.y;
                if (rx === 0 && ry === 0) // static image
                return;
                var viewport = me.game.viewport, width = this.imagewidth, height = this.imageheight, bw = viewport.bounds.width, bh = viewport.bounds.height, ax = this.anchorPoint.x, ay = this.anchorPoint.y, /*
          * Automatic positioning
          *
          * See https://github.com/melonjs/melonJS/issues/741#issuecomment-138431532
          * for a thorough description of how this works.
          */ x = ax * (rx - 1) * (bw - viewport.width) + this.offset.x - rx * vpos.x, y = ay * (ry - 1) * (bh - viewport.height) + this.offset.y - ry * vpos.y; // Repeat horizontally; start drawing from left boundary
                if (this.repeatX) this.pos.x = x % width;
                else this.pos.x = x;
                 // Repeat vertically; start drawing from top boundary
                if (this.repeatY) this.pos.y = y % height;
                else this.pos.y = y;
            },
            /*
        * override the default predraw function
        * as repeat and anchor are managed directly in the draw method
        * @ignore
        */ preDraw: function preDraw(renderer) {
                // save the context
                renderer.save(); // apply the defined alpha value
                renderer.setGlobalAlpha(renderer.globalAlpha() * this.getOpacity());
            },
            /**
        * draw the image layer
        * @ignore
        */ draw: function draw(renderer) {
                var viewport = me.game.viewport, width = this.imagewidth, height = this.imageheight, bw = viewport.bounds.width, bh = viewport.bounds.height, ax = this.anchorPoint.x, ay = this.anchorPoint.y, x = this.pos.x, y = this.pos.y;
                if (this.ratio.x === 0 && this.ratio.y === 0) {
                    // static image
                    x = x + ax * (bw - width);
                    y = y + ay * (bh - height);
                }
                renderer.translate(x, y);
                renderer.drawPattern(this._pattern, 0, 0, viewport.width * 2, viewport.height * 2);
            },
            // called when the layer is removed from the game world or a container
            onDeactivateEvent: function onDeactivateEvent() {
                // cancel all event subscriptions
                me.event.unsubscribe(this.vpChangeHdlr);
                me.event.unsubscribe(this.vpResizeHdlr);
                me.event.unsubscribe(this.vpLoadedHdlr);
            },
            /**
        * Destroy function<br>
        * @ignore
        */ destroy: function destroy() {
                me.pool.push(this.offset);
                this.offset = undefined;
                me.pool.push(this.ratio);
                this.ratio = undefined;
                this._super(me.Renderable, "destroy");
            }
        });
    })();
    (function() {
        /**
      * An object to display a fixed or animated sprite on screen.
      * @class
      * @extends me.Renderable
      * @memberOf me
      * @constructor
      * @param {Number} x the x coordinates of the sprite object
      * @param {Number} y the y coordinates of the sprite object
      * @param {Object} settings Configuration parameters for the Sprite object
      * @param {me.video.renderer.Texture|HTMLImageElement|HTMLCanvasElement|String} settings.image reference to a texture, spritesheet image or to a texture atlas
      * @param {String} [settings.name=""] name of this object
      * @param {String} [settings.region] region name of a specific region to use when using a texture atlas, see {@link me.Renderer.Texture}
      * @param {Number} [settings.framewidth] Width of a single frame within the spritesheet
      * @param {Number} [settings.frameheight] Height of a single frame within the spritesheet
      * @param {Number} [settings.flipX] flip the sprite on the horizontal axis
      * @param {Number} [settings.flipY] flip the sprite on the vertical axis
      * @param {me.Vector2d} [settings.anchorPoint={x:0.5, y:0.5}] Anchor point to draw the frame at (defaults to the center of the frame).
      * @example
      * // create a single sprite from a standalone image, with anchor in the center
      * var sprite = new me.Sprite(0, 0, {
      *     image : "PlayerTexture",
      *     framewidth : 64,
      *     frameheight : 64,
      *     anchorPoint : new me.Vector2d(0.5, 0.5)
      * });
      *
      * // create a single sprite from a packed texture
      * game.texture = new me.video.renderer.Texture(
      *     me.loader.getJSON("texture"),
      *     me.loader.getImage("texture")
      * );
      * var sprite = new me.Sprite(0, 0, {
      *     image : game.texture,
      *     region : "npc2.png",
      * });
      */ me.Sprite = me.Renderable.extend({
            /**
        * @ignore
        */ init: function init(x, y, settings) {
                /**
          * pause and resume animation
          * @public
          * @type Boolean
          * @default false
          * @name me.Sprite#animationpause
          */ this.animationpause = false;
                /**
          * animation cycling speed (delay between frame in ms)
          * @public
          * @type Number
          * @default 100
          * @name me.Sprite#animationspeed
          */ this.animationspeed = 100;
                /**
          * global offset for the position to draw from on the source image.
          * @public
          * @type me.Vector2d
          * @default <0.0,0.0>
          * @name offset
          * @memberOf me.Sprite#
          */ this.offset = me.pool.pull("me.Vector2d", 0, 0);
                /**
          * The source texture object this sprite object is using
          * @public
          * @type me.video.renderer.Texture
          * @name source
          * @memberOf me.Sprite#
          */ this.source = null; // hold all defined animation
                this.anim = {
                }; // a flag to reset animation
                this.resetAnim = undefined; // current frame information
                // (reusing current, any better/cleaner place?)
                this.current = {
                    // the current animation name
                    name: "default",
                    // length of the current animation name
                    length: 0,
                    //current frame texture offset
                    offset: new me.Vector2d(),
                    // current frame size
                    width: 0,
                    height: 0,
                    // Source rotation angle for pre-rotating the source image
                    angle: 0,
                    // current frame index
                    idx: 0
                }; // animation frame delta
                this.dt = 0; // flicker settings
                this._flicker = {
                    isFlickering: false,
                    duration: 0,
                    callback: null,
                    state: false
                }; // call the super constructor
                this._super(me.Renderable, "init", [
                    x,
                    y,
                    0,
                    0
                ]); // set the proper image/texture to use
                if (settings.image instanceof me.Renderer.prototype.Texture) {
                    this.source = settings.image;
                    this.image = this.source.getTexture();
                    this.textureAtlas = settings.image; // check for defined region
                    if (typeof settings.region !== "undefined") {
                        // use a texture atlas
                        var region = this.source.getRegion(settings.region);
                        if (region) {
                            // set the sprite region within the texture
                            this.setRegion(region); // update the default "current" frame size
                            this.current.width = settings.framewidth || region.width;
                            this.current.height = settings.frameheight || region.height;
                        } else // throw an error
                        throw new Error("Texture - region for " + settings.region + " not found");
                    }
                } else {
                    // HTMLImageElement/Canvas or String
                    this.image = _typeof(settings.image) === "object" ? settings.image : me.loader.getImage(settings.image); // update the default "current" frame size
                    this.current.width = settings.framewidth = settings.framewidth || this.image.width;
                    this.current.height = settings.frameheight = settings.frameheight || this.image.height;
                    this.source = me.video.renderer.cache.get(this.image, settings);
                    this.textureAtlas = this.source.getAtlas();
                } // store/reset the current atlas information if specified
                if (typeof settings.atlas !== "undefined") {
                    this.textureAtlas = settings.atlas;
                    this.atlasIndices = settings.atlasIndices;
                } else this.atlasIndices = null;
                 // resize based on the active frame
                this.width = this.current.width;
                this.height = this.current.height; // apply flip flags if specified
                if (typeof settings.flipX !== "undefined") this.flipX(!!settings.flipX);
                if (typeof settings.flipY !== "undefined") this.flipY(!!settings.flipY);
                 // set the default rotation angle is defined in the settings
                // * WARNING: rotating sprites decreases performance with Canvas Renderer
                if (typeof settings.rotation !== "undefined") this.currentTransform.rotate(settings.rotation);
                 // update anchorPoint
                if (settings.anchorPoint) this.anchorPoint.set(settings.anchorPoint.x, settings.anchorPoint.y);
                 // set the sprite name if specified
                if (typeof settings.name === "string") this.name = settings.name;
                 // for sprite, addAnimation will return !=0
                if (this.addAnimation("default", null) !== 0) // set as default
                this.setCurrentAnimation("default");
                 // enable currentTransform for me.Sprite based objects
                this.autoTransform = true;
            },
            /**
        * return the flickering state of the object
        * @name isFlickering
        * @memberOf me.Sprite.prototype
        * @function
        * @return {Boolean}
        */ isFlickering: function isFlickering() {
                return this._flicker.isFlickering;
            },
            /**
        * make the object flicker
        * @name flicker
        * @memberOf me.Sprite.prototype
        * @function
        * @param {Number} duration expressed in milliseconds
        * @param {Function} callback Function to call when flickering ends
        * @return {me.Sprite} Reference to this object for method chaining
        * @example
        * // make the object flicker for 1 second
        * // and then remove it
        * this.flicker(1000, function () {
        *     me.game.world.removeChild(this);
        * });
        */ flicker: function flicker(duration, callback) {
                this._flicker.duration = duration;
                if (this._flicker.duration <= 0) {
                    this._flicker.isFlickering = false;
                    this._flicker.callback = null;
                } else if (!this._flicker.isFlickering) {
                    this._flicker.callback = callback;
                    this._flicker.isFlickering = true;
                }
                return this;
            },
            /**
        * add an animation <br>
        * For fixed-sized cell sprite sheet, the index list must follow the
        * logic as per the following example :<br>
        * <img src="images/spritesheet_grid.png"/>
        * @name addAnimation
        * @memberOf me.Sprite.prototype
        * @function
        * @param {String} name animation id
        * @param {Number[]|String[]|Object[]} index list of sprite index or name
        * defining the animation. Can also use objects to specify delay for each frame, see below
        * @param {Number} [animationspeed] cycling speed for animation in ms
        * @return {Number} frame amount of frame added to the animation (delay between each frame).
        * @see me.Sprite#animationspeed
        * @example
        * // walking animation
        * this.addAnimation("walk", [ 0, 1, 2, 3, 4, 5 ]);
        * // standing animation
        * this.addAnimation("stand", [ 11, 12 ]);
        * // eating animation
        * this.addAnimation("eat", [ 6, 6 ]);
        * // rolling animation
        * this.addAnimation("roll", [ 7, 8, 9, 10 ]);
        * // slower animation
        * this.addAnimation("roll", [ 7, 8, 9, 10 ], 200);
        * // or get more specific with delay for each frame. Good solution instead of repeating:
        * this.addAnimation("turn", [{ name: 0, delay: 200 }, { name: 1, delay: 100 }])
        * // can do this with atlas values as well:
        * this.addAnimation("turn", [{ name: "turnone", delay: 200 }, { name: "turntwo", delay: 100 }])
        * // define an dying animation that stop on the last frame
        * this.addAnimation("die", [{ name: 3, delay: 200 }, { name: 4, delay: 100 }, { name: 5, delay: Infinity }])
        * // set the standing animation as default
        * this.setCurrentAnimation("stand");
        */ addAnimation: function addAnimation(name, index, animationspeed) {
                this.anim[name] = {
                    name: name,
                    frames: [],
                    idx: 0,
                    length: 0
                }; // # of frames
                var counter = 0;
                if (_typeof(this.textureAtlas) !== "object") return 0;
                if (index == null) {
                    index = []; // create a default animation with all frame
                    Object.keys(this.textureAtlas).forEach(function(v, i) {
                        index[i] = i;
                    });
                } // set each frame configuration (offset, size, etc..)
                for(var i = 0, len = index.length; i < len; i++){
                    var frame = index[i];
                    var frameObject;
                    if (typeof frame === "number" || typeof frame === "string") frameObject = {
                        name: frame,
                        delay: animationspeed || this.animationspeed
                    };
                    else frameObject = frame;
                    var frameObjectName = frameObject.name;
                    if (typeof frameObjectName === "number") {
                        if (typeof this.textureAtlas[frameObjectName] !== "undefined") {
                            // TODO: adding the cache source coordinates add undefined entries in webGL mode
                            this.anim[name].frames[i] = Object.assign({
                            }, this.textureAtlas[frameObjectName], frameObject);
                            counter++;
                        }
                    } else {
                        // string
                        if (this.atlasIndices === null) throw new Error("string parameters for addAnimation are not allowed for standard spritesheet based Texture");
                        else {
                            this.anim[name].frames[i] = Object.assign({
                            }, this.textureAtlas[this.atlasIndices[frameObjectName]], frameObject);
                            counter++;
                        }
                    }
                }
                this.anim[name].length = counter;
                return counter;
            },
            /**
        * set the current animation
        * this will always change the animation & set the frame to zero
        * @name setCurrentAnimation
        * @memberOf me.Sprite.prototype
        * @function
        * @param {String} name animation id
        * @param {String|Function} [onComplete] animation id to switch to when complete, or callback
        * @return {me.Sprite} Reference to this object for method chaining
        * @example
        * // set "walk" animation
        * this.setCurrentAnimation("walk");
        *
        * // set "walk" animation if it is not the current animation
        * if (this.isCurrentAnimation("walk")) {
        *     this.setCurrentAnimation("walk");
        * }
        *
        * // set "eat" animation, and switch to "walk" when complete
        * this.setCurrentAnimation("eat", "walk");
        *
        * // set "die" animation, and remove the object when finished
        * this.setCurrentAnimation("die", (function () {
        *    me.game.world.removeChild(this);
        *    return false; // do not reset to first frame
        * }).bind(this));
        *
        * // set "attack" animation, and pause for a short duration
        * this.setCurrentAnimation("die", (function () {
        *    this.animationpause = true;
        *
        *    // back to "standing" animation after 1 second
        *    setTimeout(function () {
        *        this.setCurrentAnimation("standing");
        *    }, 1000);
        *
        *    return false; // do not reset to first frame
        * }).bind(this));
        **/ setCurrentAnimation: function setCurrentAnimation(name, resetAnim, _preserve_dt) {
                if (this.anim[name]) {
                    this.current.name = name;
                    this.current.length = this.anim[this.current.name].length;
                    if (typeof resetAnim === "string") this.resetAnim = this.setCurrentAnimation.bind(this, resetAnim, null, true);
                    else if (typeof resetAnim === "function") this.resetAnim = resetAnim;
                    else this.resetAnim = undefined;
                    this.setAnimationFrame(this.current.idx);
                    if (!_preserve_dt) this.dt = 0;
                    this.isDirty = true;
                } else throw new Error("animation id '" + name + "' not defined");
                return this;
            },
            /**
        * reverse the given or current animation if none is specified
        * @name reverseAnimation
        * @memberOf me.Sprite.prototype
        * @function
        * @param {String} [name] animation id
        * @return {me.Sprite} Reference to this object for method chaining
        * @see me.Sprite#animationspeed
        */ reverseAnimation: function reverseAnimation(name) {
                if (typeof name !== "undefined" && typeof this.anim[name] !== "undefined") this.anim[name].frames.reverse();
                else this.anim[this.current.name].frames.reverse();
                this.isDirty = true;
                return this;
            },
            /**
        * return true if the specified animation is the current one.
        * @name isCurrentAnimation
        * @memberOf me.Sprite.prototype
        * @function
        * @param {String} name animation id
        * @return {Boolean}
        * @example
        * if (!this.isCurrentAnimation("walk")) {
        *     // do something funny...
        * }
        */ isCurrentAnimation: function isCurrentAnimation(name) {
                return this.current.name === name;
            },
            /**
        * change the current texture atlas region for this sprite
        * @see me.Texture.getRegion
        * @name setRegion
        * @memberOf me.Sprite.prototype
        * @function
        * @param {Object} region typically returned through me.Texture.getRegion()
        * @return {me.Sprite} Reference to this object for method chaining
        * @example
        * // change the sprite to "shadedDark13.png";
        * mySprite.setRegion(game.texture.getRegion("shadedDark13.png"));
        */ setRegion: function setRegion(region) {
                if (this.source !== null) // set the source texture for the given region
                this.image = this.source.getTexture(region);
                 // set the sprite offset within the texture
                this.current.offset.setV(region.offset); // set angle if defined
                this.current.angle = region.angle; // update the default "current" size
                this.width = this.current.width = region.width;
                this.height = this.current.height = region.height; // set global anchortPoint if defined
                if (region.anchorPoint) this.anchorPoint.set(this._flip.x && region.trimmed === true ? 1 - region.anchorPoint.x : region.anchorPoint.x, this._flip.y && region.trimmed === true ? 1 - region.anchorPoint.y : region.anchorPoint.y);
                this.isDirty = true;
                return this;
            },
            /**
        * force the current animation frame index.
        * @name setAnimationFrame
        * @memberOf me.Sprite.prototype
        * @function
        * @param {Number} [index=0] animation frame index
        * @return {me.Sprite} Reference to this object for method chaining
        * @example
        * // reset the current animation to the first frame
        * this.setAnimationFrame();
        */ setAnimationFrame: function setAnimationFrame(idx) {
                this.current.idx = (idx || 0) % this.current.length;
                return this.setRegion(this.getAnimationFrameObjectByIndex(this.current.idx));
            },
            /**
        * return the current animation frame index.
        * @name getCurrentAnimationFrame
        * @memberOf me.Sprite.prototype
        * @function
        * @return {Number} current animation frame index
        */ getCurrentAnimationFrame: function getCurrentAnimationFrame() {
                return this.current.idx;
            },
            /**
        * Returns the frame object by the index.
        * @name getAnimationFrameObjectByIndex
        * @memberOf me.Sprite.prototype
        * @function
        * @private
        * @return {Number} if using number indices. Returns {Object} containing frame data if using texture atlas
        */ getAnimationFrameObjectByIndex: function getAnimationFrameObjectByIndex(id) {
                return this.anim[this.current.name].frames[id];
            },
            /**
        * @ignore
        */ update: function update(dt) {
                // Update animation if necessary
                if (!this.animationpause && this.current && this.current.length > 0) {
                    var duration = this.getAnimationFrameObjectByIndex(this.current.idx).delay;
                    this.dt += dt;
                    while(this.dt >= duration){
                        this.isDirty = true;
                        this.dt -= duration;
                        var nextFrame = this.current.length > 1 ? this.current.idx + 1 : this.current.idx;
                        this.setAnimationFrame(nextFrame); // Switch animation if we reach the end of the strip and a callback is defined
                        if (this.current.idx === 0 && typeof this.resetAnim === "function") // Otherwise is must be callable
                        {
                            if (this.resetAnim() === false) {
                                // Reset to last frame
                                this.setAnimationFrame(this.current.length - 1); // Bail early without skipping any more frames.
                                this.dt %= duration;
                                break;
                            }
                        } // Get next frame duration
                        duration = this.getAnimationFrameObjectByIndex(this.current.idx).delay;
                    }
                } //update the "flickering" state if necessary
                if (this._flicker.isFlickering) {
                    this._flicker.duration -= dt;
                    if (this._flicker.duration < 0) {
                        if (typeof this._flicker.callback === "function") this._flicker.callback();
                        this.flicker(-1);
                    }
                    this.isDirty = true;
                }
                return this.isDirty;
            },
            /**
        * update the renderable's bounding rect (private)
        * @ignore
        * @name updateBoundsPos
        * @memberOf me.Sprite.prototype
        * @function
        */ updateBoundsPos: function updateBoundsPos(newX, newY) {
                var bounds = this.getBounds();
                bounds.pos.set(newX - this.anchorPoint.x * bounds.width, newY - this.anchorPoint.y * bounds.height); // XXX: This is called from the constructor, before it gets an ancestor
                if (this.ancestor instanceof me.Container && !this.floating) bounds.pos.add(this.ancestor._absPos);
                return bounds;
            },
            /**
        * called when the anchor point value is changed
        * @private
        * @name onAnchorUpdate
        * @memberOf me.Sprite.prototype
        * @function
        */ onAnchorUpdate: function onAnchorUpdate(newX, newY) {
                // since the callback is called before setting the new value
                // manually update the anchor point (required for updateBoundsPos)
                this.anchorPoint.setMuted(newX, newY); // then call updateBouds
                this.updateBoundsPos(this.pos.x, this.pos.y);
            },
            /**
        * Destroy function<br>
        * @ignore
        */ destroy: function destroy() {
                me.pool.push(this.offset);
                this.offset = undefined;
                this._super(me.Renderable, "destroy");
            },
            /**
        * @ignore
        */ draw: function draw(renderer) {
                // do nothing if we are flickering
                if (this._flicker.isFlickering) {
                    this._flicker.state = !this._flicker.state;
                    if (!this._flicker.state) return;
                } // the frame to draw
                var frame = this.current; // cache the current position and size
                var xpos = this.pos.x, ypos = this.pos.y;
                var w = frame.width, h = frame.height; // frame offset in the texture/atlas
                var frame_offset = frame.offset;
                var g_offset = this.offset; // remove image's TexturePacker/ShoeBox rotation
                if (frame.angle !== 0) {
                    renderer.translate(-xpos, -ypos);
                    renderer.rotate(frame.angle);
                    xpos -= h;
                    w = frame.height;
                    h = frame.width;
                }
                renderer.drawImage(this.image, g_offset.x + frame_offset.x, g_offset.y + frame_offset.y, w, h, xpos, ypos, w, h // dw,dh
                );
            }
        });
    })();
    (function() {
        /**
      * GUI Object<br>
      * A very basic object to manage GUI elements <br>
      * The object simply register on the "pointerdown" <br>
      * or "touchstart" event and call the onClick function"
      * @class
      * @extends me.Sprite
      * @memberOf me
      * @constructor
      * @param {Number} x the x coordinate of the GUI Object
      * @param {Number} y the y coordinate of the GUI Object
      * @param {Object} settings See {@link me.Sprite}
      * @example
      *
      * // create a basic GUI Object
      * var myButton = me.GUI_Object.extend(
      * {
      *    init:function (x, y)
      *    {
      *       var settings = {}
      *       settings.image = "button";
      *       settings.framewidth = 100;
      *       settings.frameheight = 50;
      *       // super constructor
      *       this._super(me.GUI_Object, "init", [x, y, settings]);
      *       // define the object z order
      *       this.pos.z = 4;
      *    },
      *
      *    // output something in the console
      *    // when the object is clicked
      *    onClick:function (event)
      *    {
      *       console.log("clicked!");
      *       // don't propagate the event
      *       return false;
      *    }
      * });
      *
      * // add the object at pos (10,10)
      * me.game.world.addChild(new myButton(10,10));
      *
      */ me.GUI_Object = me.Sprite.extend({
            /**
        * @ignore
        */ init: function init(x, y, settings) {
                /**
          * object can be clicked or not
          * @public
          * @type boolean
          * @default true
          * @name me.GUI_Object#isClickable
          */ this.isClickable = true;
                /**
          * Tap and hold threshold timeout in ms
          * @type {number}
          * @default 250
          * @name me.GUI_Object#holdThreshold
          */ this.holdThreshold = 250;
                /**
          * object can be tap and hold
          * @public
          * @type boolean
          * @default false
          * @name me.GUI_Object#isHoldable
          */ this.isHoldable = false;
                /**
          * true if the pointer is over the object
          * @public
          * @type boolean
          * @default false
          * @name me.GUI_Object#hover
          */ this.hover = false; // object has been updated (clicked,etc..)
                this.holdTimeout = null;
                this.updated = false;
                this.released = true; // call the parent constructor
                this._super(me.Sprite, "init", [
                    x,
                    y,
                    settings
                ]); // GUI items use screen coordinates
                this.floating = true; // enable event detection
                this.isKinematic = false;
            },
            /**
        * return true if the object has been clicked
        * @ignore
        */ update: function update(dt) {
                // call the parent constructor
                var updated = this._super(me.Sprite, "update", [
                    dt
                ]); // check if the button was updated
                if (this.updated) {
                    // clear the flag
                    if (!this.released) this.updated = false;
                    return true;
                } // else only return true/false based on the parent function
                return updated;
            },
            /**
        * function callback for the pointerdown event
        * @ignore
        */ clicked: function clicked(event) {
                // Check if left mouse button is pressed
                if (event.button === 0 && this.isClickable) {
                    this.updated = true;
                    this.released = false;
                    if (this.isHoldable) {
                        if (this.holdTimeout !== null) me.timer.clearTimeout(this.holdTimeout);
                        this.holdTimeout = me.timer.setTimeout(this.hold.bind(this), this.holdThreshold, false);
                        this.released = false;
                    }
                    return this.onClick.call(this, event);
                }
            },
            /**
        * function called when the object is pressed <br>
        * to be extended <br>
        * return false if we need to stop propagating the event
        * @name onClick
        * @memberOf me.GUI_Object.prototype
        * @public
        * @function
        * @param {Event} event the event object
        */ onClick: function onClick() /* event */ {
                return false;
            },
            /**
        * function callback for the pointerEnter event
        * @ignore
        */ enter: function enter(event) {
                this.hover = true;
                return this.onOver.call(this, event);
            },
            /**
        * function called when the pointer is over the object
        * @name onOver
        * @memberOf me.GUI_Object.prototype
        * @public
        * @function
        * @param {Event} event the event object
        */ onOver: function onOver() /* event */ {
            },
            /**
        * function callback for the pointerLeave event
        * @ignore
        */ leave: function leave(event) {
                this.hover = false;
                this.release.call(this, event);
                return this.onOut.call(this, event);
            },
            /**
        * function called when the pointer is leaving the object area
        * @name onOut
        * @memberOf me.GUI_Object.prototype
        * @public
        * @function
        * @param {Event} event the event object
        */ onOut: function onOut() /* event */ {
            },
            /**
        * function callback for the pointerup event
        * @ignore
        */ release: function release(event) {
                if (this.released === false) {
                    this.released = true;
                    me.timer.clearTimeout(this.holdTimeout);
                    return this.onRelease.call(this, event);
                }
            },
            /**
        * function called when the object is pressed and released <br>
        * to be extended <br>
        * return false if we need to stop propagating the event
        * @name onRelease
        * @memberOf me.GUI_Object.prototype
        * @public
        * @function
        * @param {Event} event the event object
        */ onRelease: function onRelease() {
                return false;
            },
            /**
        * function callback for the tap and hold timer event
        * @ignore
        */ hold: function hold() {
                me.timer.clearTimeout(this.holdTimeout);
                if (!this.released) this.onHold.call(this);
            },
            /**
        * function called when the object is pressed and held<br>
        * to be extended <br>
        * @name onHold
        * @memberOf me.GUI_Object.prototype
        * @public
        * @function
        */ onHold: function onHold() {
            },
            /**
        * function called when added to the game world or a container
        * @ignore
        */ onActivateEvent: function onActivateEvent() {
                // register pointer events
                me.input.registerPointerEvent("pointerdown", this, this.clicked.bind(this));
                me.input.registerPointerEvent("pointerup", this, this.release.bind(this));
                me.input.registerPointerEvent("pointercancel", this, this.release.bind(this));
                me.input.registerPointerEvent("pointerenter", this, this.enter.bind(this));
                me.input.registerPointerEvent("pointerleave", this, this.leave.bind(this));
            },
            /**
        * function called when removed from the game world or a container
        * @ignore
        */ onDeactivateEvent: function onDeactivateEvent() {
                // release pointer events
                me.input.releasePointerEvent("pointerdown", this);
                me.input.releasePointerEvent("pointerup", this);
                me.input.releasePointerEvent("pointercancel", this);
                me.input.releasePointerEvent("pointerenter", this);
                me.input.releasePointerEvent("pointerleave", this);
                me.timer.clearTimeout(this.holdTimeout);
            }
        });
    })();
    (function() {
        /**
      * Private function to re-use for object removal in a defer
      * @ignore
      */ var deferredRemove = function deferredRemove1(child, keepalive) {
            this.removeChildNow(child, keepalive);
        };
        var globalFloatingCounter = 0;
        /**
      * me.Container represents a collection of child objects
      * @class
      * @extends me.Renderable
      * @memberOf me
      * @constructor
      * @param {Number} [x=0] position of the container (accessible via the inherited pos.x property)
      * @param {Number} [y=0] position of the container (accessible via the inherited pos.y property)
      * @param {Number} [w=me.game.viewport.width] width of the container
      * @param {Number} [h=me.game.viewport.height] height of the container
      */ me.Container = me.Renderable.extend({
            /**
        * @ignore
        */ init: function init(x, y, width, height, root) {
                /**
          * keep track of pending sort
          * @ignore
          */ this.pendingSort = null; // call the _super constructor
                this._super(me.Renderable, "init", [
                    x || 0,
                    y || 0,
                    width || Infinity,
                    height || Infinity
                ]);
                /**
          * whether the container is the root of the scene
          * @public
          * @type Boolean
          * @default false
          * @name root
          * @memberOf me.Container
          */ this.root = root || false;
                /**
          * The array of children of this container.
          * @ignore
          */ this.children = [];
                /**
          * The property of the child object that should be used to sort on <br>
          * value : "x", "y", "z"
          * @public
          * @type String
          * @default me.game.sortOn
          * @name sortOn
          * @memberOf me.Container
          */ this.sortOn = me.game.sortOn;
                /**
          * Specify if the children list should be automatically sorted when adding a new child
          * @public
          * @type Boolean
          * @default true
          * @name autoSort
          * @memberOf me.Container
          */ this.autoSort = true;
                /**
          * Specify if the children z index should automatically be managed by the parent container
          * @public
          * @type Boolean
          * @default true
          * @name autoDepth
          * @memberOf me.Container
          */ this.autoDepth = true;
                /**
          * Specify if the container draw operation should clip his children to its own bounds
          * @public
          * @type Boolean
          * @default false
          * @name clipping
          * @memberOf me.Container
          */ this.clipping = false;
                /**
          * a callback to be extended, triggered after a child has been added or removed
          * @name onChildChange
          * @memberOf me.Container#
          * @function
          * @param {Number} index added or removed child index
          */ this.onChildChange = function() /* index */ {
                };
                /**
          * Used by the debug panel plugin
          * @ignore
          */ this.drawCount = 0;
                /**
          * The bounds that contains all its children
          * @public
          * @type me.Rect
          * @name childBounds
          * @memberOf me.Container#
          */ this.childBounds = this.getBounds().clone(); // container self apply any defined transformation
                this.autoTransform = true; // enable collision and event detection
                this.isKinematic = false; // subscribe on the canvas resize event
                if (this.root === true) // XXX: Workaround for not updating container child-bounds automatically (it's expensive!)
                me.event.subscribe(me.event.CANVAS_ONRESIZE, this.updateChildBounds.bind(this));
            },
            /**
        * reset the container, removing all childrens, and reseting transforms.
        * @name reset
        * @memberOf me.Container
        * @function
        */ reset: function reset() {
                // cancel any sort operation
                if (this.pendingSort) {
                    clearTimeout(this.pendingSort);
                    this.pendingSort = null;
                } // delete all children
                for(var i = this.children.length, obj; i >= 0; obj = this.children[--i])// don't remove it if a persistent object
                if (obj && !obj.isPersistent) this.removeChildNow(obj);
                if (typeof this.currentTransform !== "undefined") // just reset some variables
                this.currentTransform.identity();
            },
            /**
        * Add a child to the container <br>
        * if auto-sort is disable, the object will be appended at the bottom of the list.
        * Adding a child to the container will automatically remove it from its other container.
        * Meaning a child can only have one parent.  This is important if you add a renderable
        * to a container then add it to the me.game.world container it will move it out of the
        * orginal container.  Then when the me.game.world.reset() is called the renderable
        * will not be in any container.
        * @name addChild
        * @memberOf me.Container.prototype
        * @function
        * @param {me.Renderable} child
        * @param {number} [z] forces the z index of the child to the specified value
        * @return {me.Renderable} the added child
        */ addChild: function addChild(child, z) {
                if (child.ancestor instanceof me.Container) child.ancestor.removeChildNow(child);
                else // only allocate a GUID if the object has no previous ancestor
                // (e.g. move one child from one container to another)
                if (child.isRenderable) // allocated a GUID value (use child.id as based index if defined)
                child.GUID = me.utils.createGUID(child.id);
                child.ancestor = this;
                this.children.push(child); // set the child z value if required
                if (typeof child.pos !== "undefined") {
                    if (typeof z === "number") child.pos.z = z;
                    else if (this.autoDepth === true) child.pos.z = this.children.length;
                }
                if (this.autoSort === true) this.sort();
                if (typeof child.onActivateEvent === "function" && this.isAttachedToRoot()) child.onActivateEvent();
                 // force repaint in case this is a static non-animated object
                if (this.isAttachedToRoot() === true) me.game.repaint();
                this.onChildChange.call(this, this.children.length - 1);
                return child;
            },
            /**
        * Add a child to the container at the specified index<br>
        * (the list won't be sorted after insertion)
        * @name addChildAt
        * @memberOf me.Container.prototype
        * @function
        * @param {me.Renderable} child
        * @param {Number} index
        * @return {me.Renderable} the added child
        */ addChildAt: function addChildAt(child, index) {
                if (index >= 0 && index < this.children.length) {
                    if (child.ancestor instanceof me.Container) child.ancestor.removeChildNow(child);
                    else // only allocate a GUID if the object has no previous ancestor
                    // (e.g. move one child from one container to another)
                    if (child.isRenderable) // allocated a GUID value
                    child.GUID = me.utils.createGUID();
                    child.ancestor = this;
                    this.children.splice(index, 0, child);
                    if (typeof child.onActivateEvent === "function" && this.isAttachedToRoot()) child.onActivateEvent();
                     // force repaint in case this is a static non-animated object
                    if (this.isAttachedToRoot() === true) me.game.repaint();
                    this.onChildChange.call(this, index);
                    return child;
                } else throw new Error("Index (" + index + ") Out Of Bounds for addChildAt()");
            },
            /**
        * The forEach() method executes a provided function once per child element. <br>
        * callback is invoked with three arguments: <br>
        *    - the element value <br>
        *    - the element index <br>
        *    - the array being traversed <br>
        * @name forEach
        * @memberOf me.Container.prototype
        * @function
        * @param {Function} callback
        * @param {Object} [thisArg] value to use as this(i.e reference Object) when executing callback.
        * @example
        * // iterate through all children of the root container
        * me.game.world.forEach(function (child) {
        *    // do something with the child
        * });
        */ forEach: function forEach(callback, thisArg) {
                var context = this, i = 0;
                var len = this.children.length;
                if (typeof callback !== "function") throw new Error(callback + " is not a function");
                if (arguments.length > 1) context = thisArg;
                while(i < len){
                    callback.call(context, this.children[i], i, this.children);
                    i++;
                }
            },
            /**
        * Swaps the position (z-index) of 2 children
        * @name swapChildren
        * @memberOf me.Container.prototype
        * @function
        * @param {me.Renderable} child
        * @param {me.Renderable} child2
        */ swapChildren: function swapChildren(child, child2) {
                var index = this.getChildIndex(child);
                var index2 = this.getChildIndex(child2);
                if (index !== -1 && index2 !== -1) {
                    // swap z index
                    var _z = child.pos.z;
                    child.pos.z = child2.pos.z;
                    child2.pos.z = _z; // swap the positions..
                    this.children[index] = child2;
                    this.children[index2] = child;
                } else throw new Error(child + " Both the supplied childs must be a child of the caller " + this);
            },
            /**
        * Returns the Child at the specified index
        * @name getChildAt
        * @memberOf me.Container.prototype
        * @function
        * @param {Number} index
        */ getChildAt: function getChildAt(index) {
                if (index >= 0 && index < this.children.length) return this.children[index];
                else throw new Error("Index (" + index + ") Out Of Bounds for getChildAt()");
            },
            /**
        * Returns the index of the given Child
        * @name getChildIndex
        * @memberOf me.Container.prototype
        * @function
        * @param {me.Renderable} child
        */ getChildIndex: function getChildIndex(child) {
                return this.children.indexOf(child);
            },
            /**
        * Returns the next child within the container or undefined if none
        * @name getNextChild
        * @memberOf me.Container
        * @function
        * @param {me.Renderable} child
        */ getNextChild: function getNextChild(child) {
                var index = this.children.indexOf(child) - 1;
                if (index >= 0 && index < this.children.length) return this.getChildAt(index);
                return undefined;
            },
            /**
        * Returns true if contains the specified Child
        * @name hasChild
        * @memberOf me.Container.prototype
        * @function
        * @param {me.Renderable} child
        * @return {Boolean}
        */ hasChild: function hasChild(child) {
                return this === child.ancestor;
            },
            /**
        * return the child corresponding to the given property and value.<br>
        * note : avoid calling this function every frame since
        * it parses the whole object tree each time
        * @name getChildByProp
        * @memberOf me.Container.prototype
        * @public
        * @function
        * @param {String} prop Property name
        * @param {String|RegExp|Number|Boolean} value Value of the property
        * @return {me.Renderable[]} Array of childs
        * @example
        * // get the first child object called "mainPlayer" in a specific container :
        * var ent = myContainer.getChildByProp("name", "mainPlayer");
        *
        * // or query the whole world :
        * var ent = me.game.world.getChildByProp("name", "mainPlayer");
        *
        * // partial property matches are also allowed by using a RegExp.
        * // the following matches "redCOIN", "bluecoin", "bagOfCoins", etc :
        * var allCoins = me.game.world.getChildByProp("name", /coin/i);
        *
        * // searching for numbers or other data types :
        * var zIndex10 = me.game.world.getChildByProp("z", 10);
        * var inViewport = me.game.world.getChildByProp("inViewport", true);
        */ getChildByProp: function getChildByProp(prop, value) {
                var objList = [];
                function compare(obj, prop1) {
                    var v = obj[prop1];
                    if (value instanceof RegExp && typeof v === "string") {
                        if (value.test(v)) objList.push(obj);
                    } else if (v === value) objList.push(obj);
                }
                for(var i = this.children.length - 1; i >= 0; i--){
                    var obj = this.children[i];
                    compare(obj, prop);
                    if (obj instanceof me.Container) objList = objList.concat(obj.getChildByProp(prop, value));
                }
                return objList;
            },
            /**
        * returns the list of childs with the specified class type
        * @name getChildByType
        * @memberOf me.Container.prototype
        * @public
        * @function
        * @param {Object} class type
        * @return {me.Renderable[]} Array of children
        */ getChildByType: function getChildByType(_class) {
                var objList = [];
                for(var i = this.children.length - 1; i >= 0; i--){
                    var obj = this.children[i];
                    if (obj instanceof _class) objList.push(obj);
                    if (obj instanceof me.Container) objList = objList.concat(obj.getChildByType(_class));
                }
                return objList;
            },
            /**
        * returns the list of childs with the specified name<br>
        * as defined in Tiled (Name field of the Object Properties)<br>
        * note : avoid calling this function every frame since
        * it parses the whole object list each time
        * @name getChildByName
        * @memberOf me.Container.prototype
        * @public
        * @function
        * @param {String|RegExp|Number|Boolean} name entity name
        * @return {me.Renderable[]} Array of children
        */ getChildByName: function getChildByName(name) {
                return this.getChildByProp("name", name);
            },
            /**
        * return the child corresponding to the specified GUID<br>
        * note : avoid calling this function every frame since
        * it parses the whole object list each time
        * @name getChildByGUID
        * @memberOf me.Container.prototype
        * @public
        * @function
        * @param {String|RegExp|Number|Boolean} GUID entity GUID
        * @return {me.Renderable} corresponding child or null
        */ getChildByGUID: function getChildByGUID(guid) {
                var obj = this.getChildByProp("GUID", guid);
                return obj.length > 0 ? obj[0] : null;
            },
            /**
        * resizes the child bounds rectangle, based on children bounds.
        * @name updateChildBounds
        * @memberOf me.Container.prototype
        * @function
        * @return {me.Rect} updated child bounds
        */ updateChildBounds: function updateChildBounds() {
                this.childBounds.pos.set(Infinity, Infinity);
                this.childBounds.resize(-Infinity, -Infinity);
                var childBounds;
                for(var i = this.children.length, child; i--, child = this.children[i];)if (child.isRenderable) {
                    if (child instanceof me.Container) childBounds = child.childBounds;
                    else childBounds = child.getBounds();
                     // TODO : returns an "empty" rect instead of null (e.g. EntityObject)
                    // TODO : getBounds should always return something anyway
                    if (childBounds !== null) this.childBounds.union(childBounds);
                }
                return this.childBounds;
            },
            /**
        * Checks if this container is root or if it's attached to the root container.
        * @private
        * @name isAttachedToRoot
        * @memberOf me.Container.prototype
        * @function
        * @returns Boolean
        */ isAttachedToRoot: function isAttachedToRoot() {
                if (this.root === true) return true;
                else {
                    var ancestor = this.ancestor;
                    while(ancestor){
                        if (ancestor.root === true) return true;
                        ancestor = ancestor.ancestor;
                    }
                    return false;
                }
            },
            /**
        * update the renderable's bounding rect (private)
        * @private
        * @name updateBoundsPos
        * @memberOf me.Container.prototype
        * @function
        */ updateBoundsPos: function updateBoundsPos(newX, newY) {
                this._super(me.Renderable, "updateBoundsPos", [
                    newX,
                    newY
                ]); // Update container's absolute position
                this._absPos.set(newX, newY);
                if (this.ancestor instanceof me.Container && !this.floating) this._absPos.add(this.ancestor._absPos);
                 // Notify children that the parent's position has changed
                for(var i = this.children.length, child; i--, child = this.children[i];)if (child.isRenderable) child.updateBoundsPos(child.pos.x, child.pos.y);
                return this.getBounds();
            },
            /**
        * @ignore
        */ onActivateEvent: function onActivateEvent() {
                for(var i = this.children.length, child; i--, child = this.children[i];)if (typeof child.onActivateEvent === "function") child.onActivateEvent();
            },
            /**
        * Invokes the removeChildNow in a defer, to ensure the child is removed safely after the update & draw stack has completed
        * @name removeChild
        * @memberOf me.Container.prototype
        * @public
        * @function
        * @param {me.Renderable} child
        * @param {Boolean} [keepalive=False] True to prevent calling child.destroy()
        */ removeChild: function removeChild(child, keepalive) {
                if (this.hasChild(child)) me.utils["function"].defer(deferredRemove, this, child, keepalive);
                else throw new Error("Child is not mine.");
            },
            /**
        * Removes (and optionally destroys) a child from the container.<br>
        * (removal is immediate and unconditional)<br>
        * Never use keepalive=true with objects from {@link me.pool}. Doing so will create a memory leak.
        * @name removeChildNow
        * @memberOf me.Container.prototype
        * @function
        * @param {me.Renderable} child
        * @param {Boolean} [keepalive=False] True to prevent calling child.destroy()
        */ removeChildNow: function removeChildNow(child, keepalive) {
                if (this.hasChild(child) && this.getChildIndex(child) >= 0) {
                    if (typeof child.onDeactivateEvent === "function") child.onDeactivateEvent();
                    if (!keepalive) {
                        if (typeof child.destroy === "function") child.destroy();
                        me.pool.push(child);
                    } // Don't cache the child index; another element might have been removed
                    // by the child's `onDeactivateEvent` or `destroy` methods
                    var childIndex = this.getChildIndex(child);
                    if (childIndex >= 0) {
                        this.children.splice(childIndex, 1);
                        child.ancestor = undefined;
                    } // force repaint in case this is a static non-animated object
                    if (this.isAttachedToRoot() === true) me.game.repaint();
                    this.onChildChange.call(this, childIndex);
                }
            },
            /**
        * Automatically set the specified property of all childs to the given value
        * @name setChildsProperty
        * @memberOf me.Container.prototype
        * @function
        * @param {String} property property name
        * @param {Object} value property value
        * @param {Boolean} [recursive=false] recursively apply the value to child containers if true
        */ setChildsProperty: function setChildsProperty(prop, val, recursive) {
                for(var i = this.children.length; i >= 0; i--){
                    var obj = this.children[i];
                    if (recursive === true && obj instanceof me.Container) obj.setChildsProperty(prop, val, recursive);
                    obj[prop] = val;
                }
            },
            /**
        * Move the child in the group one step forward (z depth).
        * @name moveUp
        * @memberOf me.Container.prototype
        * @function
        * @param {me.Renderable} child
        */ moveUp: function moveUp(child) {
                var childIndex = this.getChildIndex(child);
                if (childIndex - 1 >= 0) // note : we use an inverted loop
                this.swapChildren(child, this.getChildAt(childIndex - 1));
            },
            /**
        * Move the child in the group one step backward (z depth).
        * @name moveDown
        * @memberOf me.Container.prototype
        * @function
        * @param {me.Renderable} child
        */ moveDown: function moveDown(child) {
                var childIndex = this.getChildIndex(child);
                if (childIndex >= 0 && childIndex + 1 < this.children.length) // note : we use an inverted loop
                this.swapChildren(child, this.getChildAt(childIndex + 1));
            },
            /**
        * Move the specified child to the top(z depth).
        * @name moveToTop
        * @memberOf me.Container.prototype
        * @function
        * @param {me.Renderable} child
        */ moveToTop: function moveToTop(child) {
                var childIndex = this.getChildIndex(child);
                if (childIndex > 0) {
                    // note : we use an inverted loop
                    this.children.splice(0, 0, this.children.splice(childIndex, 1)[0]); // increment our child z value based on the previous child depth
                    child.pos.z = this.children[1].pos.z + 1;
                }
            },
            /**
        * Move the specified child the bottom (z depth).
        * @name moveToBottom
        * @memberOf me.Container.prototype
        * @function
        * @param {me.Renderable} child
        */ moveToBottom: function moveToBottom(child) {
                var childIndex = this.getChildIndex(child);
                if (childIndex >= 0 && childIndex < this.children.length - 1) {
                    // note : we use an inverted loop
                    this.children.splice(this.children.length - 1, 0, this.children.splice(childIndex, 1)[0]); // increment our child z value based on the next child depth
                    child.pos.z = this.children[this.children.length - 2].pos.z - 1;
                }
            },
            /**
        * Manually trigger the sort of all the childs in the container</p>
        * @name sort
        * @memberOf me.Container.prototype
        * @public
        * @function
        * @param {Boolean} [recursive=false] recursively sort all containers if true
        */ sort: function sort(recursive) {
                // do nothing if there is already a pending sort
                if (!this.pendingSort) {
                    if (recursive === true) {
                        // trigger other child container sort function (if any)
                        for(var i = this.children.length, obj; i--, obj = this.children[i];)if (obj instanceof me.Container) // note : this will generate one defered sorting function
                        // for each existing containe
                        obj.sort(recursive);
                    }
                    /** @ignore */ this.pendingSort = me.utils["function"].defer(function(self) {
                        // sort everything in this container
                        self.children.sort(self["_sort" + self.sortOn.toUpperCase()]); // clear the defer id
                        self.pendingSort = null; // make sure we redraw everything
                        me.game.repaint();
                    }, this, this);
                }
            },
            /**
        * @ignore
        */ onDeactivateEvent: function onDeactivateEvent() {
                for(var i = this.children.length, child; i--, child = this.children[i];)if (typeof child.onDeactivateEvent === "function") child.onDeactivateEvent();
            },
            /**
        * Z Sorting function
        * @ignore
        */ _sortZ: function _sortZ(a, b) {
                return b.pos && a.pos ? b.pos.z - a.pos.z : a.pos ? -Infinity : Infinity;
            },
            /**
        * Reverse Z Sorting function
        * @ignore
        */ _sortReverseZ: function _sortReverseZ(a, b) {
                return a.pos && b.pos ? a.pos.z - b.pos.z : a.pos ? Infinity : -Infinity;
            },
            /**
        * X Sorting function
        * @ignore
        */ _sortX: function _sortX(a, b) {
                if (!b.pos || !a.pos) return a.pos ? -Infinity : Infinity;
                var result = b.pos.z - a.pos.z;
                return result ? result : b.pos.x - a.pos.x;
            },
            /**
        * Y Sorting function
        * @ignore
        */ _sortY: function _sortY(a, b) {
                if (!b.pos || !a.pos) return a.pos ? -Infinity : Infinity;
                var result = b.pos.z - a.pos.z;
                return result ? result : b.pos.y - a.pos.y;
            },
            /**
        * Destroy function<br>
        * @ignore
        */ destroy: function destroy() {
                // empty the container
                this.reset(); // call the parent destroy method
                this._super(me.Renderable, "destroy", arguments);
            },
            /**
        * @ignore
        */ update: function update(dt) {
                this._super(me.Renderable, "update", [
                    dt
                ]);
                var isDirty = false;
                var isFloating = false;
                var isPaused = me.state.isPaused(); // Update container's absolute position
                this._absPos.setV(this.pos);
                if (this.ancestor) this._absPos.add(this.ancestor._absPos);
                for(var i = this.children.length, obj; i--, obj = this.children[i];){
                    if (isPaused && !obj.updateWhenPaused) continue;
                    if (obj.isRenderable) {
                        isFloating = globalFloatingCounter > 0 || obj.floating;
                        if (isFloating) globalFloatingCounter++;
                         // check if object is in any active cameras
                        obj.inViewport = false; // iterate through all cameras
                        me.state.current().cameras.forEach(function(camera) {
                            if (camera.isVisible(obj, isFloating)) obj.inViewport = true;
                        }); // update our object
                        isDirty = (obj.inViewport || obj.alwaysUpdate) && obj.update(dt) || isDirty; // Update child's absolute position
                        obj._absPos.setV(this._absPos).add(obj.pos);
                        if (globalFloatingCounter > 0) globalFloatingCounter--;
                    } else // just directly call update() for non renderable object
                    isDirty = obj.update(dt) || isDirty;
                }
                return isDirty;
            },
            /**
        * @ignore
        */ draw: function draw(renderer, rect) {
                var isFloating = false;
                this.drawCount = 0; // clip the containter children to the container bounds
                if (this.root === false && this.clipping === true && this.childBounds.isFinite() === true) renderer.clipRect(this.childBounds.pos.x, this.childBounds.pos.y, this.childBounds.width, this.childBounds.height);
                 // adjust position if required (e.g. canvas/window centering)
                renderer.translate(this.pos.x, this.pos.y);
                for(var i = this.children.length, obj; i--, obj = this.children[i];)if (obj.isRenderable) {
                    isFloating = obj.floating === true;
                    if (obj.inViewport || isFloating) {
                        if (isFloating) {
                            // translate to screen coordinates
                            renderer.save();
                            renderer.resetTransform();
                        } // predraw (apply transforms)
                        obj.preDraw(renderer); // draw the object
                        obj.draw(renderer, rect); // postdraw (clean-up);
                        obj.postDraw(renderer); // restore the previous "state"
                        if (isFloating) renderer.restore();
                        this.drawCount++;
                    }
                }
            }
        });
    })();
    (function() {
        /**
      * a Generic Body Object with some physic properties and behavior functionality<br>
      The body object is offten attached as a member of an Entity.  The Body object can handle movements of the parent with
      the body.update call.  It important to know that when body.update is called there are several things that happen related to
      the movement and positioning of the parent entity (assuming its an Entity).  1) The force/gravity/friction parameters are used
      to calcuate a new velocity and 2) the parent position is updated by adding this to the parent.pos (position me.Vector2d)
      value. Thus Affecting the movement of the parent.  Look at the source code for /src/physics/body.js:update (me.Body.update) for
      a better understanding.
      * @class
      * @extends me.Rect
      * @memberOf me
      * @constructor
      * @param {me.Renderable} ancestor the parent object this body is attached to
      * @param {me.Rect|me.Rect[]|me.Polygon|me.Polygon[]|me.Line|me.Line[]|me.Ellipse|me.Ellipse[]|Object} [shapes] a initial shape, list of shapes, or JSON object defining the body
      * @param {Function} [onBodyUpdate] callback for when the body is updated (e.g. add/remove shapes)
      */ me.Body = me.Rect.extend({
            /**
        * @ignore
        */ init: function init(parent, shapes, onBodyUpdate) {
                /**
          * a reference to the parent object that contains this body,
          * or undefined if it has not been added to one.
          * @public
          * @type me.Renderable
          * @default undefined
          * @name me.Body#ancestor
          */ this.ancestor = parent;
                /**
          * The collision shapes of the body
          * @ignore
          * @type {me.Polygon[]|me.Line[]|me.Ellipse[]}
          * @name shapes
          * @memberOf me.Body
          */ if (typeof this.shapes === "undefined") this.shapes = [];
                /**
          * The body collision mask, that defines what should collide with what.<br>
          * (by default will collide with all entities)
          * @ignore
          * @type Number
          * @default me.collision.types.ALL_OBJECT
          * @name collisionMask
          * @see me.collision.types
          * @memberOf me.Body
          */ this.collisionMask = me.collision.types.ALL_OBJECT;
                /**
          * define the collision type of the body for collision filtering
          * @public
          * @type Number
          * @default me.collision.types.ENEMY_OBJECT
          * @name collisionType
          * @see me.collision.types
          * @memberOf me.Body
          * @example
          * // set the body collision type
          * myEntity.body.collisionType = me.collision.types.PLAYER_OBJECT;
          */ this.collisionType = me.collision.types.ENEMY_OBJECT;
                /**
          * body velocity<br>
          *
          * @public
          * @type me.Vector2d
          * @default <0,0>
          * @name vel
          * @memberOf me.Body
          */ if (typeof this.vel === "undefined") this.vel = new me.Vector2d();
                this.vel.set(0, 0);
                /**
          * body acceleration <br>
          * Not fully implemented yet.  At this time accel is used to set the MaximumVelocity allowed.
          * @public
          * @type me.Vector2d
          * @default <0,0>
          * @name accel
          * @deprecated
          * @see me.Body.force
          * @memberOf me.Body
          */ if (typeof this.accel === "undefined") this.accel = new me.Vector2d();
                this.accel.set(0, 0);
                /**
          * body force or acceleration (automatically) applied to the body.
          * when defining a force, user should also define a max velocity
          * @public
          * @type me.Vector2d
          * @default <0,0>
          * @name force
          * @see me.Body.setMaxVelocity
          * @memberOf me.Body
          * @example
          * init: function () {
          *    // define a default maximum acceleration, initial force and friction
          *    this.body.force.set(0, 0);
          *    this.body.friction.set(0.4, 0);
          *    this.body.setMaxVelocity(3, 15);
          * },
          *
          * // apply a postive or negative force when pressing left of right key
          * update : function (dt) {
          *     if (me.input.isKeyPressed("left"))    {
          *          this.body.force.x = -this.body.maxVel.x;
          *      } else if (me.input.isKeyPressed("right")) {
          *         this.body.force.x = this.body.maxVel.x;
          *     } else {
          *         this.body.force.x = 0;
          *     }
          * }
          */ if (typeof this.force === "undefined") this.force = new me.Vector2d();
                this.force.set(0, 0);
                /**
          * body friction
          * @public
          * @type me.Vector2d
          * @default <0,0>
          * @name friction
          * @memberOf me.Body
          */ if (typeof this.friction === "undefined") this.friction = new me.Vector2d();
                this.friction.set(0, 0);
                /**
          * the body bouciness level when colliding with other solid bodies :
          * a value of 0 will not bounce, a value of 1 will fully rebound.
          * @public
          * @type {Number}
          * @default 0
          * @name bounce
          * @memberOf me.Body
          */ this.bounce = 0;
                /**
          * the body mass
          * @public
          * @type {Number}
          * @default 1
          * @name mass
          * @memberOf me.Body
          */ this.mass = 1;
                /**
          * max velocity (to limit body velocity)
          * @public
          * @type me.Vector2d
          * @default <490,490>
          * @name maxVel
          * @memberOf me.Body
          */ if (typeof this.maxVel === "undefined") this.maxVel = new me.Vector2d();
                 // cap by default to half the default gravity force
                this.maxVel.set(490, 490);
                /**
          * Default gravity value for this body.
          * To be set to to < 0, 0 > for RPG, shooter, etc...<br>
          * @public
          * @see me.Body.gravityScale
          * @type me.Vector2d
          * @default <0,0.98>
          * @deprecated since 8.0.0
          * @name gravity
          * @memberOf me.Body
          */ if (typeof this.gravity === "undefined") {
                    var self = this;
                    this.gravity = new me.ObservableVector2d(0, 0, {
                        onUpdate: function onUpdate(x, y) {
                            // disable gravity or apply a scale if y gravity is different from 0
                            if (typeof y === "number") self.gravityScale = y / me.game.world.gravity.y;
                             // deprecation // WARNING:
                            console.log("me.Body.gravity is deprecated, please see me.Body.gravityScale to modify gravity for a specific body");
                        }
                    });
                }
                /**
          * The degree to which this body is affected by the world gravity
          * @public
          * @see me.World.gravity
          * @type Number
          * @default 1.0
          * @name gravityScale
          * @memberOf me.Body
          */ this.gravityScale = 1;
                /**
          * If true this body won't be affected by the world gravity
          * @public
          * @see me.World.gravity
          * @type Boolean
          * @default false
          * @name ignoreGravity
          * @memberOf me.Body
          */ this.ignoreGravity = false;
                /**
          * falling state of the body<br>
          * true if the object is falling<br>
          * false if the object is standing on something<br>
          * @readonly
          * @public
          * @type Boolean
          * @default false
          * @name falling
          * @memberOf me.Body
          */ this.falling = false;
                /**
          * jumping state of the body<br>
          * equal true if the body is jumping<br>
          * @readonly
          * @public
          * @type Boolean
          * @default false
          * @name jumping
          * @memberOf me.Body
          */ this.jumping = false; // call the super constructor
                this._super(me.Rect, "init", [
                    0,
                    0,
                    this.ancestor.width,
                    this.ancestor.height
                ]);
                if (typeof onBodyUpdate === "function") this.onBodyUpdate = onBodyUpdate;
                 // parses the given shapes array and add them
                if (typeof shapes !== "undefined") {
                    if (Array.isArray(shapes)) {
                        for(var s = 0; s < shapes.length; s++)this.addShape(shapes[s], true);
                        this.updateBounds();
                    } else this.addShape(shapes);
                } // automatically enable physic when a body is added to a renderable
                this.ancestor.isKinematic = false;
            },
            /**
        * add a collision shape to this body <br>
        * (note: me.Rect objects will be converted to me.Polygon before being added)
        * @name addShape
        * @memberOf me.Body
        * @public
        * @function
        * @param {me.Rect|me.Polygon|me.Line|me.Ellipse|Object} shape a shape or JSON object
        * @param {Boolean} batchInsert if true the body bounds won't be updated after adding a shape
        * @return {Number} the shape array length
        * @example
        * // add a rectangle shape
        * this.body.addShape(new me.Rect(0, 0, image.width, image.height));
        * // add a shape from a JSON object
        * this.body.addShape(me.loader.getJSON("shapesdef").banana);
        */ addShape: function addShape(shape, batchInsert) {
                if (shape instanceof me.Rect) this.shapes.push(shape.toPolygon());
                else if (shape instanceof me.Polygon || shape instanceof me.Ellipse) // else polygon or circle
                this.shapes.push(shape);
                else // JSON object
                this.fromJSON(shape);
                if (batchInsert !== true) // update the body bounds to take in account the added shape
                this.updateBounds();
                 // return the length of the shape list
                return this.shapes.length;
            },
            /**
        * sets the body shape vertices
        * @name setVertices
        * @memberOf me.Body
        * @public
        * @function
        * @param {me.Vector2d[]} vertices an array of me.Vector2d points defining a convex hull
        * @param {Number} [index=0] the shape object for which to set the vertices
        */ setVertices: function setVertices(vertices, index, batchInsert) {
                var polygon = this.getShape(index);
                if (polygon instanceof me.Polygon) polygon.setShape(0, 0, vertices);
                else // this will replace any other non polygon shape type if defined
                this.shapes[index || 0] = new me.Polygon(0, 0, vertices);
                if (batchInsert !== true) // update the body bounds to take in account the new vertices
                this.updateBounds();
            },
            /**
        * add collision mesh based on a JSON object
        * (this will also apply any physic properties defined in the given JSON file)
        * @name fromJSON
        * @memberOf me.Body
        * @public
        * @function
        * @param {Object} json a JSON object as exported from a Physics Editor tool
        * @param {String} [id] an optional shape identifier within the given the json object
        * @see https://www.codeandweb.com/physicseditor
        * @return {Number} how many shapes were added to the body
        * @example
        * // define the body based on the banana shape
        * this.body.fromJSON(me.loader.getJSON("shapesdef").banana);
        * // or ...
        * this.body.fromJSON(me.loader.getJSON("shapesdef"), "banana");
        */ fromJSON: function fromJSON(json, id) {
                var data = json;
                if (typeof id !== "undefined") json[id];
                 // Physic Editor Format (https://www.codeandweb.com/physicseditor)
                if (typeof data === "undefined") throw new Error("Identifier (" + id + ") undefined for the given JSON object)");
                if (data.length) {
                    // go through all shapes and add them to the body
                    for(var i = 0; i < data.length; i++)this.setVertices(data[i].shape, i);
                     // apply density, friction and bounce properties from the first shape
                    // Note : how to manage different mass or friction for all different shapes?
                    this.mass = data[0].density || 0;
                    this.friction.set(data[0].friction || 0, data[0].friction || 0);
                    this.bounce = data[0].bounce || 0;
                } // return the amount of shapes added to the body
                return data.length;
            },
            /**
        * return the collision shape at the given index
        * @name getShape
        * @memberOf me.Body
        * @public
        * @function
        * @param {Number} [index=0] the shape object at the specified index
        * @return {me.Polygon|me.Line|me.Ellipse} shape a shape object if defined
        */ getShape: function getShape(index) {
                return this.shapes[index || 0];
            },
            /**
        * remove the specified shape from the body shape list
        * @name removeShape
        * @memberOf me.Body
        * @public
        * @function
        * @param {me.Polygon|me.Line|me.Ellipse} shape a shape object
        * @return {Number} the shape array length
        */ removeShape: function removeShape(shape) {
                me.utils.array.remove(this.shapes, shape); // update the body bounds to take in account the removed shape
                this.updateBounds(); // return the length of the shape list
                return this.shapes.length;
            },
            /**
        * remove the shape at the given index from the body shape list
        * @name removeShapeAt
        * @memberOf me.Body
        * @public
        * @function
        * @param {Number} index the shape object at the specified index
        * @return {Number} the shape array length
        */ removeShapeAt: function removeShapeAt(index) {
                return this.removeShape(this.getShape(index));
            },
            /**
        * By default all entities are able to collide with all other entities, <br>
        * but it's also possible to specificy 'collision filters' to provide a finer <br>
        * control over which entities can collide with each other.
        * @name setCollisionMask
        * @memberOf me.Body
        * @public
        * @function
        * @see me.collision.types
        * @param {Number} bitmask the collision mask
        * @example
        * // filter collision detection with collision shapes, enemies and collectables
        * myEntity.body.setCollisionMask(me.collision.types.WORLD_SHAPE | me.collision.types.ENEMY_OBJECT | me.collision.types.COLLECTABLE_OBJECT);
        * ...
        * // disable collision detection with all other objects
        * myEntity.body.setCollisionMask(me.collision.types.NO_OBJECT);
        */ setCollisionMask: function setCollisionMask(bitmask) {
                this.collisionMask = bitmask;
            },
            /**
        * the built-in function to solve the collision response
        * @protected
        * @name respondToCollision
        * @memberOf me.Body
        * @function
        * @param {me.collision.ResponseObject} response the collision response object
        */ respondToCollision: function respondToCollision(response) {
                // the overlap vector
                var overlap = response.overlapV; // FIXME: Respond proportionally to object mass
                // Move out of the other object shape
                this.ancestor.pos.sub(overlap); // adjust velocity
                if (overlap.x !== 0) {
                    this.vel.x = ~~(0.5 + this.vel.x - overlap.x) || 0;
                    if (this.bounce > 0) this.vel.x *= -this.bounce;
                }
                if (overlap.y !== 0) {
                    this.vel.y = ~~(0.5 + this.vel.y - overlap.y) || 0;
                    if (this.bounce > 0) this.vel.y *= -this.bounce;
                     // cancel the falling an jumping flags if necessary
                    var dir = Math.sign(me.game.world.gravity.y * this.gravityScale) || 1;
                    this.falling = overlap.y >= dir;
                    this.jumping = overlap.y <= -dir;
                }
            },
            /**
        * update the body bounding rect (private)
        * the body rect size is here used to cache the total bounding rect
        * @private
        * @name updateBounds
        * @memberOf me.Body
        * @function
        */ updateBounds: function updateBounds() {
                if (this.shapes.length > 0) {
                    // reset the rect with default values
                    var _bounds = this.shapes[0].getBounds();
                    this.pos.setV(_bounds.pos);
                    this.resize(_bounds.width, _bounds.height);
                    for(var i = 1; i < this.shapes.length; i++)this.union(this.shapes[i].getBounds());
                }
                this._super(me.Rect, "updateBounds"); // trigger the onBodyChange
                if (typeof this.onBodyUpdate === "function") this.onBodyUpdate(this);
                return this;
            },
            /**
        * Rotate this body (counter-clockwise) by the specified angle (in radians).
        * Unless specified the body will be rotated around its center point
        * @name rotate
        * @memberOf me.Body
        * @function
        * @param {Number} angle The angle to rotate (in radians)
        * @param {me.Vector2d|me.ObservableVector2d} [v] an optional point to rotate around
        * @return {me.Body} Reference to this object for method chaining
        */ rotate: function rotate(angle, v) {
                v = v || this.center;
                for(var i = 0; i < this.shapes.length; i++)this.shapes[i].rotate(angle, v);
                this.updateBounds();
                return this;
            },
            /**
        * Sets accel to Velocity if x or y is not 0.  Net effect is to set the maxVel.x/y to the passed values for x/y<br>
        * note: This does not set the vel member of the body object. This is identical to the setMaxVelocity call except that the
        * accel property is updated to match the passed x and y.
        * setMaxVelocity if needed<br>
        * @name setVelocity
        * @memberOf me.Body
        * @function
        * @param {Number} x velocity on x axis
        * @param {Number} y velocity on y axis
        * @protected
        * @deprecated
        * @see me.Body.force
        */ setVelocity: function setVelocity(x, y) {
                this.accel.x = x !== 0 ? x : this.accel.x;
                this.accel.y = y !== 0 ? y : this.accel.y; // limit by default to the same max value
                this.setMaxVelocity(x, y);
            },
            /**
        * cap the body velocity (body.maxVel property) to the specified value<br>
        * @name setMaxVelocity
        * @memberOf me.Body
        * @function
        * @param {Number} x max velocity on x axis
        * @param {Number} y max velocity on y axis
        * @protected
        */ setMaxVelocity: function setMaxVelocity(x, y) {
                this.maxVel.x = x;
                this.maxVel.y = y;
            },
            /**
        * set the body default friction
        * @name setFriction
        * @memberOf me.Body
        * @function
        * @param {Number} x horizontal friction
        * @param {Number} y vertical friction
        * @protected
        */ setFriction: function setFriction(x, y) {
                this.friction.x = x || 0;
                this.friction.y = y || 0;
            },
            /**
        * apply friction to a vector
        * @ignore
        */ applyFriction: function applyFriction(vel) {
                var fx = this.friction.x * me.timer.tick, nx = vel.x + fx, x = vel.x - fx, fy = this.friction.y * me.timer.tick, ny = vel.y + fy, y = vel.y - fy;
                vel.x = nx < 0 ? nx : x > 0 ? x : 0;
                vel.y = ny < 0 ? ny : y > 0 ? y : 0;
            },
            /**
        * compute the new velocity value
        * @ignore
        */ computeVelocity: function computeVelocity(vel) {
                // apply fore if defined
                if (this.force.x) vel.x += this.force.x * me.timer.tick;
                if (this.force.y) vel.y += this.force.y * me.timer.tick;
                 // apply friction
                if (this.friction.x || this.friction.y) this.applyFriction(vel);
                if (!this.ignoreGravity) {
                    var worldGravity = me.game.world.gravity; // apply gravity if defined
                    vel.x += worldGravity.x * this.gravityScale * this.mass * me.timer.tick;
                    vel.y += worldGravity.y * this.gravityScale * this.mass * me.timer.tick; // check if falling / jumping
                    this.falling = vel.y * Math.sign(worldGravity.y * this.gravityScale) > 0;
                    this.jumping = this.falling ? false : this.jumping;
                } // cap velocity
                if (vel.y !== 0) vel.y = me.Math.clamp(vel.y, -this.maxVel.y, this.maxVel.y);
                if (vel.x !== 0) vel.x = me.Math.clamp(vel.x, -this.maxVel.x, this.maxVel.x);
            },
            /**
        * Updates the parent's position as well as computes the new body's velocity based
        * on the values of force/friction/gravity.  Velocity chages are proportional to the
        * me.timer.tick value (which can be used to scale velocities).  The approach to moving the
        * parent Entity is to compute new values of the Body.vel property then add them to
        * the parent.pos value thus changing the postion the amount of Body.vel each time the
        * update call is made. <br>
        * Updates to Body.vel are bounded by maxVel (which defaults to viewport size if not set) <br>
        *
        * In addition, when the gravity calcuation is made, if the Body.vel.y > 0 then the Body.falling
        * property is set to true and Body.jumping is set to !Body.falling.
        *
        * At this time a call to Body.Update does not call the onBodyUpdate callback that is listed in the init: function.
        * @name update
        * @memberOf me.Body
        * @function
        * @return {boolean} true if resulting velocity is different than 0
        * @see source code for me.Body.computeVelocity (private member)
        */ update: function update() /* dt */ {
                // update the velocity
                this.computeVelocity(this.vel); // update the body ancestor position
                this.ancestor.pos.add(this.vel); // returns true if vel is different from 0
                return this.vel.x !== 0 || this.vel.y !== 0;
            },
            /**
        * Destroy function<br>
        * @ignore
        */ destroy: function destroy() {
                this.onBodyUpdate = undefined;
                this.ancestor = undefined;
                this.shapes.length = 0;
            }
        });
    })();
    /*
    * A QuadTree implementation in JavaScript, a 2d spatial subdivision algorithm.
    * Based on the QuadTree Library by Timo Hausmann and released under the MIT license
    * https://github.com/timohausmann/quadtree-js/
   **/ (function() {
        /**
      * a pool of `QuadTree` objects
      */ var QT_ARRAY = [];
        /**
      * will pop a quadtree object from the array
      * or create a new one if the array is empty
      */ var QT_ARRAY_POP = function QT_ARRAY_POP1(bounds, max_objects, max_levels, level) {
            if (QT_ARRAY.length > 0) {
                var _qt = QT_ARRAY.pop();
                _qt.bounds = bounds;
                _qt.max_objects = max_objects || 4;
                _qt.max_levels = max_levels || 4;
                _qt.level = level || 0;
                return _qt;
            } else return new me.QuadTree(bounds, max_objects, max_levels, level);
        };
        /**
      * Push back a quadtree back into the array
      */ var QT_ARRAY_PUSH = function QT_ARRAY_PUSH1(qt) {
            QT_ARRAY.push(qt);
        };
        /**
      * a temporary vector object to be reused
      */ var QT_VECTOR = new me.Vector2d();
        /**
      * Quadtree Constructor <br>
      * note: the global quadtree instance is available through `me.collision.quadTree`
      * @class
      * @name QuadTree
      * @extends Object
      * @memberOf me
      * @constructor
      * @see me.collision.quadTree
      * @param {me.Rect} bounds bounds of the node
      * @param {Number} [max_objects=4] max objects a node can hold before splitting into 4 subnodes
      * @param {Number} [max_levels=4] total max levels inside root Quadtree
      * @param {Number} [level] deepth level, required for subnodes
      */ function Quadtree(bounds, max_objects, max_levels, level) {
            this.max_objects = max_objects || 4;
            this.max_levels = max_levels || 4;
            this.level = level || 0;
            this.bounds = bounds;
            this.objects = [];
            this.nodes = [];
        }
        /*
      * Split the node into 4 subnodes
      */ Quadtree.prototype.split = function() {
            var nextLevel = this.level + 1, subWidth = ~~(0.5 + this.bounds.width / 2), subHeight = ~~(0.5 + this.bounds.height / 2), x = ~~(0.5 + this.bounds.pos.x), y = ~~(0.5 + this.bounds.pos.y); //top right node
            this.nodes[0] = QT_ARRAY_POP({
                pos: {
                    x: x + subWidth,
                    y: y
                },
                width: subWidth,
                height: subHeight
            }, this.max_objects, this.max_levels, nextLevel); //top left node
            this.nodes[1] = QT_ARRAY_POP({
                pos: {
                    x: x,
                    y: y
                },
                width: subWidth,
                height: subHeight
            }, this.max_objects, this.max_levels, nextLevel); //bottom left node
            this.nodes[2] = QT_ARRAY_POP({
                pos: {
                    x: x,
                    y: y + subHeight
                },
                width: subWidth,
                height: subHeight
            }, this.max_objects, this.max_levels, nextLevel); //bottom right node
            this.nodes[3] = QT_ARRAY_POP({
                pos: {
                    x: x + subWidth,
                    y: y + subHeight
                },
                width: subWidth,
                height: subHeight
            }, this.max_objects, this.max_levels, nextLevel);
        };
        /*
      * Determine which node the object belongs to
      * @param {me.Rect} rect bounds of the area to be checked
      * @return Integer index of the subnode (0-3), or -1 if rect cannot completely fit within a subnode and is part of the parent node
      */ Quadtree.prototype.getIndex = function(item) {
            var rect = item.getBounds(), pos = rect.pos; // use world coordinates for floating items
            if (item.floating || item.ancestor && item.ancestor.floating) pos = me.game.viewport.localToWorld(pos.x, pos.y, QT_VECTOR);
            var index = -1, rx = pos.x, ry = pos.y, rw = rect.width, rh = rect.height, verticalMidpoint = this.bounds.pos.x + this.bounds.width / 2, horizontalMidpoint = this.bounds.pos.y + this.bounds.height / 2, //rect can completely fit within the top quadrants
            topQuadrant = ry < horizontalMidpoint && ry + rh < horizontalMidpoint, //rect can completely fit within the bottom quadrants
            bottomQuadrant = ry > horizontalMidpoint; //rect can completely fit within the left quadrants
            if (rx < verticalMidpoint && rx + rw < verticalMidpoint) {
                if (topQuadrant) index = 1;
                else if (bottomQuadrant) index = 2;
            } else if (rx > verticalMidpoint) {
                //rect can completely fit within the right quadrants
                if (topQuadrant) index = 0;
                else if (bottomQuadrant) index = 3;
            }
            return index;
        };
        /**
      * Insert the given object container into the node.
      * @name insertContainer
      * @memberOf me.QuadTree
      * @function
      * @param {me.Container} container group of objects to be added
      */ Quadtree.prototype.insertContainer = function(container) {
            for(var i = container.children.length, child; i--, child = container.children[i];)if (child.isKinematic !== true) {
                if (child instanceof me.Container) {
                    if (child.name !== "rootContainer") this.insert(child);
                     // recursivly insert all childs
                    this.insertContainer(child);
                } else // only insert object with a bounding box
                // Probably redundant with `isKinematic`
                if (typeof child.getBounds === "function") this.insert(child);
            }
        };
        /**
      * Insert the given object into the node. If the node
      * exceeds the capacity, it will split and add all
      * objects to their corresponding subnodes.
      * @name insert
      * @memberOf me.QuadTree
      * @function
      * @param {Object} item object to be added
      */ Quadtree.prototype.insert = function(item) {
            var index = -1; //if we have subnodes ...
            if (this.nodes.length > 0) {
                index = this.getIndex(item);
                if (index !== -1) {
                    this.nodes[index].insert(item);
                    return;
                }
            }
            this.objects.push(item);
            if (this.objects.length > this.max_objects && this.level < this.max_levels) {
                //split if we don't already have subnodes
                if (this.nodes.length === 0) this.split();
                var i = 0; //add all objects to there corresponding subnodes
                while(i < this.objects.length){
                    index = this.getIndex(this.objects[i]);
                    if (index !== -1) this.nodes[index].insert(this.objects.splice(i, 1)[0]);
                    else i = i + 1;
                }
            }
        };
        /**
      * Return all objects that could collide with the given object
      * @name retrieve
      * @memberOf me.QuadTree
      * @function
      * @param {Object} object object to be checked against
      * @param {Object} [function] a sorting function for the returned array
      * @return {Object[]} array with all detected objects
      */ Quadtree.prototype.retrieve = function(item, fn) {
            var returnObjects = this.objects; //if we have subnodes ...
            if (this.nodes.length > 0) {
                var index = this.getIndex(item); //if rect fits into a subnode ..
                if (index !== -1) returnObjects = returnObjects.concat(this.nodes[index].retrieve(item));
                else //if rect does not fit into a subnode, check it against all subnodes
                for(var i = 0; i < this.nodes.length; i = i + 1)returnObjects = returnObjects.concat(this.nodes[i].retrieve(item));
            }
            if (typeof fn === "function") returnObjects.sort(fn);
            return returnObjects;
        };
        /**
      * Remove the given item from the quadtree.
      * (this function won't recalculate the impacted node)
      * @name remove
      * @memberOf me.QuadTree
      * @function
      * @param {Object} object object to be removed
      * @return true if the item was found and removed.
      */ Quadtree.prototype.remove = function(item) {
            var found = false;
            if (typeof item.getBounds === "undefined") // ignore object that cannot be added in the first place
            return false;
             //if we have subnodes ...
            if (this.nodes.length > 0) {
                // determine to which node the item belongs to
                var index = this.getIndex(item);
                if (index !== -1) {
                    found = me.utils.array.remove(this.nodes[index], item); // trim node if empty
                    if (found && this.nodes[index].isPrunable()) this.nodes.splice(index, 1);
                }
            }
            if (found === false) // try and remove the item from the list of items in this node
            {
                if (this.objects.indexOf(item) !== -1) {
                    me.utils.array.remove(this.objects, item);
                    found = true;
                }
            }
            return found;
        };
        /**
      * return true if the node is prunable
      * @name isPrunable
      * @memberOf me.QuadTree
      * @function
      * @return true if the node is prunable
      */ Quadtree.prototype.isPrunable = function() {
            return !(this.hasChildren() || this.objects.length > 0);
        };
        /**
      * return true if the node has any children
      * @name hasChildren
      * @memberOf me.QuadTree
      * @function
      * @return true if the node has any children
      */ Quadtree.prototype.hasChildren = function() {
            for(var i = 0; i < this.nodes.length; i = i + 1){
                var subnode = this.nodes[i];
                if (subnode.length > 0 || subnode.objects.length > 0) return true;
            }
            return false;
        };
        /**
      * clear the quadtree
      * @name clear
      * @memberOf me.QuadTree
      * @function
      */ Quadtree.prototype.clear = function(bounds) {
            this.objects.length = 0;
            for(var i = 0; i < this.nodes.length; i = i + 1){
                this.nodes[i].clear(); // recycle the quadTree object
                QT_ARRAY_PUSH(this.nodes[i]);
            } // empty the array
            this.nodes.length = 0; // resize the root bounds if required
            if (typeof bounds !== "undefined") this.bounds.setShape(bounds.pos.x, bounds.pos.y, bounds.width, bounds.height);
        }; //make Quadtree available in the me namespace
        me.QuadTree = Quadtree;
    })();
    /*
    * Separating Axis Theorem implementation, based on the SAT.js library by Jim Riecken <jimr@jimr.ca>
    * Available under the MIT License - https://github.com/jriecken/sat-js
    */ (function() {
        /**
      * Constants for Vornoi regions
      * @ignore
      */ var LEFT_VORNOI_REGION = -1;
        /**
      * Constants for Vornoi regions
      * @ignore
      */ var MIDDLE_VORNOI_REGION = 0;
        /**
      * Constants for Vornoi regions
      * @ignore
      */ var RIGHT_VORNOI_REGION = 1;
        /**
      * A pool of `Vector` objects that are used in calculations to avoid allocating memory.
      * @type {Array.<Vector>}
      */ var T_VECTORS = [];
        for(var v = 0; v < 10; v++)T_VECTORS.push(new me.Vector2d());
        /**
      * A pool of arrays of numbers used in calculations to avoid allocating memory.
      * @type {Array.<Array.<number>>}
      */ var T_ARRAYS = [];
        for(var a = 0; a < 5; a++)T_ARRAYS.push([]);
         // a dummy entity object when using Line for raycasting
        var dummyEntity = {
            pos: new me.Vector2d(0, 0),
            ancestor: {
                _absPos: new me.Vector2d(0, 0)
            }
        };
        /**
      * Flattens the specified array of points onto a unit vector axis,
      * resulting in a one dimensional range of the minimum and
      * maximum value on that axis.
      * @param {Array.<Vector>} points The points to flatten.
      * @param {Vector} normal The unit vector axis to flatten on.
      * @param {Array.<number>} result An array.  After calling this function,
      *   result[0] will be the minimum value,
      *   result[1] will be the maximum value.
      */ function flattenPointsOn(points, normal, result) {
            var min = Number.MAX_VALUE;
            var max = -Number.MAX_VALUE;
            var len = points.length;
            for(var i = 0; i < len; i++){
                // The magnitude of the projection of the point onto the normal
                var dot = points[i].dotProduct(normal);
                if (dot < min) min = dot;
                if (dot > max) max = dot;
            }
            result[0] = min;
            result[1] = max;
        }
        /**
      * Check whether two convex polygons are separated by the specified
      * axis (must be a unit vector).
      * @param {Vector} aPos The position of the first polygon.
      * @param {Vector} bPos The position of the second polygon.
      * @param {Array.<Vector>} aPoints The points in the first polygon.
      * @param {Array.<Vector>} bPoints The points in the second polygon.
      * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons
      *   will be projected onto this axis.
      * @param {Response=} response A Response object (optional) which will be populated
      *   if the axis is not a separating axis.
      * @return {boolean} true if it is a separating axis, false otherwise.  If false,
      *   and a response is passed in, information about how much overlap and
      *   the direction of the overlap will be populated.
      */ function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {
            var rangeA = T_ARRAYS.pop();
            var rangeB = T_ARRAYS.pop(); // The magnitude of the offset between the two polygons
            var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
            var projectedOffset = offsetV.dotProduct(axis); // Project the polygons onto the axis.
            flattenPointsOn(aPoints, axis, rangeA);
            flattenPointsOn(bPoints, axis, rangeB); // Move B's range to its position relative to A.
            rangeB[0] += projectedOffset;
            rangeB[1] += projectedOffset; // Check if there is a gap. If there is, this is a separating axis and we can stop
            if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
                T_VECTORS.push(offsetV);
                T_ARRAYS.push(rangeA);
                T_ARRAYS.push(rangeB);
                return true;
            } // This is not a separating axis. If we're calculating a response, calculate the overlap.
            if (response) {
                var overlap = 0; // A starts further left than B
                if (rangeA[0] < rangeB[0]) {
                    response.aInB = false; // A ends before B does. We have to pull A out of B
                    if (rangeA[1] < rangeB[1]) {
                        overlap = rangeA[1] - rangeB[0];
                        response.bInA = false; // B is fully inside A.  Pick the shortest way out.
                    } else {
                        var option1 = rangeA[1] - rangeB[0];
                        var option2 = rangeB[1] - rangeA[0];
                        overlap = option1 < option2 ? option1 : -option2;
                    } // B starts further left than A
                } else {
                    response.bInA = false; // B ends before A ends. We have to push A out of B
                    if (rangeA[1] > rangeB[1]) {
                        overlap = rangeA[0] - rangeB[1];
                        response.aInB = false; // A is fully inside B.  Pick the shortest way out.
                    } else {
                        var option11 = rangeA[1] - rangeB[0];
                        var option22 = rangeB[1] - rangeA[0];
                        overlap = option11 < option22 ? option11 : -option22;
                    }
                } // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.
                var absOverlap = Math.abs(overlap);
                if (absOverlap < response.overlap) {
                    response.overlap = absOverlap;
                    response.overlapN.copy(axis);
                    if (overlap < 0) response.overlapN.negateSelf();
                }
            }
            T_VECTORS.push(offsetV);
            T_ARRAYS.push(rangeA);
            T_ARRAYS.push(rangeB);
            return false;
        }
        /**
      * Calculates which Vornoi region a point is on a line segment. <br>
      * It is assumed that both the line and the point are relative to `(0,0)`<br>
      * <pre>
      *             |       (0)      |
      *      (-1)  [S]--------------[E]  (1)
      *             |       (0)      |
      * </pre>
      *
      * @ignore
      * @param {Vector} line The line segment.
      * @param {Vector} point The point.
      * @return  {number} LEFT_VORNOI_REGION (-1) if it is the left region,
      *          MIDDLE_VORNOI_REGION (0) if it is the middle region,
      *          RIGHT_VORNOI_REGION (1) if it is the right region.
      */ function vornoiRegion(line, point) {
            var len2 = line.length2();
            var dp = point.dotProduct(line);
            if (dp < 0) // If the point is beyond the start of the line, it is in the
            // left vornoi region.
            return LEFT_VORNOI_REGION;
            else if (dp > len2) // If the point is beyond the end of the line, it is in the
            // right vornoi region.
            return RIGHT_VORNOI_REGION;
            else // Otherwise, it's in the middle one.
            return MIDDLE_VORNOI_REGION;
        }
        /**
      * A singleton for managing collision detection (and projection-based collision response) of 2D shapes.<br>
      * Based on the Separating Axis Theorem and supports detecting collisions between simple Axis-Aligned Boxes, convex polygons and circles based shapes.
      * @namespace me.collision
      * @memberOf me
      */ me.collision = (function() {
            // hold public stuff in our singleton
            var api = {
            };
            /*
        * PUBLIC STUFF
        */ /**
        * The maximum number of children that a quadtree node can contain before it is split into sub-nodes.
        * @name maxChildren
        * @memberOf me.collision
        * @public
        * @type {Number}
        * @default 8
        * @see me.game.world.broadphase
        */ api.maxChildren = 8;
            /**
        * The maximum number of levels that the quadtree will create.
        * @name maxDepth
        * @memberOf me.collision
        * @public
        * @type {Number}
        * @default 4
        * @see me.game.world.broadphase
        *
        */ api.maxDepth = 4;
            /**
        * Enum for collision type values.
        * @property NO_OBJECT to disable collision check
        * @property PLAYER_OBJECT
        * @property NPC_OBJECT
        * @property ENEMY_OBJECT
        * @property COLLECTABLE_OBJECT
        * @property ACTION_OBJECT e.g. doors
        * @property PROJECTILE_OBJECT e.g. missiles
        * @property WORLD_SHAPE e.g. walls; for map collision shapes
        * @property USER user-defined collision types (see example)
        * @property ALL_OBJECT all of the above (including user-defined types)
        * @readonly
        * @enum {Number}
        * @name types
        * @memberOf me.collision
        * @see me.body.setCollisionMask
        * @see me.body.collisionType
        * @example
        * // set the entity body collision type
        * myEntity.body.collisionType = me.collision.types.PLAYER_OBJECT;
        *
        * // filter collision detection with collision shapes, enemies and collectables
        * myEntity.body.setCollisionMask(
        *     me.collision.types.WORLD_SHAPE |
        *     me.collision.types.ENEMY_OBJECT |
        *     me.collision.types.COLLECTABLE_OBJECT
        * );
        *
        * // User-defined collision types are defined using BITWISE LEFT-SHIFT:
        * game.collisionTypes = {
        *     LOCKED_DOOR : me.collision.types.USER << 0,
        *     OPEN_DOOR   : me.collision.types.USER << 1,
        *     LOOT        : me.collision.types.USER << 2,
        * };
        *
        * // Set collision type for a door entity
        * myDoorEntity.body.collisionType = game.collisionTypes.LOCKED_DOOR;
        *
        * // Set collision mask for the player entity, so it collides with locked doors and loot
        * myPlayerEntity.body.setCollisionMask(
        *     me.collision.types.ENEMY_OBJECT |
        *     me.collision.types.WORLD_SHAPE |
        *     game.collisionTypes.LOCKED_DOOR |
        *     game.collisionTypes.LOOT
        * );
        */ api.types = {
                /** to disable collision check */ NO_OBJECT: 0,
                PLAYER_OBJECT: 1,
                NPC_OBJECT: 2,
                ENEMY_OBJECT: 4,
                COLLECTABLE_OBJECT: 8,
                ACTION_OBJECT: 16,
                // door, etc...
                PROJECTILE_OBJECT: 32,
                // missiles, etc...
                WORLD_SHAPE: 64,
                // walls, etc...
                USER: 128,
                // user-defined types start here...
                ALL_OBJECT: 4294967295 // all objects
            };
            /**
        * An object representing the result of an intersection.
        * @property {me.Renderable} a The first object participating in the intersection
        * @property {me.Renderable} b The second object participating in the intersection
        * @property {Number} overlap Magnitude of the overlap on the shortest colliding axis
        * @property {me.Vector2d} overlapV The overlap vector (i.e. `overlapN.scale(overlap, overlap)`). If this vector is subtracted from the position of a, a and b will no longer be colliding
        * @property {me.Vector2d} overlapN The shortest colliding axis (unit-vector)
        * @property {Boolean} aInB Whether the first object is entirely inside the second
        * @property {Boolean} bInA Whether the second object is entirely inside the first
        * @property {Number} indexShapeA The index of the colliding shape for the object a body
        * @property {Number} indexShapeB The index of the colliding shape for the object b body
        * @name ResponseObject
        * @memberOf me.collision
        * @public
        * @type {Object}
        * @see me.collision.check
        */ api.ResponseObject = function() {
                this.a = null;
                this.b = null;
                this.overlapN = new me.Vector2d();
                this.overlapV = new me.Vector2d();
                this.aInB = true;
                this.bInA = true;
                this.indexShapeA = -1;
                this.indexShapeB = -1;
                this.overlap = Number.MAX_VALUE;
            };
            /**
        * Set some values of the response back to their defaults. <br>
        * Call this between tests if you are going to reuse a single <br>
        * Response object for multiple intersection tests <br>
        * (recommended as it will avoid allocating extra memory) <br>
        * @name clear
        * @memberOf me.collision.ResponseObject
        * @public
        * @function
        */ api.ResponseObject.prototype.clear = function() {
                this.aInB = true;
                this.bInA = true;
                this.overlap = Number.MAX_VALUE;
                this.indexShapeA = -1;
                this.indexShapeB = -1;
                return this;
            };
            /**
        * a global instance of a response object used for collision detection <br>
        * this object will be reused amongst collision detection call if not user-defined response is specified
        * @name response
        * @memberOf me.collision
        * @public
        * @type {me.collision.ResponseObject}
        */ api.response = new api.ResponseObject();
            /**
        * a callback used to determine if two objects should collide (based on both respective objects collision mask and type).<br>
        * you can redefine this function if you need any specific rules over what should collide with what.
        * @name shouldCollide
        * @memberOf me.collision
        * @public
        * @function
        * @param {me.Renderable} a a reference to the object A.
        * @param {me.Renderable} b a reference to the object B.
        * @return {Boolean} true if they should collide, false otherwise
        */ api.shouldCollide = function(a1, b) {
                return a1.isKinematic !== true && b.isKinematic !== true && a1.body && b.body && (a1.body.collisionMask & b.body.collisionType) !== 0 && (a1.body.collisionType & b.body.collisionMask) !== 0;
            };
            /**
        * Checks if the specified entity collides with others entities
        * @name check
        * @memberOf me.collision
        * @public
        * @function
        * @param {me.Renderable} obj entity to be tested for collision
        * @param {me.collision.ResponseObject} [respObj=me.collision.response] a user defined response object that will be populated if they intersect.
        * @return {Boolean} in case of collision, false otherwise
        * @example
        * update : function (dt) {
        *    // ...
        *
        *    // handle collisions against other shapes
        *    me.collision.check(this);
        *
        *    // ...
        * },
        *
        * // colision handler
        * onCollision : function (response) {
        *     if (response.b.body.collisionType === me.collision.types.ENEMY_OBJECT) {
        *         // makes the other entity solid, by substracting the overlap vector to the current position
        *         this.pos.sub(response.overlapV);
        *         this.hurt();
        *         // not solid
        *         return false;
        *     }
        *     // Make the object solid
        *     return true;
        * },
        */ api.check = function(objA, responseObject) {
                var collision = 0;
                var response = responseObject || api.response; // retreive a list of potential colliding objects
                var candidates = me.game.world.broadphase.retrieve(objA);
                for(var i = candidates.length, objB; i--, objB = candidates[i];)// check if both objects "should" collide
                if (objB !== objA && api.shouldCollide(objA, objB) && objA.getBounds().overlaps(objB.getBounds())) {
                    // go trough all defined shapes in A
                    var aLen = objA.body.shapes.length;
                    var bLen = objB.body.shapes.length;
                    if (aLen === 0 || bLen === 0) continue;
                    var indexA = 0;
                    do {
                        var shapeA = objA.body.getShape(indexA); // go through all defined shapes in B
                        var indexB = 0;
                        do {
                            var shapeB = objB.body.getShape(indexB); // full SAT collision check
                            if (api["test" + shapeA.shapeType + shapeB.shapeType].call(this, objA, shapeA, objB, shapeB, response.clear()) === true) {
                                // we touched something !
                                collision++; // set the shape index
                                response.indexShapeA = indexA;
                                response.indexShapeB = indexB; // execute the onCollision callback
                                if (objA.onCollision && objA.onCollision(response, objB) !== false) objA.body.respondToCollision.call(objA.body, response);
                                if (objB.onCollision && objB.onCollision(response, objA) !== false) objB.body.respondToCollision.call(objB.body, response);
                            }
                            indexB++;
                        }while (indexB < bLen)
                        indexA++;
                    }while (indexA < aLen)
                }
                 // we could return the amount of objects we collided with ?
                return collision > 0;
            };
            /**
        * Checks for object colliding with the given line
        * @name rayCast
        * @memberOf me.collision
        * @public
        * @function
        * @param {me.Line} line line to be tested for collision
        * @param {Array.<me.Renderable>} [result] a user defined array that will be populated with intersecting physic objects.
        * @return {Array.<me.Renderable>} an array of intersecting physic objects
        * @example
        *    // define a line accross the viewport
        *    var ray = new me.Line(
        *        // absolute position of the line
        *        0, 0, [
        *        // starting point relative to the initial position
        *        new me.Vector2d(0, 0),
        *        // ending point
        *        new me.Vector2d(me.game.viewport.width, me.game.viewport.height)
        *    ]);
        *
        *    // check for collition
        *    result = me.collision.rayCast(ray);
        *
        *    if (result.length > 0) {
        *        // ...
        *    }
        */ api.rayCast = function(line, resultArray) {
                var collision = 0;
                var result = resultArray || []; // retrieve a list of potential colliding objects
                var candidates = me.game.world.broadphase.retrieve(line.getBounds());
                for(var i = candidates.length, objB; i--, objB = candidates[i];)// fast AABB check if both bounding boxes are overlaping
                if (objB.body && line.getBounds().overlaps(objB.getBounds())) {
                    // go trough all defined shapes in B (if any)
                    var bLen = objB.body.shapes.length;
                    if (objB.body.shapes.length === 0) continue;
                    var shapeA = line; // go through all defined shapes in B
                    var indexB = 0;
                    do {
                        var shapeB = objB.body.getShape(indexB); // full SAT collision check
                        if (api["test" + shapeA.shapeType + shapeB.shapeType].call(this, dummyEntity, shapeA, objB, shapeB)) {
                            // we touched something !
                            result[collision] = objB;
                            collision++;
                        }
                        indexB++;
                    }while (indexB < bLen)
                }
                 // cap result in case it was not empty
                result.length = collision; // return the list of colliding objects
                return result;
            };
            /**
        * Checks whether polygons collide.
        * @ignore
        * @param {me.Renderable} a a reference to the object A.
        * @param {me.Polygon} polyA a reference to the object A Polygon to be tested
        * @param {me.Renderable} b a reference to the object B.
        * @param {me.Polygon} polyB a reference to the object B Polygon to be tested
        * @param {Response=} response Response object (optional) that will be populated if they intersect.
        * @return {boolean} true if they intersect, false if they don't.
        */ api.testPolygonPolygon = function(a1, polyA, b, polyB, response) {
                // specific point for
                var aPoints = polyA.points;
                var aNormals = polyA.normals;
                var aLen = aNormals.length;
                var bPoints = polyB.points;
                var bNormals = polyB.normals;
                var bLen = bNormals.length; // aboslute shape position
                var posA = T_VECTORS.pop().copy(a1.pos).add(a1.ancestor._absPos).add(polyA.pos);
                var posB = T_VECTORS.pop().copy(b.pos).add(b.ancestor._absPos).add(polyB.pos);
                var i; // If any of the edge normals of A is a separating axis, no intersection.
                for(i = 0; i < aLen; i++)if (isSeparatingAxis(posA, posB, aPoints, bPoints, aNormals[i], response)) {
                    T_VECTORS.push(posA);
                    T_VECTORS.push(posB);
                    return false;
                }
                 // If any of the edge normals of B is a separating axis, no intersection.
                for(i = 0; i < bLen; i++)if (isSeparatingAxis(posA, posB, aPoints, bPoints, bNormals[i], response)) {
                    T_VECTORS.push(posA);
                    T_VECTORS.push(posB);
                    return false;
                }
                 // Since none of the edge normals of A or B are a separating axis, there is an intersection
                // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the
                // final overlap vector.
                if (response) {
                    response.a = a1;
                    response.b = b;
                    response.overlapV.copy(response.overlapN).scale(response.overlap);
                }
                T_VECTORS.push(posA);
                T_VECTORS.push(posB);
                return true;
            };
            /**
        * Check if two Ellipse collide.
        * @ignore
        * @param {me.Renderable} a a reference to the object A.
        * @param {me.Ellipse} ellipseA a reference to the object A Ellipse to be tested
        * @param {me.Renderable} b a reference to the object B.
        * @param {me.Ellipse} ellipseB a reference to the object B Ellipse to be tested
        * @param {Response=} response Response object (optional) that will be populated if
        *   the circles intersect.
        * @return {boolean} true if the circles intersect, false if they don't.
        */ api.testEllipseEllipse = function(a1, ellipseA, b, ellipseB, response) {
                // Check if the distance between the centers of the two
                // circles is greater than their combined radius.
                var differenceV = T_VECTORS.pop().copy(b.pos).add(b.ancestor._absPos).add(ellipseB.pos).sub(a1.pos).add(a1.ancestor._absPos).sub(ellipseA.pos);
                var radiusA = ellipseA.radius;
                var radiusB = ellipseB.radius;
                var totalRadius = radiusA + radiusB;
                var totalRadiusSq = totalRadius * totalRadius;
                var distanceSq = differenceV.length2(); // If the distance is bigger than the combined radius, they don't intersect.
                if (distanceSq > totalRadiusSq) {
                    T_VECTORS.push(differenceV);
                    return false;
                } // They intersect.  If we're calculating a response, calculate the overlap.
                if (response) {
                    var dist = Math.sqrt(distanceSq);
                    response.a = a1;
                    response.b = b;
                    response.overlap = totalRadius - dist;
                    response.overlapN.copy(differenceV.normalize());
                    response.overlapV.copy(differenceV).scale(response.overlap);
                    response.aInB = radiusA <= radiusB && dist <= radiusB - radiusA;
                    response.bInA = radiusB <= radiusA && dist <= radiusA - radiusB;
                }
                T_VECTORS.push(differenceV);
                return true;
            };
            /**
        * Check if a polygon and an ellipse collide.
        * @ignore
        * @param {me.Renderable} a a reference to the object A.
        * @param {me.Polygon} polyA a reference to the object A Polygon to be tested
        * @param {me.Renderable} b a reference to the object B.
        * @param {me.Ellipse} ellipseB a reference to the object B Ellipse to be tested
        * @param {Response=} response Response object (optional) that will be populated if they intersect.
        * @return {boolean} true if they intersect, false if they don't.
        */ api.testPolygonEllipse = function(a1, polyA, b, ellipseB, response) {
                // Get the position of the circle relative to the polygon.
                var circlePos = T_VECTORS.pop().copy(b.pos).add(b.ancestor._absPos).add(ellipseB.pos).sub(a1.pos).add(a1.ancestor._absPos).sub(polyA.pos);
                var radius = ellipseB.radius;
                var radius2 = radius * radius;
                var points = polyA.points;
                var edges = polyA.edges;
                var len = edges.length;
                var edge = T_VECTORS.pop();
                var normal = T_VECTORS.pop();
                var point = T_VECTORS.pop();
                var dist = 0; // For each edge in the polygon:
                for(var i = 0; i < len; i++){
                    var next = i === len - 1 ? 0 : i + 1;
                    var prev = i === 0 ? len - 1 : i - 1;
                    var overlap = 0;
                    var overlapN = null; // Get the edge.
                    edge.copy(edges[i]); // Calculate the center of the circle relative to the starting point of the edge.
                    point.copy(circlePos).sub(points[i]); // If the distance between the center of the circle and the point
                    // is bigger than the radius, the polygon is definitely not fully in
                    // the circle.
                    if (response && point.length2() > radius2) response.aInB = false;
                     // Calculate which Vornoi region the center of the circle is in.
                    var region = vornoiRegion(edge, point);
                    var inRegion = true; // If it's the left region:
                    if (region === LEFT_VORNOI_REGION) {
                        var point2 = null;
                        if (len > 1) {
                            // We need to make sure we're in the RIGHT_VORNOI_REGION of the previous edge.
                            edge.copy(edges[prev]); // Calculate the center of the circle relative the starting point of the previous edge
                            point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);
                            region = vornoiRegion(edge, point2);
                            if (region !== RIGHT_VORNOI_REGION) inRegion = false;
                        }
                        if (inRegion) {
                            // It's in the region we want.  Check if the circle intersects the point.
                            dist = point.length();
                            if (dist > radius) {
                                // No intersection
                                T_VECTORS.push(circlePos);
                                T_VECTORS.push(edge);
                                T_VECTORS.push(normal);
                                T_VECTORS.push(point);
                                if (point2) T_VECTORS.push(point2);
                                return false;
                            } else if (response) {
                                // It intersects, calculate the overlap.
                                response.bInA = false;
                                overlapN = point.normalize();
                                overlap = radius - dist;
                            }
                        }
                        if (point2) T_VECTORS.push(point2);
                         // If it's the right region:
                    } else if (region === RIGHT_VORNOI_REGION) {
                        if (len > 1) {
                            // We need to make sure we're in the left region on the next edge
                            edge.copy(edges[next]); // Calculate the center of the circle relative to the starting point of the next edge.
                            point.copy(circlePos).sub(points[next]);
                            region = vornoiRegion(edge, point);
                            if (region !== LEFT_VORNOI_REGION) inRegion = false;
                        }
                        if (inRegion) {
                            // It's in the region we want.  Check if the circle intersects the point.
                            dist = point.length();
                            if (dist > radius) {
                                // No intersection
                                T_VECTORS.push(circlePos);
                                T_VECTORS.push(edge);
                                T_VECTORS.push(normal);
                                T_VECTORS.push(point);
                                return false;
                            } else if (response) {
                                // It intersects, calculate the overlap.
                                response.bInA = false;
                                overlapN = point.normalize();
                                overlap = radius - dist;
                            }
                        } // Otherwise, it's the middle region:
                    } else {
                        // Need to check if the circle is intersecting the edge,
                        // Get the normal.
                        normal.copy(polyA.normals[i]); // Find the perpendicular distance between the center of the
                        // circle and the edge.
                        dist = point.dotProduct(normal);
                        var distAbs = Math.abs(dist); // If the circle is on the outside of the edge, there is no intersection.
                        if ((len === 1 || dist > 0) && distAbs > radius) {
                            // No intersection
                            T_VECTORS.push(circlePos);
                            T_VECTORS.push(edge);
                            T_VECTORS.push(normal);
                            T_VECTORS.push(point);
                            return false;
                        } else if (response) {
                            // It intersects, calculate the overlap.
                            overlapN = normal;
                            overlap = radius - dist; // If the center of the circle is on the outside of the edge, or part of the
                            // circle is on the outside, the circle is not fully inside the polygon.
                            if (dist >= 0 || overlap < 2 * radius) response.bInA = false;
                        }
                    } // If this is the smallest overlap we've seen, keep it.
                    // (overlapN may be null if the circle was in the wrong Vornoi region).
                    if (overlapN && response && Math.abs(overlap) < Math.abs(response.overlap)) {
                        response.overlap = overlap;
                        response.overlapN.copy(overlapN);
                    }
                } // Calculate the final overlap vector - based on the smallest overlap.
                if (response) {
                    response.a = a1;
                    response.b = b;
                    response.overlapV.copy(response.overlapN).scale(response.overlap);
                }
                T_VECTORS.push(circlePos);
                T_VECTORS.push(edge);
                T_VECTORS.push(normal);
                T_VECTORS.push(point);
                return true;
            };
            /**
        * Check if an ellipse and a polygon collide. <br>
        * **NOTE:** This is slightly less efficient than testPolygonEllipse as it just
        * runs testPolygonEllipse and reverses the response at the end.
        * @ignore
        * @param {me.Renderable} a a reference to the object A.
        * @param {me.Ellipse} ellipseA a reference to the object A Ellipse to be tested
        * @param {me.Renderable} a a reference to the object B.
        * @param {me.Polygon} polyB a reference to the object B Polygon to be tested
        * @param {Response=} response Response object (optional) that will be populated if
        *   they intersect.
        * @return {boolean} true if they intersect, false if they don't.
        */ api.testEllipsePolygon = function(a1, ellipseA, b, polyB, response) {
                // Test the polygon against the circle.
                var result = api.testPolygonEllipse(b, polyB, a1, ellipseA, response);
                if (result && response) {
                    // Swap A and B in the response.
                    var resa = response.a;
                    var aInB = response.aInB;
                    response.overlapN.negateSelf();
                    response.overlapV.negateSelf();
                    response.a = response.b;
                    response.b = resa;
                    response.aInB = response.bInA;
                    response.bInA = aInB;
                }
                return result;
            }; // return our object
            return api;
        })();
    })();
    (function() {
        /**
      * an object representing the physic world, and responsible for managing and updating all childs and physics
      * @class
      * @extends me.Container
      * @memberOf me
      * @constructor
      * @param {Number} [x=0] position of the container (accessible via the inherited pos.x property)
      * @param {Number} [y=0] position of the container (accessible via the inherited pos.y property)
      * @param {Number} [w=me.game.viewport.width] width of the container
      * @param {Number} [h=me.game.viewport.height] height of the container
      */ me.World = me.Container.extend({
            /**
        * @ignore
        */ init: function init(x, y, width, height) {
                // call the _super constructor
                this._super(me.Container, "init", [
                    x || 0,
                    y || 0,
                    width || Infinity,
                    height || Infinity,
                    true
                ]); // world is the root container
                this.name = "rootContainer"; // to mimic the previous behavior
                this.anchorPoint.set(0, 0);
                /**
          * the rate at which the game world is updated,
          * may be greater than or lower than the display fps
          * @public
          * @type me.Vector2d
          * @default 60
          * @name fps
          * @memberOf me.World
          * @see me.timer.maxfps
          */ this.fps = 60;
                /**
          * world gravity
          * @public
          * @type me.Vector2d
          * @default <0,0.98>
          * @name gravity
          * @memberOf me.World
          */ this.gravity = new me.Vector2d(0, 0.98);
                /**
          * the instance of the game world quadtree used for broadphase
          * @name broadphase
          * @memberOf me.World
          * @public
          * @type {me.QuadTree}
          */ this.broadphase = new me.QuadTree(this.getBounds().clone(), me.collision.maxChildren, me.collision.maxDepth); // reset the world container on the game reset signal
                me.event.subscribe(me.event.GAME_RESET, this.reset.bind(this)); // update the broadband world bounds if a new level is loaded
                me.event.subscribe(me.event.LEVEL_LOADED, function() {
                    // reset the quadtree
                    me.game.world.broadphase.clear(me.game.world.getBounds());
                });
            },
            /**
        * reset the game world
        * @name reset
        * @memberOf me.World
        * @function
        */ reset: function reset() {
                // clear the quadtree
                this.broadphase.clear(); // reset the anchorPoint
                this.anchorPoint.set(0, 0); // call the _super constructor
                this._super(me.Container, "reset");
            },
            /**
        * update the game world
        * @name reset
        * @memberOf me.World
        * @function
        */ update: function update(dt) {
                // clear the quadtree
                this.broadphase.clear(); // insert the world container (children) into the quadtree
                this.broadphase.insertContainer(this); // call the _super constructor
                return this._super(me.Container, "update", [
                    dt
                ]);
            }
        });
    })();
    (function() {
        // some ref shortcut
        var MIN = Math.min, MAX = Math.max;
        var targetV = new me.Vector2d();
        /**
      * a 2D orthographic camera
      * @class
      * @extends me.Renderable
      * @memberOf me
      * @constructor
      * @param {Number} minX start x offset
      * @param {Number} minY start y offset
      * @param {Number} maxX end x offset
      * @param {Number} maxY end y offset
      */ me.Camera2d = me.Renderable.extend({
            /**
        * @ignore
        */ init: function init(minX, minY, maxX, maxY) {
                this._super(me.Renderable, "init", [
                    minX,
                    minY,
                    maxX - minX,
                    maxY - minY
                ]);
                /**
          * Axis definition
          * @property NONE
          * @property HORIZONTAL
          * @property VERTICAL
          * @property BOTH
          * @public
          * @constant
          * @enum {Number}
          * @name AXIS
          * @memberOf me.Camera2d
          */ this.AXIS = {
                    NONE: 0,
                    HORIZONTAL: 1,
                    VERTICAL: 2,
                    BOTH: 3
                };
                /**
          * Camera bounds
          * @public
          * @type me.Rect
          * @name bounds
          * @memberOf me.Camera2d
          */ this.bounds = new me.Rect(-Infinity, -Infinity, Infinity, Infinity);
                /**
          * [IMTERNAL] enable or disable damping
          * @private
          * @type {Boolean}
          * @name smoothFollow
          * @see me.Camera2d.damping
          * @default true
          * @memberOf me.Camera2d
          */ this.smoothFollow = true;
                /**
          * Camera damping for smooth transition [0 .. 1].
          * 1 being the maximum value and will snap the camera to the target position
          * @public
          * @type {Number}
          * @name damping
          * @default 1.0
          * @memberOf me.Camera2d
          */ this.damping = 1;
                /**
          * the closest point relative to the camera
          * @public
          * @type {Number}
          * @name near
          * @default -1000
          * @memberOf me.Camera2d
          */ this.near = -1000;
                /**
          * the furthest point relative to the camera.
          * @public
          * @type {Number}
          * @name far
          * @default 1000
          * @memberOf me.Camera2d
          */ this.far = 1000;
                /**
          * the default camera projection matrix
          * (2d cameras use an orthographic projection by default).
          * @public
          * @type {me.Matrix3d}
          * @name projectionMatrix
          * @memberOf me.Camera2d
          */ this.projectionMatrix = new me.Matrix3d();
                /**
          * the invert camera transform used to unproject points
          * @ignore
          * @type {me.Matrix2d}
          * @name invCurrentTransform
          * @memberOf me.Camera2d
          */ this.invCurrentTransform = new me.Matrix2d(); // offset for shake effect
                this.offset = new me.Vector2d(); // target to follow
                this.target = null; // default value follow
                this.follow_axis = this.AXIS.NONE; // shake variables
                this._shake = {
                    intensity: 0,
                    duration: 0,
                    axis: this.AXIS.BOTH,
                    onComplete: null
                }; // flash variables
                this._fadeOut = {
                    color: null,
                    tween: null
                }; // fade variables
                this._fadeIn = {
                    color: null,
                    tween: null
                }; // default camera name
                this.name = "default"; // set a default deadzone
                this.setDeadzone(this.width / 6, this.height / 6); // for backward "compatiblity" (in terms of behavior)
                this.anchorPoint.set(0, 0); // enable event detection on the camera
                this.isKinematic = false; // update the projection matrix
                this._updateProjectionMatrix(); // subscribe to the game reset event
                me.event.subscribe(me.event.GAME_RESET, this.reset.bind(this)); // subscribe to the canvas resize event
                me.event.subscribe(me.event.CANVAS_ONRESIZE, this.resize.bind(this));
            },
            // -- some private function ---
            /** @ignore */ // update the projection matrix based on the projection frame (a rectangle)
            _updateProjectionMatrix: function _updateProjectionMatrix() {
                this.projectionMatrix.ortho(0, this.width, this.height, 0, this.near, this.far);
            },
            /** @ignore */ _followH: function _followH(target) {
                var targetX = this.pos.x;
                if (target.x - this.pos.x > this.deadzone.right) targetX = MIN(target.x - this.deadzone.right, this.bounds.width - this.width);
                else if (target.x - this.pos.x < this.deadzone.pos.x) targetX = MAX(target.x - this.deadzone.pos.x, this.bounds.pos.x);
                return targetX;
            },
            /** @ignore */ _followV: function _followV(target) {
                var targetY = this.pos.y;
                if (target.y - this.pos.y > this.deadzone.bottom) targetY = MIN(target.y - this.deadzone.bottom, this.bounds.height - this.height);
                else if (target.y - this.pos.y < this.deadzone.pos.y) targetY = MAX(target.y - this.deadzone.pos.y, this.bounds.pos.y);
                return targetY;
            },
            // -- public function ---
            /**
        * reset the camera position to specified coordinates
        * @name reset
        * @memberOf me.Camera2d
        * @function
        * @param {Number} [x=0]
        * @param {Number} [y=0]
        */ reset: function reset(x, y) {
                // reset the initial camera position to 0,0
                this.pos.x = x || 0;
                this.pos.y = y || 0; // reset the target
                this.unfollow(); // damping default value
                this.smoothFollow = true;
                this.damping = 1; // reset the transformation matrix
                this.currentTransform.identity();
                this.invCurrentTransform.identity().invert(); // update the projection matrix
                this._updateProjectionMatrix();
            },
            /**
        * change the deadzone settings.
        * the "deadzone" defines an area within the current camera in which
        * the followed renderable can move without scrolling the camera.
        * @name setDeadzone
        * @see me.Camera2d.follow
        * @memberOf me.Camera2d
        * @function
        * @param {Number} w deadzone width
        * @param {Number} h deadzone height
        */ setDeadzone: function setDeadzone(w, h) {
                if (typeof this.deadzone === "undefined") this.deadzone = new me.Rect(0, 0, 0, 0);
                 // reusing the old code for now...
                this.deadzone.pos.set(~~((this.width - w) / 2), ~~((this.height - h) / 2 - h * 0.25));
                this.deadzone.resize(w, h);
                this.smoothFollow = false; // force a camera update
                this.updateTarget();
                this.smoothFollow = true;
            },
            /**
        * resize the camera
        * @name resize
        * @memberOf me.Camera2d
        * @function
        * @param {Number} w new width of the camera
        * @param {Number} h new height of the camera
        * @return {me.Camera2d} this camera
       */ resize: function resize(w, h) {
                // parent consctructor, resize camera rect
                this._super(me.Renderable, "resize", [
                    w,
                    h
                ]); // disable damping while resizing
                this.smoothFollow = false; // reset everything
                this.setBounds(0, 0, w, h);
                this.setDeadzone(w / 6, h / 6);
                this.update();
                this.smoothFollow = true; // update the projection matrix
                this._updateProjectionMatrix(); // publish the viewport resize event
                me.event.publish(me.event.VIEWPORT_ONRESIZE, [
                    this.width,
                    this.height
                ]);
                return this;
            },
            /**
        * set the camera boundaries (set to the world limit by default).
        * the camera is bound to the given coordinates and cannot move/be scrolled outside of it.
        * @name setBounds
        * @memberOf me.Camera2d
        * @function
        * @param {Number} x world left limit
        * @param {Number} y world top limit
        * @param {Number} w world width limit
        * @param {Number} h world height limit
        */ setBounds: function setBounds(x, y, w, h) {
                this.smoothFollow = false;
                this.bounds.pos.set(x, y);
                this.bounds.resize(w, h);
                this.moveTo(this.pos.x, this.pos.y);
                this.update();
                this.smoothFollow = true;
            },
            /**
        * set the camera to follow the specified renderable. <br>
        * (this will put the camera center around the given target)
        * @name follow
        * @memberOf me.Camera2d
        * @function
        * @param {me.Renderable|me.Vector2d} target renderable or position vector to follow
        * @param {me.Camera2d.AXIS} [axis=this.AXIS.BOTH] Which axis to follow
        * @param {Number} [damping=1] default damping value
        * @example
        * // set the camera to follow this renderable on both axis, and enable damping
        * me.game.viewport.follow(this, me.game.viewport.AXIS.BOTH, 0.1);
        */ follow: function follow(target, axis, damping) {
                if (target instanceof me.Renderable) this.target = target.pos;
                else if (target instanceof me.Vector2d || target instanceof me.Vector3d) this.target = target;
                else throw new Error("invalid target for me.Camera2d.follow");
                 // if axis is null, camera is moved on target center
                this.follow_axis = typeof axis === "undefined" ? this.AXIS.BOTH : axis;
                this.smoothFollow = false;
                if (typeof damping !== "number") this.damping = 1;
                else this.damping = me.Math.clamp(damping, 0, 1);
                 // force a camera update
                this.updateTarget();
                this.smoothFollow = true;
            },
            /**
        * unfollow the current target
        * @name unfollow
        * @memberOf me.Camera2d
        * @function
        */ unfollow: function unfollow() {
                this.target = null;
                this.follow_axis = this.AXIS.NONE;
            },
            /**
        * move the camera upper-left position by the specified offset.
        * @name move
        * @memberOf me.Camera2d
        * @see me.Camera2d.focusOn
        * @function
        * @param {Number} x
        * @param {Number} y
        * @example
        * // Move the camera up by four pixels
        * me.game.viewport.move(0, -4);
        */ move: function move(x, y) {
                this.moveTo(this.pos.x + x, this.pos.y + y);
            },
            /**
        * move the camera upper-left position to the specified coordinates
        * @name moveTo
        * @memberOf me.Camera2d
        * @see me.Camera2d.focusOn
        * @function
        * @param {Number} x
        * @param {Number} y
        */ moveTo: function moveTo(x, y) {
                var _x = this.pos.x;
                var _y = this.pos.y;
                this.pos.x = me.Math.clamp(x, this.bounds.pos.x, this.bounds.width - this.width);
                this.pos.y = me.Math.clamp(y, this.bounds.pos.y, this.bounds.height - this.height); //publish the VIEWPORT_ONCHANGE event if necessary
                if (_x !== this.pos.x || _y !== this.pos.y) me.event.publish(me.event.VIEWPORT_ONCHANGE, [
                    this.pos
                ]);
            },
            /** @ignore */ updateTarget: function updateTarget() {
                if (this.target) {
                    targetV.setV(this.pos);
                    switch(this.follow_axis){
                        case this.AXIS.NONE:
                            break;
                        case this.AXIS.HORIZONTAL:
                            targetV.x = this._followH(this.target);
                            break;
                        case this.AXIS.VERTICAL:
                            targetV.y = this._followV(this.target);
                            break;
                        case this.AXIS.BOTH:
                            targetV.x = this._followH(this.target);
                            targetV.y = this._followV(this.target);
                            break;
                    }
                    if (!this.pos.equals(targetV)) {
                        // update the camera position
                        if (this.smoothFollow === true && this.damping < 1) {
                            // account for floating precision and check if we are close "enough"
                            if (me.Math.toBeCloseTo(targetV.x, this.pos.x, 2) && me.Math.toBeCloseTo(targetV.y, this.pos.y, 2)) {
                                this.pos.setV(targetV);
                                return false;
                            } else this.pos.lerp(targetV, this.damping);
                        } else this.pos.setV(targetV);
                        return true;
                    }
                }
                return false;
            },
            /** @ignore */ update: function update(dt) {
                var updated = this.updateTarget(dt);
                if (this._shake.duration > 0) {
                    this._shake.duration -= dt;
                    if (this._shake.duration <= 0) {
                        this._shake.duration = 0;
                        this.offset.setZero();
                        if (typeof this._shake.onComplete === "function") this._shake.onComplete();
                    } else {
                        if (this._shake.axis === this.AXIS.BOTH || this._shake.axis === this.AXIS.HORIZONTAL) this.offset.x = (Math.random() - 0.5) * this._shake.intensity;
                        if (this._shake.axis === this.AXIS.BOTH || this._shake.axis === this.AXIS.VERTICAL) this.offset.y = (Math.random() - 0.5) * this._shake.intensity;
                    } // updated!
                    updated = true;
                }
                if (updated === true) //publish the corresponding message
                me.event.publish(me.event.VIEWPORT_ONCHANGE, [
                    this.pos
                ]);
                 // check for fade/flash effect
                if (this._fadeIn.tween != null || this._fadeOut.tween != null) updated = true;
                if (!this.currentTransform.isIdentity()) this.invCurrentTransform.copy(this.currentTransform).invert();
                else // reset to default
                this.invCurrentTransform.identity();
                return updated;
            },
            /**
        * shake the camera
        * @name shake
        * @memberOf me.Camera2d
        * @function
        * @param {Number} intensity maximum offset that the screen can be moved
        * while shaking
        * @param {Number} duration expressed in milliseconds
        * @param {me.Camera2d.AXIS} [axis=this.AXIS.BOTH] specify on which axis you
        *   want the shake effect
        * @param {Function} [onComplete] callback once shaking effect is over
        * @param {Boolean} [force] if true this will override the current effect
        * @example
        * // shake it baby !
        * me.game.viewport.shake(10, 500, me.game.viewport.AXIS.BOTH);
        */ shake: function shake(intensity, duration, axis, onComplete, force) {
                if (this._shake.duration === 0 || force === true) {
                    this._shake.intensity = intensity;
                    this._shake.duration = duration;
                    this._shake.axis = axis || this.AXIS.BOTH;
                    this._shake.onComplete = typeof onComplete === "function" ? onComplete : undefined;
                }
            },
            /**
        * fadeOut(flash) effect<p>
        * screen is filled with the specified color and slowly goes back to normal
        * @name fadeOut
        * @memberOf me.Camera2d
        * @function
        * @param {me.Color|String} color a CSS color value
        * @param {Number} [duration=1000] expressed in milliseconds
        * @param {Function} [onComplete] callback once effect is over
        * @example
        * // fade the camera to white upon dying, reload the level, and then fade out back
        * me.game.viewport.fadeIn("#fff", 150, function() {
        *     me.audio.play("die", false);
        *     me.levelDirector.reloadLevel();
        *     me.game.viewport.fadeOut("#fff", 150);
        * });
        */ fadeOut: function fadeOut(color, duration, onComplete) {
                this._fadeOut.color = me.pool.pull("me.Color").copy(color);
                this._fadeOut.tween = me.pool.pull("me.Tween", this._fadeOut.color).to({
                    alpha: 0
                }, duration || 1000).onComplete(onComplete || null);
                this._fadeOut.tween.isPersistent = true;
                this._fadeOut.tween.start();
            },
            /**
        * fadeIn effect <p>
        * fade to the specified color
        * @name fadeIn
        * @memberOf me.Camera2d
        * @function
        * @param {me.Color|String} color a CSS color value
        * @param {Number} [duration=1000] expressed in milliseconds
        * @param {Function} [onComplete] callback once effect is over
        * @example
        * // flash the camera to white for 75ms
        * me.game.viewport.fadeIn("#FFFFFF", 75);
        */ fadeIn: function fadeIn(color, duration, onComplete) {
                this._fadeIn.color = me.pool.pull("me.Color").copy(color);
                var _alpha = this._fadeIn.color.alpha;
                this._fadeIn.color.alpha = 0;
                this._fadeIn.tween = me.pool.pull("me.Tween", this._fadeIn.color).to({
                    alpha: _alpha
                }, duration || 1000).onComplete(onComplete || null);
                this._fadeIn.tween.isPersistent = true;
                this._fadeIn.tween.start();
            },
            /**
        * return the camera width
        * @name getWidth
        * @memberOf me.Camera2d
        * @function
        * @return {Number}
        */ getWidth: function getWidth() {
                return this.width;
            },
            /**
        * return the camera height
        * @name getHeight
        * @memberOf me.Camera2d
        * @function
        * @return {Number}
        */ getHeight: function getHeight() {
                return this.height;
            },
            /**
        * set the camera position around the specified object
        * @name focusOn
        * @memberOf me.Camera2d
        * @function
        * @param {me.Renderable}
        */ focusOn: function focusOn(target) {
                var bounds = target.getBounds();
                this.moveTo(target.pos.x + bounds.pos.x + bounds.width / 2, target.pos.y + bounds.pos.y + bounds.height / 2);
            },
            /**
        * check if the specified renderable is in the camera
        * @name isVisible
        * @memberOf me.Camera2d
        * @function
        * @param {me.Renderable} object
        * @param {Boolean} [floating===object.floating] if visibility check should be done against screen coordinates
        * @return {Boolean}
        */ isVisible: function isVisible(obj, floating) {
                if (floating === true || obj.floating === true) // check against screen coordinates
                return me.video.renderer.overlaps(obj.getBounds());
                else // check if within the current camera
                return obj.getBounds().overlaps(this);
            },
            /**
        * convert the given "local" (screen) coordinates into world coordinates
        * @name localToWorld
        * @memberOf me.Camera2d
        * @function
        * @param {Number} x
        * @param {Number} y
        * @param {Number} [v] an optional vector object where to set the
        * converted value
        * @return {me.Vector2d}
        */ localToWorld: function localToWorld(x, y, v) {
                // TODO memoization for one set of coords (multitouch)
                v = v || new me.Vector2d();
                v.set(x, y).add(this.pos).sub(me.game.world.pos);
                if (!this.currentTransform.isIdentity()) this.invCurrentTransform.apply(v);
                return v;
            },
            /**
        * convert the given world coordinates into "local" (screen) coordinates
        * @name worldToLocal
        * @memberOf me.Camera2d
        * @function
        * @param {Number} x
        * @param {Number} y
        * @param {Number} [v] an optional vector object where to set the
        * converted value
        * @return {me.Vector2d}
        */ worldToLocal: function worldToLocal(x, y, v) {
                // TODO memoization for one set of coords (multitouch)
                v = v || new me.Vector2d();
                v.set(x, y);
                if (!this.currentTransform.isIdentity()) this.currentTransform.apply(v);
                return v.sub(this.pos).add(me.game.world.pos);
            },
            /**
        * render the camera effects
        * @ignore
        */ drawFX: function drawFX(renderer) {
                // fading effect
                if (this._fadeIn.tween) {
                    // add an overlay
                    // TODO use the tint feature once implemented in Canvas mode
                    renderer.save(); // reset all transform so that the overaly cover the whole camera area
                    renderer.resetTransform();
                    renderer.setColor(this._fadeIn.color);
                    renderer.fillRect(0, 0, this.width, this.height);
                    renderer.restore(); // remove the tween if over
                    if (this._fadeIn.color.alpha === 1) {
                        this._fadeIn.tween = null;
                        me.pool.push(this._fadeIn.color);
                        this._fadeIn.color = null;
                    }
                } // flashing effect
                if (this._fadeOut.tween) {
                    // add an overlay
                    // TODO use the tint feature once implemented in Canvas mode
                    renderer.save(); // reset all transform so that the overaly cover the whole camera area
                    renderer.resetTransform();
                    renderer.setColor(this._fadeOut.color);
                    renderer.fillRect(0, 0, this.width, this.height);
                    renderer.restore(); // remove the tween if over
                    if (this._fadeOut.color.alpha === 0) {
                        this._fadeOut.tween = null;
                        me.pool.push(this._fadeOut.color);
                        this._fadeOut.color = null;
                    }
                }
            },
            /**
        * draw all object visibile in this viewport
        * @ignore
        */ draw: function draw(renderer, container) {
                var translateX = this.pos.x + this.offset.x;
                var translateY = this.pos.y + this.offset.y; // translate the world coordinates by default to screen coordinates
                container.currentTransform.translate(-translateX, -translateY); // set the camera projection
                renderer.setProjection(this.projectionMatrix); // clip to camera bounds
                renderer.clipRect(0, 0, this.width, this.height);
                this.preDraw(renderer);
                container.preDraw(renderer); // draw all objects,
                // specifying the viewport as the rectangle area to redraw
                container.draw(renderer, this); // draw the viewport/camera effects
                this.drawFX(renderer);
                container.postDraw(renderer);
                this.postDraw(renderer); // translate the world coordinates by default to screen coordinates
                container.currentTransform.translate(translateX, translateY);
            }
        });
    })();
    (function() {
        /**
      * a Generic Object Entity<br>
      * @class
      * @extends me.Renderable
      * @memberOf me
      * @constructor
      * @param {Number} x the x coordinates of the entity object
      * @param {Number} y the y coordinates of the entity object
      * @param {Object} settings Entity properties, to be defined through Tiled or when calling the entity constructor
      * <img src="images/object_properties.png"/>
      * @param {Number} settings.width the physical width the entity takes up in game
      * @param {Number} settings.height the physical height the entity takes up in game
      * @param {String} [settings.name] object entity name
      * @param {String} [settings.id] object unique IDs
      * @param {Image|String} [settings.image] resource name of a spritesheet to use for the entity renderable component
      * @param {Number} [settings.framewidth=settings.width] width of a single frame in the given spritesheet
      * @param {Number} [settings.frameheight=settings.width] height of a single frame in the given spritesheet
      * @param {String} [settings.type] object type
      * @param {Number} [settings.collisionMask] Mask collision detection for this object
      * @param {me.Rect[]|me.Polygon[]|me.Line[]|me.Ellipse[]} [settings.shapes] the initial list of collision shapes (usually populated through Tiled)
      */ me.Entity = me.Renderable.extend({
            /**
        * @ignore
        */ init: function init(x, y, settings) {
                /**
          * The array of renderable children of this entity.
          * @ignore
          */ this.children = []; // ensure mandatory properties are defined
                if (typeof settings.width !== "number" || typeof settings.height !== "number") throw new Error("height and width properties are mandatory when passing settings parameters to an object entity");
                 // call the super constructor
                this._super(me.Renderable, "init", [
                    x,
                    y,
                    settings.width,
                    settings.height
                ]);
                if (settings.image) {
                    // set the frame size to the given entity size, if not defined in settings
                    settings.framewidth = settings.framewidth || settings.width;
                    settings.frameheight = settings.frameheight || settings.height;
                    this.renderable = new me.Sprite(0, 0, settings);
                } // Update anchorPoint
                if (settings.anchorPoint) this.anchorPoint.set(settings.anchorPoint.x, settings.anchorPoint.y);
                 // set the sprite name if specified
                if (typeof settings.name === "string") this.name = settings.name;
                /**
          * object type (as defined in Tiled)
          * @public
          * @type String
          * @name type
          * @memberOf me.Entity
          */ this.type = settings.type || "";
                /**
          * object unique ID (as defined in Tiled)
          * @public
          * @type Number
          * @name id
          * @memberOf me.Entity
          */ this.id = settings.id || "";
                /**
          * dead/living state of the entity<br>
          * default value : true
          * @public
          * @type Boolean
          * @name alive
          * @memberOf me.Entity
          */ this.alive = true;
                /**
          * the entity body object
          * @public
          * @type me.Body
          * @name body
          * @memberOf me.Entity
          */ // initialize the default body
                if (typeof settings.shapes === "undefined") settings.shapes = new me.Polygon(0, 0, [
                    new me.Vector2d(0, 0),
                    new me.Vector2d(this.width, 0),
                    new me.Vector2d(this.width, this.height),
                    new me.Vector2d(0, this.height)
                ]);
                if (typeof this.body !== "undefined") this.body.init(this, settings.shapes, this.onBodyUpdate.bind(this));
                else this.body = new me.Body(this, settings.shapes, this.onBodyUpdate.bind(this));
                 // resize the entity if required
                if (this.width === 0 && this.height === 0) this.resize(this.body.width, this.body.height);
                 // set the  collision mask if defined
                if (typeof settings.collisionMask !== "undefined") this.body.setCollisionMask(settings.collisionMask);
                 // set the  collision mask if defined
                if (typeof settings.collisionType !== "undefined") {
                    if (typeof me.collision.types[settings.collisionType] !== "undefined") this.body.collisionType = me.collision.types[settings.collisionType];
                    else throw new Error("Invalid value for the collisionType property");
                } // disable for entities
                this.autoTransform = false;
            },
            /** @ignore */ update: function update(dt) {
                if (this.renderable) return this.renderable.update(dt);
                return this._super(me.Renderable, "update", [
                    dt
                ]);
            },
            /**
        * update the bounds position when the position is modified
        * @private
        * @name updateBoundsPos
        * @memberOf me.Entity
        * @function
        */ updateBoundsPos: function updateBoundsPos(x, y) {
                if (typeof this.body !== "undefined") {
                    var _pos = this.body.pos;
                    this._super(me.Renderable, "updateBoundsPos", [
                        x + _pos.x,
                        y + _pos.y
                    ]);
                } else this._super(me.Renderable, "updateBoundsPos", [
                    x,
                    y
                ]);
                return this.getBounds();
            },
            /**
        * update the bounds position when the body is modified
        * @private
        * @name onBodyUpdate
        * @memberOf me.Entity
        * @function
        */ onBodyUpdate: function onBodyUpdate(body) {
                // update the entity bounds to match with the body bounds
                this.getBounds().resize(body.width, body.height); // update the bounds pos
                this.updateBoundsPos(this.pos.x, this.pos.y);
            },
            preDraw: function preDraw(renderer) {
                renderer.save(); // translate to the entity position
                renderer.translate(this.pos.x + this.body.pos.x, this.pos.y + this.body.pos.y);
                if (this.renderable instanceof me.Renderable) // draw the child renderable's anchorPoint at the entity's
                // anchor point.  the entity's anchor point is a scale from
                // body position to body width/height
                renderer.translate(this.anchorPoint.x * this.body.width, this.anchorPoint.y * this.body.height);
            },
            /**
        * object draw<br>
        * not to be called by the end user<br>
        * called by the game manager on each game loop
        * @name draw
        * @memberOf me.Entity
        * @function
        * @protected
        * @param {me.CanvasRenderer|me.WebGLRenderer} renderer a renderer object
        * @param {me.Rect} region to draw
        **/ draw: function draw(renderer, rect) {
                var renderable = this.renderable;
                if (renderable instanceof me.Renderable) {
                    // predraw (apply transforms)
                    renderable.preDraw(renderer); // draw the object
                    renderable.draw(renderer, rect); // postdraw (clean-up);
                    renderable.postDraw(renderer);
                }
            },
            /**
        * Destroy function<br>
        * @ignore
        */ destroy: function destroy() {
                // free some property objects
                if (this.renderable) {
                    this.renderable.destroy.apply(this.renderable, arguments);
                    this.children.splice(0, 1);
                } // call the parent destroy method
                this._super(me.Renderable, "destroy", arguments);
            },
            /**
        * onDeactivateEvent Notification function<br>
        * Called by engine before deleting the object
        * @name onDeactivateEvent
        * @memberOf me.Entity
        * @function
        */ onDeactivateEvent: function onDeactivateEvent() {
                if (this.renderable && this.renderable.onDeactivateEvent) this.renderable.onDeactivateEvent();
            },
            /**
        * onCollision callback<br>
        * triggered in case of collision, when this entity body is being "touched" by another one<br>
        * @name onCollision
        * @memberOf me.Entity
        * @function
        * @param {me.collision.ResponseObject} response the collision response object
        * @param {me.Entity} other the other entity touching this one (a reference to response.a or response.b)
        * @return {Boolean} true if the object should respond to the collision (its position and velocity will be corrected)
        */ onCollision: function onCollision() {
                return false;
            }
        });
        /**
      * The entity renderable component (can be any objects deriving from me.Renderable, like me.Sprite for example)
      * @public
      * @type me.Renderable
      * @name renderable
      * @memberOf me.Entity
      */ Object.defineProperty(me.Entity.prototype, "renderable", {
            /* for backward compatiblity */ /**
        * @ignore
        */ get: function get() {
                return this.children[0];
            },
            /**
        * @ignore
        */ set: function set(value) {
                if (value instanceof me.Renderable) {
                    this.children[0] = value;
                    this.children[0].ancestor = this;
                } else throw new Error(value + "should extend me.Renderable");
            },
            configurable: true
        });
    })();
    (function() {
        // a default camera instance to use across all stages
        var default_camera; // default stage settings
        var default_settings = {
            cameras: []
        };
        /**
      * A default "Stage" object <br>
      * every "stage" object (title screen, credits, ingame, etc...) to be managed <br>
      * through the state manager must inherit from this base class.
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      * @param {Object} [options] The stage` parameters
      * @param {Boolean} [options.cameras=[new me.Camera2d()]] a list of cameras (experimental)
      * @see me.state
      */ me.Stage = me.Object.extend({
            /**
        * @ignore
        */ init: function init(settings) {
                /**
          * The list of active cameras in this stage.
          * Cameras will be renderered based on this order defined in this list.
          * Only the "default" camera will be resized when the window or canvas is resized.
          * @public
          * @type {Map}
          * @name cameras
          * @memberOf me.Stage
          */ this.cameras = new Map();
                /**
          * The given constructor options
          * @public
          * @name settings
          * @memberOf me.Stage
          * @enum {Object}
          */ this.settings = Object.assign(default_settings, settings || {
                });
            },
            /**
        * Object reset function
        * @ignore
        */ reset: function reset() {
                var self = this; // add all defined cameras
                this.settings.cameras.forEach(function(camera) {
                    self.cameras.set(camera.name, camera);
                }); // empty or no default camera
                if (this.cameras.has("default") === false) {
                    if (typeof default_camera === "undefined") {
                        var width = me.video.renderer.getWidth();
                        var height = me.video.renderer.getHeight(); // new default camera instance
                        default_camera = new me.Camera2d(0, 0, width, height);
                    }
                    this.cameras.set("default", default_camera);
                } // reset the game
                me.game.reset(); // call the onReset Function
                this.onResetEvent.apply(this, arguments);
            },
            /**
        * update function
        * @name update
        * @memberOf me.Stage
        * @ignore
        * @function
        * @param {Number} dt time since the last update in milliseconds.
        * @return false
        **/ update: function update(dt) {
                // update all objects (and pass the elapsed time since last frame)
                var isDirty = me.game.world.update(dt); // update the camera/viewport
                // iterate through all cameras
                this.cameras.forEach(function(camera) {
                    if (camera.update(dt)) isDirty = true;
                });
                return isDirty;
            },
            /**
        * draw the current stage
        * @name draw
        * @memberOf me.Stage
        * @ignore
        * @function
        * @param {me.CanvasRenderer|me.WebGLRenderer} renderer a renderer object
        */ draw: function draw(renderer) {
                // iterate through all cameras
                this.cameras.forEach(function(camera) {
                    // render the root container
                    camera.draw(renderer, me.game.world);
                });
            },
            /**
        * destroy function
        * @ignore
        */ destroy: function destroy() {
                // clear all cameras
                this.cameras.clear(); // notify the object
                this.onDestroyEvent.apply(this, arguments);
            },
            /**
        * onResetEvent function<br>
        * called by the state manager when reseting the object
        * this is typically where you will load a level, add renderables, etc...
        * @name onResetEvent
        * @memberOf me.Stage
        * @function
        * @param {} [arguments...] optional arguments passed when switching state
        * @see me.state#change
        */ onResetEvent: function onResetEvent() {
            },
            /**
        * onDestroyEvent function<br>
        * called by the state manager before switching to another state
        * @name onDestroyEvent
        * @memberOf me.Stage
        * @function
        */ onDestroyEvent: function onDestroyEvent() {
            }
        });
    })();
    (function() {
        /**
      * a State Manager (state machine)<p>
      * There is no constructor function for me.state.
      * @namespace me.state
      * @memberOf me
      */ me.state = (function() {
            // hold public stuff in our singleton
            var api = {
            };
            /*-------------------------------------------
           PRIVATE STUFF
        --------------------------------------------*/ // current state
            var _state = -1; // requestAnimeFrame Id
            var _animFrameId = -1; // whether the game state is "paused"
            var _isPaused = false; // list of stages
            var _stages = {
            }; // fading transition parameters between screen
            var _fade = {
                color: "",
                duration: 0
            }; // callback when state switch is done
            /** @ignore */ var _onSwitchComplete = null; // just to keep track of possible extra arguments
            var _extraArgs = null; // store the elapsed time during pause/stop period
            var _pauseTime = 0;
            /**
        * @ignore
        */ function _startRunLoop() {
                // ensure nothing is running first and in valid state
                if (_animFrameId === -1 && _state !== -1) {
                    // reset the timer
                    me.timer.reset(); // start the main loop
                    _animFrameId = window.requestAnimationFrame(_renderFrame);
                }
            }
            /**
        * Resume the game loop after a pause.
        * @ignore
        */ function _resumeRunLoop() {
                // ensure game is actually paused and in valid state
                if (_isPaused && _state !== -1) {
                    // reset the timer
                    me.timer.reset();
                    _isPaused = false;
                }
            }
            /**
        * Pause the loop for most screen objects.
        * @ignore
        */ function _pauseRunLoop() {
                // Set the paused boolean to stop updates on (most) entities
                _isPaused = true;
            }
            /**
        * this is only called when using requestAnimFrame stuff
        * @param {Number} time current timestamp in milliseconds
        * @ignore
        */ function _renderFrame(time) {
                var stage = _stages[_state].stage; // update all game objects
                me.game.update(time, stage); // render all game objects
                me.game.draw(stage); // schedule the next frame update
                if (_animFrameId !== -1) _animFrameId = window.requestAnimationFrame(_renderFrame);
            }
            /**
        * stop the SO main loop
        * @ignore
        */ function _stopRunLoop() {
                // cancel any previous animationRequestFrame
                window.cancelAnimationFrame(_animFrameId);
                _animFrameId = -1;
            }
            /**
        * start the SO main loop
        * @ignore
        */ function _switchState(state) {
                // clear previous interval if any
                _stopRunLoop(); // call the stage destroy method
                if (_stages[_state]) // just notify the object
                _stages[_state].stage.destroy();
                if (_stages[state]) {
                    // set the global variable
                    _state = state; // call the reset function with _extraArgs as arguments
                    _stages[_state].stage.reset.apply(_stages[_state].stage, _extraArgs); // and start the main loop of the
                    // new requested state
                    _startRunLoop(); // execute callback if defined
                    if (_onSwitchComplete) _onSwitchComplete();
                     // force repaint
                    me.game.repaint();
                }
            }
            /*
        * PUBLIC STUFF
        */ /**
        * default state ID for Loading Stage
        * @constant
        * @name LOADING
        * @memberOf me.state
        */ api.LOADING = 0;
            /**
        * default state ID for Menu Stage
        * @constant
        * @name MENU
        * @memberOf me.state
        */ api.MENU = 1;
            /**
        * default state ID for "Ready" Stage
        * @constant
        * @name READY
        * @memberOf me.state
        */ api.READY = 2;
            /**
        * default state ID for Play Stage
        * @constant
        * @name PLAY
        * @memberOf me.state
        */ api.PLAY = 3;
            /**
        * default state ID for Game Over Stage
        * @constant
        * @name GAMEOVER
        * @memberOf me.state
        */ api.GAMEOVER = 4;
            /**
        * default state ID for Game End Stage
        * @constant
        * @name GAME_END
        * @memberOf me.state
        */ api.GAME_END = 5;
            /**
        * default state ID for High Score Stage
        * @constant
        * @name SCORE
        * @memberOf me.state
        */ api.SCORE = 6;
            /**
        * default state ID for Credits Stage
        * @constant
        * @name CREDITS
        * @memberOf me.state
        */ api.CREDITS = 7;
            /**
        * default state ID for Settings Stage
        * @constant
        * @name SETTINGS
        * @memberOf me.state
        */ api.SETTINGS = 8;
            /**
        * default state ID for the default Stage
        * (the default stage is the one running as soon as melonJS is started)
        * @constant
        * @name SETTINGS
        * @memberOf me.state
        */ api.DEFAULT = 9;
            /**
        * default state ID for user defined constants<br>
        * @constant
        * @name USER
        * @memberOf me.state
        * @example
        * var STATE_INFO = me.state.USER + 0;
        * var STATE_WARN = me.state.USER + 1;
        * var STATE_ERROR = me.state.USER + 2;
        * var STATE_CUTSCENE = me.state.USER + 3;
        */ api.USER = 100;
            /**
        * onPause callback
        * @function
        * @name onPause
        * @memberOf me.state
        */ api.onPause = null;
            /**
        * onResume callback
        * @function
        * @name onResume
        * @memberOf me.state
        */ api.onResume = null;
            /**
        * onStop callback
        * @function
        * @name onStop
        * @memberOf me.state
        */ api.onStop = null;
            /**
        * onRestart callback
        * @function
        * @name onRestart
        * @memberOf me.state
        */ api.onRestart = null;
            /**
        * @ignore
        */ api.init = function() {
                // set the embedded loading stage
                api.set(api.LOADING, new me.DefaultLoadingScreen()); // set and enable the default stage
                api.set(me.state.DEFAULT, new me.Stage()); // enable by default as soon as the display is initialized
                me.event.subscribe(me.event.VIDEO_INIT, function() {
                    me.state.change(me.state.DEFAULT, true);
                });
            };
            /**
        * Stop the current screen object.
        * @name stop
        * @memberOf me.state
        * @public
        * @function
        * @param {Boolean} pauseTrack pause current track on screen stop.
        */ api.stop = function(music) {
                // only stop when we are not loading stuff
                if (_state !== api.LOADING && api.isRunning()) {
                    // stop the main loop
                    _stopRunLoop(); // current music stop
                    if (music === true) me.audio.pauseTrack();
                     // store time when stopped
                    _pauseTime = window.performance.now(); // publish the stop notification
                    me.event.publish(me.event.STATE_STOP); // any callback defined ?
                    if (typeof api.onStop === "function") api.onStop();
                }
            };
            /**
        * pause the current screen object
        * @name pause
        * @memberOf me.state
        * @public
        * @function
        * @param {Boolean} pauseTrack pause current track on screen pause
        */ api.pause = function(music) {
                // only pause when we are not loading stuff
                if (_state !== api.LOADING && !api.isPaused()) {
                    // stop the main loop
                    _pauseRunLoop(); // current music stop
                    if (music === true) me.audio.pauseTrack();
                     // store time when paused
                    _pauseTime = window.performance.now(); // publish the pause event
                    me.event.publish(me.event.STATE_PAUSE); // any callback defined ?
                    if (typeof api.onPause === "function") api.onPause();
                }
            };
            /**
        * Restart the screen object from a full stop.
        * @name restart
        * @memberOf me.state
        * @public
        * @function
        * @param {Boolean} resumeTrack resume current track on screen resume
        */ api.restart = function(music) {
                if (!api.isRunning()) {
                    // restart the main loop
                    _startRunLoop(); // current music stop
                    if (music === true) me.audio.resumeTrack();
                     // calculate the elpased time
                    _pauseTime = window.performance.now() - _pauseTime; // force repaint
                    me.game.repaint(); // publish the restart notification
                    me.event.publish(me.event.STATE_RESTART, [
                        _pauseTime
                    ]); // any callback defined ?
                    if (typeof api.onRestart === "function") api.onRestart();
                }
            };
            /**
        * resume the screen object
        * @name resume
        * @memberOf me.state
        * @public
        * @function
        * @param {Boolean} resumeTrack resume current track on screen resume
        */ api.resume = function(music) {
                if (api.isPaused()) {
                    // resume the main loop
                    _resumeRunLoop(); // current music stop
                    if (music === true) me.audio.resumeTrack();
                     // calculate the elpased time
                    _pauseTime = window.performance.now() - _pauseTime; // publish the resume event
                    me.event.publish(me.event.STATE_RESUME, [
                        _pauseTime
                    ]); // any callback defined ?
                    if (typeof api.onResume === "function") api.onResume();
                }
            };
            /**
        * return the running state of the state manager
        * @name isRunning
        * @memberOf me.state
        * @public
        * @function
        * @return {Boolean} true if a "process is running"
        */ api.isRunning = function() {
                return _animFrameId !== -1;
            };
            /**
        * Return the pause state of the state manager
        * @name isPaused
        * @memberOf me.state
        * @public
        * @function
        * @return {Boolean} true if the game is paused
        */ api.isPaused = function() {
                return _isPaused;
            };
            /**
        * associate the specified state with a Stage
        * @name set
        * @memberOf me.state
        * @public
        * @function
        * @param {Number} state State ID (see constants)
        * @param {me.Stage} stage Instantiated Stage to associate with state ID
        * @param {Boolean} [start = false] if true the state will be changed immediately after adding it.
        * @example
        * var MenuButton = me.GUI_Object.extend({
        *     "onClick" : function () {
        *         // Change to the PLAY state when the button is clicked
        *         me.state.change(me.state.PLAY);
        *         return true;
        *     }
        * });
        *
        * var MenuScreen = me.Stage.extend({
        *     onResetEvent: function() {
        *         // Load background image
        *         me.game.world.addChild(
        *             new me.ImageLayer(0, 0, {
        *                 image : "bg",
        *                 z: 0 // z-index
        *             }
        *         );
        *
        *         // Add a button
        *         me.game.world.addChild(
        *             new MenuButton(350, 200, { "image" : "start" }),
        *             1 // z-index
        *         );
        *
        *         // Play music
        *         me.audio.playTrack("menu");
        *     },
        *
        *     "onDestroyEvent" : function () {
        *         // Stop music
        *         me.audio.stopTrack();
        *     }
        * });
        *
        * me.state.set(me.state.MENU, new MenuScreen());
        */ api.set = function(state, stage, start) {
                if (!(stage instanceof me.Stage)) throw new Error(stage + " is not an instance of me.Stage");
                _stages[state] = {
                };
                _stages[state].stage = stage;
                _stages[state].transition = true;
                if (start === true) api.change(state);
            };
            /**
        * return a reference to the current screen object<br>
        * useful to call a object specific method
        * @name current
        * @memberOf me.state
        * @public
        * @function
        * @return {me.Stage}
        */ api.current = function() {
                if (typeof _stages[_state] !== "undefined") return _stages[_state].stage;
            };
            /**
        * specify a global transition effect
        * @name transition
        * @memberOf me.state
        * @public
        * @function
        * @param {String} effect (only "fade" is supported for now)
        * @param {me.Color|String} color a CSS color value
        * @param {Number} [duration=1000] expressed in milliseconds
        */ api.transition = function(effect, color, duration) {
                if (effect === "fade") {
                    _fade.color = color;
                    _fade.duration = duration;
                }
            };
            /**
        * enable/disable transition for a specific state (by default enabled for all)
        * @name setTransition
        * @memberOf me.state
        * @public
        * @function
        * @param {Number} state State ID (see constants)
        * @param {Boolean} enable
        */ api.setTransition = function(state, enable) {
                _stages[state].transition = enable;
            };
            /**
        * change the game/app state
        * @name change
        * @memberOf me.state
        * @public
        * @function
        * @param {Number} state State ID (see constants)
        * @param {Boolean} forceChange if true the state will be changed immediately
        * @param {} [arguments...] extra arguments to be passed to the reset functions
        * @example
        * // The onResetEvent method on the play screen will receive two args:
        * // "level_1" and the number 3
        * me.state.change(me.state.PLAY, "level_1", 3);
        */ api.change = function(state, forceChange) {
                // Protect against undefined Stage
                if (typeof _stages[state] === "undefined") throw new Error("Undefined Stage for state '" + state + "'");
                if (api.isCurrent(state)) // do nothing if already the current state
                return;
                _extraArgs = null;
                if (arguments.length > 1) // store extra arguments if any
                _extraArgs = Array.prototype.slice.call(arguments, 1);
                 // if fading effect
                if (_fade.duration && _stages[state].transition) {
                    /** @ignore */ _onSwitchComplete = function _onSwitchComplete1() {
                        me.game.viewport.fadeOut(_fade.color, _fade.duration);
                    };
                    me.game.viewport.fadeIn(_fade.color, _fade.duration, function() {
                        me.utils["function"].defer(_switchState, this, state);
                    });
                } else // wait for the last frame to be
                // "finished" before switching
                if (forceChange === true) _switchState(state);
                else me.utils["function"].defer(_switchState, this, state);
            };
            /**
        * return true if the specified state is the current one
        * @name isCurrent
        * @memberOf me.state
        * @public
        * @function
        * @param {Number} state State ID (see constants)
        */ api.isCurrent = function(state) {
                return _state === state;
            }; // return our object
            return api;
        })();
    })();
    (function() {
        // a basic progress bar object
        var ProgressBar = me.Renderable.extend({
            /**
        * @ignore
        */ init: function init(x, y, w, h) {
                var self = this;
                this.barHeight = h;
                this._super(me.Renderable, "init", [
                    x,
                    y,
                    w,
                    h
                ]);
                this.anchorPoint.set(0, 0);
                this.loaderHdlr = me.event.subscribe(me.event.LOADER_PROGRESS, self.onProgressUpdate.bind(self));
                this.resizeHdlr = me.event.subscribe(me.event.VIEWPORT_ONRESIZE, self.resize.bind(self)); // store current progress
                this.progress = 0;
            },
            /**
        * make sure the screen is refreshed every frame
        * @ignore
        */ onProgressUpdate: function onProgressUpdate(progress) {
                this.progress = ~~(progress * this.width);
                this.isDirty = true;
            },
            /**
        * draw function
        * @ignore
        */ draw: function draw(renderer) {
                // clear the background
                renderer.clearColor("#202020"); // draw the progress bar
                renderer.setColor("black");
                renderer.fillRect(this.pos.x, me.game.viewport.centerY, renderer.getWidth(), this.barHeight / 2);
                renderer.setColor("#55aa00");
                renderer.fillRect(this.pos.x, me.game.viewport.centerY, this.progress, this.barHeight / 2);
            },
            /**
        * Called by engine before deleting the object
        * @ignore
        */ onDestroyEvent: function onDestroyEvent() {
                // cancel the callback
                me.event.unsubscribe(this.loaderHdlr);
                me.event.unsubscribe(this.resizeHdlr);
                this.loaderHdlr = this.resizeHdlr = null;
            }
        }); // the melonJS Logo
        var IconLogo = me.Renderable.extend({
            /**
        * @ignore
        */ init: function init(x, y) {
                this._super(me.Renderable, "init", [
                    x,
                    y,
                    100,
                    85
                ]);
                this.iconCanvas = me.video.createCanvas(me.Math.nextPowerOfTwo(this.width), me.Math.nextPowerOfTwo(this.height), false);
                var context = me.video.renderer.getContext2d(this.iconCanvas);
                context.beginPath();
                context.moveTo(0.7, 48.9);
                context.bezierCurveTo(10.8, 68.9, 38.4, 75.8, 62.2, 64.5);
                context.bezierCurveTo(86.1, 53.1, 97.2, 27.7, 87, 7.7);
                context.lineTo(87, 7.7);
                context.bezierCurveTo(89.9, 15.4, 73.9, 30.2, 50.5, 41.4);
                context.bezierCurveTo(27.1, 52.5, 5.2, 55.8, 0.7, 48.9);
                context.lineTo(0.7, 48.9);
                context.closePath();
                context.fillStyle = "rgb(255, 255, 255)";
                context.fill();
                context.beginPath();
                context.moveTo(84, 7);
                context.bezierCurveTo(87.6, 14.7, 72.5, 30.2, 50.2, 41.6);
                context.bezierCurveTo(27.9, 53, 6.9, 55.9, 3.2, 48.2);
                context.bezierCurveTo(-0.5, 40.4, 14.6, 24.9, 36.9, 13.5);
                context.bezierCurveTo(59.2, 2.2, 80.3, -0.8, 84, 7);
                context.lineTo(84, 7);
                context.closePath();
                context.lineWidth = 5.3;
                context.strokeStyle = "rgb(255, 255, 255)";
                context.lineJoin = "miter";
                context.miterLimit = 4;
                context.stroke();
                this.anchorPoint.set(0.5, 0.5);
            },
            /**
        * @ignore
        */ draw: function draw(renderer) {
                renderer.drawImage(this.iconCanvas, renderer.getWidth() / 2, this.pos.y);
            }
        }); // the melonJS Text Logo
        var TextLogo = me.Renderable.extend({
            /**
        * @ignore
        */ init: function init(w, h) {
                this._super(me.Renderable, "init", [
                    0,
                    0,
                    w,
                    h
                ]);
                this.textWidth = 0; // offscreen cache canvas
                this.fontCanvas = me.video.createCanvas(256, 64, true);
                this.drawFont(me.video.renderer.getContext2d(this.fontCanvas));
                this.anchorPoint.set(0, 0);
            },
            drawFont: function drawFont(context) {
                var logo1 = me.pool.pull("me.Text", 0, 0, {
                    font: "century gothic",
                    size: 16,
                    fillStyle: "white",
                    textAlign: "middle",
                    textBaseline: "top",
                    text: "Commander"
                });
                var logo2 = me.pool.pull("me.Text", 0, 0, {
                    font: "century gothic",
                    size: 16,
                    fillStyle: "#55aa00",
                    textAlign: "middle",
                    textBaseline: "top",
                    bold: true,
                    text: "-Kektus"
                }); // compute both logo respective size
                var logo1_width = logo1.measureText(context).width;
                var logo2_width = logo2.measureText(context).width;
                this.textWidth = logo1_width + logo2_width; // calculate the final rendering position
                this.pos.x = Math.round((this.width - this.textWidth) / 2);
                this.pos.y = Math.round(this.height / 2 + 16); // use the private _drawFont method to directly draw on the canvas context
                logo1._drawFont(context, [
                    "Commander"
                ], 0, 0);
                logo2._drawFont(context, [
                    "-Kektus"
                ], logo1_width, 0); // put them back into the object pool
                me.pool.push(logo1);
                me.pool.push(logo2);
            },
            /**
        * @ignore
        */ draw: function draw(renderer) {
                renderer.drawImage(this.fontCanvas, Math.round((renderer.getWidth() - this.textWidth) / 2), this.pos.y);
            }
        });
        /**
      * a default loading screen
      * @memberOf me
      * @ignore
      * @constructor
      */ me.DefaultLoadingScreen = me.Stage.extend({
            /**
        * call when the loader is resetted
        * @ignore
        */ onResetEvent: function onResetEvent() {
                var barHeight = 8; // progress bar
                me.game.world.addChild(new ProgressBar(0, me.video.renderer.getHeight() / 2, me.video.renderer.getWidth(), barHeight), 1); // melonJS logo
                me.game.world.addChild(new IconLogo(me.video.renderer.getWidth() / 2, me.video.renderer.getHeight() / 2 - barHeight * 2 - 35), 2); // melonJS text
                me.game.world.addChild(new TextLogo(me.video.renderer.getWidth(), me.video.renderer.getHeight()), 2);
            }
        });
    })();
    (function() {
        /**
      * a small class to manage loading of stuff and manage resources
      * There is no constructor function for me.input.
      * @namespace me.loader
      * @memberOf me
      */ me.loader = (function() {
            // hold public stuff in our singleton
            var api = {
            }; // contains all the images loaded
            var imgList = {
            }; // contains all the TMX loaded
            var tmxList = {
            }; // contains all the binary files loaded
            var binList = {
            }; // contains all the JSON files
            var jsonList = {
            }; // baseURL
            var baseURL = {
            }; // flag to check loading status
            var resourceCount = 0;
            var loadCount = 0;
            var timerId = 0;
            /**
        * check the loading status
        * @ignore
        */ function checkLoadStatus(onload) {
                if (loadCount === resourceCount) {
                    // wait 1/2s and execute callback (cheap workaround to ensure everything is loaded)
                    if (onload || api.onload) {
                        // make sure we clear the timer
                        clearTimeout(timerId); // trigger the onload callback
                        // we call either the supplied callback (which takes precedence) or the global one
                        var callback = onload || api.onload;
                        setTimeout(function() {
                            callback();
                            me.event.publish(me.event.LOADER_COMPLETE);
                        }, 300);
                    } else throw new Error("no load callback defined");
                } else timerId = setTimeout(function() {
                    checkLoadStatus(onload);
                }, 100);
            }
            /**
        * load Images
        * @example
        * preloadImages([
        *     { name : 'image1', src : 'images/image1.png'},
        *     { name : 'image2', src : 'images/image2.png'},
        *     { name : 'image3', src : 'images/image3.png'},
        *     { name : 'image4', src : 'images/image4.png'}
        * ]);
        * @ignore
        */ function preloadImage(img, onload, onerror) {
                // create new Image object and add to list
                imgList[img.name] = new Image();
                imgList[img.name].onload = onload;
                imgList[img.name].onerror = onerror;
                if (typeof api.crossOrigin === "string") imgList[img.name].crossOrigin = api.crossOrigin;
                imgList[img.name].src = img.src + api.nocache;
            }
            /**
        * load a font face
        * @example
        * preloadFontFace(
        *     name: "'kenpixel'", type: "fontface",  src: "url('data/font/kenvector_future.woff2')"
        * ]);
        * @ignore
        */ function preloadFontFace(data, onload, onerror) {
                var font = new FontFace(data.name, data.src); // loading promise
                font.load().then(function() {
                    // apply the font after the font has finished downloading
                    document.fonts.add(font);
                    document.body.style.fontFamily = data.name; // onloaded callback
                    onload();
                }, function(e) {
                    // rejected
                    onerror(data.name);
                });
            }
            /**
        * preload TMX files
        * @ignore
        */ function preloadTMX(tmxData, onload, onerror) {
                function addToTMXList(data) {
                    // set the TMX content
                    tmxList[tmxData.name] = data; // add the tmx to the levelDirector
                    if (tmxData.type === "tmx") me.levelDirector.addTMXLevel(tmxData.name);
                } //if the data is in the tmxData object, don't get it via a XMLHTTPRequest
                if (tmxData.data) {
                    addToTMXList(tmxData.data);
                    onload();
                    return;
                }
                var xmlhttp = new XMLHttpRequest(); // check the data format ('tmx', 'json')
                var format = me.utils.file.getExtension(tmxData.src);
                if (xmlhttp.overrideMimeType) {
                    if (format === "json") xmlhttp.overrideMimeType("application/json");
                    else xmlhttp.overrideMimeType("text/xml");
                }
                xmlhttp.open("GET", tmxData.src + api.nocache, true);
                xmlhttp.withCredentials = me.loader.withCredentials; // set the callbacks
                xmlhttp.ontimeout = onerror;
                xmlhttp.onreadystatechange = function() {
                    if (xmlhttp.readyState === 4) {
                        // status = 0 when file protocol is used, or cross-domain origin,
                        // (With Chrome use "--allow-file-access-from-files --disable-web-security")
                        if (xmlhttp.status === 200 || xmlhttp.status === 0 && xmlhttp.responseText) {
                            var result = null; // parse response
                            switch(format){
                                case "xml":
                                case "tmx":
                                case "tsx":
                                    // ie9 does not fully implement the responseXML
                                    if (me.device.ua.match(/msie/i) || !xmlhttp.responseXML) {
                                        if (window.DOMParser) // manually create the XML DOM
                                        result = new DOMParser().parseFromString(xmlhttp.responseText, "text/xml");
                                        else throw new Error("XML file format loading not supported, use the JSON file format instead");
                                    } else result = xmlhttp.responseXML;
                                     // converts to a JS object
                                    var data = me.TMXUtils.parse(result);
                                    switch(format){
                                        case "tmx":
                                            result = data.map;
                                            break;
                                        case "tsx":
                                            result = data.tilesets[0];
                                            break;
                                    }
                                    break;
                                case "json":
                                    result = JSON.parse(xmlhttp.responseText);
                                    break;
                                default:
                                    throw new Error("TMX file format " + format + "not supported !");
                            } //set the TMX content
                            addToTMXList(result); // fire the callback
                            onload();
                        } else onerror(tmxData.name);
                    }
                }; // send the request
                xmlhttp.send();
            }
            /**
        * preload JSON files
        * @ignore
        */ function preloadJSON(data, onload, onerror) {
                var xmlhttp = new XMLHttpRequest();
                if (xmlhttp.overrideMimeType) xmlhttp.overrideMimeType("application/json");
                xmlhttp.open("GET", data.src + api.nocache, true);
                xmlhttp.withCredentials = me.loader.withCredentials; // set the callbacks
                xmlhttp.ontimeout = onerror;
                xmlhttp.onreadystatechange = function() {
                    if (xmlhttp.readyState === 4) {
                        // status = 0 when file protocol is used, or cross-domain origin,
                        // (With Chrome use "--allow-file-access-from-files --disable-web-security")
                        if (xmlhttp.status === 200 || xmlhttp.status === 0 && xmlhttp.responseText) {
                            // get the Texture Packer Atlas content
                            jsonList[data.name] = JSON.parse(xmlhttp.responseText); // fire the callback
                            onload();
                        } else onerror(data.name);
                    }
                }; // send the request
                xmlhttp.send();
            }
            /**
        * preload Binary files
        * @ignore
        */ function preloadBinary(data, onload, onerror) {
                var httpReq = new XMLHttpRequest(); // load our file
                httpReq.open("GET", data.src + api.nocache, true);
                httpReq.withCredentials = me.loader.withCredentials;
                httpReq.responseType = "arraybuffer";
                httpReq.onerror = onerror;
                httpReq.onload = function() {
                    var arrayBuffer = httpReq.response;
                    if (arrayBuffer) {
                        var byteArray = new Uint8Array(arrayBuffer);
                        var buffer = [];
                        for(var i = 0; i < byteArray.byteLength; i++)buffer[i] = String.fromCharCode(byteArray[i]);
                        binList[data.name] = buffer.join(""); // callback
                        onload();
                    }
                };
                httpReq.send();
            }
            /**
        * preload Binary files
        * @ignore
        */ function preloadJavascript(data, onload, onerror) {
                var script = document.createElement("script");
                script.src = data.src;
                script.type = "text/javascript";
                if (typeof api.crossOrigin === "string") script.crossOrigin = api.crossOrigin;
                script.defer = true;
                script.onload = function() {
                    // callback
                    onload();
                };
                script.onerror = function() {
                    // callback
                    onerror(data.name);
                };
                document.getElementsByTagName("body")[0].appendChild(script);
            }
            /**
        * to enable/disable caching
        * @ignore
        */ api.nocache = "";
            /*
        * PUBLIC STUFF
        */ /**
        * onload callback
        * @public
        * @function
        * @name onload
        * @memberOf me.loader
        * @example
        * // set a callback when everything is loaded
        * me.loader.onload = this.loaded.bind(this);
        */ api.onload = undefined;
            /**
        * onProgress callback<br>
        * each time a resource is loaded, the loader will fire the specified function,
        * giving the actual progress [0 ... 1], as argument, and an object describing the resource loaded
        * @public
        * @function
        * @name onProgress
        * @memberOf me.loader
        * @example
        * // set a callback for progress notification
        * me.loader.onProgress = this.updateProgress.bind(this);
        */ api.onProgress = undefined;
            /**
        * crossOrigin attribute to configure the CORS requests for Image data element.
        * By default (that is, when the attribute is not specified), CORS is not used at all.
        * The "anonymous" keyword means that there will be no exchange of user credentials via cookies,
        * client-side SSL certificates or HTTP authentication as described in the Terminology section of the CORS specification.<br>
        * @public
        * @type String
        * @name crossOrigin
        * @default undefined
        * @memberOf me.loader
        * @see https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes
        * @example
        *  // allow for cross-origin texture loading in WebGL
        * me.loader.crossOrigin = "anonymous";
        *
        * // set all ressources to be loaded
        * me.loader.preload(game.resources, this.loaded.bind(this));
        */ api.crossOrigin = undefined;
            /**
        * indicates whether or not cross-site Access-Control requests should be made using credentials such as cookies,
        * authorization headers or TLS client certificates. Setting withCredentials has no effect on same-site requests.
        * @public
        * @type Boolean
        * @name withCredentials
        * @default false
        * @memberOf me.loader
        * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials
        * @example
        *  // enable withCredentials
        * me.loader.withCredentials = true;
        *
        * // set all ressources to be loaded
        * me.loader.preload(game.resources, this.loaded.bind(this));
        */ api.withCredentials = false;
            /**
        * just increment the number of already loaded resources
        * @ignore
        */ api.onResourceLoaded = function(res) {
                // increment the loading counter
                loadCount++; // currrent progress
                var progress = loadCount / resourceCount; // call callback if defined
                if (api.onProgress) // pass the load progress in percent, as parameter
                api.onProgress(progress, res);
                me.event.publish(me.event.LOADER_PROGRESS, [
                    progress,
                    res
                ]);
            };
            /**
        * on error callback for image loading
        * @ignore
        */ api.onLoadingError = function(res) {
                throw new Error("Failed loading resource " + res.src);
            };
            /**
        * enable the nocache mechanism
        * @ignore
        */ api.setNocache = function(enable) {
                api.nocache = enable ? "?" + ~~(Math.random() * 10000000) : "";
            };
            /**
        * change the default baseURL for the given asset type.<br>
        * (this will prepend the asset URL and must finish with a '/')
        * @name setBaseURL
        * @memberOf me.loader
        * @public
        * @function
        * @param {String} type  "*", "audio", binary", "image", "json", "js", "tmx", "tsx"
        * @param {String} [url="./"] default base URL
        * @example
        * // change the base URL relative address for audio assets
        * me.loader.setBaseURL("audio", "data/audio/");
        * // change the base URL absolute address for all object types
        * me.loader.setBaseURL("*", "http://myurl.com/")
        */ api.setBaseURL = function(type, url) {
                if (type !== "*") baseURL[type] = url;
                else {
                    // "wildcards"
                    baseURL["audio"] = url;
                    baseURL["binary"] = url;
                    baseURL["image"] = url;
                    baseURL["json"] = url;
                    baseURL["js"] = url;
                    baseURL["tmx"] = url;
                    baseURL["tsx"] = url; // XXX ?
                //baseURL["fontface"] = url;
                }
            };
            /**
        * set all the specified game resources to be preloaded.
        * @name preload
        * @memberOf me.loader
        * @public
        * @function
        * @param {Object[]} resources
        * @param {String} resources.name internal name of the resource
        * @param {String} resources.type  "audio", binary", "image", "json","js", "tmx", "tsx", "fontface"
        * @param {String} resources.src  path and/or file name of the resource (for audio assets only the path is required)
        * @param {Boolean} [resources.stream] Set to true to force HTML5 Audio, which allows not to wait for large file to be downloaded before playing.
        * @param {function} [onload=me.loader.onload] function to be called when all resources are loaded
        * @param {boolean} [switchToLoadState=true] automatically switch to the loading screen
        * @example
        * game_resources = [
        *   // PNG tileset
        *   {name: "tileset-platformer", type: "image",  src: "data/map/tileset.png"},
        *   // PNG packed texture
        *   {name: "texture", type:"image", src: "data/gfx/texture.png"}
        *   // TSX file
        *   {name: "meta_tiles", type: "tsx", src: "data/map/meta_tiles.tsx"},
        *   // TMX level (XML & JSON)
        *   {name: "map1", type: "tmx", src: "data/map/map1.json"},
        *   {name: "map2", type: "tmx", src: "data/map/map2.tmx"},
        *   {name: "map3", type: "tmx", format: "json", data: {"height":15,"layers":[...],"tilewidth":32,"version":1,"width":20}},
        *   {name: "map4", type: "tmx", format: "xml", data: {xml representation of tmx}},
        *   // audio resources
        *   {name: "bgmusic", type: "audio",  src: "data/audio/"},
        *   {name: "cling",   type: "audio",  src: "data/audio/"},
        *   // binary file
        *   {name: "ymTrack", type: "binary", src: "data/audio/main.ym"},
        *   // JSON file (used for texturePacker)
        *   {name: "texture", type: "json", src: "data/gfx/texture.json"},
        *   // JavaScript file
        *   {name: "plugin", type: "js", src: "data/js/plugin.js"},
        *   // Font Face
        *   { name: "'kenpixel'", type: "fontface",  src: "url('data/font/kenvector_future.woff2')" }
        * ];
        * ...
        * // set all resources to be loaded
        * me.loader.preload(game.resources, this.loaded.bind(this));
        */ api.preload = function(res, onload, switchToLoadState) {
                // parse the resources
                for(var i = 0; i < res.length; i++)resourceCount += api.load(res[i], api.onResourceLoaded.bind(api, res[i]), api.onLoadingError.bind(api, res[i]));
                 // set the onload callback if defined
                if (typeof onload !== "undefined") api.onload = onload;
                if (switchToLoadState !== false) // swith to the loading screen
                me.state.change(me.state.LOADING);
                 // check load status
                checkLoadStatus(onload);
            };
            /**
        * Load a single resource (to be used if you need to load additional resource during the game)
        * @name load
        * @memberOf me.loader
        * @public
        * @function
        * @param {Object} resource
        * @param {String} resource.name internal name of the resource
        * @param {String} resource.type  "audio", binary", "image", "json", "tmx", "tsx"
        * @param {String} resource.src  path and/or file name of the resource (for audio assets only the path is required)
        * @param {Boolean} [resource.stream] Set to true to force HTML5 Audio, which allows not to wait for large file to be downloaded before playing.
        * @param {Function} onload function to be called when the resource is loaded
        * @param {Function} onerror function to be called in case of error
        * @example
        * // load an image asset
        * me.loader.load({name: "avatar",  type:"image",  src: "data/avatar.png"}, this.onload.bind(this), this.onerror.bind(this));
        *
        * // start loading music
        * me.loader.load({
        *     name   : "bgmusic",
        *     type   : "audio",
        *     src    : "data/audio/"
        * }, function () {
        *     me.audio.play("bgmusic");
        * });
        */ api.load = function(res, onload, onerror) {
                // transform the url if necessary
                if (typeof baseURL[res.type] !== "undefined") res.src = baseURL[res.type] + res.src;
                 // check ressource type
                switch(res.type){
                    case "binary":
                        // reuse the preloadImage fn
                        preloadBinary.call(this, res, onload, onerror);
                        return 1;
                    case "image":
                        // reuse the preloadImage fn
                        preloadImage.call(this, res, onload, onerror);
                        return 1;
                    case "json":
                        preloadJSON.call(this, res, onload, onerror);
                        return 1;
                    case "js":
                        preloadJavascript.call(this, res, onload, onerror);
                        return 1;
                    case "tmx":
                    case "tsx":
                        preloadTMX.call(this, res, onload, onerror);
                        return 1;
                    case "audio":
                        me.audio.load(res, !!res.stream, onload, onerror);
                        return 1;
                    case "fontface":
                        preloadFontFace.call(this, res, onload, onerror);
                        return 1;
                    default:
                        throw new Error("load : unknown or invalid resource type : " + res.type);
                }
            };
            /**
        * unload specified resource to free memory
        * @name unload
        * @memberOf me.loader
        * @public
        * @function
        * @param {Object} resource
        * @return {Boolean} true if unloaded
        * @example me.loader.unload({name: "avatar",  type:"image",  src: "data/avatar.png"});
        */ api.unload = function(res) {
                switch(res.type){
                    case "binary":
                        if (!(res.name in binList)) return false;
                        delete binList[res.name];
                        return true;
                    case "image":
                        if (!(res.name in imgList)) return false;
                        delete imgList[res.name];
                        return true;
                    case "json":
                        if (!(res.name in jsonList)) return false;
                        delete jsonList[res.name];
                        return true;
                    case "js":
                        // ??
                        return true;
                    case "fontface":
                        // ??
                        return true;
                    case "tmx":
                    case "tsx":
                        if (!(res.name in tmxList)) return false;
                        delete tmxList[res.name];
                        return true;
                    case "audio":
                        return me.audio.unload(res.name);
                    default:
                        throw new Error("unload : unknown or invalid resource type : " + res.type);
                }
            };
            /**
        * unload all resources to free memory
        * @name unloadAll
        * @memberOf me.loader
        * @public
        * @function
        * @example me.loader.unloadAll();
        */ api.unloadAll = function() {
                var name; // unload all binary resources
                for(name in binList)if (binList.hasOwnProperty(name)) api.unload({
                    "name": name,
                    "type": "binary"
                });
                 // unload all image resources
                for(name in imgList)if (imgList.hasOwnProperty(name)) api.unload({
                    "name": name,
                    "type": "image"
                });
                 // unload all tmx resources
                for(name in tmxList)if (tmxList.hasOwnProperty(name)) api.unload({
                    "name": name,
                    "type": "tmx"
                });
                 // unload all in json resources
                for(name in jsonList)if (jsonList.hasOwnProperty(name)) api.unload({
                    "name": name,
                    "type": "json"
                });
                 // unload all audio resources
                me.audio.unloadAll();
            };
            /**
        * return the specified TMX/TSX object
        * @name getTMX
        * @memberOf me.loader
        * @public
        * @function
        * @param {String} tmx name of the tmx/tsx element ("map1");
        * @return {XML|Object} requested element or null if not found
        */ api.getTMX = function(elt) {
                // force as string
                elt = "" + elt;
                if (elt in tmxList) return tmxList[elt];
                return null;
            };
            /**
        * return the specified Binary object
        * @name getBinary
        * @memberOf me.loader
        * @public
        * @function
        * @param {String} name of the binary object ("ymTrack");
        * @return {Object} requested element or null if not found
        */ api.getBinary = function(elt) {
                // force as string
                elt = "" + elt;
                if (elt in binList) return binList[elt];
                return null;
            };
            /**
        * return the specified Image Object
        * @name getImage
        * @memberOf me.loader
        * @public
        * @function
        * @param {String} image name of the Image element ("tileset-platformer");
        * @return {HTMLImageElement} requested element or null if not found
        */ api.getImage = function(image) {
                // force as string and extract the base name
                image = me.utils.file.getBasename("" + image);
                if (image in imgList) // return the corresponding Image object
                return imgList[image];
                return null;
            };
            /**
        * return the specified JSON Object
        * @name getJSON
        * @memberOf me.loader
        * @public
        * @function
        * @param {String} Name for the json file to load
        * @return {Object}
        */ api.getJSON = function(elt) {
                // force as string
                elt = "" + elt;
                if (elt in jsonList) return jsonList[elt];
                return null;
            };
            /**
        * Return the loading progress in percent
        * @name getLoadProgress
        * @memberOf me.loader
        * @public
        * @function
        * @deprecated use callback instead
        * @see me.loader.onProgress
        * @see me.event.LOADER_PROGRESS
        * @return {Number}
        */ api.getLoadProgress = function() {
                return loadCount / resourceCount;
            }; // return our object
            return api;
        })();
    })();
    /*
    * ASCII Table
    * http://www.asciitable.com/
    * [ !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz]
    *
    * -> first char " " 32d (0x20);
    */ (function() {
        var runits = [
            "ex",
            "em",
            "pt",
            "px"
        ];
        var toPX = [
            12,
            24,
            0.75,
            1
        ];
        /**
      * apply the current font style to the given context
      * @ignore
      */ var setContextStyle = function setContextStyle1(context, font, stroke) {
            context.font = font.font;
            context.fillStyle = font.fillStyle.toRGBA();
            if (stroke === true) {
                context.strokeStyle = font.strokeStyle.toRGBA();
                context.lineWidth = font.lineWidth;
            }
            context.textAlign = font.textAlign;
            context.textBaseline = font.textBaseline;
        };
        /**
      * a generic system font object.
      * @class
      * @extends me.Renderable
      * @memberOf me
      * @constructor
      * @param {Number} x position of the text object
      * @param {Number} y position of the text object
      * @param {Object} settings the text configuration
      * @param {String} settings.font a CSS family font name
      * @param {Number|String} settings.size size, or size + suffix (px, em, pt)
      * @param {me.Color|String} [settings.fillStyle="#000000"] a CSS color value
      * @param {me.Color|String} [settings.strokeStyle="#000000"] a CSS color value
      * @param {Number} [settings.lineWidth=1] line width, in pixels, when drawing stroke
      * @param {String} [settings.textAlign="left"] horizontal text alignment
      * @param {String} [settings.textBaseline="top"] the text baseline
      * @param {Number} [settings.lineHeight=1.0] line spacing height
      * @param {me.Vector2d} [settings.anchorPoint={x:0.0, y:0.0}] anchor point to draw the text at
      * @param {(String|String[])} [settings.text] a string, or an array of strings
      * @example
      * var font = new me.Text(0, 0, {font: "Arial", size: 8, fillStyle: this.color});
      */ me.Text = me.Renderable.extend({
            /** @ignore */ init: function init(x, y, settings) {
                // call the parent constructor
                this._super(me.Renderable, "init", [
                    x,
                    y,
                    settings.width || 0,
                    settings.height || 0
                ]);
                /**
          * defines the color used to draw the font.<br>
          * @public
          * @type me.Color
          * @default black
          * @name me.Text#fillStyle
          */ if (typeof settings.fillStyle !== "undefined") {
                    if (settings.fillStyle instanceof me.Color) this.fillStyle = settings.fillStyle;
                    else // string (#RGB, #ARGB, #RRGGBB, #AARRGGBB)
                    this.fillStyle = me.pool.pull("me.Color").parseCSS(settings.fillStyle);
                } else this.fillStyle = me.pool.pull("me.Color", 0, 0, 0);
                /**
          * defines the color used to draw the font stroke.<br>
          * @public
          * @type me.Color
          * @default black
          * @name me.Text#strokeStyle
          */ if (typeof settings.strokeStyle !== "undefined") {
                    if (settings.strokeStyle instanceof me.Color) this.strokeStyle = settings.strokeStyle;
                    else // string (#RGB, #ARGB, #RRGGBB, #AARRGGBB)
                    this.strokeStyle = me.pool.pull("me.Color").parseCSS(settings.strokeStyle);
                } else this.strokeStyle = me.pool.pull("me.Color", 0, 0, 0);
                /**
          * sets the current line width, in pixels, when drawing stroke
          * @public
          * @type Number
          * @default 1
          * @name me.Text#lineWidth
          */ this.lineWidth = settings.lineWidth || 1;
                /**
          * Set the default text alignment (or justification),<br>
          * possible values are "left", "right", and "center".<br>
          * @public
          * @type String
          * @default "left"
          * @name me.Text#textAlign
          */ this.textAlign = settings.textAlign || "left";
                /**
          * Set the text baseline (e.g. the Y-coordinate for the draw operation), <br>
          * possible values are "top", "hanging, "middle, "alphabetic, "ideographic, "bottom"<br>
          * @public
          * @type String
          * @default "top"
          * @name me.Text#textBaseline
          */ this.textBaseline = settings.textBaseline || "top";
                /**
          * Set the line spacing height (when displaying multi-line strings). <br>
          * Current font height will be multiplied with this value to set the line height.
          * @public
          * @type Number
          * @default 1.0
          * @name me.Text#lineHeight
          */ this.lineHeight = settings.lineHeight || 1;
                /**
          * the text to be displayed
          * @private
          * @type {String[]}
          * @name _text
          * @memberOf me.Text
          */ this._text = [];
                /**
          * the font size (in px)
          * @public
          * @type {Number}
          * @name fontSize
          * @default 10
          * @memberOf me.Text
         */ this.fontSize = 10; // anchor point
                if (typeof settings.anchorPoint !== "undefined") this.anchorPoint.setV(settings.anchorPoint);
                else this.anchorPoint.set(0, 0);
                 // if floating was specified through settings
                if (typeof settings.floating !== "undefined") this.floating = !!settings.floating;
                 // font name and type
                this.setFont(settings.font, settings.size); // aditional
                if (settings.bold === true) this.bold();
                if (settings.italic === true) this.italic();
                 // set the text
                this.setText(settings.text);
            },
            /**
        * make the font bold
        * @name bold
        * @memberOf me.Text.prototype
        * @function
        * @return this object for chaining
        */ bold: function bold() {
                this.font = "bold " + this.font;
                this.isDirty = true;
                return this;
            },
            /**
        * make the font italic
        * @name italic
        * @memberOf me.Text.prototype
        * @function
        * @return this object for chaining
        */ italic: function italic() {
                this.font = "italic " + this.font;
                this.isDirty = true;
                return this;
            },
            /**
        * set the font family and size
        * @name setFont
        * @memberOf me.Text.prototype
        * @function
        * @param {String} font a CSS font name
        * @param {Number|String} [size=10] size in px, or size + suffix (px, em, pt)
        * @return this object for chaining
        * @example
        * font.setFont("Arial", 20);
        * font.setFont("Arial", "1.5em");
        */ setFont: function setFont(font, size) {
                // font name and type
                var font_names = font.split(",").map(function(value) {
                    value = value.trim();
                    return !/(^".*"$)|(^'.*'$)/.test(value) ? "\"" + value + "\"" : value;
                }); // font size
                if (typeof size === "number") {
                    this.fontSize = size;
                    size += "px";
                } else /* string */ {
                    // extract the units and convert if necessary
                    var CSSval = size.match(/([-+]?[\d.]*)(.*)/);
                    this.fontSize = parseFloat(CSSval[1]);
                    if (CSSval[2]) this.fontSize *= toPX[runits.indexOf(CSSval[2])];
                    else // no unit define, assume px
                    size += "px";
                }
                this.height = this.fontSize;
                this.font = size + " " + font_names.join(",");
                this.isDirty = true;
                return this;
            },
            /**
        * change the text to be displayed
        * @name setText
        * @memberOf me.Text.prototype
        * @function
        * @param {Number|String|String[]} value a string, or an array of strings
        * @return this object for chaining
        */ setText: function setText(value) {
                if (typeof value === "undefined") value = "";
                if (this._text.toString() !== value.toString()) {
                    if (!Array.isArray(value)) this._text = ("" + value).split("\n");
                    else this._text = value;
                    this.isDirty = true;
                }
                return this;
            },
            /**
        * measure the given text size in pixels
        * @name measureText
        * @memberOf me.Text.prototype
        * @function
        * @param {me.CanvasRenderer|me.WebGLRenderer} [renderer] reference a renderer instance
        * @param {String} [text] the text to be measured
        * @param {me.Rect} [ret] a object in which to store the text metrics
        * @returns {TextMetrics} a TextMetrics object with two properties: `width` and `height`, defining the output dimensions
        */ measureText: function measureText(renderer, text, ret) {
                var context;
                if (typeof renderer === "undefined") context = me.video.renderer.getFontContext();
                else if (renderer instanceof me.Renderer) context = renderer.getFontContext();
                else // else it's a 2d rendering context object
                context = renderer;
                var textMetrics = ret || this.getBounds();
                var lineHeight = this.fontSize * this.lineHeight;
                var strings = typeof text !== "undefined" ? ("" + text).split("\n") : this._text; // save the previous context
                context.save(); // apply the style font
                setContextStyle(context, this); // compute the bounding box size
                this.height = this.width = 0;
                for(var i = 0; i < strings.length; i++){
                    this.width = Math.max(context.measureText(me.utils.string.trimRight("" + strings[i])).width, this.width);
                    this.height += lineHeight;
                }
                textMetrics.width = Math.ceil(this.width);
                textMetrics.height = Math.ceil(this.height); // compute the bounding box position
                textMetrics.pos.x = Math.floor(this.textAlign === "right" ? this.pos.x - this.width : this.textAlign === "center" ? this.pos.x - this.width / 2 : this.pos.x);
                textMetrics.pos.y = Math.floor(this.textBaseline.search(/^(top|hanging)$/) === 0 ? this.pos.y : this.textBaseline === "middle" ? this.pos.y - textMetrics.height / 2 : this.pos.y - textMetrics.height); // restore the context
                context.restore(); // returns the Font bounds me.Rect by default
                return textMetrics;
            },
            /**
        * @ignore
        */ update: function update() /* dt */ {
                if (this.isDirty === true) this.measureText();
                return this.isDirty;
            },
            /**
        * draw a text at the specified coord
        * @name draw
        * @memberOf me.Text.prototype
        * @function
        * @param {me.CanvasRenderer|me.WebGLRenderer} renderer Reference to the destination renderer instance
        * @param {String} [text]
        * @param {Number} [x]
        * @param {Number} [y]
        */ draw: function draw(renderer, text, x, y, stroke) {
                // "hacky patch" for backward compatibilty
                if (typeof this.ancestor === "undefined") {
                    // update text cache
                    this.setText(text); // update position if changed
                    if (this.pos.x !== x || this.pos.y !== y) {
                        this.pos.x = x;
                        this.pos.y = y;
                        this.isDirty = true;
                    } // force update bounds
                    this.update(0); // save the previous context
                    renderer.save(); // apply the defined alpha value
                    renderer.setGlobalAlpha(renderer.globalAlpha() * this.getOpacity());
                } else {
                    // added directly to an object container
                    x = this.pos.x;
                    y = this.pos.y;
                }
                if (renderer.settings.subPixel === false) {
                    // clamp to pixel grid if required
                    x = ~~x;
                    y = ~~y;
                } // draw the text
                renderer.drawFont(this._drawFont(renderer.getFontContext(), this._text, x, y, stroke || false)); // for backward compatibilty
                if (typeof this.ancestor === "undefined") // restore previous context
                renderer.restore();
                 // clear the dirty flag here for
                // backward compatibility 
                this.isDirty = false;
            },
            /**
        * draw a stroke text at the specified coord, as defined <br>
        * by the `lineWidth` and `fillStroke` properties. <br>
        * Note : using drawStroke is not recommended for performance reasons
        * @name drawStroke
        * @memberOf me.Text.prototype
        * @function
        * @param {me.CanvasRenderer|me.WebGLRenderer} renderer Reference to the destination renderer instance
        * @param {String} text
        * @param {Number} x
        * @param {Number} y
        */ drawStroke: function drawStroke(renderer, text, x, y) {
                this.draw.call(this, renderer, text, x, y, true);
            },
            /**
        * @ignore
        */ _drawFont: function _drawFont(context, text, x, y, stroke) {
                setContextStyle(context, this, stroke);
                var lineHeight = this.fontSize * this.lineHeight;
                for(var i = 0; i < text.length; i++){
                    var string = me.utils.string.trimRight("" + text[i]); // draw the string
                    context[stroke ? "strokeText" : "fillText"](string, x, y); // add leading space
                    y += lineHeight;
                }
                return this.getBounds();
            },
            /**
        * Destroy function
        * @ignore
        */ destroy: function destroy() {
                me.pool.push(this.fillStyle);
                me.pool.push(this.strokeStyle);
                this.fillStyle = this.strokeStyle = undefined;
                this._text.length = 0;
                this._super(me.Renderable, "destroy");
            }
        });
    })();
    (function() {
        /**
      * Measures the width of a single line of text, does not account for \n
      * @ignore
      */ var measureTextWidth = function measureTextWidth1(font, text) {
            var characters = text.split("");
            var width = 0;
            var lastGlyph = null;
            for(var i = 0; i < characters.length; i++){
                var ch = characters[i].charCodeAt(0);
                var glyph = font.fontData.glyphs[ch];
                var kerning = lastGlyph && lastGlyph.kerning ? lastGlyph.getKerning(ch) : 0;
                width += (glyph.xadvance + kerning) * font.fontScale.x;
                lastGlyph = glyph;
            }
            return width;
        };
        /**
      * Measures the height of a single line of text, does not account for \n
      * @ignore
      */ var measureTextHeight = function measureTextHeight1(font) {
            return font.fontData.capHeight * font.lineHeight * font.fontScale.y;
        };
        /**
      * a bitmap font object
      * @class
      * @extends me.Renderable
      * @memberOf me
      * @constructor
      * @param {Number} [scale=1.0]
      * @param {Object} settings the text configuration
      * @param {String|Image} settings.font a font name to identify the corresponing source image
      * @param {String} [settings.fontData=settings.font] the bitmap font data corresponding name, or the bitmap font data itself
      * @param {Number} [settings.size] size a scaling ratio
      * @param {me.Color|String} [settings.fillStyle] a CSS color value used to tint the bitmapText (@see me.BitmapText.tint)
      * @param {Number} [settings.lineWidth=1] line width, in pixels, when drawing stroke
      * @param {String} [settings.textAlign="left"] horizontal text alignment
      * @param {String} [settings.textBaseline="top"] the text baseline
      * @param {Number} [settings.lineHeight=1.0] line spacing height
      * @param {me.Vector2d} [settings.anchorPoint={x:0.0, y:0.0}] anchor point to draw the text at
      * @param {(String|String[])} [settings.text] a string, or an array of strings
      * @example
      * // Use me.loader.preload or me.loader.load to load assets
      * me.loader.preload([
      *     { name: "arial", type: "binary" src: "data/font/arial.fnt" },
      *     { name: "arial", type: "image" src: "data/font/arial.png" },
      * ])
      * // Then create an instance of your bitmap font:
      * var myFont = new me.BitmapText(x, y, {font:"arial", text:"Hello"});
      * // two possibilities for using "myFont"
      * // either call the draw function from your Renderable draw function
      * myFont.draw(renderer, "Hello!", 0, 0);
      * // or just add it to the word container
      * me.game.world.addChild(myFont);
      */ me.BitmapText = me.Renderable.extend({
            /** @ignore */ init: function init(x, y, settings) {
                // call the parent constructor
                this._super(me.Renderable, "init", [
                    x,
                    y,
                    settings.width || 0,
                    settings.height || 0
                ]);
                /**
          * Set the default text alignment (or justification),<br>
          * possible values are "left", "right", and "center".
          * @public
          * @type String
          * @default "left"
          * @name textAlign
          * @memberOf me.BitmapText
          */ this.textAlign = settings.textAlign || "left";
                /**
          * Set the text baseline (e.g. the Y-coordinate for the draw operation), <br>
          * possible values are "top", "hanging, "middle, "alphabetic, "ideographic, "bottom"<br>
          * @public
          * @type String
          * @default "top"
          * @name textBaseline
          * @memberOf me.BitmapText
          */ this.textBaseline = settings.textBaseline || "top";
                /**
          * Set the line spacing height (when displaying multi-line strings). <br>
          * Current font height will be multiplied with this value to set the line height.
          * @public
          * @type Number
          * @default 1.0
          * @name lineHeight
          * @memberOf me.BitmapText
          */ this.lineHeight = settings.lineHeight || 1;
                /**
          * the text to be displayed
          * @private
          * @type {String[]}
          * @name _text
          * @memberOf me.BitmapText
          */ this._text = [];
                /** @ignore */ // scaled font size;
                this.fontScale = me.pool.pull("me.Vector2d", 1, 1); // get the corresponding image
                this.fontImage = _typeof(settings.font) === "object" ? settings.font : me.loader.getImage(settings.font);
                if (typeof settings.fontData !== "string") // use settings.font to retreive the data from the loader
                this.fontData = me.pool.pull("me.BitmapTextData", me.loader.getBinary(settings.font));
                else this.fontData = me.pool.pull("me.BitmapTextData", settings.fontData.includes("info face") ? settings.fontData : me.loader.getBinary(settings.fontData));
                if (typeof settings.floating !== "undefined") this.floating = !!settings.floating;
                 // resize if necessary
                if (typeof settings.size === "number" && settings.size !== 1) this.resize(settings.size);
                 // apply given fillstyle
                if (typeof settings.fillStyle !== "undefined") {
                    if (settings.fillStyle instanceof me.Color) this.fillStyle.setColor(settings.fillStyle);
                    else // string (#RGB, #ARGB, #RRGGBB, #AARRGGBB)
                    this.fillStyle.parseCSS(settings.fillStyle);
                } // update anchorPoint if provided
                if (typeof settings.anchorPoint !== "undefined") this.anchorPoint.set(settings.anchorPoint.x, settings.anchorPoint.y);
                else this.anchorPoint.set(0, 0);
                 // set the text
                this.setText(settings.text);
            },
            /**
        * change the font settings
        * @name set
        * @memberOf me.BitmapText.prototype
        * @function
        * @param {String} textAlign ("left", "center", "right")
        * @param {Number} [scale]
        * @return this object for chaining
        */ set: function set(textAlign, scale) {
                this.textAlign = textAlign; // updated scaled Size
                if (scale) this.resize(scale);
                this.isDirty = true;
                return this;
            },
            /**
        * change the text to be displayed
        * @name setText
        * @memberOf me.BitmapText.prototype
        * @function
        * @param {Number|String|String[]} value a string, or an array of strings
        * @return this object for chaining
        */ setText: function setText(value) {
                if (typeof value === "undefined") value = "";
                if (this._text.toString() !== value.toString()) {
                    if (!Array.isArray(value)) this._text = ("" + value).split("\n");
                    else this._text = value;
                    this.isDirty = true;
                }
                return this;
            },
            /**
        * change the font display size
        * @name resize
        * @memberOf me.BitmapText.prototype
        * @function
        * @param {Number} scale ratio
        * @return this object for chaining
        */ resize: function resize(scale) {
                this.fontScale.set(scale, scale); // clear the cache text to recalculate bounds
                this.isDirty = true;
                return this;
            },
            /**
        * measure the given text size in pixels
        * @name measureText
        * @memberOf me.BitmapText.prototype
        * @function
        * @param {String} [text]
        * @param {me.Rect} [ret] a object in which to store the text metrics
        * @returns {TextMetrics} a TextMetrics object with two properties: `width` and `height`, defining the output dimensions
        */ measureText: function measureText(text, ret) {
                text = text || this._text;
                var stringHeight = measureTextHeight(this);
                var textMetrics = ret || this.getBounds();
                var strings = typeof text === "string" ? ("" + text).split("\n") : text;
                textMetrics.height = textMetrics.width = 0;
                for(var i = 0; i < strings.length; i++){
                    textMetrics.width = Math.max(measureTextWidth(this, strings[i]), textMetrics.width);
                    textMetrics.height += stringHeight;
                }
                return textMetrics;
            },
            /**
        * @ignore
        */ update: function update() /* dt */ {
                if (this.isDirty === true) this.measureText();
                return this.isDirty;
            },
            /**
        * draw the bitmap font
        * @name draw
        * @memberOf me.BitmapText.prototype
        * @function
        * @param {me.CanvasRenderer|me.WebGLRenderer} renderer Reference to the destination renderer instance
        * @param {String} [text]
        * @param {Number} [x]
        * @param {Number} [y]
        */ draw: function draw(renderer, text, x, y) {
                // save the previous global alpha value
                var _alpha = renderer.globalAlpha(); // allows to provide backward compatibility when
                // adding Bitmap Font to an object container
                if (typeof this.ancestor === "undefined") {
                    // update cache
                    this.setText(text); // force update bounds
                    this.update(0);
                    renderer.setGlobalAlpha(_alpha * this.getOpacity());
                } else {
                    // added directly to an object container
                    x = this.pos.x;
                    y = this.pos.y;
                }
                var lX = x;
                var stringHeight = measureTextHeight(this);
                var maxWidth = 0;
                for(var i = 0; i < this._text.length; i++){
                    x = lX;
                    var string = me.utils.string.trimRight(this._text[i]); // adjust x pos based on alignment value
                    var stringWidth = measureTextWidth(this, string);
                    switch(this.textAlign){
                        case "right":
                            x -= stringWidth;
                            break;
                        case "center":
                            x -= stringWidth * 0.5;
                            break;
                    } // adjust y pos based on alignment value
                    switch(this.textBaseline){
                        case "middle":
                            y -= stringHeight * 0.5;
                            break;
                        case "ideographic":
                        case "alphabetic":
                        case "bottom":
                            y -= stringHeight;
                            break;
                    } // update initial position if required
                    if (this.isDirty === true && typeof this.ancestor === "undefined") {
                        if (i === 0) this.pos.y = y;
                        if (maxWidth < stringWidth) {
                            maxWidth = stringWidth;
                            this.pos.x = x;
                        }
                    } // draw the string
                    var lastGlyph = null;
                    for(var c = 0, len = string.length; c < len; c++){
                        // calculate the char index
                        var ch = string.charCodeAt(c);
                        var glyph = this.fontData.glyphs[ch];
                        var glyphWidth = glyph.width;
                        var glyphHeight = glyph.height;
                        var kerning = lastGlyph && lastGlyph.kerning ? lastGlyph.getKerning(ch) : 0; // draw it
                        if (glyphWidth !== 0 && glyphHeight !== 0) // some browser throw an exception when drawing a 0 width or height image
                        renderer.drawImage(this.fontImage, glyph.x, glyph.y, glyphWidth, glyphHeight, x + glyph.xoffset, y + glyph.yoffset * this.fontScale.y, glyphWidth * this.fontScale.x, glyphHeight * this.fontScale.y);
                         // increment position
                        x += (glyph.xadvance + kerning) * this.fontScale.x;
                        lastGlyph = glyph;
                    } // increment line
                    y += stringHeight;
                }
                if (typeof this.ancestor === "undefined") // restore the previous global alpha value
                renderer.setGlobalAlpha(_alpha);
                 // clear the dirty flag here for
                // backward compatibility
                this.isDirty = false;
            },
            /**
        * Destroy function
        * @ignore
        */ destroy: function destroy() {
                me.pool.push(this.fontScale);
                this.fontScale = undefined;
                me.pool.push(this.fontData);
                this.fontData = undefined;
                this._text.length = 0;
                this._super(me.Renderable, "destroy");
            }
        });
        /**
      * defines the color used to tint the bitmap text
      * @public
      * @type {me.Color}
      * @name fillStyle
      * @see me.Renderable#tint
      * @memberOf me.BitmapText
      */ Object.defineProperty(me.BitmapText.prototype, "fillStyle", {
            /**
        * @ignore
        */ get: function get() {
                return this.tint;
            },
            /**
        * @ignore
        */ set: function set(value) {
                this.tint = value;
            },
            configurable: true
        });
    })();
    (function() {
        // bitmap constants
        var LOG2_PAGE_SIZE = 9;
        var PAGE_SIZE = 1 << LOG2_PAGE_SIZE;
        var capChars = [
            "M",
            "N",
            "B",
            "D",
            "C",
            "E",
            "F",
            "K",
            "A",
            "G",
            "H",
            "I",
            "J",
            "L",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z"
        ];
        /**
      * a glyph representing a single character in a font
      */ var Glyph = me.Object.extend({
            /**
        * @ignore
        */ init: function init() {
                this.id = 0;
                this.x = 0;
                this.y = 0;
                this.width = 0;
                this.height = 0;
                this.u = 0;
                this.v = 0;
                this.u2 = 0;
                this.v2 = 0;
                this.xoffset = 0;
                this.yoffset = 0;
                this.xadvance = 0;
                this.fixedWidth = false;
            },
            /**
        * @ignore
        */ getKerning: function getKerning(ch) {
                if (this.kerning) {
                    var page = this.kerning[ch >>> LOG2_PAGE_SIZE];
                    if (page) return page[ch & PAGE_SIZE - 1] || 0;
                }
                return 0;
            },
            /**
        * @ignore
        */ setKerning: function setKerning(ch, value) {
                if (!this.kerning) this.kerning = {
                };
                var page = this.kerning[ch >>> LOG2_PAGE_SIZE];
                if (typeof page === "undefined") {
                    this.kerning[ch >>> LOG2_PAGE_SIZE] = {
                    };
                    page = this.kerning[ch >>> LOG2_PAGE_SIZE];
                }
                page[ch & PAGE_SIZE - 1] = value;
            }
        });
        /**
      * Class for storing relevant data from the font file.
      * @class me.BitmapTextData
      * @memberOf me
      * @param data {String} - The bitmap font data pulled from the resource loader using me.loader.getBinary()
      * @constructor
      */ me.BitmapTextData = me.Object.extend({
            /**
        * @ignore
        */ init: function init(data) {
                this.padTop = 0;
                this.padRight = 0;
                this.padBottom = 0;
                this.padLeft = 0;
                this.lineHeight = 0; // The distance from the top of most uppercase characters to the baseline. Since the drawing position is the cap height of
                // the first line, the cap height can be used to get the location of the baseline.
                this.capHeight = 1; // The distance from the bottom of the glyph that extends the lowest to the baseline. This number is negative.
                this.descent = 0;
                /**
          * The map of glyphs, each key is a char code.
          * @name glyphs
          * @type {Object}
          * @memberOf me.BitmapTextData
          */ this.glyphs = {
                }; // parse the data
                this.parse(data);
            },
            /**
        * Creates a glyph to use for the space character
        * @private
        * @name _createSpaceGlyph
        * @memberOf me.BitmapTextData
        * @function
        */ _createSpaceGlyph: function _createSpaceGlyph() {
                var spaceCharCode = " ".charCodeAt(0);
                var glyph = this.glyphs[spaceCharCode];
                if (!glyph) {
                    glyph = new Glyph();
                    glyph.id = spaceCharCode;
                    glyph.xadvance = this._getFirstGlyph().xadvance;
                    this.glyphs[spaceCharCode] = glyph;
                }
            },
            /**
        * Gets the first glyph in the map that is not a space character
        * @private
        * @name _getFirstGlyph
        * @memberOf me.BitmapTextData
        * @function
        * @returns {me.Glyph}
        */ _getFirstGlyph: function _getFirstGlyph() {
                var keys = Object.keys(this.glyphs);
                for(var i = 0; i < keys.length; i++){
                    if (keys[i] > 32) return this.glyphs[keys[i]];
                }
                return null;
            },
            /**
        * Gets the value from a string of pairs. For example: one=1 two=2 something=hi. Can accept the regex of /one={d}/
        * and returns the value of d
        * @private
        * @name _getValueFromPair
        * @memberOf me.BitmapTextData
        * @function
        * @returns {String}
        */ _getValueFromPair: function _getValueFromPair(string, pattern) {
                var value = string.match(pattern);
                if (!value) throw new Error("Could not find pattern " + pattern + " in string: " + string);
                return value[0].split("=")[1];
            },
            /**
        * This parses the font data text and builds a map of glyphs containing the data for each character
        * @name parse
        * @memberOf me.BitmapTextData
        * @function
        * @param {String} fontData
        */ parse: function parse(fontData) {
                if (!fontData) throw new Error("File containing font data was empty, cannot load the bitmap font.");
                var lines = fontData.split(/\r\n|\n/);
                var padding = fontData.match(/padding\=\d+,\d+,\d+,\d+/g);
                if (!padding) throw new Error("Padding not found in first line");
                var paddingValues = padding[0].split("=")[1].split(",");
                this.padTop = parseFloat(paddingValues[0]);
                this.padLeft = parseFloat(paddingValues[1]);
                this.padBottom = parseFloat(paddingValues[2]);
                this.padRight = parseFloat(paddingValues[3]);
                this.lineHeight = parseFloat(this._getValueFromPair(lines[1], /lineHeight\=\d+/g));
                var baseLine = parseFloat(this._getValueFromPair(lines[1], /base\=\d+/g));
                var padY = this.padTop + this.padBottom;
                var glyph = null;
                var i;
                for(i = 4; i < lines.length; i++){
                    var line = lines[i];
                    var characterValues = line.split(/=|\s+/);
                    if (!line || /^kernings/.test(line)) continue;
                    if (/^kerning\s/.test(line)) {
                        var first = parseFloat(characterValues[2]);
                        var second = parseFloat(characterValues[4]);
                        var amount = parseFloat(characterValues[6]);
                        glyph = this.glyphs[first];
                        if (glyph !== null && typeof glyph !== "undefined") glyph.setKerning(second, amount);
                    } else {
                        glyph = new Glyph();
                        var ch = parseFloat(characterValues[2]);
                        glyph.id = ch;
                        glyph.x = parseFloat(characterValues[4]);
                        glyph.y = parseFloat(characterValues[6]);
                        glyph.width = parseFloat(characterValues[8]);
                        glyph.height = parseFloat(characterValues[10]);
                        glyph.xoffset = parseFloat(characterValues[12]);
                        glyph.yoffset = parseFloat(characterValues[14]);
                        glyph.xadvance = parseFloat(characterValues[16]);
                        if (glyph.width > 0 && glyph.height > 0) this.descent = Math.min(baseLine + glyph.yoffset, this.descent);
                        this.glyphs[ch] = glyph;
                    }
                }
                this.descent += this.padBottom;
                this._createSpaceGlyph();
                var capGlyph = null;
                for(i = 0; i < capChars.length; i++){
                    var capChar = capChars[i];
                    capGlyph = this.glyphs[capChar.charCodeAt(0)];
                    if (capGlyph) break;
                }
                if (!capGlyph) {
                    for(var charCode in this.glyphs)if (this.glyphs.hasOwnProperty(charCode)) {
                        glyph = this.glyphs[charCode];
                        if (glyph.height === 0 || glyph.width === 0) continue;
                        this.capHeight = Math.max(this.capHeight, glyph.height);
                    }
                } else this.capHeight = capGlyph.height;
                this.capHeight -= padY;
            }
        });
    })();
    var howler = createCommonjsModule(function(module, exports) {
        /*!
    *  howler.js v2.2.0
    *  howlerjs.com
    *
    *  (c) 2013-2020, James Simpson of GoldFire Studios
    *  goldfirestudios.com
    *
    *  MIT License
    */ (function() {
            /** Global Methods **/ /***************************************************************************/ /**
      * Create the global controller. All contained methods and properties apply
      * to all sounds that are currently playing or will be in the future.
      */ var HowlerGlobal = function() {
                this.init();
            };
            HowlerGlobal.prototype = {
                /**
        * Initialize the global Howler object.
        * @return {Howler}
        */ init: function() {
                    var self = this || Howler;
                    // Create a global ID counter.
                    self._counter = 1000;
                    // Pool of unlocked HTML5 Audio objects.
                    self._html5AudioPool = [];
                    self.html5PoolSize = 10;
                    // Internal properties.
                    self._codecs = {
                    };
                    self._howls = [];
                    self._muted = false;
                    self._volume = 1;
                    self._canPlayEvent = 'canplaythrough';
                    self._navigator = typeof window !== 'undefined' && window.navigator ? window.navigator : null;
                    // Public properties.
                    self.masterGain = null;
                    self.noAudio = false;
                    self.usingWebAudio = true;
                    self.autoSuspend = true;
                    self.ctx = null;
                    // Set to false to disable the auto audio unlocker.
                    self.autoUnlock = true;
                    // Setup the various state values for global tracking.
                    self._setup();
                    return self;
                },
                /**
        * Get/set the global volume for all sounds.
        * @param  {Float} vol Volume from 0.0 to 1.0.
        * @return {Howler/Float}     Returns self or current volume.
        */ volume: function(vol) {
                    var self = this || Howler;
                    vol = parseFloat(vol);
                    // If we don't have an AudioContext created yet, run the setup.
                    if (!self.ctx) setupAudioContext();
                    if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
                        self._volume = vol;
                        // Don't update any of the nodes if we are muted.
                        if (self._muted) return self;
                        // When using Web Audio, we just need to adjust the master gain.
                        if (self.usingWebAudio) self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
                        // Loop through and change volume for all HTML5 audio nodes.
                        for(var i = 0; i < self._howls.length; i++)if (!self._howls[i]._webAudio) {
                            // Get all of the sounds in this Howl group.
                            var ids = self._howls[i]._getSoundIds();
                            // Loop through all sounds and change the volumes.
                            for(var j = 0; j < ids.length; j++){
                                var sound = self._howls[i]._soundById(ids[j]);
                                if (sound && sound._node) sound._node.volume = sound._volume * vol;
                            }
                        }
                        return self;
                    }
                    return self._volume;
                },
                /**
        * Handle muting and unmuting globally.
        * @param  {Boolean} muted Is muted or not.
        */ mute: function(muted) {
                    var self = this || Howler;
                    // If we don't have an AudioContext created yet, run the setup.
                    if (!self.ctx) setupAudioContext();
                    self._muted = muted;
                    // With Web Audio, we just need to mute the master gain.
                    if (self.usingWebAudio) self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);
                    // Loop through and mute all HTML5 Audio nodes.
                    for(var i = 0; i < self._howls.length; i++)if (!self._howls[i]._webAudio) {
                        // Get all of the sounds in this Howl group.
                        var ids = self._howls[i]._getSoundIds();
                        // Loop through all sounds and mark the audio node as muted.
                        for(var j = 0; j < ids.length; j++){
                            var sound = self._howls[i]._soundById(ids[j]);
                            if (sound && sound._node) sound._node.muted = muted ? true : sound._muted;
                        }
                    }
                    return self;
                },
                /**
        * Handle stopping all sounds globally.
        */ stop: function() {
                    var self = this || Howler;
                    // Loop through all Howls and stop them.
                    for(var i = 0; i < self._howls.length; i++)self._howls[i].stop();
                    return self;
                },
                /**
        * Unload and destroy all currently loaded Howl objects.
        * @return {Howler}
        */ unload: function() {
                    var self = this || Howler;
                    for(var i = self._howls.length - 1; i >= 0; i--)self._howls[i].unload();
                    // Create a new AudioContext to make sure it is fully reset.
                    if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
                        self.ctx.close();
                        self.ctx = null;
                        setupAudioContext();
                    }
                    return self;
                },
                /**
        * Check for codec support of specific extension.
        * @param  {String} ext Audio file extention.
        * @return {Boolean}
        */ codecs: function(ext) {
                    return (this || Howler)._codecs[ext.replace(/^x-/, '')];
                },
                /**
        * Setup various state values for global tracking.
        * @return {Howler}
        */ _setup: function() {
                    var self = this || Howler;
                    // Keeps track of the suspend/resume state of the AudioContext.
                    self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';
                    // Automatically begin the 30-second suspend process
                    self._autoSuspend();
                    // Check if audio is available.
                    if (!self.usingWebAudio) {
                        // No audio is available on this system if noAudio is set to true.
                        if (typeof Audio !== 'undefined') try {
                            var test = new Audio();
                            // Check if the canplaythrough event is available.
                            if (typeof test.oncanplaythrough === 'undefined') self._canPlayEvent = 'canplay';
                        } catch (e) {
                            self.noAudio = true;
                        }
                        else self.noAudio = true;
                    }
                    // Test to make sure audio isn't disabled in Internet Explorer.
                    try {
                        var test = new Audio();
                        if (test.muted) self.noAudio = true;
                    } catch (e) {
                    }
                    // Check for supported codecs.
                    if (!self.noAudio) self._setupCodecs();
                    return self;
                },
                /**
        * Check for browser support for various codecs and cache the results.
        * @return {Howler}
        */ _setupCodecs: function() {
                    var self = this || Howler;
                    var audioTest = null;
                    // Must wrap in a try/catch because IE11 in server mode throws an error.
                    try {
                        audioTest = typeof Audio !== 'undefined' ? new Audio() : null;
                    } catch (err) {
                        return self;
                    }
                    if (!audioTest || typeof audioTest.canPlayType !== 'function') return self;
                    var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');
                    // Opera version <33 has mixed MP3 support, so we need to check for and block it.
                    var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\/([0-6].)/g);
                    var isOldOpera = checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33;
                    self._codecs = {
                        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
                        mpeg: !!mpegTest,
                        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
                        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
                        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
                        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
                        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
                        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
                        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
                        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
                        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
                        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
                        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
                        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
                        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
                    };
                    return self;
                },
                /**
        * Some browsers/devices will only allow audio to be played after a user interaction.
        * Attempt to automatically unlock audio on the first user interaction.
        * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
        * @return {Howler}
        */ _unlockAudio: function() {
                    var self = this || Howler;
                    // Only run this if Web Audio is supported and it hasn't already been unlocked.
                    if (self._audioUnlocked || !self.ctx) return;
                    self._audioUnlocked = false;
                    self.autoUnlock = false;
                    // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
                    // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
                    // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
                    if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
                        self._mobileUnloaded = true;
                        self.unload();
                    }
                    // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
                    // http://stackoverflow.com/questions/24119684
                    self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);
                    // Call this method on touch start to create and play a buffer,
                    // then check if the audio actually played to determine if
                    // audio has now been unlocked on iOS, Android, etc.
                    var unlock = function(e) {
                        // Create a pool of unlocked HTML5 Audio objects that can
                        // be used for playing sounds without user interaction. HTML5
                        // Audio objects must be individually unlocked, as opposed
                        // to the WebAudio API which only needs a single activation.
                        // This must occur before WebAudio setup or the source.onended
                        // event will not fire.
                        while(self._html5AudioPool.length < self.html5PoolSize)try {
                            var audioNode = new Audio();
                            // Mark this Audio object as unlocked to ensure it can get returned
                            // to the unlocked pool when released.
                            audioNode._unlocked = true;
                            // Add the audio node to the pool.
                            self._releaseHtml5Audio(audioNode);
                        } catch (e1) {
                            self.noAudio = true;
                            break;
                        }
                        // Loop through any assigned audio nodes and unlock them.
                        for(var i = 0; i < self._howls.length; i++)if (!self._howls[i]._webAudio) {
                            // Get all of the sounds in this Howl group.
                            var ids = self._howls[i]._getSoundIds();
                            // Loop through all sounds and unlock the audio nodes.
                            for(var j = 0; j < ids.length; j++){
                                var sound = self._howls[i]._soundById(ids[j]);
                                if (sound && sound._node && !sound._node._unlocked) {
                                    sound._node._unlocked = true;
                                    sound._node.load();
                                }
                            }
                        }
                        // Fix Android can not play in suspend state.
                        self._autoResume();
                        // Create an empty buffer.
                        var source = self.ctx.createBufferSource();
                        source.buffer = self._scratchBuffer;
                        source.connect(self.ctx.destination);
                        // Play the empty buffer.
                        if (typeof source.start === 'undefined') source.noteOn(0);
                        else source.start(0);
                        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
                        if (typeof self.ctx.resume === 'function') self.ctx.resume();
                        // Setup a timeout to check that we are unlocked on the next event loop.
                        source.onended = function() {
                            source.disconnect(0);
                            // Update the unlocked state and prevent this check from happening again.
                            self._audioUnlocked = true;
                            // Remove the touch start listener.
                            document.removeEventListener('touchstart', unlock, true);
                            document.removeEventListener('touchend', unlock, true);
                            document.removeEventListener('click', unlock, true);
                            // Let all sounds know that audio has been unlocked.
                            for(var i1 = 0; i1 < self._howls.length; i1++)self._howls[i1]._emit('unlock');
                        };
                    };
                    // Setup a touch start listener to attempt an unlock in.
                    document.addEventListener('touchstart', unlock, true);
                    document.addEventListener('touchend', unlock, true);
                    document.addEventListener('click', unlock, true);
                    return self;
                },
                /**
        * Get an unlocked HTML5 Audio object from the pool. If none are left,
        * return a new Audio object and throw a warning.
        * @return {Audio} HTML5 Audio object.
        */ _obtainHtml5Audio: function() {
                    var self = this || Howler;
                    // Return the next object from the pool if one exists.
                    if (self._html5AudioPool.length) return self._html5AudioPool.pop();
                    //.Check if the audio is locked and throw a warning.
                    var testPlay = new Audio().play();
                    if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) testPlay.catch(function() {
                        console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');
                    });
                    return new Audio();
                },
                /**
        * Return an activated HTML5 Audio object to the pool.
        * @return {Howler}
        */ _releaseHtml5Audio: function(audio) {
                    var self = this || Howler;
                    // Don't add audio to the pool if we don't know if it has been unlocked.
                    if (audio._unlocked) self._html5AudioPool.push(audio);
                    return self;
                },
                /**
        * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
        * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
        * @return {Howler}
        */ _autoSuspend: function() {
                    var self = this;
                    if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) return;
                    // Check if any sounds are playing.
                    for(var i = 0; i < self._howls.length; i++){
                        if (self._howls[i]._webAudio) for(var j = 0; j < self._howls[i]._sounds.length; j++){
                            if (!self._howls[i]._sounds[j]._paused) return self;
                        }
                    }
                    if (self._suspendTimer) clearTimeout(self._suspendTimer);
                    // If no sound has played after 30 seconds, suspend the context.
                    self._suspendTimer = setTimeout(function() {
                        if (!self.autoSuspend) return;
                        self._suspendTimer = null;
                        self.state = 'suspending';
                        // Handle updating the state of the audio context after suspending.
                        var handleSuspension = function() {
                            self.state = 'suspended';
                            if (self._resumeAfterSuspend) {
                                delete self._resumeAfterSuspend;
                                self._autoResume();
                            }
                        };
                        // Either the state gets suspended or it is interrupted.
                        // Either way, we need to update the state to suspended.
                        self.ctx.suspend().then(handleSuspension, handleSuspension);
                    }, 30000);
                    return self;
                },
                /**
        * Automatically resume the Web Audio AudioContext when a new sound is played.
        * @return {Howler}
        */ _autoResume: function() {
                    var self = this;
                    if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) return;
                    if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {
                        clearTimeout(self._suspendTimer);
                        self._suspendTimer = null;
                    } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {
                        self.ctx.resume().then(function() {
                            self.state = 'running';
                            // Emit to all Howls that the audio has resumed.
                            for(var i = 0; i < self._howls.length; i++)self._howls[i]._emit('resume');
                        });
                        if (self._suspendTimer) {
                            clearTimeout(self._suspendTimer);
                            self._suspendTimer = null;
                        }
                    } else if (self.state === 'suspending') self._resumeAfterSuspend = true;
                    return self;
                }
            };
            // Setup the global audio controller.
            var Howler = new HowlerGlobal();
            /** Group Methods **/ /***************************************************************************/ /**
      * Create an audio group controller.
      * @param {Object} o Passed in properties for this group.
      */ var Howl = function(o) {
                var self = this;
                // Throw an error if no source is provided.
                if (!o.src || o.src.length === 0) {
                    console.error('An array of source files must be passed with any new Howl.');
                    return;
                }
                self.init(o);
            };
            Howl.prototype = {
                /**
        * Initialize a new Howl group object.
        * @param  {Object} o Passed in properties for this group.
        * @return {Howl}
        */ init: function(o) {
                    var self = this;
                    // If we don't have an AudioContext created yet, run the setup.
                    if (!Howler.ctx) setupAudioContext();
                    // Setup user-defined default properties.
                    self._autoplay = o.autoplay || false;
                    self._format = typeof o.format !== 'string' ? o.format : [
                        o.format
                    ];
                    self._html5 = o.html5 || false;
                    self._muted = o.mute || false;
                    self._loop = o.loop || false;
                    self._pool = o.pool || 5;
                    self._preload = typeof o.preload === 'boolean' || o.preload === 'metadata' ? o.preload : true;
                    self._rate = o.rate || 1;
                    self._sprite = o.sprite || {
                    };
                    self._src = typeof o.src !== 'string' ? o.src : [
                        o.src
                    ];
                    self._volume = o.volume !== undefined ? o.volume : 1;
                    self._xhr = {
                        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',
                        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
                        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false
                    };
                    // Setup all other default properties.
                    self._duration = 0;
                    self._state = 'unloaded';
                    self._sounds = [];
                    self._endTimers = {
                    };
                    self._queue = [];
                    self._playLock = false;
                    // Setup event listeners.
                    self._onend = o.onend ? [
                        {
                            fn: o.onend
                        }
                    ] : [];
                    self._onfade = o.onfade ? [
                        {
                            fn: o.onfade
                        }
                    ] : [];
                    self._onload = o.onload ? [
                        {
                            fn: o.onload
                        }
                    ] : [];
                    self._onloaderror = o.onloaderror ? [
                        {
                            fn: o.onloaderror
                        }
                    ] : [];
                    self._onplayerror = o.onplayerror ? [
                        {
                            fn: o.onplayerror
                        }
                    ] : [];
                    self._onpause = o.onpause ? [
                        {
                            fn: o.onpause
                        }
                    ] : [];
                    self._onplay = o.onplay ? [
                        {
                            fn: o.onplay
                        }
                    ] : [];
                    self._onstop = o.onstop ? [
                        {
                            fn: o.onstop
                        }
                    ] : [];
                    self._onmute = o.onmute ? [
                        {
                            fn: o.onmute
                        }
                    ] : [];
                    self._onvolume = o.onvolume ? [
                        {
                            fn: o.onvolume
                        }
                    ] : [];
                    self._onrate = o.onrate ? [
                        {
                            fn: o.onrate
                        }
                    ] : [];
                    self._onseek = o.onseek ? [
                        {
                            fn: o.onseek
                        }
                    ] : [];
                    self._onunlock = o.onunlock ? [
                        {
                            fn: o.onunlock
                        }
                    ] : [];
                    self._onresume = [];
                    // Web Audio or HTML5 Audio?
                    self._webAudio = Howler.usingWebAudio && !self._html5;
                    // Automatically try to enable audio.
                    if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) Howler._unlockAudio();
                    // Keep track of this Howl group in the global controller.
                    Howler._howls.push(self);
                    // If they selected autoplay, add a play event to the load queue.
                    if (self._autoplay) self._queue.push({
                        event: 'play',
                        action: function() {
                            self.play();
                        }
                    });
                    // Load the source file unless otherwise specified.
                    if (self._preload && self._preload !== 'none') self.load();
                    return self;
                },
                /**
        * Load the audio file.
        * @return {Howler}
        */ load: function() {
                    var self = this;
                    var url = null;
                    // If no audio is available, quit immediately.
                    if (Howler.noAudio) {
                        self._emit('loaderror', null, 'No audio support.');
                        return;
                    }
                    // Make sure our source is in an array.
                    if (typeof self._src === 'string') self._src = [
                        self._src
                    ];
                    // Loop through the sources and pick the first one that is compatible.
                    for(var i = 0; i < self._src.length; i++){
                        var ext, str;
                        if (self._format && self._format[i]) // If an extension was specified, use that instead.
                        ext = self._format[i];
                        else {
                            // Make sure the source is a string.
                            str = self._src[i];
                            if (typeof str !== 'string') {
                                self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
                                continue;
                            }
                            // Extract the file extension from the URL or base64 data URI.
                            ext = /^data:audio\/([^;,]+);/i.exec(str);
                            if (!ext) ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
                            if (ext) ext = ext[1].toLowerCase();
                        }
                        // Log a warning if no extension was found.
                        if (!ext) console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
                        // Check if this extension is available.
                        if (ext && Howler.codecs(ext)) {
                            url = self._src[i];
                            break;
                        }
                    }
                    if (!url) {
                        self._emit('loaderror', null, 'No codec support for selected audio sources.');
                        return;
                    }
                    self._src = url;
                    self._state = 'loading';
                    // If the hosting page is HTTPS and the source isn't,
                    // drop down to HTML5 Audio to avoid Mixed Content errors.
                    if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
                        self._html5 = true;
                        self._webAudio = false;
                    }
                    // Create a new sound object and add it to the pool.
                    new Sound(self);
                    // Load and decode the audio data for playback.
                    if (self._webAudio) loadBuffer(self);
                    return self;
                },
                /**
        * Play a sound or resume previous playback.
        * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
        * @param  {Boolean} internal Internal Use: true prevents event firing.
        * @return {Number}          Sound ID.
        */ play: function(sprite, internal) {
                    var self = this;
                    var id = null;
                    // Determine if a sprite, sound id or nothing was passed
                    if (typeof sprite === 'number') {
                        id = sprite;
                        sprite = null;
                    } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) // If the passed sprite doesn't exist, do nothing.
                    return null;
                    else if (typeof sprite === 'undefined') {
                        // Use the default sound sprite (plays the full audio length).
                        sprite = '__default';
                        // Check if there is a single paused sound that isn't ended.
                        // If there is, play that sound. If not, continue as usual.
                        if (!self._playLock) {
                            var num = 0;
                            for(var i = 0; i < self._sounds.length; i++)if (self._sounds[i]._paused && !self._sounds[i]._ended) {
                                num++;
                                id = self._sounds[i]._id;
                            }
                            if (num === 1) sprite = null;
                            else id = null;
                        }
                    }
                    // Get the selected node, or get one from the pool.
                    var sound = id ? self._soundById(id) : self._inactiveSound();
                    // If the sound doesn't exist, do nothing.
                    if (!sound) return null;
                    // Select the sprite definition.
                    if (id && !sprite) sprite = sound._sprite || '__default';
                    // If the sound hasn't loaded, we must wait to get the audio's duration.
                    // We also need to wait to make sure we don't run into race conditions with
                    // the order of function calls.
                    if (self._state !== 'loaded') {
                        // Set the sprite value on this sound.
                        sound._sprite = sprite;
                        // Mark this sound as not ended in case another sound is played before this one loads.
                        sound._ended = false;
                        // Add the sound to the queue to be played on load.
                        var soundId = sound._id;
                        self._queue.push({
                            event: 'play',
                            action: function() {
                                self.play(soundId);
                            }
                        });
                        return soundId;
                    }
                    // Don't play the sound if an id was passed and it is already playing.
                    if (id && !sound._paused) {
                        // Trigger the play event, in order to keep iterating through queue.
                        if (!internal) self._loadQueue('play');
                        return sound._id;
                    }
                    // Make sure the AudioContext isn't suspended, and resume it if it is.
                    if (self._webAudio) Howler._autoResume();
                    // Determine how long to play for and where to start playing.
                    var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
                    var duration = Math.max(0, (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000 - seek);
                    var timeout = duration * 1000 / Math.abs(sound._rate);
                    var start = self._sprite[sprite][0] / 1000;
                    var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
                    sound._sprite = sprite;
                    // Mark the sound as ended instantly so that this async playback
                    // doesn't get grabbed by another call to play while this one waits to start.
                    sound._ended = false;
                    // Update the parameters of the sound.
                    var setParams = function() {
                        sound._paused = false;
                        sound._seek = seek;
                        sound._start = start;
                        sound._stop = stop;
                        sound._loop = !!(sound._loop || self._sprite[sprite][2]);
                    };
                    // End the sound instantly if seek is at the end.
                    if (seek >= stop) {
                        self._ended(sound);
                        return;
                    }
                    // Begin the actual playback.
                    var node = sound._node;
                    if (self._webAudio) {
                        // Fire this when the sound is ready to play to begin Web Audio playback.
                        var playWebAudio = function() {
                            self._playLock = false;
                            setParams();
                            self._refreshBuffer(sound);
                            // Setup the playback params.
                            var vol = sound._muted || self._muted ? 0 : sound._volume;
                            node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
                            sound._playStart = Howler.ctx.currentTime;
                            // Play the sound using the supported method.
                            if (typeof node.bufferSource.start === 'undefined') sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
                            else sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
                            // Start a new timer if none is present.
                            if (timeout !== Infinity) self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
                            if (!internal) setTimeout(function() {
                                self._emit('play', sound._id);
                                self._loadQueue();
                            }, 0);
                        };
                        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') playWebAudio();
                        else {
                            self._playLock = true;
                            // Wait for the audio context to resume before playing.
                            self.once('resume', playWebAudio);
                            // Cancel the end timer.
                            self._clearTimer(sound._id);
                        }
                    } else {
                        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
                        var playHtml5 = function() {
                            node.currentTime = seek;
                            node.muted = sound._muted || self._muted || Howler._muted || node.muted;
                            node.volume = sound._volume * Howler.volume();
                            node.playbackRate = sound._rate;
                            // Some browsers will throw an error if this is called without user interaction.
                            try {
                                var play = node.play();
                                // Support older browsers that don't support promises, and thus don't have this issue.
                                if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {
                                    // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
                                    self._playLock = true;
                                    // Set param values immediately.
                                    setParams();
                                    // Releases the lock and executes queued actions.
                                    play.then(function() {
                                        self._playLock = false;
                                        node._unlocked = true;
                                        if (!internal) {
                                            self._emit('play', sound._id);
                                            self._loadQueue();
                                        }
                                    }).catch(function() {
                                        self._playLock = false;
                                        self._emit('playerror', sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                        // Reset the ended and paused values.
                                        sound._ended = true;
                                        sound._paused = true;
                                    });
                                } else if (!internal) {
                                    self._playLock = false;
                                    setParams();
                                    self._emit('play', sound._id);
                                    self._loadQueue();
                                }
                                // Setting rate before playing won't work in IE, so we set it again here.
                                node.playbackRate = sound._rate;
                                // If the node is still paused, then we can assume there was a playback issue.
                                if (node.paused) {
                                    self._emit('playerror', sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                    return;
                                }
                                // Setup the end timer on sprites or listen for the ended event.
                                if (sprite !== '__default' || sound._loop) self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
                                else {
                                    self._endTimers[sound._id] = function() {
                                        // Fire ended on this audio node.
                                        self._ended(sound);
                                        // Clear this listener.
                                        node.removeEventListener('ended', self._endTimers[sound._id], false);
                                    };
                                    node.addEventListener('ended', self._endTimers[sound._id], false);
                                }
                            } catch (err) {
                                self._emit('playerror', sound._id, err);
                            }
                        };
                        // If this is streaming audio, make sure the src is set and load again.
                        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {
                            node.src = self._src;
                            node.load();
                        }
                        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
                        var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler._navigator.isCocoonJS;
                        if (node.readyState >= 3 || loadedNoReadyState) playHtml5();
                        else {
                            self._playLock = true;
                            var listener = function() {
                                // Begin playback.
                                playHtml5();
                                // Clear this listener.
                                node.removeEventListener(Howler._canPlayEvent, listener, false);
                            };
                            node.addEventListener(Howler._canPlayEvent, listener, false);
                            // Cancel the end timer.
                            self._clearTimer(sound._id);
                        }
                    }
                    return sound._id;
                },
                /**
        * Pause playback and save current position.
        * @param  {Number} id The sound ID (empty to pause all in group).
        * @return {Howl}
        */ pause: function(id) {
                    var self = this;
                    // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
                    if (self._state !== 'loaded' || self._playLock) {
                        self._queue.push({
                            event: 'pause',
                            action: function() {
                                self.pause(id);
                            }
                        });
                        return self;
                    }
                    // If no id is passed, get all ID's to be paused.
                    var ids = self._getSoundIds(id);
                    for(var i = 0; i < ids.length; i++){
                        // Clear the end timer.
                        self._clearTimer(ids[i]);
                        // Get the sound.
                        var sound = self._soundById(ids[i]);
                        if (sound && !sound._paused) {
                            // Reset the seek position.
                            sound._seek = self.seek(ids[i]);
                            sound._rateSeek = 0;
                            sound._paused = true;
                            // Stop currently running fades.
                            self._stopFade(ids[i]);
                            if (sound._node) {
                                if (self._webAudio) {
                                    // Make sure the sound has been created.
                                    if (!sound._node.bufferSource) continue;
                                    if (typeof sound._node.bufferSource.stop === 'undefined') sound._node.bufferSource.noteOff(0);
                                    else sound._node.bufferSource.stop(0);
                                    // Clean up the buffer source.
                                    self._cleanBuffer(sound._node);
                                } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) sound._node.pause();
                            }
                        }
                        // Fire the pause event, unless `true` is passed as the 2nd argument.
                        if (!arguments[1]) self._emit('pause', sound ? sound._id : null);
                    }
                    return self;
                },
                /**
        * Stop playback and reset to start.
        * @param  {Number} id The sound ID (empty to stop all in group).
        * @param  {Boolean} internal Internal Use: true prevents event firing.
        * @return {Howl}
        */ stop: function(id, internal) {
                    var self = this;
                    // If the sound hasn't loaded, add it to the load queue to stop when capable.
                    if (self._state !== 'loaded' || self._playLock) {
                        self._queue.push({
                            event: 'stop',
                            action: function() {
                                self.stop(id);
                            }
                        });
                        return self;
                    }
                    // If no id is passed, get all ID's to be stopped.
                    var ids = self._getSoundIds(id);
                    for(var i = 0; i < ids.length; i++){
                        // Clear the end timer.
                        self._clearTimer(ids[i]);
                        // Get the sound.
                        var sound = self._soundById(ids[i]);
                        if (sound) {
                            // Reset the seek position.
                            sound._seek = sound._start || 0;
                            sound._rateSeek = 0;
                            sound._paused = true;
                            sound._ended = true;
                            // Stop currently running fades.
                            self._stopFade(ids[i]);
                            if (sound._node) {
                                if (self._webAudio) // Make sure the sound's AudioBufferSourceNode has been created.
                                {
                                    if (sound._node.bufferSource) {
                                        if (typeof sound._node.bufferSource.stop === 'undefined') sound._node.bufferSource.noteOff(0);
                                        else sound._node.bufferSource.stop(0);
                                        // Clean up the buffer source.
                                        self._cleanBuffer(sound._node);
                                    }
                                } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                                    sound._node.currentTime = sound._start || 0;
                                    sound._node.pause();
                                    // If this is a live stream, stop download once the audio is stopped.
                                    if (sound._node.duration === Infinity) self._clearSound(sound._node);
                                }
                            }
                            if (!internal) self._emit('stop', sound._id);
                        }
                    }
                    return self;
                },
                /**
        * Mute/unmute a single sound or all sounds in this Howl group.
        * @param  {Boolean} muted Set to true to mute and false to unmute.
        * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
        * @return {Howl}
        */ mute: function(muted, id) {
                    var self = this;
                    // If the sound hasn't loaded, add it to the load queue to mute when capable.
                    if (self._state !== 'loaded' || self._playLock) {
                        self._queue.push({
                            event: 'mute',
                            action: function() {
                                self.mute(muted, id);
                            }
                        });
                        return self;
                    }
                    // If applying mute/unmute to all sounds, update the group's value.
                    if (typeof id === 'undefined') {
                        if (typeof muted === 'boolean') self._muted = muted;
                        else return self._muted;
                    }
                    // If no id is passed, get all ID's to be muted.
                    var ids = self._getSoundIds(id);
                    for(var i = 0; i < ids.length; i++){
                        // Get the sound.
                        var sound = self._soundById(ids[i]);
                        if (sound) {
                            sound._muted = muted;
                            // Cancel active fade and set the volume to the end value.
                            if (sound._interval) self._stopFade(sound._id);
                            if (self._webAudio && sound._node) sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
                            else if (sound._node) sound._node.muted = Howler._muted ? true : muted;
                            self._emit('mute', sound._id);
                        }
                    }
                    return self;
                },
                /**
        * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
        *   volume() -> Returns the group's volume value.
        *   volume(id) -> Returns the sound id's current volume.
        *   volume(vol) -> Sets the volume of all sounds in this Howl group.
        *   volume(vol, id) -> Sets the volume of passed sound id.
        * @return {Howl/Number} Returns self or current volume.
        */ volume: function() {
                    var self = this;
                    var args = arguments;
                    var vol, id;
                    // Determine the values based on arguments.
                    if (args.length === 0) // Return the value of the groups' volume.
                    return self._volume;
                    else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
                        // First check if this is an ID, and if not, assume it is a new volume.
                        var ids = self._getSoundIds();
                        var index = ids.indexOf(args[0]);
                        if (index >= 0) id = parseInt(args[0], 10);
                        else vol = parseFloat(args[0]);
                    } else if (args.length >= 2) {
                        vol = parseFloat(args[0]);
                        id = parseInt(args[1], 10);
                    }
                    // Update the volume or return the current volume.
                    var sound;
                    if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
                        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
                        if (self._state !== 'loaded' || self._playLock) {
                            self._queue.push({
                                event: 'volume',
                                action: function() {
                                    self.volume.apply(self, args);
                                }
                            });
                            return self;
                        }
                        // Set the group volume.
                        if (typeof id === 'undefined') self._volume = vol;
                        // Update one or all volumes.
                        id = self._getSoundIds(id);
                        for(var i = 0; i < id.length; i++){
                            // Get the sound.
                            sound = self._soundById(id[i]);
                            if (sound) {
                                sound._volume = vol;
                                // Stop currently running fades.
                                if (!args[2]) self._stopFade(id[i]);
                                if (self._webAudio && sound._node && !sound._muted) sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
                                else if (sound._node && !sound._muted) sound._node.volume = vol * Howler.volume();
                                self._emit('volume', sound._id);
                            }
                        }
                    } else {
                        sound = id ? self._soundById(id) : self._sounds[0];
                        return sound ? sound._volume : 0;
                    }
                    return self;
                },
                /**
        * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
        * @param  {Number} from The value to fade from (0.0 to 1.0).
        * @param  {Number} to   The volume to fade to (0.0 to 1.0).
        * @param  {Number} len  Time in milliseconds to fade.
        * @param  {Number} id   The sound id (omit to fade all sounds).
        * @return {Howl}
        */ fade: function(from, to, len, id) {
                    var self = this;
                    // If the sound hasn't loaded, add it to the load queue to fade when capable.
                    if (self._state !== 'loaded' || self._playLock) {
                        self._queue.push({
                            event: 'fade',
                            action: function() {
                                self.fade(from, to, len, id);
                            }
                        });
                        return self;
                    }
                    // Make sure the to/from/len values are numbers.
                    from = Math.min(Math.max(0, parseFloat(from)), 1);
                    to = Math.min(Math.max(0, parseFloat(to)), 1);
                    len = parseFloat(len);
                    // Set the volume to the start position.
                    self.volume(from, id);
                    // Fade the volume of one or all sounds.
                    var ids = self._getSoundIds(id);
                    for(var i = 0; i < ids.length; i++){
                        // Get the sound.
                        var sound = self._soundById(ids[i]);
                        // Create a linear fade or fall back to timeouts with HTML5 Audio.
                        if (sound) {
                            // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
                            if (!id) self._stopFade(ids[i]);
                            // If we are using Web Audio, let the native methods do the actual fade.
                            if (self._webAudio && !sound._muted) {
                                var currentTime = Howler.ctx.currentTime;
                                var end = currentTime + len / 1000;
                                sound._volume = from;
                                sound._node.gain.setValueAtTime(from, currentTime);
                                sound._node.gain.linearRampToValueAtTime(to, end);
                            }
                            self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');
                        }
                    }
                    return self;
                },
                /**
        * Starts the internal interval to fade a sound.
        * @param  {Object} sound Reference to sound to fade.
        * @param  {Number} from The value to fade from (0.0 to 1.0).
        * @param  {Number} to   The volume to fade to (0.0 to 1.0).
        * @param  {Number} len  Time in milliseconds to fade.
        * @param  {Number} id   The sound id to fade.
        * @param  {Boolean} isGroup   If true, set the volume on the group.
        */ _startFadeInterval: function(sound, from, to, len, id, isGroup) {
                    var self = this;
                    var vol = from;
                    var diff = to - from;
                    var steps = Math.abs(diff / 0.01);
                    var stepLen = Math.max(4, steps > 0 ? len / steps : len);
                    var lastTick = Date.now();
                    // Store the value being faded to.
                    sound._fadeTo = to;
                    // Update the volume value on each interval tick.
                    sound._interval = setInterval(function() {
                        // Update the volume based on the time since the last tick.
                        var tick = (Date.now() - lastTick) / len;
                        lastTick = Date.now();
                        vol += diff * tick;
                        // Make sure the volume is in the right bounds.
                        if (diff < 0) vol = Math.max(to, vol);
                        else vol = Math.min(to, vol);
                        // Round to within 2 decimal points.
                        vol = Math.round(vol * 100) / 100;
                        // Change the volume.
                        if (self._webAudio) sound._volume = vol;
                        else self.volume(vol, sound._id, true);
                        // Set the group's volume.
                        if (isGroup) self._volume = vol;
                        // When the fade is complete, stop it and fire event.
                        if (to < from && vol <= to || to > from && vol >= to) {
                            clearInterval(sound._interval);
                            sound._interval = null;
                            sound._fadeTo = null;
                            self.volume(to, sound._id);
                            self._emit('fade', sound._id);
                        }
                    }, stepLen);
                },
                /**
        * Internal method that stops the currently playing fade when
        * a new fade starts, volume is changed or the sound is stopped.
        * @param  {Number} id The sound id.
        * @return {Howl}
        */ _stopFade: function(id) {
                    var self = this;
                    var sound = self._soundById(id);
                    if (sound && sound._interval) {
                        if (self._webAudio) sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
                        clearInterval(sound._interval);
                        sound._interval = null;
                        self.volume(sound._fadeTo, id);
                        sound._fadeTo = null;
                        self._emit('fade', id);
                    }
                    return self;
                },
                /**
        * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
        *   loop() -> Returns the group's loop value.
        *   loop(id) -> Returns the sound id's loop value.
        *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
        *   loop(loop, id) -> Sets the loop value of passed sound id.
        * @return {Howl/Boolean} Returns self or current loop value.
        */ loop: function() {
                    var self = this;
                    var args = arguments;
                    var loop, id, sound;
                    // Determine the values for loop and id.
                    if (args.length === 0) // Return the grou's loop value.
                    return self._loop;
                    else if (args.length === 1) {
                        if (typeof args[0] === 'boolean') {
                            loop = args[0];
                            self._loop = loop;
                        } else {
                            // Return this sound's loop value.
                            sound = self._soundById(parseInt(args[0], 10));
                            return sound ? sound._loop : false;
                        }
                    } else if (args.length === 2) {
                        loop = args[0];
                        id = parseInt(args[1], 10);
                    }
                    // If no id is passed, get all ID's to be looped.
                    var ids = self._getSoundIds(id);
                    for(var i = 0; i < ids.length; i++){
                        sound = self._soundById(ids[i]);
                        if (sound) {
                            sound._loop = loop;
                            if (self._webAudio && sound._node && sound._node.bufferSource) {
                                sound._node.bufferSource.loop = loop;
                                if (loop) {
                                    sound._node.bufferSource.loopStart = sound._start || 0;
                                    sound._node.bufferSource.loopEnd = sound._stop;
                                }
                            }
                        }
                    }
                    return self;
                },
                /**
        * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
        *   rate() -> Returns the first sound node's current playback rate.
        *   rate(id) -> Returns the sound id's current playback rate.
        *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
        *   rate(rate, id) -> Sets the playback rate of passed sound id.
        * @return {Howl/Number} Returns self or the current playback rate.
        */ rate: function() {
                    var self = this;
                    var args = arguments;
                    var rate, id;
                    // Determine the values based on arguments.
                    if (args.length === 0) // We will simply return the current rate of the first node.
                    id = self._sounds[0]._id;
                    else if (args.length === 1) {
                        // First check if this is an ID, and if not, assume it is a new rate value.
                        var ids = self._getSoundIds();
                        var index = ids.indexOf(args[0]);
                        if (index >= 0) id = parseInt(args[0], 10);
                        else rate = parseFloat(args[0]);
                    } else if (args.length === 2) {
                        rate = parseFloat(args[0]);
                        id = parseInt(args[1], 10);
                    }
                    // Update the playback rate or return the current value.
                    var sound;
                    if (typeof rate === 'number') {
                        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
                        if (self._state !== 'loaded' || self._playLock) {
                            self._queue.push({
                                event: 'rate',
                                action: function() {
                                    self.rate.apply(self, args);
                                }
                            });
                            return self;
                        }
                        // Set the group rate.
                        if (typeof id === 'undefined') self._rate = rate;
                        // Update one or all volumes.
                        id = self._getSoundIds(id);
                        for(var i = 0; i < id.length; i++){
                            // Get the sound.
                            sound = self._soundById(id[i]);
                            if (sound) {
                                // Keep track of our position when the rate changed and update the playback
                                // start position so we can properly adjust the seek position for time elapsed.
                                if (self.playing(id[i])) {
                                    sound._rateSeek = self.seek(id[i]);
                                    sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
                                }
                                sound._rate = rate;
                                // Change the playback rate.
                                if (self._webAudio && sound._node && sound._node.bufferSource) sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
                                else if (sound._node) sound._node.playbackRate = rate;
                                // Reset the timers.
                                var seek = self.seek(id[i]);
                                var duration = (self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000 - seek;
                                var timeout = duration * 1000 / Math.abs(sound._rate);
                                // Start a new end timer if sound is already playing.
                                if (self._endTimers[id[i]] || !sound._paused) {
                                    self._clearTimer(id[i]);
                                    self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
                                }
                                self._emit('rate', sound._id);
                            }
                        }
                    } else {
                        sound = self._soundById(id);
                        return sound ? sound._rate : self._rate;
                    }
                    return self;
                },
                /**
        * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
        *   seek() -> Returns the first sound node's current seek position.
        *   seek(id) -> Returns the sound id's current seek position.
        *   seek(seek) -> Sets the seek position of the first sound node.
        *   seek(seek, id) -> Sets the seek position of passed sound id.
        * @return {Howl/Number} Returns self or the current seek position.
        */ seek: function() {
                    var self = this;
                    var args = arguments;
                    var seek, id;
                    // Determine the values based on arguments.
                    if (args.length === 0) // We will simply return the current position of the first node.
                    id = self._sounds[0]._id;
                    else if (args.length === 1) {
                        // First check if this is an ID, and if not, assume it is a new seek position.
                        var ids = self._getSoundIds();
                        var index = ids.indexOf(args[0]);
                        if (index >= 0) id = parseInt(args[0], 10);
                        else if (self._sounds.length) {
                            id = self._sounds[0]._id;
                            seek = parseFloat(args[0]);
                        }
                    } else if (args.length === 2) {
                        seek = parseFloat(args[0]);
                        id = parseInt(args[1], 10);
                    }
                    // If there is no ID, bail out.
                    if (typeof id === 'undefined') return self;
                    // If the sound hasn't loaded, add it to the load queue to seek when capable.
                    if (self._state !== 'loaded' || self._playLock) {
                        self._queue.push({
                            event: 'seek',
                            action: function() {
                                self.seek.apply(self, args);
                            }
                        });
                        return self;
                    }
                    // Get the sound.
                    var sound = self._soundById(id);
                    if (sound) {
                        if (typeof seek === 'number' && seek >= 0) {
                            // Pause the sound and update position for restarting playback.
                            var playing = self.playing(id);
                            if (playing) self.pause(id, true);
                            // Move the position of the track and cancel timer.
                            sound._seek = seek;
                            sound._ended = false;
                            self._clearTimer(id);
                            // Update the seek position for HTML5 Audio.
                            if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) sound._node.currentTime = seek;
                            // Seek and emit when ready.
                            var seekAndEmit = function() {
                                self._emit('seek', id);
                                // Restart the playback if the sound was playing.
                                if (playing) self.play(id, true);
                            };
                            // Wait for the play lock to be unset before emitting (HTML5 Audio).
                            if (playing && !self._webAudio) {
                                var emitSeek = function() {
                                    if (!self._playLock) seekAndEmit();
                                    else setTimeout(emitSeek, 0);
                                };
                                setTimeout(emitSeek, 0);
                            } else seekAndEmit();
                        } else {
                            if (self._webAudio) {
                                var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
                                var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
                                return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
                            } else return sound._node.currentTime;
                        }
                    }
                    return self;
                },
                /**
        * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
        * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
        * @return {Boolean} True if playing and false if not.
        */ playing: function(id) {
                    var self = this;
                    // Check the passed sound ID (if any).
                    if (typeof id === 'number') {
                        var sound = self._soundById(id);
                        return sound ? !sound._paused : false;
                    }
                    // Otherwise, loop through all sounds and check if any are playing.
                    for(var i = 0; i < self._sounds.length; i++){
                        if (!self._sounds[i]._paused) return true;
                    }
                    return false;
                },
                /**
        * Get the duration of this sound. Passing a sound id will return the sprite duration.
        * @param  {Number} id The sound id to check. If none is passed, return full source duration.
        * @return {Number} Audio duration in seconds.
        */ duration: function(id) {
                    var self = this;
                    var duration = self._duration;
                    // If we pass an ID, get the sound and return the sprite length.
                    var sound = self._soundById(id);
                    if (sound) duration = self._sprite[sound._sprite][1] / 1000;
                    return duration;
                },
                /**
        * Returns the current loaded state of this Howl.
        * @return {String} 'unloaded', 'loading', 'loaded'
        */ state: function() {
                    return this._state;
                },
                /**
        * Unload and destroy the current Howl object.
        * This will immediately stop all sound instances attached to this group.
        */ unload: function() {
                    var self = this;
                    // Stop playing any active sounds.
                    var sounds = self._sounds;
                    for(var i = 0; i < sounds.length; i++){
                        // Stop the sound if it is currently playing.
                        if (!sounds[i]._paused) self.stop(sounds[i]._id);
                        // Remove the source or disconnect.
                        if (!self._webAudio) {
                            // Set the source to 0-second silence to stop any downloading (except in IE).
                            self._clearSound(sounds[i]._node);
                            // Remove any event listeners.
                            sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
                            sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
                            // Release the Audio object back to the pool.
                            Howler._releaseHtml5Audio(sounds[i]._node);
                        }
                        // Empty out all of the nodes.
                        delete sounds[i]._node;
                        // Make sure all timers are cleared out.
                        self._clearTimer(sounds[i]._id);
                    }
                    // Remove the references in the global Howler object.
                    var index = Howler._howls.indexOf(self);
                    if (index >= 0) Howler._howls.splice(index, 1);
                    // Delete this sound from the cache (if no other Howl is using it).
                    var remCache = true;
                    for(i = 0; i < Howler._howls.length; i++)if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {
                        remCache = false;
                        break;
                    }
                    if (cache && remCache) delete cache[self._src];
                    // Clear global errors.
                    Howler.noAudio = false;
                    // Clear out `self`.
                    self._state = 'unloaded';
                    self._sounds = [];
                    self = null;
                    return null;
                },
                /**
        * Listen to a custom event.
        * @param  {String}   event Event name.
        * @param  {Function} fn    Listener to call.
        * @param  {Number}   id    (optional) Only listen to events for this sound.
        * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
        * @return {Howl}
        */ on: function(event, fn, id, once) {
                    var self = this;
                    var events = self['_on' + event];
                    if (typeof fn === 'function') events.push(once ? {
                        id: id,
                        fn: fn,
                        once: once
                    } : {
                        id: id,
                        fn: fn
                    });
                    return self;
                },
                /**
        * Remove a custom event. Call without parameters to remove all events.
        * @param  {String}   event Event name.
        * @param  {Function} fn    Listener to remove. Leave empty to remove all.
        * @param  {Number}   id    (optional) Only remove events for this sound.
        * @return {Howl}
        */ off: function(event, fn, id) {
                    var self = this;
                    var events = self['_on' + event];
                    var i = 0;
                    // Allow passing just an event and ID.
                    if (typeof fn === 'number') {
                        id = fn;
                        fn = null;
                    }
                    if (fn || id) // Loop through event store and remove the passed function.
                    for(i = 0; i < events.length; i++){
                        var isId = id === events[i].id;
                        if (fn === events[i].fn && isId || !fn && isId) {
                            events.splice(i, 1);
                            break;
                        }
                    }
                    else if (event) // Clear out all events of this type.
                    self['_on' + event] = [];
                    else {
                        // Clear out all events of every type.
                        var keys = Object.keys(self);
                        for(i = 0; i < keys.length; i++)if (keys[i].indexOf('_on') === 0 && Array.isArray(self[keys[i]])) self[keys[i]] = [];
                    }
                    return self;
                },
                /**
        * Listen to a custom event and remove it once fired.
        * @param  {String}   event Event name.
        * @param  {Function} fn    Listener to call.
        * @param  {Number}   id    (optional) Only listen to events for this sound.
        * @return {Howl}
        */ once: function(event, fn, id) {
                    var self = this;
                    // Setup the event listener.
                    self.on(event, fn, id, 1);
                    return self;
                },
                /**
        * Emit all events of a specific type and pass the sound id.
        * @param  {String} event Event name.
        * @param  {Number} id    Sound ID.
        * @param  {Number} msg   Message to go with event.
        * @return {Howl}
        */ _emit: function(event, id, msg) {
                    var self = this;
                    var events = self['_on' + event];
                    // Loop through event store and fire all functions.
                    for(var i = events.length - 1; i >= 0; i--)// Only fire the listener if the correct ID is used.
                    if (!events[i].id || events[i].id === id || event === 'load') {
                        setTimeout((function(fn) {
                            fn.call(this, id, msg);
                        }).bind(self, events[i].fn), 0);
                        // If this event was setup with `once`, remove it.
                        if (events[i].once) self.off(event, events[i].fn, events[i].id);
                    }
                    // Pass the event type into load queue so that it can continue stepping.
                    self._loadQueue(event);
                    return self;
                },
                /**
        * Queue of actions initiated before the sound has loaded.
        * These will be called in sequence, with the next only firing
        * after the previous has finished executing (even if async like play).
        * @return {Howl}
        */ _loadQueue: function(event) {
                    var self = this;
                    if (self._queue.length > 0) {
                        var task = self._queue[0];
                        // Remove this task if a matching event was passed.
                        if (task.event === event) {
                            self._queue.shift();
                            self._loadQueue();
                        }
                        // Run the task if no event type is passed.
                        if (!event) task.action();
                    }
                    return self;
                },
                /**
        * Fired when playback ends at the end of the duration.
        * @param  {Sound} sound The sound object to work with.
        * @return {Howl}
        */ _ended: function(sound) {
                    var self = this;
                    var sprite = sound._sprite;
                    // If we are using IE and there was network latency we may be clipping
                    // audio before it completes playing. Lets check the node to make sure it
                    // believes it has completed, before ending the playback.
                    if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
                        setTimeout(self._ended.bind(self, sound), 100);
                        return self;
                    }
                    // Should this sound loop?
                    var loop = !!(sound._loop || self._sprite[sprite][2]);
                    // Fire the ended event.
                    self._emit('end', sound._id);
                    // Restart the playback for HTML5 Audio loop.
                    if (!self._webAudio && loop) self.stop(sound._id, true).play(sound._id);
                    // Restart this timer if on a Web Audio loop.
                    if (self._webAudio && loop) {
                        self._emit('play', sound._id);
                        sound._seek = sound._start || 0;
                        sound._rateSeek = 0;
                        sound._playStart = Howler.ctx.currentTime;
                        var timeout = (sound._stop - sound._start) * 1000 / Math.abs(sound._rate);
                        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
                    }
                    // Mark the node as paused.
                    if (self._webAudio && !loop) {
                        sound._paused = true;
                        sound._ended = true;
                        sound._seek = sound._start || 0;
                        sound._rateSeek = 0;
                        self._clearTimer(sound._id);
                        // Clean up the buffer source.
                        self._cleanBuffer(sound._node);
                        // Attempt to auto-suspend AudioContext if no sounds are still playing.
                        Howler._autoSuspend();
                    }
                    // When using a sprite, end the track.
                    if (!self._webAudio && !loop) self.stop(sound._id, true);
                    return self;
                },
                /**
        * Clear the end timer for a sound playback.
        * @param  {Number} id The sound ID.
        * @return {Howl}
        */ _clearTimer: function(id) {
                    var self = this;
                    if (self._endTimers[id]) {
                        // Clear the timeout or remove the ended listener.
                        if (typeof self._endTimers[id] !== 'function') clearTimeout(self._endTimers[id]);
                        else {
                            var sound = self._soundById(id);
                            if (sound && sound._node) sound._node.removeEventListener('ended', self._endTimers[id], false);
                        }
                        delete self._endTimers[id];
                    }
                    return self;
                },
                /**
        * Return the sound identified by this ID, or return null.
        * @param  {Number} id Sound ID
        * @return {Object}    Sound object or null.
        */ _soundById: function(id) {
                    var self = this;
                    // Loop through all sounds and find the one with this ID.
                    for(var i = 0; i < self._sounds.length; i++){
                        if (id === self._sounds[i]._id) return self._sounds[i];
                    }
                    return null;
                },
                /**
        * Return an inactive sound from the pool or create a new one.
        * @return {Sound} Sound playback object.
        */ _inactiveSound: function() {
                    var self = this;
                    self._drain();
                    // Find the first inactive node to recycle.
                    for(var i = 0; i < self._sounds.length; i++){
                        if (self._sounds[i]._ended) return self._sounds[i].reset();
                    }
                    // If no inactive node was found, create a new one.
                    return new Sound(self);
                },
                /**
        * Drain excess inactive sounds from the pool.
        */ _drain: function() {
                    var self = this;
                    var limit = self._pool;
                    var cnt = 0;
                    var i = 0;
                    // If there are less sounds than the max pool size, we are done.
                    if (self._sounds.length < limit) return;
                    // Count the number of inactive sounds.
                    for(i = 0; i < self._sounds.length; i++)if (self._sounds[i]._ended) cnt++;
                    // Remove excess inactive sounds, going in reverse order.
                    for(i = self._sounds.length - 1; i >= 0; i--){
                        if (cnt <= limit) return;
                        if (self._sounds[i]._ended) {
                            // Disconnect the audio source when using Web Audio.
                            if (self._webAudio && self._sounds[i]._node) self._sounds[i]._node.disconnect(0);
                            // Remove sounds until we have the pool size.
                            self._sounds.splice(i, 1);
                            cnt--;
                        }
                    }
                },
                /**
        * Get all ID's from the sounds pool.
        * @param  {Number} id Only return one ID if one is passed.
        * @return {Array}    Array of IDs.
        */ _getSoundIds: function(id) {
                    var self = this;
                    if (typeof id === 'undefined') {
                        var ids = [];
                        for(var i = 0; i < self._sounds.length; i++)ids.push(self._sounds[i]._id);
                        return ids;
                    } else return [
                        id
                    ];
                },
                /**
        * Load the sound back into the buffer source.
        * @param  {Sound} sound The sound object to work with.
        * @return {Howl}
        */ _refreshBuffer: function(sound) {
                    var self = this;
                    // Setup the buffer source for playback.
                    sound._node.bufferSource = Howler.ctx.createBufferSource();
                    sound._node.bufferSource.buffer = cache[self._src];
                    // Connect to the correct node.
                    if (sound._panner) sound._node.bufferSource.connect(sound._panner);
                    else sound._node.bufferSource.connect(sound._node);
                    // Setup looping and playback rate.
                    sound._node.bufferSource.loop = sound._loop;
                    if (sound._loop) {
                        sound._node.bufferSource.loopStart = sound._start || 0;
                        sound._node.bufferSource.loopEnd = sound._stop || 0;
                    }
                    sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);
                    return self;
                },
                /**
        * Prevent memory leaks by cleaning up the buffer source after playback.
        * @param  {Object} node Sound's audio node containing the buffer source.
        * @return {Howl}
        */ _cleanBuffer: function(node) {
                    var self = this;
                    var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;
                    if (Howler._scratchBuffer && node.bufferSource) {
                        node.bufferSource.onended = null;
                        node.bufferSource.disconnect(0);
                        if (isIOS) try {
                            node.bufferSource.buffer = Howler._scratchBuffer;
                        } catch (e) {
                        }
                    }
                    node.bufferSource = null;
                    return self;
                },
                /**
        * Set the source to a 0-second silence to stop any downloading (except in IE).
        * @param  {Object} node Audio node to clear.
        */ _clearSound: function(node) {
                    var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
                    if (!checkIE) node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
                }
            };
            /** Single Sound Methods **/ /***************************************************************************/ /**
      * Setup the sound object, which each node attached to a Howl group is contained in.
      * @param {Object} howl The Howl parent group.
      */ var Sound = function(howl) {
                this._parent = howl;
                this.init();
            };
            Sound.prototype = {
                /**
        * Initialize a new Sound object.
        * @return {Sound}
        */ init: function() {
                    var self = this;
                    var parent = self._parent;
                    // Setup the default parameters.
                    self._muted = parent._muted;
                    self._loop = parent._loop;
                    self._volume = parent._volume;
                    self._rate = parent._rate;
                    self._seek = 0;
                    self._paused = true;
                    self._ended = true;
                    self._sprite = '__default';
                    // Generate a unique ID for this sound.
                    self._id = ++Howler._counter;
                    // Add itself to the parent's pool.
                    parent._sounds.push(self);
                    // Create the new node.
                    self.create();
                    return self;
                },
                /**
        * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
        * @return {Sound}
        */ create: function() {
                    var self = this;
                    var parent = self._parent;
                    var volume = Howler._muted || self._muted || self._parent._muted ? 0 : self._volume;
                    if (parent._webAudio) {
                        // Create the gain node for controlling volume (the source will connect to this).
                        self._node = typeof Howler.ctx.createGain === 'undefined' ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
                        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
                        self._node.paused = true;
                        self._node.connect(Howler.masterGain);
                    } else if (!Howler.noAudio) {
                        // Get an unlocked Audio object from the pool.
                        self._node = Howler._obtainHtml5Audio();
                        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
                        self._errorFn = self._errorListener.bind(self);
                        self._node.addEventListener('error', self._errorFn, false);
                        // Listen for 'canplaythrough' event to let us know the sound is ready.
                        self._loadFn = self._loadListener.bind(self);
                        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);
                        // Setup the new audio node.
                        self._node.src = parent._src;
                        self._node.preload = parent._preload === true ? 'auto' : parent._preload;
                        self._node.volume = volume * Howler.volume();
                        // Begin loading the source.
                        self._node.load();
                    }
                    return self;
                },
                /**
        * Reset the parameters of this sound to the original state (for recycle).
        * @return {Sound}
        */ reset: function() {
                    var self = this;
                    var parent = self._parent;
                    // Reset all of the parameters of this sound.
                    self._muted = parent._muted;
                    self._loop = parent._loop;
                    self._volume = parent._volume;
                    self._rate = parent._rate;
                    self._seek = 0;
                    self._rateSeek = 0;
                    self._paused = true;
                    self._ended = true;
                    self._sprite = '__default';
                    // Generate a new ID so that it isn't confused with the previous sound.
                    self._id = ++Howler._counter;
                    return self;
                },
                /**
        * HTML5 Audio error listener callback.
        */ _errorListener: function() {
                    var self = this;
                    // Fire an error event and pass back the code.
                    self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);
                    // Clear the event listener.
                    self._node.removeEventListener('error', self._errorFn, false);
                },
                /**
        * HTML5 Audio canplaythrough listener callback.
        */ _loadListener: function() {
                    var self = this;
                    var parent = self._parent;
                    // Round up the duration to account for the lower precision in HTML5 Audio.
                    parent._duration = Math.ceil(self._node.duration * 10) / 10;
                    // Setup a sprite if none is defined.
                    if (Object.keys(parent._sprite).length === 0) parent._sprite = {
                        __default: [
                            0,
                            parent._duration * 1000
                        ]
                    };
                    if (parent._state !== 'loaded') {
                        parent._state = 'loaded';
                        parent._emit('load');
                        parent._loadQueue();
                    }
                    // Clear the event listener.
                    self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
                }
            };
            /** Helper Methods **/ /***************************************************************************/ var cache = {
            };
            /**
      * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
      * @param  {Howl} self
      */ var loadBuffer = function(self) {
                var url = self._src;
                // Check if the buffer has already been cached and use it instead.
                if (cache[url]) {
                    // Set the duration from the cache.
                    self._duration = cache[url].duration;
                    // Load the sound into this Howl.
                    loadSound(self);
                    return;
                }
                if (/^data:[^;]+;base64,/.test(url)) {
                    // Decode the base64 data URI without XHR, since some browsers don't support it.
                    var data = atob(url.split(',')[1]);
                    var dataView = new Uint8Array(data.length);
                    for(var i = 0; i < data.length; ++i)dataView[i] = data.charCodeAt(i);
                    decodeAudioData(dataView.buffer, self);
                } else {
                    // Load the buffer from the URL.
                    var xhr = new XMLHttpRequest();
                    xhr.open(self._xhr.method, url, true);
                    xhr.withCredentials = self._xhr.withCredentials;
                    xhr.responseType = 'arraybuffer';
                    // Apply any custom headers to the request.
                    if (self._xhr.headers) Object.keys(self._xhr.headers).forEach(function(key) {
                        xhr.setRequestHeader(key, self._xhr.headers[key]);
                    });
                    xhr.onload = function() {
                        // Make sure we get a successful response back.
                        var code = (xhr.status + '')[0];
                        if (code !== '0' && code !== '2' && code !== '3') {
                            self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
                            return;
                        }
                        decodeAudioData(xhr.response, self);
                    };
                    xhr.onerror = function() {
                        // If there is an error, switch to HTML5 Audio.
                        if (self._webAudio) {
                            self._html5 = true;
                            self._webAudio = false;
                            self._sounds = [];
                            delete cache[url];
                            self.load();
                        }
                    };
                    safeXhrSend(xhr);
                }
            };
            /**
      * Send the XHR request wrapped in a try/catch.
      * @param  {Object} xhr XHR to send.
      */ var safeXhrSend = function(xhr) {
                try {
                    xhr.send();
                } catch (e) {
                    xhr.onerror();
                }
            };
            /**
      * Decode audio data from an array buffer.
      * @param  {ArrayBuffer} arraybuffer The audio data.
      * @param  {Howl}        self
      */ var decodeAudioData = function(arraybuffer, self) {
                // Fire a load error if something broke.
                var error = function() {
                    self._emit('loaderror', null, 'Decoding audio data failed.');
                };
                // Load the sound on success.
                var success = function(buffer) {
                    if (buffer && self._sounds.length > 0) {
                        cache[self._src] = buffer;
                        loadSound(self, buffer);
                    } else error();
                };
                // Decode the buffer into an audio source.
                if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
                else Howler.ctx.decodeAudioData(arraybuffer, success, error);
            };
            /**
      * Sound is now loaded, so finish setting everything up and fire the loaded event.
      * @param  {Howl} self
      * @param  {Object} buffer The decoded buffer sound source.
      */ var loadSound = function(self, buffer) {
                // Set the duration.
                if (buffer && !self._duration) self._duration = buffer.duration;
                // Setup a sprite if none is defined.
                if (Object.keys(self._sprite).length === 0) self._sprite = {
                    __default: [
                        0,
                        self._duration * 1000
                    ]
                };
                // Fire the loaded event.
                if (self._state !== 'loaded') {
                    self._state = 'loaded';
                    self._emit('load');
                    self._loadQueue();
                }
            };
            /**
      * Setup the audio context when available, or switch to HTML5 Audio mode.
      */ var setupAudioContext = function() {
                // If we have already detected that Web Audio isn't supported, don't run this step again.
                if (!Howler.usingWebAudio) return;
                // Check if we are using Web Audio and setup the AudioContext if we are.
                try {
                    if (typeof AudioContext !== 'undefined') Howler.ctx = new AudioContext();
                    else if (typeof webkitAudioContext !== 'undefined') Howler.ctx = new webkitAudioContext();
                    else Howler.usingWebAudio = false;
                } catch (e) {
                    Howler.usingWebAudio = false;
                }
                // If the audio context creation still failed, set using web audio to false.
                if (!Howler.ctx) Howler.usingWebAudio = false;
                // Check if a webview is being used on iOS8 or earlier (rather than the browser).
                // If it is, disable Web Audio as it causes crashing.
                var iOS = /iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform);
                var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
                var version = appVersion ? parseInt(appVersion[1], 10) : null;
                if (iOS && version && version < 9) {
                    var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
                    if (Howler._navigator && !safari) Howler.usingWebAudio = false;
                }
                // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
                if (Howler.usingWebAudio) {
                    Howler.masterGain = typeof Howler.ctx.createGain === 'undefined' ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
                    Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);
                    Howler.masterGain.connect(Howler.ctx.destination);
                }
                // Re-run the setup on Howler.
                Howler._setup();
            };
            exports.Howler = Howler;
            exports.Howl = Howl;
            // Add to global in Node.js (for testing, etc).
            if (typeof commonjsGlobal !== 'undefined') {
                commonjsGlobal.HowlerGlobal = HowlerGlobal;
                commonjsGlobal.Howler = Howler;
                commonjsGlobal.Howl = Howl;
                commonjsGlobal.Sound = Sound;
            } else if (typeof window !== 'undefined') {
                window.HowlerGlobal = HowlerGlobal;
                window.Howler = Howler;
                window.Howl = Howl;
                window.Sound = Sound;
            }
        })();
        /*!
    *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
    *  
    *  howler.js v2.2.0
    *  howlerjs.com
    *
    *  (c) 2013-2020, James Simpson of GoldFire Studios
    *  goldfirestudios.com
    *
    *  MIT License
    */ (function() {
            // Setup default properties.
            HowlerGlobal.prototype._pos = [
                0,
                0,
                0
            ];
            HowlerGlobal.prototype._orientation = [
                0,
                0,
                -1,
                0,
                1,
                0
            ];
            /** Global Methods **/ /***************************************************************************/ /**
      * Helper method to update the stereo panning position of all current Howls.
      * Future Howls will not use this value unless explicitly set.
      * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
      * @return {Howler/Number}     Self or current stereo panning value.
      */ HowlerGlobal.prototype.stereo = function(pan) {
                var self = this;
                // Stop right here if not using Web Audio.
                if (!self.ctx || !self.ctx.listener) return self;
                // Loop through all Howls and update their stereo panning.
                for(var i = self._howls.length - 1; i >= 0; i--)self._howls[i].stereo(pan);
                return self;
            };
            /**
      * Get/set the position of the listener in 3D cartesian space. Sounds using
      * 3D position will be relative to the listener's position.
      * @param  {Number} x The x-position of the listener.
      * @param  {Number} y The y-position of the listener.
      * @param  {Number} z The z-position of the listener.
      * @return {Howler/Array}   Self or current listener position.
      */ HowlerGlobal.prototype.pos = function(x, y, z) {
                var self = this;
                // Stop right here if not using Web Audio.
                if (!self.ctx || !self.ctx.listener) return self;
                // Set the defaults for optional 'y' & 'z'.
                y = typeof y !== 'number' ? self._pos[1] : y;
                z = typeof z !== 'number' ? self._pos[2] : z;
                if (typeof x === 'number') {
                    self._pos = [
                        x,
                        y,
                        z
                    ];
                    if (typeof self.ctx.listener.positionX !== 'undefined') {
                        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
                        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
                        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
                    } else self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
                } else return self._pos;
                return self;
            };
            /**
      * Get/set the direction the listener is pointing in the 3D cartesian space.
      * A front and up vector must be provided. The front is the direction the
      * face of the listener is pointing, and up is the direction the top of the
      * listener is pointing. Thus, these values are expected to be at right angles
      * from each other.
      * @param  {Number} x   The x-orientation of the listener.
      * @param  {Number} y   The y-orientation of the listener.
      * @param  {Number} z   The z-orientation of the listener.
      * @param  {Number} xUp The x-orientation of the top of the listener.
      * @param  {Number} yUp The y-orientation of the top of the listener.
      * @param  {Number} zUp The z-orientation of the top of the listener.
      * @return {Howler/Array}     Returns self or the current orientation vectors.
      */ HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
                var self = this;
                // Stop right here if not using Web Audio.
                if (!self.ctx || !self.ctx.listener) return self;
                // Set the defaults for optional 'y' & 'z'.
                var or = self._orientation;
                y = typeof y !== 'number' ? or[1] : y;
                z = typeof z !== 'number' ? or[2] : z;
                xUp = typeof xUp !== 'number' ? or[3] : xUp;
                yUp = typeof yUp !== 'number' ? or[4] : yUp;
                zUp = typeof zUp !== 'number' ? or[5] : zUp;
                if (typeof x === 'number') {
                    self._orientation = [
                        x,
                        y,
                        z,
                        xUp,
                        yUp,
                        zUp
                    ];
                    if (typeof self.ctx.listener.forwardX !== 'undefined') {
                        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
                        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
                        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
                        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
                        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
                        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
                    } else self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
                } else return or;
                return self;
            };
            /** Group Methods **/ /***************************************************************************/ /**
      * Add new properties to the core init.
      * @param  {Function} _super Core init method.
      * @return {Howl}
      */ Howl.prototype.init = (function(_super) {
                return function(o) {
                    var self = this;
                    // Setup user-defined default properties.
                    self._orientation = o.orientation || [
                        1,
                        0,
                        0
                    ];
                    self._stereo = o.stereo || null;
                    self._pos = o.pos || null;
                    self._pannerAttr = {
                        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
                        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
                        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
                        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
                        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
                        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
                        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
                        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
                    };
                    // Setup event listeners.
                    self._onstereo = o.onstereo ? [
                        {
                            fn: o.onstereo
                        }
                    ] : [];
                    self._onpos = o.onpos ? [
                        {
                            fn: o.onpos
                        }
                    ] : [];
                    self._onorientation = o.onorientation ? [
                        {
                            fn: o.onorientation
                        }
                    ] : [];
                    // Complete initilization with howler.js core's init function.
                    return _super.call(this, o);
                };
            })(Howl.prototype.init);
            /**
      * Get/set the stereo panning of the audio source for this sound or all in the group.
      * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
      * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
      * @return {Howl/Number}    Returns self or the current stereo panning value.
      */ Howl.prototype.stereo = function(pan, id) {
                var self = this;
                // Stop right here if not using Web Audio.
                if (!self._webAudio) return self;
                // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
                if (self._state !== 'loaded') {
                    self._queue.push({
                        event: 'stereo',
                        action: function() {
                            self.stereo(pan, id);
                        }
                    });
                    return self;
                }
                // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
                var pannerType = typeof Howler.ctx.createStereoPanner === 'undefined' ? 'spatial' : 'stereo';
                // Setup the group's stereo panning if no ID is passed.
                if (typeof id === 'undefined') {
                    // Return the group's stereo panning if no parameters are passed.
                    if (typeof pan === 'number') {
                        self._stereo = pan;
                        self._pos = [
                            pan,
                            0,
                            0
                        ];
                    } else return self._stereo;
                }
                // Change the streo panning of one or all sounds in group.
                var ids = self._getSoundIds(id);
                for(var i = 0; i < ids.length; i++){
                    // Get the sound.
                    var sound = self._soundById(ids[i]);
                    if (sound) {
                        if (typeof pan === 'number') {
                            sound._stereo = pan;
                            sound._pos = [
                                pan,
                                0,
                                0
                            ];
                            if (sound._node) {
                                // If we are falling back, make sure the panningModel is equalpower.
                                sound._pannerAttr.panningModel = 'equalpower';
                                // Check if there is a panner setup and create a new one if not.
                                if (!sound._panner || !sound._panner.pan) setupPanner(sound, pannerType);
                                if (pannerType === 'spatial') {
                                    if (typeof sound._panner.positionX !== 'undefined') {
                                        sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                                        sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                                        sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                                    } else sound._panner.setPosition(pan, 0, 0);
                                } else sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
                            }
                            self._emit('stereo', sound._id);
                        } else return sound._stereo;
                    }
                }
                return self;
            };
            /**
      * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
      * @param  {Number} x  The x-position of the audio source.
      * @param  {Number} y  The y-position of the audio source.
      * @param  {Number} z  The z-position of the audio source.
      * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
      * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
      */ Howl.prototype.pos = function(x, y, z, id) {
                var self = this;
                // Stop right here if not using Web Audio.
                if (!self._webAudio) return self;
                // If the sound hasn't loaded, add it to the load queue to change position when capable.
                if (self._state !== 'loaded') {
                    self._queue.push({
                        event: 'pos',
                        action: function() {
                            self.pos(x, y, z, id);
                        }
                    });
                    return self;
                }
                // Set the defaults for optional 'y' & 'z'.
                y = typeof y !== 'number' ? 0 : y;
                z = typeof z !== 'number' ? -0.5 : z;
                // Setup the group's spatial position if no ID is passed.
                if (typeof id === 'undefined') {
                    // Return the group's spatial position if no parameters are passed.
                    if (typeof x === 'number') self._pos = [
                        x,
                        y,
                        z
                    ];
                    else return self._pos;
                }
                // Change the spatial position of one or all sounds in group.
                var ids = self._getSoundIds(id);
                for(var i = 0; i < ids.length; i++){
                    // Get the sound.
                    var sound = self._soundById(ids[i]);
                    if (sound) {
                        if (typeof x === 'number') {
                            sound._pos = [
                                x,
                                y,
                                z
                            ];
                            if (sound._node) {
                                // Check if there is a panner setup and create a new one if not.
                                if (!sound._panner || sound._panner.pan) setupPanner(sound, 'spatial');
                                if (typeof sound._panner.positionX !== 'undefined') {
                                    sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
                                    sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
                                    sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
                                } else sound._panner.setPosition(x, y, z);
                            }
                            self._emit('pos', sound._id);
                        } else return sound._pos;
                    }
                }
                return self;
            };
            /**
      * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
      * space. Depending on how direction the sound is, based on the `cone` attributes,
      * a sound pointing away from the listener can be quiet or silent.
      * @param  {Number} x  The x-orientation of the source.
      * @param  {Number} y  The y-orientation of the source.
      * @param  {Number} z  The z-orientation of the source.
      * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
      * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
      */ Howl.prototype.orientation = function(x, y, z, id) {
                var self = this;
                // Stop right here if not using Web Audio.
                if (!self._webAudio) return self;
                // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
                if (self._state !== 'loaded') {
                    self._queue.push({
                        event: 'orientation',
                        action: function() {
                            self.orientation(x, y, z, id);
                        }
                    });
                    return self;
                }
                // Set the defaults for optional 'y' & 'z'.
                y = typeof y !== 'number' ? self._orientation[1] : y;
                z = typeof z !== 'number' ? self._orientation[2] : z;
                // Setup the group's spatial orientation if no ID is passed.
                if (typeof id === 'undefined') {
                    // Return the group's spatial orientation if no parameters are passed.
                    if (typeof x === 'number') self._orientation = [
                        x,
                        y,
                        z
                    ];
                    else return self._orientation;
                }
                // Change the spatial orientation of one or all sounds in group.
                var ids = self._getSoundIds(id);
                for(var i = 0; i < ids.length; i++){
                    // Get the sound.
                    var sound = self._soundById(ids[i]);
                    if (sound) {
                        if (typeof x === 'number') {
                            sound._orientation = [
                                x,
                                y,
                                z
                            ];
                            if (sound._node) {
                                // Check if there is a panner setup and create a new one if not.
                                if (!sound._panner) {
                                    // Make sure we have a position to setup the node with.
                                    if (!sound._pos) sound._pos = self._pos || [
                                        0,
                                        0,
                                        -0.5
                                    ];
                                    setupPanner(sound, 'spatial');
                                }
                                if (typeof sound._panner.orientationX !== 'undefined') {
                                    sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
                                    sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
                                    sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
                                } else sound._panner.setOrientation(x, y, z);
                            }
                            self._emit('orientation', sound._id);
                        } else return sound._orientation;
                    }
                }
                return self;
            };
            /**
      * Get/set the panner node's attributes for a sound or group of sounds.
      * This method can optionall take 0, 1 or 2 arguments.
      *   pannerAttr() -> Returns the group's values.
      *   pannerAttr(id) -> Returns the sound id's values.
      *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
      *   pannerAttr(o, id) -> Set's the values of passed sound id.
      *
      *   Attributes:
      *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
      *                      inside of which there will be no volume reduction.
      *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
      *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
      *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
      *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
      *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
      *                     listener. Can be `linear`, `inverse` or `exponential.
      *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
      *                   will not be reduced any further.
      *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
      *                   This is simply a variable of the distance model and has a different effect depending on which model
      *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
      *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
      *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`
      *                     with `inverse` and `exponential`.
      *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
      *                     Can be `HRTF` or `equalpower`.
      *
      * @return {Howl/Object} Returns self or current panner attributes.
      */ Howl.prototype.pannerAttr = function() {
                var self = this;
                var args = arguments;
                var o, id, sound;
                // Stop right here if not using Web Audio.
                if (!self._webAudio) return self;
                // Determine the values based on arguments.
                if (args.length === 0) // Return the group's panner attribute values.
                return self._pannerAttr;
                else if (args.length === 1) {
                    if (typeof args[0] === 'object') {
                        o = args[0];
                        // Set the grou's panner attribute values.
                        if (typeof id === 'undefined') {
                            if (!o.pannerAttr) o.pannerAttr = {
                                coneInnerAngle: o.coneInnerAngle,
                                coneOuterAngle: o.coneOuterAngle,
                                coneOuterGain: o.coneOuterGain,
                                distanceModel: o.distanceModel,
                                maxDistance: o.maxDistance,
                                refDistance: o.refDistance,
                                rolloffFactor: o.rolloffFactor,
                                panningModel: o.panningModel
                            };
                            self._pannerAttr = {
                                coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
                                coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
                                coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
                                distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,
                                maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,
                                refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,
                                rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
                                panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel
                            };
                        }
                    } else {
                        // Return this sound's panner attribute values.
                        sound = self._soundById(parseInt(args[0], 10));
                        return sound ? sound._pannerAttr : self._pannerAttr;
                    }
                } else if (args.length === 2) {
                    o = args[0];
                    id = parseInt(args[1], 10);
                }
                // Update the values of the specified sounds.
                var ids = self._getSoundIds(id);
                for(var i = 0; i < ids.length; i++){
                    sound = self._soundById(ids[i]);
                    if (sound) {
                        // Merge the new values into the sound.
                        var pa = sound._pannerAttr;
                        pa = {
                            coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
                            coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
                            coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
                            distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
                            maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
                            refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
                            rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,
                            panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel
                        };
                        // Update the panner values or create a new panner if none exists.
                        var panner = sound._panner;
                        if (panner) {
                            panner.coneInnerAngle = pa.coneInnerAngle;
                            panner.coneOuterAngle = pa.coneOuterAngle;
                            panner.coneOuterGain = pa.coneOuterGain;
                            panner.distanceModel = pa.distanceModel;
                            panner.maxDistance = pa.maxDistance;
                            panner.refDistance = pa.refDistance;
                            panner.rolloffFactor = pa.rolloffFactor;
                            panner.panningModel = pa.panningModel;
                        } else {
                            // Make sure we have a position to setup the node with.
                            if (!sound._pos) sound._pos = self._pos || [
                                0,
                                0,
                                -0.5
                            ];
                            // Create a new panner node.
                            setupPanner(sound, 'spatial');
                        }
                    }
                }
                return self;
            };
            /** Single Sound Methods **/ /***************************************************************************/ /**
      * Add new properties to the core Sound init.
      * @param  {Function} _super Core Sound init method.
      * @return {Sound}
      */ Sound.prototype.init = (function(_super) {
                return function() {
                    var self = this;
                    var parent = self._parent;
                    // Setup user-defined default properties.
                    self._orientation = parent._orientation;
                    self._stereo = parent._stereo;
                    self._pos = parent._pos;
                    self._pannerAttr = parent._pannerAttr;
                    // Complete initilization with howler.js core Sound's init function.
                    _super.call(this);
                    // If a stereo or position was specified, set it up.
                    if (self._stereo) parent.stereo(self._stereo);
                    else if (self._pos) parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
                };
            })(Sound.prototype.init);
            /**
      * Override the Sound.reset method to clean up properties from the spatial plugin.
      * @param  {Function} _super Sound reset method.
      * @return {Sound}
      */ Sound.prototype.reset = (function(_super) {
                return function() {
                    var self = this;
                    var parent = self._parent;
                    // Reset all spatial plugin properties on this sound.
                    self._orientation = parent._orientation;
                    self._stereo = parent._stereo;
                    self._pos = parent._pos;
                    self._pannerAttr = parent._pannerAttr;
                    // If a stereo or position was specified, set it up.
                    if (self._stereo) parent.stereo(self._stereo);
                    else if (self._pos) parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
                    else if (self._panner) {
                        // Disconnect the panner.
                        self._panner.disconnect(0);
                        self._panner = undefined;
                        parent._refreshBuffer(self);
                    }
                    // Complete resetting of the sound.
                    return _super.call(this);
                };
            })(Sound.prototype.reset);
            /** Helper Methods **/ /***************************************************************************/ /**
      * Create a new panner node and save it on the sound.
      * @param  {Sound} sound Specific sound to setup panning on.
      * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
      */ var setupPanner = function(sound, type) {
                type = type || 'spatial';
                // Create the new panner node.
                if (type === 'spatial') {
                    sound._panner = Howler.ctx.createPanner();
                    sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
                    sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
                    sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
                    sound._panner.distanceModel = sound._pannerAttr.distanceModel;
                    sound._panner.maxDistance = sound._pannerAttr.maxDistance;
                    sound._panner.refDistance = sound._pannerAttr.refDistance;
                    sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
                    sound._panner.panningModel = sound._pannerAttr.panningModel;
                    if (typeof sound._panner.positionX !== 'undefined') {
                        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
                        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
                        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
                    } else sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
                    if (typeof sound._panner.orientationX !== 'undefined') {
                        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
                        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
                        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
                    } else sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
                } else {
                    sound._panner = Howler.ctx.createStereoPanner();
                    sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
                }
                sound._panner.connect(sound._node);
                // Update the connections.
                if (!sound._paused) sound._parent.pause(sound._id, true).play(sound._id, true);
            };
        })();
    });
    // external import
    (function() {
        /**
      * There is no constructor function for me.audio.
      * @namespace me.audio
      * @memberOf me
      */ me.audio = (function() {
            /*
        * PRIVATE STUFF
        */ // hold public stuff in our singleton
            var api = {
            }; // audio channel list
            var audioTracks = {
            }; // current music
            var current_track_id = null; // a retry counter
            var retry_counter = 0;
            /**
        * event listener callback on load error
        * @ignore
        */ function soundLoadError(sound_name, onerror_cb) {
                // check the retry counter
                if ((retry_counter++) > 3) {
                    // something went wrong
                    var errmsg = "melonJS: failed loading " + sound_name;
                    if (me.sys.stopOnAudioError === false) {
                        // disable audio
                        me.audio.disable(); // call error callback if defined
                        if (onerror_cb) onerror_cb();
                         // warning
                        console.log(errmsg + ", disabling audio");
                    } else // throw an exception and stop everything !
                    throw new Error(errmsg);
                     // else try loading again !
                } else audioTracks[sound_name].load();
            }
            /*
        * PUBLIC STUFF
        */ /**
        * Initialize and configure the audio support.<br>
        * melonJS supports a wide array of audio codecs that have varying browser support :
        * <i> ("mp3", "mpeg", opus", "ogg", "oga", "wav", "aac", "caf", "m4a", "m4b", "mp4", "weba", "webm", "dolby", "flac")</i>.<br>
        * For a maximum browser coverage the recommendation is to use at least two of them,
        * typically default to webm and then fallback to mp3 for the best balance of small filesize and high quality,
        * webm has nearly full browser coverage with a great combination of compression and quality, and mp3 will fallback gracefully for other browsers.
        * It is important to remember that melonJS selects the first compatible sound based on the list of extensions and given order passed here.
        * So if you want webm to be used before mp3, you need to put the audio format in that order.
        * @name init
        * @memberOf me.audio
        * @public
        * @function
        * @param {String} [audioFormat="mp3"] audio format provided
        * @return {Boolean} Indicates whether audio initialization was successful
        * @example
        * // initialize the "sound engine", giving "webm" as default desired audio format, and "mp3" as a fallback
        * if (!me.audio.init("webm,mp3")) {
        *     alert("Sorry but your browser does not support html 5 audio !");
        *     return;
        * }
        */ api.init = function(audioFormat) {
                if (!me.initialized) throw new Error("me.audio.init() called before engine initialization.");
                 // if no param is given to init we use mp3 by default
                audioFormat = typeof audioFormat === "string" ? audioFormat : "mp3"; // convert it into an array
                this.audioFormats = audioFormat.split(",");
                return !howler.Howler.noAudio;
            };
            /**
        * return true if audio (HTML5 or WebAudio) is supported
        * @see me.audio#hasAudio
        * @name hasAudio
        * @memberOf me.audio
        * @public
        * @function
        */ api.hasAudio = function() {
                return !howler.Howler.noAudio;
            };
            /**
        * enable audio output <br>
        * only useful if audio supported and previously disabled through
        *
        * @see me.audio#disable
        * @name enable
        * @memberOf me.audio
        * @public
        * @function
        */ api.enable = function() {
                this.unmuteAll();
            };
            /**
        * disable audio output
        *
        * @name disable
        * @memberOf me.audio
        * @public
        * @function
        */ api.disable = function() {
                this.muteAll();
            };
            /**
        * Load an audio file.<br>
        * <br>
        * sound item must contain the following fields :<br>
        * - name    : name of the sound<br>
        * - src     : source path<br>
        * @ignore
        */ api.load = function(sound, html5, onload_cb, onerror_cb) {
                var urls = [];
                if (typeof this.audioFormats === "undefined" || this.audioFormats.length === 0) throw new Error("target audio extension(s) should be set through me.audio.init() before calling the preloader.");
                for(var i = 0; i < this.audioFormats.length; i++)urls.push(sound.src + sound.name + "." + this.audioFormats[i] + me.loader.nocache);
                audioTracks[sound.name] = new howler.Howl({
                    src: urls,
                    volume: howler.Howler.volume(),
                    html5: html5 === true,
                    xhrWithCredentials: me.loader.withCredentials,
                    /**
            * @ignore
            */ onloaderror: function onloaderror() {
                        soundLoadError.call(me.audio, sound.name, onerror_cb);
                    },
                    /**
            * @ignore
            */ onload: function onload() {
                        retry_counter = 0;
                        if (onload_cb) onload_cb();
                    }
                });
                return 1;
            };
            /**
        * play the specified sound
        * @name play
        * @memberOf me.audio
        * @public
        * @function
        * @param {String} sound_name audio clip name - case sensitive
        * @param {Boolean} [loop=false] loop audio
        * @param {Function} [onend] Function to call when sound instance ends playing.
        * @param {Number} [volume=default] Float specifying volume (0.0 - 1.0 values accepted).
        * @return {Number} the sound instance ID.
        * @example
        * // play the "cling" audio clip
        * me.audio.play("cling");
        * // play & repeat the "engine" audio clip
        * me.audio.play("engine", true);
        * // play the "gameover_sfx" audio clip and call myFunc when finished
        * me.audio.play("gameover_sfx", false, myFunc);
        * // play the "gameover_sfx" audio clip with a lower volume level
        * me.audio.play("gameover_sfx", false, null, 0.5);
        */ api.play = function(sound_name, loop, onend, volume) {
                var sound = audioTracks[sound_name];
                if (sound && typeof sound !== "undefined") {
                    var id = sound.play();
                    if (typeof loop === "boolean") // arg[0] can take different types in howler 2.0
                    sound.loop(loop, id);
                    sound.volume(typeof volume === "number" ? me.Math.clamp(volume, 0, 1) : howler.Howler.volume(), id);
                    if (typeof onend === "function") {
                        if (loop === true) sound.on("end", onend, id);
                        else sound.once("end", onend, id);
                    }
                    return id;
                } else throw new Error("audio clip " + sound_name + " does not exist");
            };
            /**
        * Fade a currently playing sound between two volumee.
        * @name fade
        * @memberOf me.audio
        * @public
        * @function
        * @param {String} sound_name audio clip name - case sensitive
        * @param {Number} from Volume to fade from (0.0 to 1.0).
        * @param {Number} to Volume to fade to (0.0 to 1.0).
        * @param {Number} duration Time in milliseconds to fade.
        * @param {Number} [id] the sound instance ID. If none is passed, all sounds in group will fade.
        */ api.fade = function(sound_name, from, to, duration, id) {
                var sound = audioTracks[sound_name];
                if (sound && typeof sound !== "undefined") sound.fade(from, to, duration, id);
                else throw new Error("audio clip " + sound_name + " does not exist");
            };
            /**
        * get/set the position of playback for a sound.
        * @name seek
        * @memberOf me.audio
        * @public
        * @function
        * @param {String} sound_name audio clip name - case sensitive
        * @param {Number} [seek]  The position to move current playback to (in seconds).
        * @param {Number} [id] the sound instance ID. If none is passed, all sounds in group will changed.
        * @return return the current seek position (if no extra parameters were given)
        * @example
        * // return the current position of the background music
        * var current_pos = me.audio.seek("dst-gameforest");
        * // set back the position of the background music to the beginning
        * me.audio.seek("dst-gameforest", 0);
        */ api.seek = function(sound_name, seek, id) {
                var sound = audioTracks[sound_name];
                if (sound && typeof sound !== "undefined") return sound.seek.apply(sound, Array.prototype.slice.call(arguments, 1));
                else throw new Error("audio clip " + sound_name + " does not exist");
            };
            /**
        * get or set the rate of playback for a sound.
        * @name rate
        * @memberOf me.audio
        * @public
        * @function
        * @param {String} sound_name audio clip name - case sensitive
        * @param {Number} [rate] playback rate : 0.5 to 4.0, with 1.0 being normal speed.
        * @param {Number} [id] the sound instance ID. If none is passed, all sounds in group will be changed.
        * @return return the current playback rate (if no extra parameters were given)
        * @example
        * // get the playback rate of the background music
        * var rate = me.audio.rate("dst-gameforest");
        * // speed up the playback of the background music
        * me.audio.rate("dst-gameforest", 2.0);
        */ api.rate = function(sound_name, rate, id) {
                var sound = audioTracks[sound_name];
                if (sound && typeof sound !== "undefined") return sound.rate.apply(sound, Array.prototype.slice.call(arguments, 1));
                else throw new Error("audio clip " + sound_name + " does not exist");
            };
            /**
        * stop the specified sound on all channels
        * @name stop
        * @memberOf me.audio
        * @public
        * @function
        * @param {String} [sound_name] audio clip name (case sensitive). If none is passed, all sounds are stopped.
        * @param {Number} [id] the sound instance ID. If none is passed, all sounds in group will stop.
        * @example
        * me.audio.stop("cling");
        */ api.stop = function(sound_name, id) {
                if (typeof sound_name !== "undefined") {
                    var sound = audioTracks[sound_name];
                    if (sound && typeof sound !== "undefined") {
                        sound.stop(id); // remove the defined onend callback (if any defined)
                        sound.off("end", undefined, id);
                    } else throw new Error("audio clip " + sound_name + " does not exist");
                } else howler.Howler.stop();
            };
            /**
        * pause the specified sound on all channels<br>
        * this function does not reset the currentTime property
        * @name pause
        * @memberOf me.audio
        * @public
        * @function
        * @param {String} sound_name audio clip name - case sensitive
        * @param {Number} [id] the sound instance ID. If none is passed, all sounds in group will pause.
        * @example
        * me.audio.pause("cling");
        */ api.pause = function(sound_name, id) {
                var sound = audioTracks[sound_name];
                if (sound && typeof sound !== "undefined") sound.pause(id);
                else throw new Error("audio clip " + sound_name + " does not exist");
            };
            /**
        * resume the specified sound on all channels<br>
        * @name resume
        * @memberOf me.audio
        * @public
        * @function
        * @param {String} sound_name audio clip name - case sensitive
        * @param {Number} [id] the sound instance ID. If none is passed, all sounds in group will resume.
        * @example
        * // play a audio clip
        * var id = me.audio.play("myClip");
        * ...
        * // pause it
        * me.audio.pause("myClip", id);
        * ...
        * // resume
        * me.audio.resume("myClip", id);
        */ api.resume = function(sound_name, id) {
                var sound = audioTracks[sound_name];
                if (sound && typeof sound !== "undefined") sound.play(id);
                else throw new Error("audio clip " + sound_name + " does not exist");
            };
            /**
        * play the specified audio track<br>
        * this function automatically set the loop property to true<br>
        * and keep track of the current sound being played.
        * @name playTrack
        * @memberOf me.audio
        * @public
        * @function
        * @param {String} sound_name audio track name - case sensitive
        * @param {Number} [volume=default] Float specifying volume (0.0 - 1.0 values accepted).
        * @return {Number} the sound instance ID.
        * @example
        * me.audio.playTrack("awesome_music");
        */ api.playTrack = function(sound_name, volume) {
                current_track_id = sound_name;
                return me.audio.play(current_track_id, true, null, volume);
            };
            /**
        * stop the current audio track
        *
        * @see me.audio#playTrack
        * @name stopTrack
        * @memberOf me.audio
        * @public
        * @function
        * @example
        * // play a awesome music
        * me.audio.playTrack("awesome_music");
        * // stop the current music
        * me.audio.stopTrack();
        */ api.stopTrack = function() {
                if (current_track_id !== null) {
                    audioTracks[current_track_id].stop();
                    current_track_id = null;
                }
            };
            /**
        * pause the current audio track
        *
        * @name pauseTrack
        * @memberOf me.audio
        * @public
        * @function
        * @example
        * me.audio.pauseTrack();
        */ api.pauseTrack = function() {
                if (current_track_id !== null) audioTracks[current_track_id].pause();
            };
            /**
        * resume the previously paused audio track
        *
        * @name resumeTrack
        * @memberOf me.audio
        * @public
        * @function
        * @example
        * // play an awesome music
        * me.audio.playTrack("awesome_music");
        * // pause the audio track
        * me.audio.pauseTrack();
        * // resume the music
        * me.audio.resumeTrack();
        */ api.resumeTrack = function() {
                if (current_track_id !== null) audioTracks[current_track_id].play();
            };
            /**
        * returns the current track Id
        * @name getCurrentTrack
        * @memberOf me.audio
        * @public
        * @function
        * @return {String} audio track name
        */ api.getCurrentTrack = function() {
                return current_track_id;
            };
            /**
        * set the default global volume
        * @name setVolume
        * @memberOf me.audio
        * @public
        * @function
        * @param {Number} volume Float specifying volume (0.0 - 1.0 values accepted).
        */ api.setVolume = function(volume) {
                howler.Howler.volume(volume);
            };
            /**
        * get the default global volume
        * @name getVolume
        * @memberOf me.audio
        * @public
        * @function
        * @returns {Number} current volume value in Float [0.0 - 1.0] .
        */ api.getVolume = function() {
                return howler.Howler.volume();
            };
            /**
        * mute or unmute the specified sound, but does not pause the playback.
        * @name mute
        * @memberOf me.audio
        * @public
        * @function
        * @param {String} sound_name audio clip name - case sensitive
        * @param {Number} [id] the sound instance ID. If none is passed, all sounds in group will mute.
        * @param {Boolean} [mute=true] True to mute and false to unmute
        * @example
        * // mute the background music
        * me.audio.mute("awesome_music");
        */ api.mute = function(sound_name, id, mute) {
                // if not defined : true
                mute = typeof mute === "undefined" ? true : !!mute;
                var sound = audioTracks[sound_name];
                if (sound && typeof sound !== "undefined") sound.mute(mute, id);
                else throw new Error("audio clip " + sound_name + " does not exist");
            };
            /**
        * unmute the specified sound
        * @name unmute
        * @memberOf me.audio
        * @public
        * @function
        * @param {String} sound_name audio clip name
        * @param {Number} [id] the sound instance ID. If none is passed, all sounds in group will unmute.
        */ api.unmute = function(sound_name, id) {
                api.mute(sound_name, id, false);
            };
            /**
        * mute all audio
        * @name muteAll
        * @memberOf me.audio
        * @public
        * @function
        */ api.muteAll = function() {
                howler.Howler.mute(true);
            };
            /**
        * unmute all audio
        * @name unmuteAll
        * @memberOf me.audio
        * @public
        * @function
        */ api.unmuteAll = function() {
                howler.Howler.mute(false);
            };
            /**
        * Returns true if audio is muted globally.
        * @name muted
        * @memberOf me.audio
        * @public
        * @function
        * @return {Boolean} true if audio is muted globally
        */ api.muted = function() {
                return howler.Howler._muted;
            };
            /**
        * unload specified audio track to free memory
        *
        * @name unload
        * @memberOf me.audio
        * @public
        * @function
        * @param {String} sound_name audio track name - case sensitive
        * @return {Boolean} true if unloaded
        * @example
        * me.audio.unload("awesome_music");
        */ api.unload = function(sound_name) {
                if (!(sound_name in audioTracks)) return false;
                 // destroy the Howl object
                audioTracks[sound_name].unload();
                delete audioTracks[sound_name];
                return true;
            };
            /**
        * unload all audio to free memory
        *
        * @name unloadAll
        * @memberOf me.audio
        * @public
        * @function
        * @example
        * me.audio.unloadAll();
        */ api.unloadAll = function() {
                for(var sound_name in audioTracks)if (audioTracks.hasOwnProperty(sound_name)) api.unload(sound_name);
            }; // return our object
            return api;
        })();
    })();
    (function() {
        /**
      * video functions
      * There is no constructor function for me.video
      * @namespace me.video
      * @memberOf me
      */ me.video = (function() {
            // hold public stuff in our api
            var api = {
            };
            var designRatio = 1;
            var designWidth = 0;
            var designHeight = 0; // default video settings
            var settings = {
                parent: document.body,
                renderer: 2,
                // AUTO
                doubleBuffering: false,
                autoScale: false,
                scale: 1,
                scaleMethod: "fit",
                transparent: false,
                blendMode: "normal",
                antiAlias: false,
                failIfMajorPerformanceCaveat: true,
                subPixel: false,
                preferWebGL1: true,
                powerPreference: "default",
                verbose: false,
                consoleHeader: true
            };
            /**
        * Auto-detect the best renderer to use
        * @ignore
        */ function autoDetectRenderer(options) {
                try {
                    if (me.device.isWebGLSupported(options)) return new me.WebGLRenderer(options);
                } catch (e) {
                    console.log("Error creating WebGL renderer :" + e.message);
                }
                return new me.CanvasRenderer(options);
            }
            /*
        * PUBLIC STUFF
        */ /**
        * Select the HTML5 Canvas renderer
        * @public
        * @name CANVAS
        * @memberOf me.video
        * @enum {Number}
        */ api.CANVAS = 0;
            /**
        * Select the WebGL renderer
        * @public
        * @name WEBGL
        * @memberOf me.video
        * @enum {Number}
        */ api.WEBGL = 1;
            /**
        * Auto-select the renderer (Attempt WebGL first, with fallback to Canvas)
        * @public
        * @name AUTO
        * @memberOf me.video
        * @enum {Number}
        */ api.AUTO = 2;
            /**
        * the parent container of the main canvas element
        * @ignore
        * @type {HTMLElement}
        * @readonly
        * @name parent
        * @memberOf me.video
        */ api.parent = null;
            /**
        * the scaling ratio to be applied to the display canvas
        * @type {me.Vector2d}
        * @default <1,1>
        * @memberOf me.video
        */ api.scaleRatio = new me.Vector2d(1, 1);
            /**
        * Initialize the "video" system (create a canvas based on the given arguments, and the related renderer). <br>
        * melonJS support various scaling mode, that can be enabled <u>once the scale option is set to <b>`auto`</b></u> : <br>
        *  - <i><b>`fit`</b></i> : Letterboxed; content is scaled to design aspect ratio <br>
        * <center><img src="images/scale-fit.png"/></center><br>
        *  - <i><b>`fill-min`</b></i> : Canvas is resized to fit minimum design resolution; content is scaled to design aspect ratio <br>
        * <center><img src="images/scale-fill-min.png"/></center><br>
        *  - <i><b>`fill-max`</b></i> : Canvas is resized to fit maximum design resolution; content is scaled to design aspect ratio <br>
        * <center><img src="images/scale-fill-max.png"/></center><br>
        *  - <i><b>`flex`</b><</i> : Canvas width & height is resized to fit; content is scaled to design aspect ratio <br>
        * <center><img src="images/scale-flex.png"/></center><br>
        *  - <i><b>`flex-width`</b></i> : Canvas width is resized to fit; content is scaled to design aspect ratio <br>
        * <center><img src="images/scale-flex-width.png"/></center><br>
        *  - <i><b>`flex-height`</b></i> : Canvas height is resized to fit; content is scaled to design aspect ratio <br>
        * <center><img src="images/scale-flex-height.png"/></center><br>
        *  - <i><b>`stretch`</b></i> : Canvas is resized to fit; content is scaled to screen aspect ratio
        * <center><img src="images/scale-stretch.png"/></center><br>
        * @name init
        * @memberOf me.video
        * @function
        * @param {Number} width The width of the canvas viewport
        * @param {Number} height The height of the canvas viewport
        * @param {Object} [options] The optional video/renderer parameters.<br> (see Renderer(s) documentation for further specific options)
        * @param {String|HTMLElement} [options.parent=document.body] the DOM parent element to hold the canvas in the HTML file
        * @param {Number} [options.renderer=me.video.AUTO] renderer to use (me.video.CANVAS, me.video.WEBGL, me.video.AUTO)
        * @param {Boolean} [options.doubleBuffering=false] enable/disable double buffering
        * @param {Number|String} [options.scale=1.0] enable scaling of the canvas ('auto' for automatic scaling)
        * @param {String} [options.scaleMethod="fit"] screen scaling modes ('fit','fill-min','fill-max','flex','flex-width','flex-height','stretch')
        * @param {Boolean} [options.preferWebGL1=true] if false the renderer will try to use WebGL 2 if supported
        * @param {String} [options.powerPreference="default"] a hint to the user agent indicating what configuration of GPU is suitable for the WebGL context ("default", "high-performance", "low-power"). To be noted that Safari and Chrome (since version 80) both default to "low-power" to save battery life and improve the user experience on these dual-GPU machines.
        * @param {Boolean} [options.transparent=false] whether to allow transparent pixels in the front buffer (screen).
        * @param {Boolean} [options.antiAlias=false] whether to enable or not video scaling interpolation
        * @param {Boolean} [options.consoleHeader=true] whether to display melonJS version and basic device information in the console
        * @return {Boolean} false if initialization failed (canvas not supported)
        * @see me.CanvasRenderer
        * @see me.WebGLRenderer
        * @example
        * // init the video with a 640x480 canvas
        * me.video.init(640, 480, {
        *     parent : "screen",
        *     renderer : me.video.AUTO,
        *     scale : "auto",
        *     scaleMethod : "fit",
        *     doubleBuffering : true
        * });
        */ api.init = function(game_width, game_height, options) {
                // ensure melonjs has been properly initialized
                if (!me.initialized) throw new Error("me.video.init() called before engine initialization.");
                 // revert to default options if not defined
                settings = Object.assign(settings, options || {
                }); // sanitize potential given parameters
                settings.width = game_width;
                settings.height = game_height;
                settings.doubleBuffering = !!settings.doubleBuffering;
                settings.transparent = !!settings.transparent;
                settings.antiAlias = !!settings.antiAlias;
                settings.failIfMajorPerformanceCaveat = !!settings.failIfMajorPerformanceCaveat;
                settings.subPixel = !!settings.subPixel;
                settings.verbose = !!settings.verbose;
                if (settings.scaleMethod.search(/^(fill-(min|max)|fit|flex(-(width|height))?|stretch)$/) !== -1) settings.autoScale = settings.scale === "auto" || true;
                else {
                    // default scaling method
                    settings.scaleMethod = "fit";
                    settings.autoScale = settings.scale === "auto" || false;
                } // for backward compatilibty with melonJS 7.1.1 and lower
                if (typeof settings.wrapper !== "undefined") {
                    me.utils.deprecated("settings.wrapper", "settings.parent", "8.0.0");
                    settings.parent = settings.wrapper;
                } // display melonJS version
                if (settings.consoleHeader !== false) // output video information in the console
                console.log("melonJS v" + me.version + " | http://melonjs.org");
                 // override renderer settings if &webgl is defined in the URL
                var uriFragment = me.utils.getUriFragment();
                if (uriFragment.webgl === true || uriFragment.webgl1 === true || uriFragment.webgl2 === true) {
                    settings.renderer = api.WEBGL;
                    if (uriFragment.webgl2 === true) settings.preferWebGL1 = false;
                } // normalize scale
                settings.scale = settings.autoScale ? 1 : +settings.scale || 1;
                me.video.scaleRatio.set(settings.scale, settings.scale); // force double buffering if scaling is required
                if (settings.autoScale || settings.scale !== 1) settings.doubleBuffering = true;
                 // hold the requested video size ratio
                designRatio = game_width / game_height;
                designWidth = game_width;
                designHeight = game_height; // default scaled size value
                settings.zoomX = game_width * me.video.scaleRatio.x;
                settings.zoomY = game_height * me.video.scaleRatio.y; //add a channel for the onresize/onorientationchange event
                window.addEventListener("resize", me.utils["function"].throttle(function(event) {
                    me.event.publish(me.event.WINDOW_ONRESIZE, [
                        event
                    ]);
                }, 100), false); // Screen Orientation API
                window.addEventListener("orientationchange", function(event) {
                    me.event.publish(me.event.WINDOW_ONORIENTATION_CHANGE, [
                        event
                    ]);
                }, false); // pre-fixed implementation on mozzila
                window.addEventListener("onmozorientationchange", function(event) {
                    me.event.publish(me.event.WINDOW_ONORIENTATION_CHANGE, [
                        event
                    ]);
                }, false);
                if (typeof window.screen !== "undefined") // is this one required ?
                window.screen.onorientationchange = function(event) {
                    me.event.publish(me.event.WINDOW_ONORIENTATION_CHANGE, [
                        event
                    ]);
                };
                 // Automatically update relative canvas position on scroll
                window.addEventListener("scroll", me.utils["function"].throttle(function(e) {
                    me.event.publish(me.event.WINDOW_ONSCROLL, [
                        e
                    ]);
                }, 100), false); // register to the channel
                me.event.subscribe(me.event.WINDOW_ONRESIZE, me.video.onresize.bind(me.video));
                me.event.subscribe(me.event.WINDOW_ONORIENTATION_CHANGE, me.video.onresize.bind(me.video));
                try {
                    /**
            * A reference to the current video renderer
            * @public
            * @memberOf me.video
            * @name renderer
            * @type {me.Renderer|me.CanvasRenderer|me.WebGLRenderer}
            */ switch(settings.renderer){
                        case api.AUTO:
                        case api.WEBGL:
                            this.renderer = autoDetectRenderer(settings);
                            break;
                        default:
                            this.renderer = new me.CanvasRenderer(settings);
                            break;
                    }
                } catch (e) {
                    console(e.message); // me.video.init() returns false if failing at creating/using a HTML5 canvas
                    return false;
                } // add our canvas (default to document.body if settings.parent is undefined)
                me.video.parent = me.device.getElement(settings.parent);
                me.video.parent.appendChild(this.renderer.getScreenCanvas()); // trigger an initial resize();
                me.video.onresize(); // add an observer to detect when the dom tree is modified
                if ("MutationObserver" in window) {
                    // Create an observer instance linked to the callback function
                    var observer = new MutationObserver(me.video.onresize.bind(me.video)); // Start observing the target node for configured mutations
                    observer.observe(me.video.parent, {
                        attributes: false,
                        childList: true,
                        subtree: true
                    });
                }
                if (settings.consoleHeader !== false) {
                    var renderType = me.video.renderer instanceof me.CanvasRenderer ? "CANVAS" : "WebGL" + me.video.renderer.WebGLVersion;
                    var audioType = me.device.hasWebAudio ? "Web Audio" : "HTML5 Audio";
                    var gpu_renderer = typeof me.video.renderer.GPURenderer === "string" ? " (" + me.video.renderer.GPURenderer + ")" : ""; // output video information in the console
                    console.log(renderType + " renderer" + gpu_renderer + " | " + audioType + " | " + "pixel ratio " + me.device.devicePixelRatio + " | " + (me.device.isMobile ? "mobile" : "desktop") + " | " + me.device.getScreenOrientation() + " | " + me.device.language);
                    console.log("resolution: requested " + game_width + "x" + game_height + ", got " + me.video.renderer.getWidth() + "x" + me.video.renderer.getHeight());
                } // notify the video has been initialized
                me.event.publish(me.event.VIDEO_INIT);
                return true;
            };
            /**
        * Create and return a new Canvas element
        * @name createCanvas
        * @memberOf me.video
        * @function
        * @param {Number} width width
        * @param {Number} height height
        * @param {Boolean} [offscreen=false] will returns an OffscreenCanvas if supported
        * @return {HTMLCanvasElement|OffscreenCanvas}
        */ api.createCanvas = function(width, height, offscreen) {
                var _canvas;
                if (width === 0 || height === 0) throw new Error("width or height was zero, Canvas could not be initialized !");
                if (me.device.OffscreenCanvas === true && offscreen === true) {
                    _canvas = new OffscreenCanvas(0, 0); // stubbing style for compatibility,
                    // as OffscreenCanvas is detached from the DOM
                    if (typeof _canvas.style === "undefined") _canvas.style = {
                    };
                } else // "else" create a "standard" canvas
                _canvas = document.createElement("canvas");
                _canvas.width = width;
                _canvas.height = height;
                return _canvas;
            };
            /**
        * return a reference to the parent DOM element holding the main canvas
        * @name getParent
        * @memberOf me.video
        * @function
        * @return {HTMLElement}
        */ api.getParent = function() {
                return me.video.parent;
            };
            /**
        * callback for window resize event
        * @ignore
        */ api.onresize = function() {
                var renderer = me.video.renderer;
                var settings1 = renderer.settings;
                var scaleX = 1, scaleY = 1;
                if (settings1.autoScale) {
                    // set max the canvas max size if CSS values are defined
                    var canvasMaxWidth = Infinity;
                    var canvasMaxHeight = Infinity;
                    if (window.getComputedStyle) {
                        var style = window.getComputedStyle(renderer.getScreenCanvas(), null);
                        canvasMaxWidth = parseInt(style.maxWidth, 10) || Infinity;
                        canvasMaxHeight = parseInt(style.maxHeight, 10) || Infinity;
                    } // get the maximum canvas size within the parent div containing the canvas container
                    var nodeBounds = me.device.getParentBounds(me.video.getParent());
                    var _max_width = Math.min(canvasMaxWidth, nodeBounds.width);
                    var _max_height = Math.min(canvasMaxHeight, nodeBounds.height); // calculate final canvas width & height
                    var screenRatio = _max_width / _max_height;
                    if (settings1.scaleMethod === "fill-min" && screenRatio > designRatio || settings1.scaleMethod === "fill-max" && screenRatio < designRatio || settings1.scaleMethod === "flex-width") {
                        // resize the display canvas to fill the parent container
                        var sWidth = Math.min(canvasMaxWidth, designHeight * screenRatio);
                        scaleX = scaleY = _max_width / sWidth;
                        renderer.resize(Math.floor(sWidth), designHeight);
                    } else if (settings1.scaleMethod === "fill-min" && screenRatio < designRatio || settings1.scaleMethod === "fill-max" && screenRatio > designRatio || settings1.scaleMethod === "flex-height") {
                        // resize the display canvas to fill the parent container
                        var sHeight = Math.min(canvasMaxHeight, designWidth * (_max_height / _max_width));
                        scaleX = scaleY = _max_height / sHeight;
                        renderer.resize(designWidth, Math.floor(sHeight));
                    } else if (settings1.scaleMethod === "flex") // resize the display canvas to fill the parent container
                    renderer.resize(Math.floor(_max_width), Math.floor(_max_height));
                    else if (settings1.scaleMethod === "stretch") {
                        // scale the display canvas to fit with the parent container
                        scaleX = _max_width / designWidth;
                        scaleY = _max_height / designHeight;
                    } else // scale the display canvas to fit the parent container
                    // make sure we maintain the original aspect ratio
                    if (screenRatio < designRatio) scaleX = scaleY = _max_width / designWidth;
                    else scaleX = scaleY = _max_height / designHeight;
                     // adjust scaling ratio based on the new scaling ratio
                    me.video.scale(scaleX, scaleY);
                }
            };
            /**
        * scale the "displayed" canvas by the given scalar.
        * this will modify the size of canvas element directly.
        * Only use this if you are not using the automatic scaling feature.
        * @name scale
        * @memberOf me.video
        * @function
        * @see me.video.init
        * @param {Number} x x scaling multiplier
        * @param {Number} y y scaling multiplier
        */ api.scale = function(x, y) {
                var renderer = me.video.renderer;
                var canvas = renderer.getScreenCanvas();
                var context = renderer.getScreenContext();
                var settings1 = renderer.settings;
                var pixelRatio = me.device.devicePixelRatio;
                var w = settings1.zoomX = canvas.width * x * pixelRatio;
                var h = settings1.zoomY = canvas.height * y * pixelRatio; // update the global scale variable
                me.video.scaleRatio.set(x * pixelRatio, y * pixelRatio); // adjust CSS style based on device pixel ratio
                canvas.style.width = w / pixelRatio + "px";
                canvas.style.height = h / pixelRatio + "px"; // if anti-alias and blend mode were resetted (e.g. Canvas mode)
                renderer.setAntiAlias(context, settings1.antiAlias);
                renderer.setBlendMode(settings1.blendMode, context); // force repaint
                me.game.repaint();
            }; // return our api
            return api;
        })();
    })();
    (function() {
        /**
      * a base renderer object
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      * @param {Object} options The renderer parameters
      * @param {Number} options.width The width of the canvas without scaling
      * @param {Number} options.height The height of the canvas without scaling
      * @param {HTMLCanvasElement} [options.canvas] The html canvas to draw to on screen
      * @param {Boolean} [options.doubleBuffering=false] Whether to enable double buffering
      * @param {Boolean} [options.antiAlias=false] Whether to enable anti-aliasing, use false (default) for a pixelated effect.
      * @param {Boolean} [options.failIfMajorPerformanceCaveat=true] If true, the renderer will switch to CANVAS mode if the performances of a WebGL context would be dramatically lower than that of a native application making equivalent OpenGL calls.
      * @param {Boolean} [options.transparent=false] Whether to enable transparency on the canvas (performance hit when enabled)
      * @param {Boolean} [options.blendMode="normal"] the default blend mode to use ("normal", "multiply")
      * @param {Boolean} [options.subPixel=false] Whether to enable subpixel rendering (performance hit when enabled)
      * @param {Boolean} [options.verbose=false] Enable the verbose mode that provides additional details as to what the renderer is doing
      * @param {Number} [options.zoomX=width] The actual width of the canvas with scaling applied
      * @param {Number} [options.zoomY=height] The actual height of the canvas with scaling applied
      */ me.Renderer = me.Object.extend({
            /**
        * @ignore
        */ init: function init(options) {
                /**
          * The given constructor options
          * @public
          * @name settings
          * @memberOf me.Renderer#
          * @enum {Object}
          */ this.settings = options;
                /**
          * true if the current rendering context is valid
          * @name isContextValid
          * @memberOf me.Renderer
          * @default true
          * type {Boolean}
          */ this.isContextValid = true;
                /**
          * @ignore
          */ this.currentScissor = new Int32Array([
                    0,
                    0,
                    this.settings.width,
                    this.settings.height
                ]);
                /**
          * @ignore
          */ this.currentBlendMode = "normal"; // create the main screen canvas
                if (me.device.ejecta === true) // a main canvas is already automatically created by Ejecta
                this.canvas = document.getElementById("canvas");
                else if (typeof window.canvas !== "undefined") // a global canvas is available, e.g. webapp adapter for wechat
                this.canvas = window.canvas;
                else if (typeof this.settings.canvas !== "undefined") this.canvas = this.settings.canvas;
                else this.canvas = me.video.createCanvas(this.settings.zoomX, this.settings.zoomY);
                 // canvas object and context
                this.backBufferCanvas = this.canvas;
                this.context = null; // global color
                this.currentColor = new me.Color(0, 0, 0, 1); // global tint color
                this.currentTint = new me.Color(255, 255, 255, 1); // the projectionMatrix (set through setProjection)
                this.projectionMatrix = new me.Matrix3d(); // default uvOffset
                this.uvOffset = 0; // the parent container bouds
                this.parentBounds = new me.Rect(0, 0, 0, 0); // reset the instantiated renderer on game reset
                me.event.subscribe(me.event.GAME_RESET, function() {
                    me.video.renderer.reset();
                });
                return this;
            },
            /**
        * prepare the framebuffer for drawing a new frame
        * @name clear
        * @memberOf me.Renderer.prototype
        * @function
        */ clear: function clear() {
            },
            /**
        * Reset context state
        * @name reset
        * @memberOf me.Renderer.prototype
        * @function
        */ reset: function reset() {
                this.resetTransform();
                this.setBlendMode(this.settings.blendMode);
                this.setColor("#000000");
                this.clearTint();
                this.cache.clear();
                this.currentScissor[0] = 0;
                this.currentScissor[1] = 0;
                this.currentScissor[2] = this.backBufferCanvas.width;
                this.currentScissor[3] = this.backBufferCanvas.height;
            },
            /**
        * return a reference to the system canvas
        * @name getCanvas
        * @memberOf me.Renderer.prototype
        * @function
        * @return {HTMLCanvasElement}
        */ getCanvas: function getCanvas() {
                return this.backBufferCanvas;
            },
            /**
        * return a reference to the screen canvas
        * @name getScreenCanvas
        * @memberOf me.Renderer.prototype
        * @function
        * @return {HTMLCanvasElement}
        */ getScreenCanvas: function getScreenCanvas() {
                return this.canvas;
            },
            /**
        * return a reference to the screen canvas corresponding 2d Context<br>
        * (will return buffered context if double buffering is enabled, or a reference to the Screen Context)
        * @name getScreenContext
        * @memberOf me.Renderer.prototype
        * @function
        * @return {Context2d}
        */ getScreenContext: function getScreenContext() {
                return this.context;
            },
            /**
        * returns the current blend mode for this renderer
        * @name getBlendMode
        * @memberOf me.Renderer.prototype
        * @function
        * @return {String} blend mode
        */ getBlendMode: function getBlendMode() {
                return this.currentBlendMode;
            },
            /**
        * Returns the 2D Context object of the given Canvas<br>
        * Also configures anti-aliasing and blend modes based on constructor options.
        * @name getContext2d
        * @memberOf me.Renderer.prototype
        * @function
        * @param {HTMLCanvasElement} canvas
        * @param {Boolean} [transparent=true] use false to disable transparency
        * @return {Context2d}
        */ getContext2d: function getContext2d(c, transparent) {
                if (typeof c === "undefined" || c === null) throw new Error("You must pass a canvas element in order to create a 2d context");
                if (typeof c.getContext === "undefined") throw new Error("Your browser does not support HTML5 canvas.");
                if (typeof transparent !== "boolean") transparent = true;
                var _context = c.getContext("2d", {
                    "alpha": transparent
                });
                if (!_context.canvas) _context.canvas = c;
                this.setAntiAlias(_context, this.settings.antiAlias);
                return _context;
            },
            /**
        * return the width of the system Canvas
        * @name getWidth
        * @memberOf me.Renderer.prototype
        * @function
        * @return {Number}
        */ getWidth: function getWidth() {
                return this.backBufferCanvas.width;
            },
            /**
        * return the height of the system Canvas
        * @name getHeight
        * @memberOf me.Renderer.prototype
        * @function
        * @return {Number}
        */ getHeight: function getHeight() {
                return this.backBufferCanvas.height;
            },
            /**
        * get the current fill & stroke style color.
        * @name getColor
        * @memberOf me.Renderer.prototype
        * @function
        * @param {me.Color} current global color
        */ getColor: function getColor() {
                return this.currentColor;
            },
            /**
        * return the current global alpha
        * @name globalAlpha
        * @memberOf me.Renderer.prototype
        * @function
        * @return {Number}
        */ globalAlpha: function globalAlpha() {
                return this.currentColor.glArray[3];
            },
            /**
        * check if the given rectangle overlaps with the renderer screen coordinates
        * @name overlaps
        * @memberOf me.Renderer.prototype
        * @function
        * @param  {me.Rect} rect
        * @return {boolean} true if overlaps
        */ overlaps: function overlaps(rect) {
                return rect.left < this.getWidth() && rect.right > 0 && rect.top < this.getHeight() && rect.bottom > 0;
            },
            /**
        * resizes the system canvas
        * @name resize
        * @memberOf me.Renderer.prototype
        * @function
        * @param {Number} width new width of the canvas
        * @param {Number} height new height of the canvas
        */ resize: function resize(width, height) {
                if (width !== this.backBufferCanvas.width || height !== this.backBufferCanvas.height) {
                    this.canvas.width = this.backBufferCanvas.width = width;
                    this.canvas.height = this.backBufferCanvas.height = height;
                    this.currentScissor[0] = 0;
                    this.currentScissor[1] = 0;
                    this.currentScissor[2] = width;
                    this.currentScissor[3] = height; // publish the corresponding event
                    me.event.publish(me.event.CANVAS_ONRESIZE, [
                        width,
                        height
                    ]);
                }
            },
            /**
        * enable/disable image smoothing (scaling interpolation) for the given context
        * @name setAntiAlias
        * @memberOf me.Renderer.prototype
        * @function
        * @param {Context2d} context
        * @param {Boolean} [enable=false]
        */ setAntiAlias: function setAntiAlias(context, enable) {
                var canvas = context.canvas; // enable/disable antialis on the given Context2d object
                me.agent.setPrefixed("imageSmoothingEnabled", enable === true, context); // set antialias CSS property on the main canvas
                if (enable !== true) {
                    // https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering
                    canvas.style["image-rendering"] = "optimizeSpeed"; // legal fallback
                    canvas.style["image-rendering"] = "-moz-crisp-edges"; // Firefox
                    canvas.style["image-rendering"] = "-o-crisp-edges"; // Opera
                    canvas.style["image-rendering"] = "-webkit-optimize-contrast"; // Safari
                    canvas.style["image-rendering"] = "optimize-contrast"; // CSS 3
                    canvas.style["image-rendering"] = "crisp-edges"; // CSS 4
                    canvas.style["image-rendering"] = "pixelated"; // CSS 4
                    canvas.style.msInterpolationMode = "nearest-neighbor"; // IE8+
                } else canvas.style["image-rendering"] = "auto";
            },
            /**
        * set/change the current projection matrix (WebGL only)
        * @name setProjection
        * @memberOf me.Renderer.prototype
        * @function
        * @param {me.Matrix3d} matrix
        */ setProjection: function setProjection(matrix) {
                this.projectionMatrix.copy(matrix);
            },
            /**
        * stroke the given shape
        * @name stroke
        * @memberOf me.Renderer.prototype
        * @function
        * @param {me.Rect|me.Polygon|me.Line|me.Ellipse} shape a shape object to stroke
        */ stroke: function stroke(shape, fill) {
                if (shape.shapeType === "Rectangle") this.strokeRect(shape.left, shape.top, shape.width, shape.height, fill);
                else if (shape instanceof me.Line || shape instanceof me.Polygon) this.strokePolygon(shape, fill);
                else if (shape instanceof me.Ellipse) this.strokeEllipse(shape.pos.x, shape.pos.y, shape.radiusV.x, shape.radiusV.y, fill);
            },
            /**
        * tint the given image or canvas using the given color
        * @name tint
        * @memberOf me.Renderer.prototype
        * @function
        * @param {HTMLImageElement|HTMLCanvasElement|OffscreenCanvas} image the source image to be tinted
        * @param {me.Color|String} color the color that will be used to tint the image
        * @param {String} [mode="multiply"] the composition mode used to tint the image
        * @return {HTMLCanvasElement|OffscreenCanvas} a new canvas element representing the tinted image
        */ tint: function tint(src, color, mode) {
                var canvas = me.video.createCanvas(src.width, src.height, true);
                var context = this.getContext2d(canvas);
                context.save();
                context.fillStyle = color instanceof me.Color ? color.toRGB() : color;
                context.fillRect(0, 0, src.width, src.height);
                context.globalCompositeOperation = mode || "multiply";
                context.drawImage(src, 0, 0);
                context.globalCompositeOperation = "destination-atop";
                context.drawImage(src, 0, 0);
                context.restore();
                return canvas;
            },
            /**
        * fill the given shape
        * @name fill
        * @memberOf me.Renderer.prototype
        * @function
        * @param {me.Rect|me.Polygon|me.Line|me.Ellipse} shape a shape object to fill
        */ fill: function fill(shape) {
                this.stroke(shape, true);
            },
            /**
        * A mask limits rendering elements to the shape and position of the given mask object.
        * So, if the renderable is larger than the mask, only the intersecting part of the renderable will be visible.
        * Mask are not preserved through renderer context save and restore.
        * @name setMask
        * @memberOf me.Renderer.prototype
        * @function
        * @param {me.Rect|me.Polygon|me.Line|me.Ellipse} [mask] the shape defining the mask to be applied
        */ setMask: function setMask(mask) {
            },
            /**
        * disable (remove) the rendering mask set through setMask.
        * @name clearMask
        * @see me.Renderer#setMask
        * @memberOf me.Renderer.prototype
        * @function
        */ clearMask: function clearMask() {
            },
            /**
        * set a coloring tint for sprite based renderables
        * @name setTint
        * @memberOf me.Renderer.prototype
        * @function
        * @param {me.Color} [tint] the tint color
        */ setTint: function setTint(tint1) {
                // global tint color
                this.currentTint.copy(tint1);
            },
            /**
        * clear the rendering tint set through setTint.
        * @name clearTint
        * @see me.Renderer#setTint
        * @memberOf me.Renderer.prototype
        * @function
        */ clearTint: function clearTint() {
                // reset to default
                this.currentTint.setColor(255, 255, 255, 1);
            },
            /**
        * @ignore
        */ drawFont: function drawFont() /*bounds*/ {
            }
        });
    })();
    (function() {
        /**
      * A Texture atlas object, currently supports : <br>
      * - [TexturePacker]{@link http://www.codeandweb.com/texturepacker/} : through JSON export (standard and multipack texture atlas) <br>
      * - [ShoeBox]{@link http://renderhjs.net/shoebox/} : through JSON export using the
      * melonJS setting [file]{@link https://github.com/melonjs/melonJS/raw/master/media/shoebox_JSON_export.sbx} <br>
      * - [Free Texture Packer]{@link http://free-tex-packer.com/app/} : through JSON export (standard and multipack texture atlas) <br>
      * - Standard (fixed cell size) spritesheet : through a {framewidth:xx, frameheight:xx, anchorPoint:me.Vector2d} object
      * @class
      * @extends me.Object
      * @memberOf me.Renderer
      * @name Texture
      * @constructor
      * @param {Object|Object[]} atlas atlas information. See {@link me.loader.getJSON}
      * @param {HTMLImageElement|HTMLCanvasElement|String|HTMLImageElement[]|HTMLCanvasElement[]|String[]} [source=atlas.meta.image] Image source
      * @param {Boolean} [cached=false] Use true to skip caching this Texture
      * @example
      * // create a texture atlas from a JSON Object
      * game.texture = new me.video.renderer.Texture(
      *     me.loader.getJSON("texture")
      * );
      *
      * // create a texture atlas from a multipack JSON Object
      * game.texture = new me.video.renderer.Texture([
      *     me.loader.getJSON("texture-0"),
      *     me.loader.getJSON("texture-1"),
      *     me.loader.getJSON("texture-2")
      * ]);
      *
      * // create a texture atlas for a spritesheet with an anchorPoint in the center of each frame
      * game.texture = new me.video.renderer.Texture(
      *     {
      *         framewidth : 32,
      *         frameheight : 32,
      *         anchorPoint : new me.Vector2d(0.5, 0.5)
      *     },
      *     me.loader.getImage("spritesheet")
      * );
      */ me.Renderer.prototype.Texture = me.Object.extend({
            /**
        * @ignore
        */ init: function init(atlases, src, cache) {
                /**
          * to identify the atlas format (e.g. texture packer)
          * @ignore
          */ this.format = null;
                /**
          * the texture source(s) itself
          * @type Map
          * @ignore
          */ this.sources = new Map();
                /**
          * the atlas dictionnaries
          * @type Map
          * @ignore
          */ this.atlases = new Map(); // parse given atlas(es) paremeters
                if (typeof atlases !== "undefined") {
                    // normalize to array to keep the following code generic
                    atlases = Array.isArray(atlases) ? atlases : [
                        atlases
                    ];
                    for(var i in atlases){
                        var atlas = atlases[i];
                        if (typeof atlas.meta !== "undefined") {
                            // Texture Packer or Free Texture Packer
                            if (atlas.meta.app.includes("texturepacker") || atlas.meta.app.includes("free-tex-packer")) {
                                this.format = "texturepacker"; // set the texture
                                if (typeof src === "undefined") {
                                    // get the texture name from the atlas meta data
                                    var image = me.loader.getImage(atlas.meta.image);
                                    if (!image) throw new Error("Atlas texture '" + image + "' not found");
                                    this.sources.set(atlas.meta.image, image);
                                } else this.sources.set(atlas.meta.image || "default", typeof src === "string" ? me.loader.getImage(src) : src);
                                this.repeat = "no-repeat";
                            } else if (atlas.meta.app.includes("ShoeBox")) {
                                if (!atlas.meta.exporter || !atlas.meta.exporter.includes("melonJS")) throw new Error("ShoeBox requires the JSON exporter : https://github.com/melonjs/melonJS/tree/master/media/shoebox_JSON_export.sbx");
                                this.format = "ShoeBox";
                                this.repeat = "no-repeat";
                                this.sources.set("default", typeof src === "string" ? me.loader.getImage(src) : src);
                            } else if (atlas.meta.app.includes("melonJS")) {
                                this.format = "melonJS";
                                this.repeat = atlas.meta.repeat || "no-repeat";
                                this.sources.set("default", typeof src === "string" ? me.loader.getImage(src) : src);
                            } // initialize the atlas
                            this.atlases.set(atlas.meta.image || "default", this.parse(atlas));
                        } else // a regular spritesheet
                        if (typeof atlas.framewidth !== "undefined" && typeof atlas.frameheight !== "undefined") {
                            this.format = "Spritesheet (fixed cell size)";
                            this.repeat = "no-repeat";
                            if (typeof src !== "undefined") // overwrite if specified
                            atlas.image = typeof src === "string" ? me.loader.getImage(src) : src;
                             // initialize the atlas
                            this.atlases.set("default", this.parseFromSpriteSheet(atlas));
                            this.sources.set("default", atlas.image);
                        }
                    } // end forEach
                } // if format not recognized
                if (this.atlases.length === 0) throw new Error("texture atlas format not supported");
                 // Add self to TextureCache if cache !== false
                if (cache !== false) {
                    var _iterator = _createForOfIteratorHelper(this.sources), _step;
                    try {
                        for(_iterator.s(); !(_step = _iterator.n()).done;){
                            var source = _step.value;
                            if (cache instanceof me.Renderer.TextureCache) cache.set(source, this);
                            else me.video.renderer.cache.set(source, this);
                        }
                    } catch (err) {
                        _iterator.e(err);
                    } finally{
                        _iterator.f();
                    }
                }
            },
            /**
        * create a simple 1 frame texture atlas based on the given parameters
        * @ignore
        */ createAtlas: function createAtlas(width, height, name, repeat) {
                return {
                    "meta": {
                        "app": "melonJS",
                        "size": {
                            "w": width,
                            "h": height
                        },
                        "repeat": repeat || "no-repeat",
                        "image": "default"
                    },
                    "frames": [
                        {
                            "filename": name || "default",
                            "frame": {
                                "x": 0,
                                "y": 0,
                                "w": width,
                                "h": height
                            }
                        }
                    ]
                };
            },
            /**
        * build an atlas from the given data
        * @ignore
        */ parse: function parse(data) {
                var atlas = {
                };
                var self = this;
                data.frames.forEach(function(frame) {
                    // fix wrongly formatted JSON (e.g. last dummy object in ShoeBox)
                    if (frame.hasOwnProperty("filename")) {
                        // Source coordinates
                        var s = frame.frame;
                        var originX, originY; // Pixel-based offset origin from the top-left of the source frame
                        var hasTextureAnchorPoint = frame.spriteSourceSize && frame.sourceSize && frame.pivot;
                        if (hasTextureAnchorPoint) {
                            originX = frame.sourceSize.w * frame.pivot.x - (frame.trimmed ? frame.spriteSourceSize.x : 0);
                            originY = frame.sourceSize.h * frame.pivot.y - (frame.trimmed ? frame.spriteSourceSize.y : 0);
                        }
                        atlas[frame.filename] = {
                            name: frame.filename,
                            // frame name
                            texture: data.meta.image || "default",
                            // the source texture
                            offset: new me.Vector2d(s.x, s.y),
                            anchorPoint: hasTextureAnchorPoint ? new me.Vector2d(originX / s.w, originY / s.h) : null,
                            trimmed: !!frame.trimmed,
                            width: s.w,
                            height: s.h,
                            angle: frame.rotated === true ? -me.Math.ETA : 0
                        };
                        self.addUvsMap(atlas, frame.filename, data.meta.size.w, data.meta.size.h);
                    }
                });
                return atlas;
            },
            /**
        * build an atlas from the given spritesheet
        * @ignore
        */ parseFromSpriteSheet: function parseFromSpriteSheet(data) {
                var atlas = {
                };
                var image = data.image;
                var spacing = data.spacing || 0;
                var margin = data.margin || 0;
                var width = image.width;
                var height = image.height; // calculate the sprite count (line, col)
                var spritecount = me.pool.pull("me.Vector2d", ~~((width - margin + spacing) / (data.framewidth + spacing)), ~~((height - margin + spacing) / (data.frameheight + spacing))); // verifying the texture size
                if (width % (data.framewidth + spacing) !== 0 || height % (data.frameheight + spacing) !== 0) {
                    var computed_width = spritecount.x * (data.framewidth + spacing);
                    var computed_height = spritecount.y * (data.frameheight + spacing);
                    if (computed_width - width !== spacing && computed_height - height !== spacing) {
                        // "truncate size" if delta is different from the spacing size
                        width = computed_width;
                        height = computed_height; // warning message
                        console.warn("Spritesheet Texture for image: " + image.src + " is not divisible by " + (data.framewidth + spacing) + "x" + (data.frameheight + spacing) + ", truncating effective size to " + width + "x" + height);
                    }
                } // build the local atlas
                for(var frame = 0, count = spritecount.x * spritecount.y; frame < count; frame++){
                    var name = "" + frame;
                    atlas[name] = {
                        name: name,
                        texture: "default",
                        // the source texture
                        offset: new me.Vector2d(margin + (spacing + data.framewidth) * (frame % spritecount.x), margin + (spacing + data.frameheight) * ~~(frame / spritecount.x)),
                        anchorPoint: data.anchorPoint || null,
                        trimmed: false,
                        width: data.framewidth,
                        height: data.frameheight,
                        angle: 0
                    };
                    this.addUvsMap(atlas, name, width, height);
                }
                me.pool.push(spritecount);
                return atlas;
            },
            /**
        * @ignore
        */ addUvsMap: function addUvsMap(atlas, frame, w, h) {
                // ignore if using the Canvas Renderer
                if (me.video.renderer instanceof me.WebGLRenderer) {
                    // Source coordinates
                    var s = atlas[frame].offset;
                    var sw = atlas[frame].width;
                    var sh = atlas[frame].height;
                    atlas[frame].uvs = new Float32Array([
                        s.x / w,
                        s.y / h,
                        (s.x + sw) / w,
                        (s.y + sh) / h // Bottom
                    ]); // Cache source coordinates
                    // TODO: Remove this when the Batcher only accepts a region name
                    var key = s.x + "," + s.y + "," + w + "," + h;
                    atlas[key] = atlas[frame];
                }
                return atlas[frame];
            },
            /**
        * @ignore
        */ addQuadRegion: function addQuadRegion(name, x, y, w, h) {
                // TODO: Require proper atlas regions instead of caching arbitrary region keys
                if (me.video.renderer.settings.verbose === true) console.warn("Adding texture region", name, "for texture", this);
                var source = this.getTexture();
                var atlas = this.getAtlas();
                var dw = source.width;
                var dh = source.height;
                atlas[name] = {
                    name: name,
                    offset: new me.Vector2d(x, y),
                    width: w,
                    height: h,
                    angle: 0
                };
                this.addUvsMap(atlas, name, dw, dh);
                return atlas[name];
            },
            /**
        * return the default or specified atlas dictionnary
        * @name getAtlas
        * @memberOf me.Renderer.Texture
        * @function
        * @param {String} [name] atlas name in case of multipack textures
        * @return {Object}
        */ getAtlas: function getAtlas(key) {
                if (typeof key === "string") return this.atlases.get(key);
                else return this.atlases.values().next().value;
            },
            /**
        * return the source texture for the given region (or default one if none specified)
        * @name getTexture
        * @memberOf me.Renderer.Texture
        * @function
        * @param {Object} [region] region name in case of multipack textures
        * @return {HTMLImageElement|HTMLCanvasElement}
        */ getTexture: function getTexture(region) {
                if (_typeof(region) === "object" && typeof region.texture === "string") return this.sources.get(region.texture);
                else return this.sources.values().next().value;
            },
            /**
        * return a normalized region (or frame) information for the specified sprite name
        * @name getRegion
        * @memberOf me.Renderer.Texture
        * @function
        * @param {String} name name of the sprite
        * @param {String} [atlas] name of a specific atlas where to search for the region
        * @return {Object}
        */ getRegion: function getRegion(name, atlas) {
                var region;
                if (typeof atlas === "string") region = this.getAtlas(atlas)[name];
                else // look for the given region in each existing atlas
                this.atlases.forEach(function(atlas1) {
                    if (typeof atlas1[name] !== "undefined") // there should be only one
                    region = atlas1[name];
                });
                return region;
            },
            /**
        * return the uvs mapping for the given region
        * @name getUVs
        * @memberOf me.Renderer.Texture
        * @function
        * @param {Object} region region (or frame) name
        * @return {Float32Array} region Uvs
        */ getUVs: function getUVs(name) {
                // Get the source texture region
                var region = this.getRegion(name);
                if (typeof region === "undefined") {
                    // TODO: Require proper atlas regions instead of caching arbitrary region keys
                    var keys = name.split(","), sx = +keys[0], sy = +keys[1], sw = +keys[2], sh = +keys[3];
                    region = this.addQuadRegion(name, sx, sy, sw, sh);
                }
                return region.uvs;
            },
            /**
        * Create a sprite object using the first region found using the specified name
        * @name createSpriteFromName
        * @memberOf me.Renderer.Texture
        * @function
        * @param {String} name name of the sprite
        * @param {Object} [settings] Additional settings passed to the {@link me.Sprite} contructor
        * @return {me.Sprite}
        * @example
        * // create a new texture object under the `game` namespace
        * game.texture = new me.video.renderer.Texture(
        *    me.loader.getJSON("texture"),
        *    me.loader.getImage("texture")
        * );
        * ...
        * ...
        * // add the coin sprite as renderable for the entity
        * var sprite = game.texture.createSpriteFromName("coin.png");
        * // set the renderable position to bottom center
        * sprite.anchorPoint.set(0.5, 1.0);
        */ createSpriteFromName: function createSpriteFromName(name, settings) {
                // instantiate a new sprite object
                return me.pool.pull("me.Sprite", 0, 0, Object.assign({
                    image: this,
                    region: name
                }, settings || {
                }));
            },
            /**
        * Create an animation object using the first region found using all specified names
        * @name createAnimationFromName
        * @memberOf me.Renderer.Texture
        * @function
        * @param {String[]|Number[]} names list of names for each sprite
        * (when manually creating a Texture out of a spritesheet, only numeric values are authorized)
        * @param {Object} [settings] Additional settings passed to the {@link me.Sprite} contructor
        * @return {me.Sprite}
        * @example
        * // create a new texture object under the `game` namespace
        * game.texture = new me.video.renderer.Texture(
        *     me.loader.getJSON("texture"),
        *     me.loader.getImage("texture")
        * );
        *
        * // create a new Sprite as renderable for the entity
        * var sprite = game.texture.createAnimationFromName([
        *     "walk0001.png", "walk0002.png", "walk0003.png",
        *     "walk0004.png", "walk0005.png", "walk0006.png",
        *     "walk0007.png", "walk0008.png", "walk0009.png",
        *     "walk0010.png", "walk0011.png"
        * ]);
        *
        * // define an additional basic walking animation
        * sprite.addAnimation ("simple_walk", [0,2,1]);
        * // you can also use frame name to define your animation
        * sprite.addAnimation ("speed_walk", ["walk0007.png", "walk0008.png", "walk0009.png", "walk0010.png"]);
        * // set the default animation
        * sprite.setCurrentAnimation("simple_walk");
        * // set the renderable position to bottom center
        * sprite.anchorPoint.set(0.5, 1.0);
        */ createAnimationFromName: function createAnimationFromName(names, settings) {
                var tpAtlas = [], indices = {
                };
                var width = 0, height = 0;
                var region; // iterate through the given names
                // and create a "normalized" atlas
                for(var i = 0; i < names.length; ++i){
                    region = this.getRegion(names[i]);
                    if (region == null) // throw an error
                    throw new Error("Texture - region for " + names[i] + " not found");
                    tpAtlas[i] = region; // save the corresponding index
                    indices[names[i]] = i; // calculate the max size of a frame
                    width = Math.max(region.width, width);
                    height = Math.max(region.height, height);
                } // instantiate a new animation sheet object
                return new me.Sprite(0, 0, Object.assign({
                    image: this,
                    framewidth: width,
                    frameheight: height,
                    margin: 0,
                    spacing: 0,
                    atlas: tpAtlas,
                    atlasIndices: indices
                }, settings || {
                }));
            }
        });
    })();
    (function() {
        /**
      * a basic texture cache object
      * @ignore
      */ me.Renderer.TextureCache = me.Object.extend({
            /**
        * @ignore
        */ init: function init(max_size) {
                this.cache = new Map();
                this.tinted = new Map();
                this.units = new Map();
                this.max_size = max_size || Infinity;
                this.clear();
            },
            /**
        * @ignore
        */ clear: function clear() {
                this.cache.clear();
                this.tinted.clear();
                this.units.clear();
                this.length = 0;
            },
            /**
        * @ignore
        */ validate: function validate() {
                if (this.length >= this.max_size) // TODO: Merge textures instead of throwing an exception
                throw new Error("Texture cache overflow: " + this.max_size + " texture units available for this GPU.");
            },
            /**
        * @ignore
        */ get: function get(image, atlas) {
                if (!this.cache.has(image)) {
                    if (!atlas) atlas = me.video.renderer.Texture.prototype.createAtlas.apply(me.video.renderer.Texture.prototype, [
                        image.width,
                        image.height,
                        image.src ? me.utils.file.getBasename(image.src) : undefined
                    ]);
                    this.set(image, new me.video.renderer.Texture(atlas, image, false));
                }
                return this.cache.get(image);
            },
            /**
        * @ignore
        */ tint: function tint(src, color) {
                // make sure the src is in the cache
                var image_cache = this.tinted.get(src);
                if (image_cache === undefined) image_cache = this.tinted.set(src, new Map());
                if (!image_cache.has(color)) image_cache.set(color, me.video.renderer.tint(src, color, "multiply"));
                return image_cache.get(color);
            },
            /**
        * @ignore
        */ set: function set(image, texture) {
                var width = image.width;
                var height = image.height; // warn if a non POT texture is added to the cache when using WebGL1
                if (me.video.renderer.WebGLVersion === 1 && (!me.Math.isPowerOfTwo(width) || !me.Math.isPowerOfTwo(height))) {
                    var src = typeof image.src !== "undefined" ? image.src : image;
                    console.warn("[Texture] " + src + " is not a POT texture " + "(" + width + "x" + height + ")");
                }
                this.cache.set(image, texture);
            },
            /**
        * @ignore
        */ getUnit: function getUnit(texture) {
                if (!this.units.has(texture)) {
                    this.validate();
                    this.units.set(texture, this.length++);
                }
                return this.units.get(texture);
            }
        });
    })();
    (function() {
        /**
      * a canvas renderer object
      * @class
      * @extends me.Renderer
      * @memberOf me
      * @constructor
      * @param {Object} options The renderer parameters
      * @param {Number} options.width The width of the canvas without scaling
      * @param {Number} options.height The height of the canvas without scaling
      * @param {HTMLCanvasElement} [options.canvas] The html canvas to draw to on screen
      * @param {Boolean} [options.doubleBuffering=false] Whether to enable double buffering
      * @param {Boolean} [options.antiAlias=false] Whether to enable anti-aliasing
      * @param {Boolean} [options.transparent=false] Whether to enable transparency on the canvas (performance hit when enabled)
      * @param {Boolean} [options.subPixel=false] Whether to enable subpixel renderering (performance hit when enabled)
      * @param {Boolean} [options.textureSeamFix=true] enable the texture seam fix when rendering Tile when antiAlias is off for the canvasRenderer
      * @param {Number} [options.zoomX=width] The actual width of the canvas with scaling applied
      * @param {Number} [options.zoomY=height] The actual height of the canvas with scaling applied
      */ me.CanvasRenderer = me.Renderer.extend({
            /**
        * @ignore
        */ init: function init(options) {
                // parent constructor
                this._super(me.Renderer, "init", [
                    options
                ]); // defined the 2d context
                this.context = this.getContext2d(this.getScreenCanvas(), this.settings.transparent); // create the back buffer if we use double buffering
                if (this.settings.doubleBuffering) {
                    this.backBufferCanvas = me.video.createCanvas(this.settings.width, this.settings.height, true);
                    this.backBufferContext2D = this.getContext2d(this.backBufferCanvas);
                } else {
                    this.backBufferCanvas = this.getScreenCanvas();
                    this.backBufferContext2D = this.context;
                }
                this.setBlendMode(this.settings.blendMode); // apply the default color to the 2d context
                this.setColor(this.currentColor); // create a texture cache
                this.cache = new me.Renderer.TextureCache();
                if (this.settings.textureSeamFix !== false && !this.settings.antiAlias) // enable the tile texture seam fix with the canvas renderer
                this.uvOffset = 1;
                return this;
            },
            /**
        * Reset context state
        * @name reset
        * @memberOf me.CanvasRenderer.prototype
        * @function
        */ reset: function reset() {
                this._super(me.Renderer, "reset");
                this.clearColor(this.currentColor, this.settings.transparent !== true);
            },
            /**
        * Reset the canvas transform to identity
        * @name resetTransform
        * @memberOf me.CanvasRenderer.prototype
        * @function
        */ resetTransform: function resetTransform() {
                this.backBufferContext2D.setTransform(1, 0, 0, 1, 0, 0);
            },
            /**
        * Set a blend mode for the given context
        * @name setBlendMode
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {String} [mode="normal"] blend mode : "normal", "multiply"
        * @param {Context2d} [context]
        */ setBlendMode: function setBlendMode(mode, context) {
                context = context || this.getContext();
                this.currentBlendMode = mode;
                switch(mode){
                    case "multiply":
                        context.globalCompositeOperation = "multiply";
                        break;
                    default:
                        // normal
                        context.globalCompositeOperation = "source-over";
                        this.currentBlendMode = "normal";
                        break;
                } // transparent setting will override the given blendmode for this.context
                if (this.settings.doubleBuffering && this.settings.transparent) // Clears the front buffer for each frame blit
                this.context.globalCompositeOperation = "copy";
            },
            /**
        * prepare the framebuffer for drawing a new frame
        * @name clear
        * @memberOf me.CanvasRenderer.prototype
        * @function
        */ clear: function clear() {
                if (this.settings.transparent) this.clearColor("rgba(0,0,0,0)", true);
            },
            /**
        * render the main framebuffer on screen
        * @name flush
        * @memberOf me.CanvasRenderer.prototype
        * @function
        */ flush: function flush() {
                if (this.settings.doubleBuffering) this.context.drawImage(this.backBufferCanvas, 0, 0);
            },
            /**
        * Clears the main framebuffer with the given color
        * @name clearColor
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {me.Color|String} color CSS color.
        * @param {Boolean} [opaque=false] Allow transparency [default] or clear the surface completely [true]
        */ clearColor: function clearColor(col, opaque) {
                this.save();
                this.resetTransform();
                this.backBufferContext2D.globalCompositeOperation = opaque ? "copy" : "source-over";
                this.backBufferContext2D.fillStyle = col instanceof me.Color ? col.toRGBA() : col;
                this.fillRect(0, 0, this.backBufferCanvas.width, this.backBufferCanvas.height);
                this.restore();
            },
            /**
        * Erase the pixels in the given rectangular area by setting them to transparent black (rgba(0,0,0,0)).
        * @name clearRect
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} x x axis of the coordinate for the rectangle starting point.
        * @param {Number} y y axis of the coordinate for the rectangle starting point.
        * @param {Number} width The rectangle's width.
        * @param {Number} height The rectangle's height.
        */ clearRect: function clearRect(x, y, width, height) {
                this.backBufferContext2D.clearRect(x, y, width, height);
            },
            /**
        * Create a pattern with the specified repetition
        * @name createPattern
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {image} image Source image
        * @param {String} repeat Define how the pattern should be repeated
        * @return {CanvasPattern}
        * @see me.ImageLayer#repeat
        * @example
        * var tileable   = renderer.createPattern(image, "repeat");
        * var horizontal = renderer.createPattern(image, "repeat-x");
        * var vertical   = renderer.createPattern(image, "repeat-y");
        * var basic      = renderer.createPattern(image, "no-repeat");
        */ createPattern: function createPattern(image, repeat) {
                return this.backBufferContext2D.createPattern(image, repeat);
            },
            /**
        * Draw an image onto the main using the canvas api
        * @name drawImage
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Image} image An element to draw into the context. The specification permits any canvas image source (CanvasImageSource), specifically, a CSSImageValue, an HTMLImageElement, an SVGImageElement, an HTMLVideoElement, an HTMLCanvasElement, an ImageBitmap, or an OffscreenCanvas.
        * @param {Number} sx The X coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
        * @param {Number} sy The Y coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
        * @param {Number} sw The width of the sub-rectangle of the source image to draw into the destination context. If not specified, the entire rectangle from the coordinates specified by sx and sy to the bottom-right corner of the image is used.
        * @param {Number} sh The height of the sub-rectangle of the source image to draw into the destination context.
        * @param {Number} dx The X coordinate in the destination canvas at which to place the top-left corner of the source image.
        * @param {Number} dy The Y coordinate in the destination canvas at which to place the top-left corner of the source image.
        * @param {Number} dWidth The width to draw the image in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in width when drawn.
        * @param {Number} dHeight The height to draw the image in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in height when drawn.
        * @example
        * // Position the image on the canvas:
        * renderer.drawImage(image, dx, dy);
        * // Position the image on the canvas, and specify width and height of the image:
        * renderer.drawImage(image, dx, dy, dWidth, dHeight);
        * // Clip the image and position the clipped part on the canvas:
        * renderer.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        */ drawImage: function drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
                if (this.backBufferContext2D.globalAlpha < 1 / 255) // Fast path: don't draw fully transparent
                return;
                if (typeof sw === "undefined") {
                    sw = dw = image.width;
                    sh = dh = image.height;
                    dx = sx;
                    dy = sy;
                    sx = 0;
                    sy = 0;
                } else if (typeof dx === "undefined") {
                    dx = sx;
                    dy = sy;
                    dw = sw;
                    dh = sh;
                    sw = image.width;
                    sh = image.height;
                    sx = 0;
                    sy = 0;
                }
                if (this.settings.subPixel === false) {
                    // clamp to pixel grid
                    dx = ~~dx;
                    dy = ~~dy;
                } // apply a tint if required
                var source = image;
                var tint = this.currentTint.toArray();
                if (tint[0] !== 1 || tint[1] !== 1 || tint[2] !== 1) // get a tinted version of this image from the texture cache
                source = this.cache.tint(image, this.currentTint.toRGB());
                this.backBufferContext2D.drawImage(source, sx, sy, sw, sh, dx, dy, dw, dh);
            },
            /**
        * Draw a pattern within the given rectangle.
        * @name drawPattern
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {CanvasPattern} pattern Pattern object
        * @param {Number} x
        * @param {Number} y
        * @param {Number} width
        * @param {Number} height
        * @see me.CanvasRenderer#createPattern
        */ drawPattern: function drawPattern(pattern, x, y, width, height) {
                if (this.backBufferContext2D.globalAlpha < 1 / 255) // Fast path: don't draw fully transparent
                return;
                var fillStyle = this.backBufferContext2D.fillStyle;
                this.backBufferContext2D.fillStyle = pattern;
                this.backBufferContext2D.fillRect(x, y, width, height);
                this.backBufferContext2D.fillStyle = fillStyle;
            },
            /**
        * Stroke an arc at the specified coordinates with given radius, start and end points
        * @name strokeArc
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} x arc center point x-axis
        * @param {Number} y arc center point y-axis
        * @param {Number} radius
        * @param {Number} start start angle in radians
        * @param {Number} end end angle in radians
        * @param {Boolean} [antiClockwise=false] draw arc anti-clockwise
        */ strokeArc: function strokeArc(x, y, radius, start, end, antiClockwise, fill) {
                var context = this.backBufferContext2D;
                if (context.globalAlpha < 1 / 255) // Fast path: don't draw fully transparent
                return;
                context.translate(x, y);
                context.beginPath();
                context.arc(0, 0, radius, start, end, antiClockwise || false);
                context[fill === true ? "fill" : "stroke"]();
                context.translate(-x, -y);
            },
            /**
        * Fill an arc at the specified coordinates with given radius, start and end points
        * @name fillArc
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} x arc center point x-axis
        * @param {Number} y arc center point y-axis
        * @param {Number} radius
        * @param {Number} start start angle in radians
        * @param {Number} end end angle in radians
        * @param {Boolean} [antiClockwise=false] draw arc anti-clockwise
        */ fillArc: function fillArc(x, y, radius, start, end, antiClockwise) {
                this.strokeArc(x, y, radius, start, end, antiClockwise || false, true);
            },
            /**
        * Stroke an ellipse at the specified coordinates with given radius
        * @name strokeEllipse
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} x ellipse center point x-axis
        * @param {Number} y ellipse center point y-axis
        * @param {Number} w horizontal radius of the ellipse
        * @param {Number} h vertical radius of the ellipse
        */ strokeEllipse: function strokeEllipse(x, y, w, h, fill) {
                var context = this.backBufferContext2D;
                if (context.globalAlpha < 1 / 255) // Fast path: don't draw fully transparent
                return;
                var hw = w, hh = h, lx = x - hw, rx = x + hw, ty = y - hh, by = y + hh;
                var xmagic = hw * 0.551784, ymagic = hh * 0.551784, xmin = x - xmagic, xmax = x + xmagic, ymin = y - ymagic, ymax = y + ymagic;
                context.beginPath();
                context.moveTo(x, ty);
                context.bezierCurveTo(xmax, ty, rx, ymin, rx, y);
                context.bezierCurveTo(rx, ymax, xmax, by, x, by);
                context.bezierCurveTo(xmin, by, lx, ymax, lx, y);
                context.bezierCurveTo(lx, ymin, xmin, ty, x, ty);
                context[fill === true ? "fill" : "stroke"]();
                context.closePath();
            },
            /**
        * Fill an ellipse at the specified coordinates with given radius
        * @name fillEllipse
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} x ellipse center point x-axis
        * @param {Number} y ellipse center point y-axis
        * @param {Number} w horizontal radius of the ellipse
        * @param {Number} h vertical radius of the ellipse
        */ fillEllipse: function fillEllipse(x, y, w, h) {
                this.strokeEllipse(x, y, w, h, true);
            },
            /**
        * Stroke a line of the given two points
        * @name strokeLine
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} startX the start x coordinate
        * @param {Number} startY the start y coordinate
        * @param {Number} endX the end x coordinate
        * @param {Number} endY the end y coordinate
        */ strokeLine: function strokeLine(startX, startY, endX, endY) {
                var context = this.backBufferContext2D;
                if (context < 1 / 255) // Fast path: don't draw fully transparent
                return;
                context.beginPath();
                context.moveTo(startX, startY);
                context.lineTo(endX, endY);
                context.stroke();
            },
            /**
        * Fill a line of the given two points
        * @name fillLine
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} startX the start x coordinate
        * @param {Number} startY the start y coordinate
        * @param {Number} endX the end x coordinate
        * @param {Number} endY the end y coordinate
        */ fillLine: function fillLine(startX, startY, endX, endY) {
                this.strokeLine(startX, startY, endX, endY);
            },
            /**
        * Stroke the given me.Polygon on the screen
        * @name strokePolygon
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {me.Polygon} poly the shape to draw
        */ strokePolygon: function strokePolygon(poly, fill) {
                var context = this.backBufferContext2D;
                if (context.globalAlpha < 1 / 255) // Fast path: don't draw fully transparent
                return;
                this.translate(poly.pos.x, poly.pos.y);
                context.beginPath();
                context.moveTo(poly.points[0].x, poly.points[0].y);
                var point;
                for(var i = 1; i < poly.points.length; i++){
                    point = poly.points[i];
                    context.lineTo(point.x, point.y);
                }
                context.lineTo(poly.points[0].x, poly.points[0].y);
                context[fill === true ? "fill" : "stroke"]();
                context.closePath();
                this.translate(-poly.pos.x, -poly.pos.y);
            },
            /**
        * Fill the given me.Polygon on the screen
        * @name fillPolygon
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {me.Polygon} poly the shape to draw
        */ fillPolygon: function fillPolygon(poly) {
                this.strokePolygon(poly, true);
            },
            /**
        * Stroke a rectangle at the specified coordinates
        * @name strokeRect
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} x
        * @param {Number} y
        * @param {Number} width
        * @param {Number} height
        */ strokeRect: function strokeRect(x, y, width, height, fill) {
                if (fill === true) this.fillRect(x, y, width, height);
                else {
                    if (this.backBufferContext2D.globalAlpha < 1 / 255) // Fast path: don't draw fully transparent
                    return;
                    this.backBufferContext2D.strokeRect(x, y, width, height);
                }
            },
            /**
        * Draw a filled rectangle at the specified coordinates
        * @name fillRect
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} x
        * @param {Number} y
        * @param {Number} width
        * @param {Number} height
        */ fillRect: function fillRect(x, y, width, height) {
                if (this.backBufferContext2D.globalAlpha < 1 / 255) // Fast path: don't draw fully transparent
                return;
                this.backBufferContext2D.fillRect(x, y, width, height);
            },
            /**
        * return a reference to the system 2d Context
        * @name getContext
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @return {CanvasRenderingContext2D}
        */ getContext: function getContext() {
                return this.backBufferContext2D;
            },
            /**
        * return a reference to the font 2d Context
        * @ignore
        */ getFontContext: function getFontContext() {
                // in canvas mode we can directly use the 2d context
                return this.getContext();
            },
            /**
        * save the canvas context
        * @name save
        * @memberOf me.CanvasRenderer.prototype
        * @function
        */ save: function save() {
                this.backBufferContext2D.save();
            },
            /**
        * restores the canvas context
        * @name restore
        * @memberOf me.CanvasRenderer.prototype
        * @function
        */ restore: function restore() {
                this.backBufferContext2D.restore();
                this.currentColor.glArray[3] = this.backBufferContext2D.globalAlpha;
                this.currentScissor[0] = 0;
                this.currentScissor[1] = 0;
                this.currentScissor[2] = this.backBufferCanvas.width;
                this.currentScissor[3] = this.backBufferCanvas.height;
            },
            /**
        * rotates the canvas context
        * @name rotate
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} angle in radians
        */ rotate: function rotate(angle) {
                this.backBufferContext2D.rotate(angle);
            },
            /**
        * scales the canvas context
        * @name scale
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} x
        * @param {Number} y
        */ scale: function scale(x, y) {
                this.backBufferContext2D.scale(x, y);
            },
            /**
        * Set the current fill & stroke style color.
        * By default, or upon reset, the value is set to #000000.
        * @name setColor
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {me.Color|String} color css color value
        */ setColor: function setColor(color) {
                this.backBufferContext2D.strokeStyle = this.backBufferContext2D.fillStyle = color instanceof me.Color ? color.toRGBA() : color;
            },
            /**
        * Set the global alpha on the canvas context
        * @name setGlobalAlpha
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} alpha 0.0 to 1.0 values accepted.
        */ setGlobalAlpha: function setGlobalAlpha(a) {
                this.backBufferContext2D.globalAlpha = this.currentColor.glArray[3] = a;
            },
            /**
        * Set the line width on the context
        * @name setLineWidth
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} width Line width
        */ setLineWidth: function setLineWidth(width) {
                this.backBufferContext2D.lineWidth = width;
            },
            /**
        * Reset (overrides) the renderer transformation matrix to the
        * identity one, and then apply the given transformation matrix.
        * @name setTransform
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {me.Matrix2d} mat2d Matrix to transform by
        */ setTransform: function setTransform(mat2d) {
                this.resetTransform();
                this.transform(mat2d);
            },
            /**
        * Multiply given matrix into the renderer tranformation matrix
        * @name transform
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {me.Matrix2d} mat2d Matrix to transform by
        */ transform: function transform(mat2d) {
                var m = mat2d.toArray(), a = m[0], b = m[1], c = m[3], d = m[4], e = m[6], f = m[7];
                if (this.settings.subPixel === false) {
                    e |= 0;
                    f |= 0;
                }
                this.backBufferContext2D.transform(a, b, c, d, e, f);
            },
            /**
        * Translates the context to the given position
        * @name translate
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} x
        * @param {Number} y
        */ translate: function translate(x, y) {
                if (this.settings.subPixel === false) this.backBufferContext2D.translate(~~x, ~~y);
                else this.backBufferContext2D.translate(x, y);
            },
            /**
        * clip the given region from the original canvas. Once a region is clipped,
        * all future drawing will be limited to the clipped region.
        * You can however save the current region using the save(),
        * and restore it (with the restore() method) any time in the future.
        * (<u>this is an experimental feature !</u>)
        * @name clipRect
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {Number} x
        * @param {Number} y
        * @param {Number} width
        * @param {Number} height
        */ clipRect: function clipRect(x, y, width, height) {
                var canvas = this.backBufferCanvas; // if requested box is different from the current canvas size;
                if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height) {
                    var currentScissor = this.currentScissor; // if different from the current scissor box
                    if (currentScissor[0] !== x || currentScissor[1] !== y || currentScissor[2] !== width || currentScissor[3] !== height) {
                        var context = this.backBufferContext2D;
                        context.beginPath();
                        context.rect(x, y, width, height);
                        context.clip(); // save the new currentScissor box
                        currentScissor[0] = x;
                        currentScissor[1] = y;
                        currentScissor[2] = width;
                        currentScissor[3] = height;
                    }
                }
            },
            /**
        * A mask limits rendering elements to the shape and position of the given mask object.
        * So, if the renderable is larger than the mask, only the intersecting part of the renderable will be visible.
        * Mask are not preserved through renderer context save and restore.
        * @name setMask
        * @memberOf me.CanvasRenderer.prototype
        * @function
        * @param {me.Rect|me.Polygon|me.Line|me.Ellipse} [mask] the shape defining the mask to be applied
        */ setMask: function setMask(mask) {
                var context = this.backBufferContext2D;
                var _x = mask.pos.x, _y = mask.pos.y; // https://github.com/melonjs/melonJS/issues/648
                if (mask instanceof me.Ellipse) {
                    var hw = mask.radiusV.x, hh = mask.radiusV.y, lx = _x - hw, rx = _x + hw, ty = _y - hh, by = _y + hh;
                    var xmagic = hw * 0.551784, ymagic = hh * 0.551784, xmin = _x - xmagic, xmax = _x + xmagic, ymin = _y - ymagic, ymax = _y + ymagic;
                    context.beginPath();
                    context.moveTo(_x, ty);
                    context.bezierCurveTo(xmax, ty, rx, ymin, rx, _y);
                    context.bezierCurveTo(rx, ymax, xmax, by, _x, by);
                    context.bezierCurveTo(xmin, by, lx, ymax, lx, _y);
                    context.bezierCurveTo(lx, ymin, xmin, ty, _x, ty);
                } else {
                    context.save();
                    context.beginPath();
                    context.moveTo(_x + mask.points[0].x, _y + mask.points[0].y);
                    var point;
                    for(var i = 1; i < mask.points.length; i++){
                        point = mask.points[i];
                        context.lineTo(_x + point.x, _y + point.y);
                    }
                    context.closePath();
                }
                context.clip();
            },
            /**
        * disable (remove) the rendering mask set through setMask.
        * @name clearMask
        * @see me.CanvasRenderer#setMask
        * @memberOf me.CanvasRenderer.prototype
        * @function
        */ clearMask: function clearMask() {
                this.backBufferContext2D.restore();
            }
        });
    })();
    (function() {
        /**
      * a WebGL renderer object
      * @extends me.Renderer
      * @namespace me.WebGLRenderer
      * @memberOf me
      * @constructor
      * @param {Object} options The renderer parameters
      * @param {Number} options.width The width of the canvas without scaling
      * @param {Number} options.height The height of the canvas without scaling
      * @param {HTMLCanvasElement} [options.canvas] The html canvas to draw to on screen
      * @param {Boolean} [options.doubleBuffering=false] Whether to enable double buffering
      * @param {Boolean} [options.antiAlias=false] Whether to enable anti-aliasing
      * @param {Boolean} [options.failIfMajorPerformanceCaveat=true] If true, the renderer will switch to CANVAS mode if the performances of a WebGL context would be dramatically lower than that of a native application making equivalent OpenGL calls.
      * @param {Boolean} [options.transparent=false] Whether to enable transparency on the canvas (performance hit when enabled)
      * @param {Boolean} [options.subPixel=false] Whether to enable subpixel renderering (performance hit when enabled)
      * @param {Boolean} [options.preferWebGL1=true] if false the renderer will try to use WebGL 2 if supported
      * @param {String} [options.powerPreference="default"] a hint to the user agent indicating what configuration of GPU is suitable for the WebGL context ("default", "high-performance", "low-power"). To be noted that Safari and Chrome (since version 80) both default to "low-power" to save battery life and improve the user experience on these dual-GPU machines.
      * @param {Number} [options.zoomX=width] The actual width of the canvas with scaling applied
      * @param {Number} [options.zoomY=height] The actual height of the canvas with scaling applied
      * @param {me.WebGLCompositor} [options.compositor] A class that implements the compositor API
      */ me.WebGLRenderer = me.Renderer.extend({
            /**
        * @ignore
        */ init: function init(options) {
                // reference to this renderer
                var renderer = this; // parent contructor
                this._super(me.Renderer, "init", [
                    options
                ]);
                /**
          * The WebGL context
          * @name gl
          * @memberOf me.WebGLRenderer
          * type {WebGLRenderingContext}
          */ this.context = this.gl = this.getContextGL(this.getScreenCanvas(), options.transparent);
                /**
          * The WebGL version used by this renderer (1 or 2)
          * @name WebGLVersion
          * @memberOf me.WebGLRenderer
          * @type {Number}
          * @default 1
          * @readonly
          */ this.webGLVersion = 1;
                /**
          * The vendor string of the underlying graphics driver.
          * @name GPUVendor
          * @memberOf me.WebGLRenderer
          * @type {String}
          * @default null
          * @readonly
          */ this.GPUVendor = null;
                /**
          * The renderer string of the underlying graphics driver.
          * @name GPURenderer
          * @memberOf me.WebGLRenderer
          * @type {String}
          * @default null
          * @readonly
          */ this.GPURenderer = null;
                /**
          * Maximum number of texture unit supported under the current context
          * @name maxTextures
          * @memberOf me.WebGLRenderer
          * @type {Number}
          * @readonly
          */ this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
                /**
          * @ignore
          */ this._colorStack = [];
                /**
          * @ignore
          */ this._matrixStack = [];
                /**
          * @ignore
          */ this._scissorStack = [];
                /**
          * @ignore
          */ this._glPoints = [
                    new me.Vector2d(),
                    new me.Vector2d(),
                    new me.Vector2d(),
                    new me.Vector2d()
                ];
                /**
          * The current transformation matrix used for transformations on the overall scene
          * @name currentTransform
          * @type me.Matrix2d
          * @memberOf me.WebGLRenderer#
          */ this.currentTransform = new me.Matrix2d();
                /**
          * The current compositor used by the renderer
          * @name currentCompositor
          * @type me.WebGLCompositor
          * @memberOf me.WebGLRenderer#
          */ this.currentCompositor = null; // Create a compositor
                var Compositor = this.settings.compositor || me.WebGLCompositor;
                this.setCompositor(new Compositor(this)); // default WebGL state(s)
                this.gl.disable(this.gl.DEPTH_TEST);
                this.gl.disable(this.gl.SCISSOR_TEST);
                this.gl.enable(this.gl.BLEND); // set default mode
                this.setBlendMode(this.settings.blendMode); // get GPU vendor and renderer
                var debugInfo = this.gl.getExtension("WEBGL_debug_renderer_info");
                if (debugInfo !== null) {
                    this.GPUVendor = this.gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    this.GPURenderer = this.gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                } // Create a texture cache
                this.cache = new me.Renderer.TextureCache(this.maxTextures); // to simulate context lost and restore :
                // var ctx = me.video.renderer.context.getExtension('WEBGL_lose_context');
                // ctx.loseContext()
                this.getScreenCanvas().addEventListener("webglcontextlost", function(event) {
                    event.preventDefault();
                    renderer.isContextValid = false;
                    me.event.publish(me.event.WEBGL_ONCONTEXT_LOST, [
                        renderer
                    ]);
                }, false); // ctx.restoreContext()
                this.getScreenCanvas().addEventListener("webglcontextrestored", function(event) {
                    renderer.reset();
                    renderer.isContextValid = true;
                    me.event.publish(me.event.WEBGL_ONCONTEXT_RESTORED, [
                        renderer
                    ]);
                }, false);
                return this;
            },
            /**
        * Reset context state
        * @name reset
        * @memberOf me.WebGLRenderer.prototype
        * @function
        */ reset: function reset() {
                this._super(me.Renderer, "reset");
                if (this.isContextValid === false) // on context lost/restore
                this.currentCompositor.init(this);
                else this.currentCompositor.reset();
                this.gl.disable(this.gl.SCISSOR_TEST);
                if (typeof this.fontContext2D !== "undefined") this.createFontTexture(this.cache);
            },
            /**
        * assign a compositor to this renderer
        * @name setCompositor
        * @function
        * @param {WebGLCompositor} compositor a compositor instance
        * @memberOf me.WebGLRenderer.prototype
        * @function
        */ setCompositor: function setCompositor(compositor) {
                if (this.currentCompositor !== null && this.currentCompositor !== compositor) // flush the current compositor
                this.currentCompositor.flush();
                this.currentCompositor = compositor;
            },
            /**
        * Reset the gl transform to identity
        * @name resetTransform
        * @memberOf me.WebGLRenderer.prototype
        * @function
        */ resetTransform: function resetTransform() {
                this.currentTransform.identity();
            },
            /**
        * @ignore
        */ createFontTexture: function createFontTexture(cache) {
                if (typeof this.fontTexture === "undefined") {
                    var canvas = this.backBufferCanvas;
                    var width = canvas.width;
                    var height = canvas.height;
                    if (this.WebGLVersion === 1) {
                        if (!me.Math.isPowerOfTwo(width)) width = me.Math.nextPowerOfTwo(canvas.width);
                        if (!me.Math.isPowerOfTwo(height)) height = me.Math.nextPowerOfTwo(canvas.height);
                    }
                    var image = me.video.createCanvas(width, height, true);
                    /**
            * @ignore
            */ this.fontContext2D = this.getContext2d(image);
                    /**
            * @ignore
            */ this.fontTexture = new this.Texture(this.Texture.prototype.createAtlas.apply(this.Texture.prototype, [
                        canvas.width,
                        canvas.height,
                        "fontTexture"
                    ]), image, cache);
                    this.currentCompositor.uploadTexture(this.fontTexture, 0, 0, 0);
                } else // fontTexture was already created, just add it back into the cache
                cache.set(this.fontContext2D.canvas, this.fontTexture);
            },
            /**
        * Create a pattern with the specified repetition
        * @name createPattern
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {image} image Source image
        * @param {String} repeat Define how the pattern should be repeated
        * @return {me.video.renderer.Texture}
        * @see me.ImageLayer#repeat
        * @example
        * var tileable   = renderer.createPattern(image, "repeat");
        * var horizontal = renderer.createPattern(image, "repeat-x");
        * var vertical   = renderer.createPattern(image, "repeat-y");
        * var basic      = renderer.createPattern(image, "no-repeat");
        */ createPattern: function createPattern(image, repeat) {
                if (me.video.renderer.WebGLVersion === 1 && (!me.Math.isPowerOfTwo(image.width) || !me.Math.isPowerOfTwo(image.height))) {
                    var src = typeof image.src !== "undefined" ? image.src : image;
                    throw new Error("[WebGL Renderer] " + src + " is not a POT texture " + "(" + image.width + "x" + image.height + ")");
                }
                var texture = new this.Texture(this.Texture.prototype.createAtlas.apply(this.Texture.prototype, [
                    image.width,
                    image.height,
                    "pattern",
                    repeat
                ]), image); // FIXME: Remove old cache entry and texture when changing the repeat mode
                this.currentCompositor.uploadTexture(texture);
                return texture;
            },
            /**
        * Flush the compositor to the frame buffer
        * @name flush
        * @memberOf me.WebGLRenderer.prototype
        * @function
        */ flush: function flush() {
                this.currentCompositor.flush();
            },
            /**
        * Clears the gl context with the given color.
        * @name clearColor
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {me.Color|String} [color] CSS color.
        * @param {Boolean} [opaque=false] Allow transparency [default] or clear the surface completely [true]
        */ clearColor: function clearColor(col, opaque) {
                var glArray;
                this.save();
                if (col instanceof me.Color) glArray = col.toArray();
                else // reuse temporary the renderer default color object
                glArray = this.getColor().parseCSS(col).toArray();
                 // clear gl context with the specified color
                this.currentCompositor.clearColor(glArray[0], glArray[1], glArray[2], opaque === true ? 1 : glArray[3]);
                this.currentCompositor.clear(); // restore default clear Color black
                this.currentCompositor.clearColor(0, 0, 0, 0);
                this.restore();
            },
            /**
        * Erase the pixels in the given rectangular area by setting them to transparent black (rgba(0,0,0,0)).
        * @name clearRect
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} x x axis of the coordinate for the rectangle starting point.
        * @param {Number} y y axis of the coordinate for the rectangle starting point.
        * @param {Number} width The rectangle's width.
        * @param {Number} height The rectangle's height.
        */ clearRect: function clearRect(x, y, width, height) {
                var color = this.currentColor.clone();
                this.currentColor.copy("#000000");
                this.fillRect(x, y, width, height);
                this.currentColor.copy(color);
                me.pool.push(color);
            },
            /**
        * @ignore
        */ drawFont: function drawFont(bounds) {
                var fontContext = this.getFontContext(); // Force-upload the new texture
                this.currentCompositor.uploadTexture(this.fontTexture, 0, 0, 0, true); // Add the new quad
                var key = bounds.pos.x + "," + bounds.pos.y + "," + bounds.width + "," + bounds.height;
                this.currentCompositor.addQuad(this.fontTexture, key, bounds.pos.x, bounds.pos.y, bounds.width, bounds.height); // Clear font context2D
                fontContext.clearRect(bounds.pos.x, bounds.pos.y, bounds.width, bounds.height);
            },
            /**
        * Draw an image to the gl context
        * @name drawImage
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Image} image An element to draw into the context. The specification permits any canvas image source (CanvasImageSource), specifically, a CSSImageValue, an HTMLImageElement, an SVGImageElement, an HTMLVideoElement, an HTMLCanvasElement, an ImageBitmap, or an OffscreenCanvas.
        * @param {Number} sx The X coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
        * @param {Number} sy The Y coordinate of the top left corner of the sub-rectangle of the source image to draw into the destination context.
        * @param {Number} sw The width of the sub-rectangle of the source image to draw into the destination context. If not specified, the entire rectangle from the coordinates specified by sx and sy to the bottom-right corner of the image is used.
        * @param {Number} sh The height of the sub-rectangle of the source image to draw into the destination context.
        * @param {Number} dx The X coordinate in the destination canvas at which to place the top-left corner of the source image.
        * @param {Number} dy The Y coordinate in the destination canvas at which to place the top-left corner of the source image.
        * @param {Number} dWidth The width to draw the image in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in width when drawn.
        * @param {Number} dHeight The height to draw the image in the destination canvas. This allows scaling of the drawn image. If not specified, the image is not scaled in height when drawn.
        * @example
        * // Position the image on the canvas:
        * renderer.drawImage(image, dx, dy);
        * // Position the image on the canvas, and specify width and height of the image:
        * renderer.drawImage(image, dx, dy, dWidth, dHeight);
        * // Clip the image and position the clipped part on the canvas:
        * renderer.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        */ drawImage: function drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
                if (typeof sw === "undefined") {
                    sw = dw = image.width;
                    sh = dh = image.height;
                    dx = sx;
                    dy = sy;
                    sx = 0;
                    sy = 0;
                } else if (typeof dx === "undefined") {
                    dx = sx;
                    dy = sy;
                    dw = sw;
                    dh = sh;
                    sw = image.width;
                    sh = image.height;
                    sx = 0;
                    sy = 0;
                }
                if (this.settings.subPixel === false) {
                    // clamp to pixel grid
                    dx |= 0;
                    dy |= 0;
                }
                var key = sx + "," + sy + "," + sw + "," + sh;
                this.currentCompositor.addQuad(this.cache.get(image), key, dx, dy, dw, dh);
            },
            /**
        * Draw a pattern within the given rectangle.
        * @name drawPattern
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {me.video.renderer.Texture} pattern Pattern object
        * @param {Number} x
        * @param {Number} y
        * @param {Number} width
        * @param {Number} height
        * @see me.WebGLRenderer#createPattern
        */ drawPattern: function drawPattern(pattern, x, y, width, height) {
                var key = "0,0," + width + "," + height;
                this.currentCompositor.addQuad(pattern, key, x, y, width, height);
            },
            /**
        * return a reference to the screen canvas corresponding WebGL Context
        * @name getScreenContext
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @return {WebGLRenderingContext}
        */ getScreenContext: function getScreenContext() {
                return this.gl;
            },
            /**
        * Returns the WebGL Context object of the given Canvas
        * @name getContextGL
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Canvas} canvas
        * @param {Boolean} [transparent=true] use false to disable transparency
        * @return {WebGLRenderingContext}
        */ getContextGL: function getContextGL(canvas, transparent) {
                if (typeof canvas === "undefined" || canvas === null) throw new Error("You must pass a canvas element in order to create a GL context");
                if (typeof transparent !== "boolean") transparent = true;
                var attr = {
                    alpha: transparent,
                    antialias: this.settings.antiAlias,
                    depth: false,
                    stencil: true,
                    preserveDrawingBuffer: false,
                    premultipliedAlpha: transparent,
                    powerPreference: this.settings.powerPreference,
                    failIfMajorPerformanceCaveat: this.settings.failIfMajorPerformanceCaveat
                };
                var gl; // attempt to create a WebGL2 context if requested
                if (this.settings.preferWebGL1 === false) {
                    gl = canvas.getContext("webgl2", attr);
                    if (gl) this.WebGLVersion = 2;
                } // fallback to WebGL1
                if (!gl) {
                    this.WebGLVersion = 1;
                    gl = canvas.getContext("webgl", attr) || canvas.getContext("experimental-webgl", attr);
                }
                if (!gl) throw new Error("A WebGL context could not be created.");
                return gl;
            },
            /**
        * Returns the WebGLContext instance for the renderer
        * return a reference to the system 2d Context
        * @name getContext
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @return {WebGLRenderingContext}
        */ getContext: function getContext() {
                return this.gl;
            },
            /**
        * set a blend mode for the given context
        * @name setBlendMode
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {String} [mode="normal"] blend mode : "normal", "multiply"
        * @param {WebGLRenderingContext} [gl]
        */ setBlendMode: function setBlendMode(mode, gl) {
                gl = gl || this.gl;
                gl.enable(gl.BLEND);
                switch(mode){
                    case "multiply":
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                        this.currentBlendMode = mode;
                        break;
                    default:
                        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                        this.currentBlendMode = "normal";
                        break;
                }
            },
            /**
        * return a reference to the font 2d Context
        * @ignore
        */ getFontContext: function getFontContext() {
                if (typeof this.fontContext2D === "undefined") {
                    // warn the end user about performance impact
                    console.warn("[WebGL Renderer] WARNING : Using Standard me.Text with WebGL will severly impact performances !"); // create the font texture if not done yet
                    this.createFontTexture(this.cache);
                }
                return this.fontContext2D;
            },
            /**
        * restores the canvas context
        * @name restore
        * @memberOf me.WebGLRenderer.prototype
        * @function
        */ restore: function restore() {
                // do nothing if there is no saved states
                if (this._matrixStack.length !== 0) {
                    var color = this._colorStack.pop();
                    var matrix = this._matrixStack.pop(); // restore the previous context
                    this.currentColor.copy(color);
                    this.currentTransform.copy(matrix); // recycle objects
                    me.pool.push(color);
                    me.pool.push(matrix);
                }
                if (this._scissorStack.length !== 0) // FIXME : prevent `scissor` object realloc and GC
                this.currentScissor.set(this._scissorStack.pop());
                else {
                    // turn off scissor test
                    this.gl.disable(this.gl.SCISSOR_TEST);
                    this.currentScissor[0] = 0;
                    this.currentScissor[1] = 0;
                    this.currentScissor[2] = this.backBufferCanvas.width;
                    this.currentScissor[3] = this.backBufferCanvas.height;
                }
            },
            /**
        * saves the canvas context
        * @name save
        * @memberOf me.WebGLRenderer.prototype
        * @function
        */ save: function save() {
                this._colorStack.push(this.currentColor.clone());
                this._matrixStack.push(this.currentTransform.clone());
                if (this.gl.isEnabled(this.gl.SCISSOR_TEST)) // FIXME avoid slice and object realloc
                this._scissorStack.push(this.currentScissor.slice());
            },
            /**
        * rotates the uniform matrix
        * @name rotate
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} angle in radians
        */ rotate: function rotate(angle) {
                this.currentTransform.rotate(angle);
            },
            /**
        * scales the uniform matrix
        * @name scale
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} x
        * @param {Number} y
        */ scale: function scale(x, y) {
                this.currentTransform.scale(x, y);
            },
            /**
        * not used by this renderer?
        * @ignore
        */ setAntiAlias: function setAntiAlias(context, enable) {
                this._super(me.Renderer, "setAntiAlias", [
                    context,
                    enable
                ]); // TODO: perhaps handle GLNEAREST or other options with texture binding
            },
            /**
        * Set the global alpha
        * @name setGlobalAlpha
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} alpha 0.0 to 1.0 values accepted.
        */ setGlobalAlpha: function setGlobalAlpha(a) {
                this.currentColor.glArray[3] = a;
            },
            /**
        * Set the current fill & stroke style color.
        * By default, or upon reset, the value is set to #000000.
        * @name setColor
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {me.Color|String} color css color string.
        */ setColor: function setColor(color) {
                var alpha = this.currentColor.glArray[3];
                this.currentColor.copy(color);
                this.currentColor.glArray[3] *= alpha;
            },
            /**
        * Set the line width
        * @name setLineWidth
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} width Line width
        */ setLineWidth: function setLineWidth(width) {
                this.getScreenContext().lineWidth(width);
            },
            /**
        * Stroke an arc at the specified coordinates with given radius, start and end points
        * @name strokeArc
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} x arc center point x-axis
        * @param {Number} y arc center point y-axis
        * @param {Number} radius
        * @param {Number} start start angle in radians
        * @param {Number} end end angle in radians
        * @param {Boolean} [antiClockwise=false] draw arc anti-clockwise
        */ strokeArc: function strokeArc(x, y, radius, start, end, antiClockwise, fill) {
                if (fill === true) this.fillArc(x, y, radius, start, end, antiClockwise);
                else {
                    // XXX to be optimzed using a specific shader
                    var points = this._glPoints;
                    var i, len = Math.floor(24 * Math.sqrt(radius * 2));
                    var theta = (end - start) / (len * 2);
                    var theta2 = theta * 2;
                    var cos_theta = Math.cos(theta);
                    var sin_theta = Math.sin(theta); // Grow internal points buffer if necessary
                    for(i = points.length; i < len + 1; i++)points.push(new me.Vector2d());
                     // calculate and draw all segments
                    for(i = 0; i < len; i++){
                        var angle = theta + start + theta2 * i;
                        var cos = Math.cos(angle);
                        var sin = -Math.sin(angle);
                        points[i].x = x + (cos_theta * cos + sin_theta * sin) * radius;
                        points[i].y = y + (cos_theta * -sin + sin_theta * cos) * radius;
                    } // batch draw all lines
                    this.currentCompositor.drawVertices(this.gl.LINE_STRIP, points, len);
                }
            },
            /**
        * Fill an arc at the specified coordinates with given radius, start and end points
        * @name fillArc
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} x arc center point x-axis
        * @param {Number} y arc center point y-axis
        * @param {Number} radius
        * @param {Number} start start angle in radians
        * @param {Number} end end angle in radians
        * @param {Boolean} [antiClockwise=false] draw arc anti-clockwise
        */ fillArc: function fillArc(x, y, radius, start, end, antiClockwise) {
                // XXX to be optimzed using a specific shader
                var points = this._glPoints;
                var i, index = 0;
                var len = Math.floor(24 * Math.sqrt(radius * 2));
                var theta = (end - start) / (len * 2);
                var theta2 = theta * 2;
                var cos_theta = Math.cos(theta);
                var sin_theta = Math.sin(theta); // Grow internal points buffer if necessary
                for(i = points.length; i < len * 2; i++)points.push(new me.Vector2d());
                 // calculate and draw all segments
                for(i = 0; i < len - 1; i++){
                    var angle = theta + start + theta2 * i;
                    var cos = Math.cos(angle);
                    var sin = -Math.sin(angle);
                    points[index++].set(x, y);
                    points[index++].set(x - (cos_theta * cos + sin_theta * sin) * radius, y - (cos_theta * -sin + sin_theta * cos) * radius);
                } // batch draw all triangles
                this.currentCompositor.drawVertices(this.gl.TRIANGLE_STRIP, points, index);
            },
            /**
        * Stroke an ellipse at the specified coordinates with given radius
        * @name strokeEllipse
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} x ellipse center point x-axis
        * @param {Number} y ellipse center point y-axis
        * @param {Number} w horizontal radius of the ellipse
        * @param {Number} h vertical radius of the ellipse
        */ strokeEllipse: function strokeEllipse(x, y, w, h, fill) {
                if (fill === true) this.fillEllipse(x, y, w, h);
                else {
                    // XXX to be optimzed using a specific shader
                    var len = Math.floor(24 * Math.sqrt(w)) || Math.floor(12 * Math.sqrt(w + h));
                    var segment = me.Math.TAU / len;
                    var points = this._glPoints, i; // Grow internal points buffer if necessary
                    for(i = points.length; i < len; i++)points.push(new me.Vector2d());
                     // calculate and draw all segments
                    for(i = 0; i < len; i++){
                        points[i].x = x + Math.sin(segment * -i) * w;
                        points[i].y = y + Math.cos(segment * -i) * h;
                    } // batch draw all lines
                    this.currentCompositor.drawVertices(this.gl.LINE_LOOP, points, len);
                }
            },
            /**
        * Fill an ellipse at the specified coordinates with given radius
        * @name fillEllipse
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} x ellipse center point x-axis
        * @param {Number} y ellipse center point y-axis
        * @param {Number} w horizontal radius of the ellipse
        * @param {Number} h vertical radius of the ellipse
        */ fillEllipse: function fillEllipse(x, y, w, h) {
                // XXX to be optimzed using a specific shader
                var len = Math.floor(24 * Math.sqrt(w)) || Math.floor(12 * Math.sqrt(w + h));
                var segment = me.Math.TAU / len;
                var points = this._glPoints;
                var index = 0, i; // Grow internal points buffer if necessary
                for(i = points.length; i < (len + 1) * 2; i++)points.push(new me.Vector2d());
                 // draw all vertices vertex coordinates
                for(i = 0; i < len + 1; i++){
                    points[index++].set(x, y);
                    points[index++].set(x + Math.sin(segment * i) * w, y + Math.cos(segment * i) * h);
                } // batch draw all triangles
                this.currentCompositor.drawVertices(this.gl.TRIANGLE_STRIP, points, index);
            },
            /**
        * Stroke a line of the given two points
        * @name strokeLine
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} startX the start x coordinate
        * @param {Number} startY the start y coordinate
        * @param {Number} endX the end x coordinate
        * @param {Number} endY the end y coordinate
        */ strokeLine: function strokeLine(startX, startY, endX, endY) {
                var points = this._glPoints;
                points[0].x = startX;
                points[0].y = startY;
                points[1].x = endX;
                points[1].y = endY;
                this.currentCompositor.drawVertices(this.gl.LINE_STRIP, points, 2);
            },
            /**
        * Fill a line of the given two points
        * @name fillLine
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} startX the start x coordinate
        * @param {Number} startY the start y coordinate
        * @param {Number} endX the end x coordinate
        * @param {Number} endY the end y coordinate
        */ fillLine: function fillLine(startX, startY, endX, endY) {
                this.strokeLine(startX, startY, endX, endY);
            },
            /**
        * Stroke a me.Polygon on the screen with a specified color
        * @name strokePolygon
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {me.Polygon} poly the shape to draw
        */ strokePolygon: function strokePolygon(poly, fill) {
                if (fill === true) this.fillPolygon(poly);
                else {
                    var len = poly.points.length, points = this._glPoints, i; // Grow internal points buffer if necessary
                    for(i = points.length; i < len; i++)points.push(new me.Vector2d());
                     // calculate and draw all segments
                    for(i = 0; i < len; i++){
                        points[i].x = poly.pos.x + poly.points[i].x;
                        points[i].y = poly.pos.y + poly.points[i].y;
                    }
                    this.currentCompositor.drawVertices(this.gl.LINE_LOOP, points, len);
                }
            },
            /**
        * Fill a me.Polygon on the screen
        * @name fillPolygon
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {me.Polygon} poly the shape to draw
       */ fillPolygon: function fillPolygon(poly) {
                var points = poly.points;
                var glPoints = this._glPoints;
                var indices = poly.getIndices();
                var x = poly.pos.x, y = poly.pos.y;
                var i; // Grow internal points buffer if necessary
                for(i = glPoints.length; i < indices.length; i++)glPoints.push(new me.Vector2d());
                 // calculate all vertices
                for(i = 0; i < indices.length; i++)glPoints[i].set(x + points[indices[i]].x, y + points[indices[i]].y);
                 // draw all triangle
                this.currentCompositor.drawVertices(this.gl.TRIANGLES, glPoints, indices.length);
            },
            /**
        * Draw a stroke rectangle at the specified coordinates
        * @name strokeRect
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} x
        * @param {Number} y
        * @param {Number} width
        * @param {Number} height
        */ strokeRect: function strokeRect(x, y, width, height, fill) {
                if (fill === true) this.fillRect(x, y, width, height);
                else {
                    var points = this._glPoints;
                    points[0].x = x;
                    points[0].y = y;
                    points[1].x = x + width;
                    points[1].y = y;
                    points[2].x = x + width;
                    points[2].y = y + height;
                    points[3].x = x;
                    points[3].y = y + height;
                    this.currentCompositor.drawVertices(this.gl.LINE_LOOP, points, 4);
                }
            },
            /**
        * Draw a filled rectangle at the specified coordinates
        * @name fillRect
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} x
        * @param {Number} y
        * @param {Number} width
        * @param {Number} height
        */ fillRect: function fillRect(x, y, width, height) {
                var glPoints = this._glPoints;
                glPoints[0].x = x + width;
                glPoints[0].y = y;
                glPoints[1].x = x;
                glPoints[1].y = y;
                glPoints[2].x = x + width;
                glPoints[2].y = y + height;
                glPoints[3].x = x;
                glPoints[3].y = y + height;
                this.currentCompositor.drawVertices(this.gl.TRIANGLE_STRIP, glPoints, 4);
            },
            /**
        * Reset (overrides) the renderer transformation matrix to the
        * identity one, and then apply the given transformation matrix.
        * @name setTransform
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {me.Matrix2d} mat2d Matrix to transform by
        */ setTransform: function setTransform(mat2d) {
                this.resetTransform();
                this.transform(mat2d);
            },
            /**
        * Multiply given matrix into the renderer tranformation matrix
        * @name transform
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {me.Matrix2d} mat2d Matrix to transform by
        */ transform: function transform(mat2d) {
                var currentTransform = this.currentTransform;
                currentTransform.multiply(mat2d);
                if (this.settings.subPixel === false) {
                    // snap position values to pixel grid
                    var a = currentTransform.toArray();
                    a[6] |= 0;
                    a[7] |= 0;
                }
            },
            /**
        * Translates the uniform matrix by the given coordinates
        * @name translate
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} x
        * @param {Number} y
        */ translate: function translate(x, y) {
                var currentTransform = this.currentTransform;
                currentTransform.translate(x, y);
                if (this.settings.subPixel === false) {
                    // snap position values to pixel grid
                    var a = currentTransform.toArray();
                    a[6] |= 0;
                    a[7] |= 0;
                }
            },
            /**
        * clip the given region from the original canvas. Once a region is clipped,
        * all future drawing will be limited to the clipped region.
        * You can however save the current region using the save(),
        * and restore it (with the restore() method) any time in the future.
        * (<u>this is an experimental feature !</u>)
        * @name clipRect
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {Number} x
        * @param {Number} y
        * @param {Number} width
        * @param {Number} height
        */ clipRect: function clipRect(x, y, width, height) {
                var canvas = this.backBufferCanvas;
                var gl = this.gl; // if requested box is different from the current canvas size
                if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height) {
                    var currentScissor = this.currentScissor;
                    if (gl.isEnabled(gl.SCISSOR_TEST)) {
                        // if same as the current scissor box do nothing
                        if (currentScissor[0] === x && currentScissor[1] === y && currentScissor[2] === width && currentScissor[3] === height) return;
                    } // flush the compositor
                    this.flush(); // turn on scissor test
                    gl.enable(this.gl.SCISSOR_TEST); // set the scissor rectangle (note : coordinates are left/bottom)
                    gl.scissor(x + this.currentTransform.tx, canvas.height - height - y - this.currentTransform.ty, width, height); // save the new currentScissor box
                    currentScissor[0] = x;
                    currentScissor[1] = y;
                    currentScissor[2] = width;
                    currentScissor[3] = height;
                } else // turn off scissor test
                gl.disable(gl.SCISSOR_TEST);
            },
            /**
        * A mask limits rendering elements to the shape and position of the given mask object.
        * So, if the renderable is larger than the mask, only the intersecting part of the renderable will be visible.
        * Mask are not preserved through renderer context save and restore.
        * @name setMask
        * @memberOf me.WebGLRenderer.prototype
        * @function
        * @param {me.Rect|me.Polygon|me.Line|me.Ellipse} [mask] the shape defining the mask to be applied
        */ setMask: function setMask(mask) {
                var gl = this.gl; // flush the compositor
                this.flush(); // Enable and setup GL state to write to stencil buffer
                gl.enable(gl.STENCIL_TEST);
                gl.clear(gl.STENCIL_BUFFER_BIT);
                gl.colorMask(false, false, false, false);
                gl.stencilFunc(gl.NOTEQUAL, 1, 1);
                gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);
                this.fill(mask); // flush the compositor
                this.flush(); // Use stencil buffer to affect next rendering object
                gl.colorMask(true, true, true, true);
                gl.stencilFunc(gl.EQUAL, 1, 1);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
            },
            /**
        * disable (remove) the rendering mask set through setMask.
        * @name clearMask
        * @see me.WebGLRenderer#setMask
        * @memberOf me.WebGLRenderer.prototype
        * @function
        */ clearMask: function clearMask() {
                // flush the compositor
                this.flush();
                this.gl.disable(this.gl.STENCIL_TEST);
            }
        });
    })();
    var primitiveVertex = "// Current vertex point\nattribute vec2 aVertex;\n\n// Projection matrix\nuniform mat4 uProjectionMatrix;\n\n// Vertex color\nuniform vec4 uColor;\n\n// Fragment color\nvarying vec4 vColor;\n\nvoid main(void) {\n    // Transform the vertex position by the projection matrix\n    gl_Position = uProjectionMatrix * vec4(aVertex, 0.0, 1.0);\n    // Pass the remaining attributes to the fragment shader\n    vColor = vec4(uColor.rgb * uColor.a, uColor.a);\n}\n";
    var primitiveFragment = "varying vec4 vColor;\n\nvoid main(void) {\n    gl_FragColor = vColor;\n}\n";
    var quadVertex = "attribute vec2 aVertex;\nattribute vec2 aRegion;\nattribute vec4 aColor;\n\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vRegion;\nvarying vec4 vColor;\n\nvoid main(void) {\n    // Transform the vertex position by the projection matrix\n     gl_Position = uProjectionMatrix * vec4(aVertex, 0.0, 1.0);\n    // Pass the remaining attributes to the fragment shader\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n    vRegion = aRegion;\n}\n";
    var quadFragment = "uniform sampler2D uSampler;\nvarying vec4 vColor;\nvarying vec2 vRegion;\n\nvoid main(void) {\n    gl_FragColor = texture2D(uSampler, vRegion) * vColor;\n}\n";
    (function() {
        // Handy constants
        var VERTEX_SIZE = 2;
        var REGION_SIZE = 2;
        var COLOR_SIZE = 4;
        var ELEMENT_SIZE = VERTEX_SIZE + REGION_SIZE + COLOR_SIZE;
        var ELEMENT_OFFSET = ELEMENT_SIZE * Float32Array.BYTES_PER_ELEMENT;
        var VERTEX_ELEMENT = 0;
        var REGION_ELEMENT = VERTEX_ELEMENT + VERTEX_SIZE;
        var COLOR_ELEMENT = REGION_ELEMENT + REGION_SIZE;
        var ELEMENTS_PER_QUAD = 4;
        var INDICES_PER_QUAD = 6;
        var MAX_LENGTH = 16000;
        /**
      * A WebGL Compositor object. This class handles all of the WebGL state<br>
      * Pushes texture regions or shape geometry into WebGL buffers, automatically flushes to GPU
      * @extends me.Object
      * @namespace me.WebGLCompositor
      * @memberOf me
      * @constructor
      * @param {me.WebGLRenderer} renderer the current WebGL renderer session
      */ me.WebGLCompositor = me.Object.extend({
            /**
        * @ignore
        */ init: function init(renderer) {
                // local reference
                var gl = renderer.gl;
                /**
          * The number of quads held in the batch
          * @name length
          * @memberOf me.WebGLCompositor
          * @type Number
          * @readonly
          */ this.length = 0; // list of active texture units
                this.currentTextureUnit = -1;
                this.boundTextures = []; // Vector pool
                this.v = [
                    new me.Vector2d(),
                    new me.Vector2d(),
                    new me.Vector2d(),
                    new me.Vector2d()
                ]; // the associated renderer
                this.renderer = renderer; // WebGL context
                this.gl = renderer.gl; // Global fill color
                this.color = renderer.currentColor; // Global tint color
                this.tint = renderer.currentTint; // Global transformation matrix
                this.viewMatrix = renderer.currentTransform;
                /**
          * a reference to the active WebGL shader
          * @name activeShader
          * @memberOf me.WebGLCompositor
          * @type {me.GLShader}
          */ this.activeShader = null;
                /**
          * primitive type to render (gl.POINTS, gl.LINE_STRIP, gl.LINE_LOOP, gl.LINES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN, gl.TRIANGLES)
          * @name mode
          * @see me.WebGLCompositor
          * @memberOf me.WebGLCompositor
          * @default gl.TRIANGLES
          */ this.mode = gl.TRIANGLES;
                /**
          * an array of vertex attribute properties
          * @name attributes
          * @see me.WebGLCompositor.addAttribute
          * @memberOf me.WebGLCompositor
          */ this.attributes = []; // Load and create shader programs
                this.primitiveShader = new me.GLShader(this.gl, primitiveVertex, primitiveFragment);
                this.quadShader = new me.GLShader(this.gl, quadVertex, quadFragment); /// define all vertex attributes
                this.addAttribute("aVertex", 2, gl.FLOAT, false, 0 * Float32Array.BYTES_PER_ELEMENT); // 0
                this.addAttribute("aRegion", 2, gl.FLOAT, false, 2 * Float32Array.BYTES_PER_ELEMENT); // 1
                this.addAttribute("aColor", 4, gl.FLOAT, false, 4 * Float32Array.BYTES_PER_ELEMENT); // 2
                // Stream buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
                gl.bufferData(gl.ARRAY_BUFFER, MAX_LENGTH * ELEMENT_OFFSET * ELEMENTS_PER_QUAD, gl.STREAM_DRAW);
                this.sbSize = 256;
                this.sbIndex = 0; // Quad stream buffer
                this.stream = new Float32Array(this.sbSize * ELEMENT_SIZE * ELEMENTS_PER_QUAD); // Index buffer
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.createIB(), gl.STATIC_DRAW); // register to the CANVAS resize channel
                me.event.subscribe(me.event.CANVAS_ONRESIZE, (function(width, height) {
                    this.flush();
                    this.setViewport(0, 0, width, height);
                }).bind(this));
                this.reset();
            },
            /**
        * Reset compositor internal state
        * @ignore
        */ reset: function reset() {
                this.sbIndex = 0;
                this.length = 0; // WebGL context
                this.gl = this.renderer.gl;
                this.flush(); // initial viewport size
                this.setViewport(0, 0, this.renderer.getScreenCanvas().width, this.renderer.getScreenCanvas().height); // Initialize clear color
                this.clearColor(0, 0, 0, 0); // delete all related bound texture
                for(var i = 0; i < this.renderer.maxTextures; i++){
                    var texture = this.boundTextures[i];
                    if (texture !== null) this.gl.deleteTexture(texture);
                    this.boundTextures[i] = null;
                }
                this.currentTextureUnit = -1; // set the quad shader as the default program
                this.useShader(this.quadShader);
            },
            /**
        * add vertex attribute property definition to the compositor
        * @name addAttribute
        * @memberOf me.WebGLCompositor
        * @function
        * @param {String} name name of the attribute in the vertex shader
        * @param {Number} size number of components per vertex attribute. Must be 1, 2, 3, or 4.
        * @param {GLenum} type data type of each component in the array
        * @param {Boolean} normalized whether integer data values should be normalized into a certain
        * @param {Number} offset offset in bytes of the first component in the vertex attribute array
        */ addAttribute: function addAttribute(name, size, type, normalized, offset) {
                this.attributes.push({
                    name: name,
                    size: size,
                    type: type,
                    normalized: normalized,
                    offset: offset
                });
            },
            /**
        * Sets the viewport
        * @name setViewport
        * @memberOf me.WebGLCompositor
        * @function
        * @param {Number} x x position of viewport
        * @param {Number} y y position of viewport
        * @param {Number} width width of viewport
        * @param {Number} height height of viewport
        */ setViewport: function setViewport(x, y, w, h) {
                this.gl.viewport(x, y, w, h);
            },
            /**
        * Create a WebGL texture from an image
        * @name createTexture2D
        * @memberOf me.WebGLCompositor
        * @function
        * @param {Number} unit Destination texture unit
        * @param {Image|Canvas|ImageData|UInt8Array[]|Float32Array[]} image Source image
        * @param {Number} filter gl.LINEAR or gl.NEAREST
        * @param {String} [repeat="no-repeat"] Image repeat behavior (see {@link me.ImageLayer#repeat})
        * @param {Number} [w] Source image width (Only use with UInt8Array[] or Float32Array[] source image)
        * @param {Number} [h] Source image height (Only use with UInt8Array[] or Float32Array[] source image)
        * @param {Number} [b] Source image border (Only use with UInt8Array[] or Float32Array[] source image)
        * @param {Number} [b] Source image border (Only use with UInt8Array[] or Float32Array[] source image)
        * @param {Boolean} [premultipliedAlpha=true] Multiplies the alpha channel into the other color channels
        * @param {Boolean} [mipmap=true] Whether mipmap levels should be generated for this texture
        * @return {WebGLTexture} a WebGL texture
        */ createTexture2D: function createTexture2D(unit, image, filter, repeat, w, h, b, premultipliedAlpha, mipmap) {
                var gl = this.gl;
                repeat = repeat || "no-repeat";
                var isPOT = me.Math.isPowerOfTwo(w || image.width) && me.Math.isPowerOfTwo(h || image.height);
                var texture = gl.createTexture();
                var rs = repeat.search(/^repeat(-x)?$/) === 0 && (isPOT || this.renderer.WebGLVersion === 2) ? gl.REPEAT : gl.CLAMP_TO_EDGE;
                var rt = repeat.search(/^repeat(-y)?$/) === 0 && (isPOT || this.renderer.WebGLVersion === 2) ? gl.REPEAT : gl.CLAMP_TO_EDGE;
                this.setTexture2D(texture, unit);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, rs);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, rt);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, typeof premultipliedAlpha === "boolean" ? premultipliedAlpha : true);
                if (w || h || b) gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, b, gl.RGBA, gl.UNSIGNED_BYTE, image);
                else gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                 // generate the sprite mimap (used when scaling) if a PowerOfTwo texture
                if (isPOT && mipmap !== false) gl.generateMipmap(gl.TEXTURE_2D);
                return texture;
            },
            /**
        * assign the given WebGL texture to the current batch
        * @name setTexture2D
        * @memberOf me.WebGLCompositor
        * @function
        * @param {WebGLTexture} a WebGL texture
        * @param {Number} unit Texture unit to which the given texture is bound
        */ setTexture2D: function setTexture2D(texture, unit) {
                var gl = this.gl;
                if (texture !== this.boundTextures[unit]) {
                    this.flush();
                    if (this.currentTextureUnit !== unit) {
                        this.currentTextureUnit = unit;
                        gl.activeTexture(gl.TEXTURE0 + unit);
                    }
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    this.boundTextures[unit] = texture;
                } else if (this.currentTextureUnit !== unit) {
                    this.flush();
                    this.currentTextureUnit = unit;
                    gl.activeTexture(gl.TEXTURE0 + unit);
                }
            },
            /**
        * @ignore
        */ uploadTexture: function uploadTexture(texture, w, h, b, force) {
                var unit = this.renderer.cache.getUnit(texture);
                var texture2D = this.boundTextures[unit];
                if (texture2D === null || force) this.createTexture2D(unit, texture.getTexture(), this.renderer.settings.antiAlias ? this.gl.LINEAR : this.gl.NEAREST, texture.repeat, w, h, b, texture.premultipliedAlpha);
                else this.setTexture2D(texture2D, unit);
                return this.currentTextureUnit;
            },
            /**
        * Create a full index buffer for the element array
        * @ignore
        */ createIB: function createIB() {
                var indices = [
                    0,
                    1,
                    2,
                    2,
                    1,
                    3
                ]; // ~384KB index buffer
                var data = new Array(MAX_LENGTH * INDICES_PER_QUAD);
                for(var i = 0; i < data.length; i++)data[i] = indices[i % INDICES_PER_QUAD] + ~~(i / INDICES_PER_QUAD) * ELEMENTS_PER_QUAD;
                return new Uint16Array(data);
            },
            /**
        * Resize the stream buffer, retaining its original contents
        * @ignore
        */ resizeSB: function resizeSB() {
                this.sbSize <<= 1;
                var stream = new Float32Array(this.sbSize * ELEMENT_SIZE * ELEMENTS_PER_QUAD);
                stream.set(this.stream);
                this.stream = stream;
            },
            /**
        * Select the shader to use for compositing
        * @name useShader
        * @see me.GLShader
        * @memberOf me.WebGLCompositor
        * @function
        * @param {me.GLShader} shader a reference to a GLShader instance
        */ useShader: function useShader(shader) {
                if (this.activeShader !== shader) {
                    this.flush();
                    this.activeShader = shader;
                    this.activeShader.bind();
                    this.activeShader.setUniform("uProjectionMatrix", this.renderer.projectionMatrix); // set the vertex attributes
                    for(var index = 0; index < this.attributes.length; ++index){
                        var gl = this.gl;
                        var element = this.attributes[index];
                        var location = this.activeShader.getAttribLocation(element.name);
                        if (location !== -1) {
                            gl.enableVertexAttribArray(location);
                            gl.vertexAttribPointer(location, element.size, element.type, element.normalized, ELEMENT_OFFSET, element.offset);
                        } else gl.disableVertexAttribArray(index);
                    }
                }
            },
            /**
        * Add a textured quad
        * @name addQuad
        * @memberOf me.WebGLCompositor
        * @function
        * @param {me.video.renderer.Texture} texture Source texture
        * @param {String} key Source texture region name
        * @param {Number} x Destination x-coordinate
        * @param {Number} y Destination y-coordinate
        * @param {Number} w Destination width
        * @param {Number} h Destination height
        */ addQuad: function addQuad(texture, key, x, y, w, h) {
                //var gl = this.gl;
                var color = this.color.toArray();
                var tint = this.tint.toArray();
                if (color[3] < 1 / 255) // Fast path: don't send fully transparent quads
                return;
                else // use the global alpha
                tint[3] = color[3];
                if (this.length >= MAX_LENGTH) this.flush();
                if (this.length >= this.sbSize) this.resizeSB();
                this.useShader(this.quadShader); // upload and activate the texture if necessary
                var unit = this.uploadTexture(texture); // set fragement sampler accordingly
                this.quadShader.setUniform("uSampler", unit); // Transform vertices
                var m = this.viewMatrix, v0 = this.v[0].set(x, y), v1 = this.v[1].set(x + w, y), v2 = this.v[2].set(x, y + h), v3 = this.v[3].set(x + w, y + h);
                if (!m.isIdentity()) {
                    m.apply(v0);
                    m.apply(v1);
                    m.apply(v2);
                    m.apply(v3);
                } // Array index computation
                var idx0 = this.sbIndex, idx1 = idx0 + ELEMENT_SIZE, idx2 = idx1 + ELEMENT_SIZE, idx3 = idx2 + ELEMENT_SIZE; // Fill vertex buffer
                // FIXME: Pack each vertex vector into single float
                this.stream[idx0 + VERTEX_ELEMENT + 0] = v0.x;
                this.stream[idx0 + VERTEX_ELEMENT + 1] = v0.y;
                this.stream[idx1 + VERTEX_ELEMENT + 0] = v1.x;
                this.stream[idx1 + VERTEX_ELEMENT + 1] = v1.y;
                this.stream[idx2 + VERTEX_ELEMENT + 0] = v2.x;
                this.stream[idx2 + VERTEX_ELEMENT + 1] = v2.y;
                this.stream[idx3 + VERTEX_ELEMENT + 0] = v3.x;
                this.stream[idx3 + VERTEX_ELEMENT + 1] = v3.y; // Fill texture coordinates buffer
                var uvs = texture.getUVs(key); // FIXME: Pack each texture coordinate into single floats
                this.stream[idx0 + REGION_ELEMENT + 0] = uvs[0];
                this.stream[idx0 + REGION_ELEMENT + 1] = uvs[1];
                this.stream[idx1 + REGION_ELEMENT + 0] = uvs[2];
                this.stream[idx1 + REGION_ELEMENT + 1] = uvs[1];
                this.stream[idx2 + REGION_ELEMENT + 0] = uvs[0];
                this.stream[idx2 + REGION_ELEMENT + 1] = uvs[3];
                this.stream[idx3 + REGION_ELEMENT + 0] = uvs[2];
                this.stream[idx3 + REGION_ELEMENT + 1] = uvs[3]; // Fill color buffer
                // FIXME: Pack color vector into single float
                this.stream.set(tint, idx0 + COLOR_ELEMENT);
                this.stream.set(tint, idx1 + COLOR_ELEMENT);
                this.stream.set(tint, idx2 + COLOR_ELEMENT);
                this.stream.set(tint, idx3 + COLOR_ELEMENT);
                this.sbIndex += ELEMENT_SIZE * ELEMENTS_PER_QUAD;
                this.length++;
            },
            /**
        * Flush batched texture operations to the GPU
        * @param
        * @memberOf me.WebGLCompositor
        * @function
        */ flush: function flush() {
                if (this.length) {
                    var gl = this.gl; // Copy data into stream buffer
                    var len = this.length * ELEMENT_SIZE * ELEMENTS_PER_QUAD;
                    gl.bufferData(gl.ARRAY_BUFFER, this.stream.subarray(0, len), gl.STREAM_DRAW); // Draw the stream buffer
                    gl.drawElements(this.mode, this.length * INDICES_PER_QUAD, gl.UNSIGNED_SHORT, 0);
                    this.sbIndex = 0;
                    this.length = 0;
                }
            },
            /**
        * Draw an array of vertices
        * @name drawVertices
        * @memberOf me.WebGLCompositor
        * @function
        * @param {GLENUM} [mode=gl.TRIANGLES] primitive type to render (gl.POINTS, gl.LINE_STRIP, gl.LINE_LOOP, gl.LINES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN, gl.TRIANGLES)
        * @param {me.Vector2d[]} verts vertices
        * @param {Number} [vertexCount=verts.length] amount of points defined in the points array
        */ drawVertices: function drawVertices(mode, verts, vertexCount) {
                var gl = this.gl;
                vertexCount = vertexCount || verts.length; // use the primitive shader
                this.useShader(this.primitiveShader); // Set the line color
                this.primitiveShader.setUniform("uColor", this.color); // Put vertex data into the stream buffer
                var offset = 0;
                var m = this.viewMatrix;
                var m_isIdentity = m.isIdentity();
                for(var i = 0; i < vertexCount; i++){
                    if (!m_isIdentity) m.apply(verts[i]);
                    this.stream[offset + 0] = verts[i].x;
                    this.stream[offset + 1] = verts[i].y;
                    offset += ELEMENT_SIZE;
                } // Copy data into the stream buffer
                gl.bufferData(gl.ARRAY_BUFFER, this.stream.subarray(0, vertexCount * ELEMENT_SIZE), gl.STREAM_DRAW); // Draw the stream buffer
                gl.drawArrays(mode, 0, vertexCount);
            },
            /**
        * Specify the color values used when clearing color buffers. The values are clamped between 0 and 1.
        * @name clearColor
        * @memberOf me.WebGLCompositor
        * @function
        * @param {Number} r - the red color value used when the color buffers are cleared
        * @param {Number} g - the green color value used when the color buffers are cleared
        * @param {Number} b - the blue color value used when the color buffers are cleared
        * @param {Number} a - the alpha color value used when the color buffers are cleared
        */ clearColor: function clearColor(r, g, b, a) {
                this.gl.clearColor(r, g, b, a);
            },
            /**
        * Clear the frame buffer
        * @name clear
        * @memberOf me.WebGLCompositor
        * @function
        */ clear: function clear() {
                this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            }
        });
    })();
    (function() {
        /**
      * @private
      */ function extractUniforms(gl, shader) {
            var uniforms = {
            }, uniRx = /uniform\s+(\w+)\s+(\w+)/g, uniformsData = {
            }, descriptor = {
            }, locations = {
            }, match; // Detect all uniform names and types
            [
                shader.vertex,
                shader.fragment
            ].forEach(function(shader1) {
                while(match = uniRx.exec(shader1))uniformsData[match[2]] = match[1];
            }); // Get uniform references
            Object.keys(uniformsData).forEach(function(name) {
                var type = uniformsData[name];
                locations[name] = gl.getUniformLocation(shader.program, name);
                descriptor[name] = {
                    "get": (function(name1) {
                        /**
              * A getter for the uniform location
              * @ignore
              */ return function() {
                            return locations[name1];
                        };
                    })(name),
                    "set": (function(name1, type1, fn) {
                        if (type1.indexOf("mat") === 0) /**
                * A generic setter for uniform matrices
                * @ignore
                */ return function(val) {
                            gl[fn](locations[name1], false, val);
                        };
                        else /**
               * A generic setter for uniform vectors
               * @ignore
               */ return function(val) {
                            var fnv = fn;
                            if (val.length && fn.substr(-1) !== "v") fnv += "v";
                            gl[fnv](locations[name1], val);
                        };
                    })(name, type, "uniform" + fnHash[type])
                };
            });
            Object.defineProperties(uniforms, descriptor);
            return uniforms;
        }
        /**
      * @private
      */ function extractAttributes(gl, shader) {
            var attributes = {
            }, attrRx = /attribute\s+\w+\s+(\w+)/g, match, i = 0; // Detect all attribute names
            while(match = attrRx.exec(shader.vertex))attributes[match[1]] = i++;
            return attributes;
        }
        /**
      * @private
      */ function compileShader(gl, type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(shader));
            return shader;
        }
        /**
      * Compile GLSL into a shader object
      * @private
      */ function compileProgram(gl, vertex, fragment, attributes) {
            var vertShader = compileShader(gl, gl.VERTEX_SHADER, vertex);
            var fragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragment);
            var program = gl.createProgram();
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader); // force vertex attributes to use location 0 as starting location to prevent
            // browser to do complicated emulation when running on desktop OpenGL (e.g. on macOS)
            for(var location in attributes)gl.bindAttribLocation(program, attributes[location], location);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                var error_msg = "Error initializing Shader " + this + "\n" + "gl.VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n" + "gl.getError()" + gl.getError() + "\n" + "gl.getProgramInfoLog()" + gl.getProgramInfoLog(program); // house cleaning
                gl.deleteProgram(program);
                program = null; // throw the exception
                throw new Error(error_msg);
            }
            gl.useProgram(program); // clean-up
            gl.deleteShader(vertShader);
            gl.deleteShader(fragShader);
            return program;
        }
        /**
      * Hash map of GLSL data types to WebGL Uniform methods
      * @private
      */ var fnHash = {
            "bool": "1i",
            "int": "1i",
            "float": "1f",
            "vec2": "2fv",
            "vec3": "3fv",
            "vec4": "4fv",
            "bvec2": "2iv",
            "bvec3": "3iv",
            "bvec4": "4iv",
            "ivec2": "2iv",
            "ivec3": "3iv",
            "ivec4": "4iv",
            "mat2": "Matrix2fv",
            "mat3": "Matrix3fv",
            "mat4": "Matrix4fv",
            "sampler2D": "1i"
        };
        /**
      * set precision for the fiven shader source
      * won't do anything if the precision is already specified
      * @private
      */ function setPrecision(src, precision) {
            if (src.substring(0, 9) !== "precision") return "precision " + precision + " float;" + src;
            return src;
        }
        /**
      * clean the given source from space, comments, etc...
      * @private
      */ function minify(src) {
            // remove comments
            src = src.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, "$1"); // Remove leading and trailing whitespace from lines
            src = src.replace(/(\\n\s+)|(\s+\\n)/g, ""); // Remove line breaks
            src = src.replace(/(\\r|\\n)+/g, ""); // Remove unnecessary whitespace
            src = src.replace(/\s*([;,[\](){}\\\/\-+*|^&!=<>?~%])\s*/g, "$1");
            return src;
        }
        /**
      * a base GL Shader object
      * @class
      * @extends me.Object
      * @param {WebGLRenderingContext} gl the current WebGL rendering context
      * @param {String} vertex a string containing the GLSL source code to set
      * @param {String} fragment a string containing the GLSL source code to set
      * @param {String} [precision=auto detected] float precision ('lowp', 'mediump' or 'highp').
      * @constructor
      * @see https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders
      * @example
      * // create a basic shader
      * var myShader = new me.GLShader(
      *    // WebGL rendering context
      *    gl,
      *    // vertex shader
      *    [
      *        "void main() {",
      *        "    gl_Position = doMathToMakeClipspaceCoordinates;",
      *        "}"
      *    ].join("\n"),
      *    // fragment shader
      *    [
      *        "void main() {",
      *        "    gl_FragColor = doMathToMakeAColor;",
      *        "}"
      *    ].join("\n")
      *  )
      * // use the shader
      * myShader.bind();
      */ me.GLShader = me.Object.extend({
            /**
        * @ignore
        */ init: function init(gl, vertex, fragment, precision) {
                /**
          * the active gl rendering context
          * @public
          * @type {WebGLRenderingContext}
          * @name gl
          * @memberOf me.GLShader
          */ this.gl = gl;
                /**
          * the vertex shader source code
          * @public
          * @type {String}
          * @name vertex
          * @memberOf me.GLShader
          */ this.vertex = setPrecision(minify(vertex), precision || me.device.getMaxShaderPrecision(this.gl));
                /**
          * the fragment shader source code
          * @public
          * @type {String}
          * @name vertex
          * @memberOf me.GLShader
          */ this.fragment = setPrecision(minify(fragment), precision || me.device.getMaxShaderPrecision(this.gl));
                /**
          * the location attributes of the shader
          * @public
          * @type {GLint[]}
          * @name attributes
          * @memberOf me.GLShader
          */ this.attributes = extractAttributes(this.gl, this);
                /**
          * a reference to the shader program (once compiled)
          * @public
          * @type {WebGLProgram}
          * @name program
          * @memberOf me.GLShader
          */ this.program = compileProgram(this.gl, this.vertex, this.fragment, this.attributes);
                /**
          * the uniforms of the shader
          * @public
          * @type {Object}
          * @name uniforms
          * @memberOf me.GLShader
          */ this.uniforms = extractUniforms(this.gl, this); // destroy the shader on context lost (will be recreated on context restore)
                me.event.subscribe(me.event.WEBGL_ONCONTEXT_LOST, this.destroy.bind(this));
                return this;
            },
            /**
        * Installs this shader program as part of current rendering state
        * @name bind
        * @memberOf me.GLShader
        * @function
        */ bind: function bind() {
                this.gl.useProgram(this.program);
            },
            /**
        * returns the location of an attribute variable in this shader program
        * @name getAttribLocation
        * @memberOf me.GLShader
        * @function
        * @param {String} name the name of the attribute variable whose location to get.
        * @return {GLint} number indicating the location of the variable name if found. Returns -1 otherwise
        */ getAttribLocation: function getAttribLocation(name) {
                var attr = this.attributes[name];
                if (typeof attr !== "undefined") return attr;
                else return -1;
            },
            /**
        * Set the uniform to the given value
        * @name setUniform
        * @memberOf me.GLShader
        * @function
        * @param {String} name the uniform name
        * @param {Object|Float32Array} value the value to assign to that uniform
        * @example
        * myShader.setUniform("uProjectionMatrix", this.projectionMatrix);
        */ setUniform: function setUniform(name, value) {
                var uniforms = this.uniforms;
                if (typeof uniforms[name] !== "undefined") {
                    if (_typeof(value) === "object" && typeof value.toArray === "function") uniforms[name] = value.toArray();
                    else uniforms[name] = value;
                } else throw new Error("undefined (" + name + ") uniform for shader " + this);
            },
            /**
        * destroy this shader objects resources (program, attributes, uniforms)
        * @name destroy
        * @memberOf me.GLShader
        * @function
        */ destroy: function destroy() {
                this.uniforms = null;
                this.attributes = null;
                this.gl.deleteProgram(this.program);
                this.vertex = null;
                this.fragment = null;
            }
        });
    })();
    (function() {
        /**
      * cache value for the offset of the canvas position within the page
      * @ignore
      */ var viewportOffset = new me.Vector2d();
        /**
      * a pointer object, representing a single finger on a touch enabled device.
      * @class
      * @extends me.Rect
      * @memberOf me
      * @constructor
      */ me.Pointer = me.Rect.extend({
            /**
        * @ignore
        */ init: function init(x, y, w, h) {
                /**
           * the originating Event Object
           * @public
           * @type {PointerEvent|TouchEvent|MouseEvent}
           * @name event
           * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent
           * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
           * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
           * @memberOf me.Pointer
           */ this.event = undefined;
                /**
          * a string containing the event's type.
          * @public
          * @type {String}
          * @name type
          * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/type
          * @memberOf me.Pointer
          */ this.type = undefined;
                /**
          * the button property indicates which button was pressed on the mouse to trigger the event.
          * @public
          * @type {Number}
          * @name button
          * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
          * @memberOf me.Pointer
          */ this.button = 0;
                /**
          * indicates whether or not the pointer device that created the event is the primary pointer.
          * @public
          * @type {Boolean}
          * @name isPrimary
          * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
          * @memberOf me.Pointer
          */ this.isPrimary = false;
                /**
          * the horizontal coordinate at which the event occurred, relative to the left edge of the entire document.
          * @public
          * @type {Number}
          * @name pageX
          * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageX
          * @memberOf me.Pointer
          */ this.pageX = 0;
                /**
          * the vertical coordinate at which the event occurred, relative to the left edge of the entire document.
          * @public
          * @type {Number}
          * @name pageY
          * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageY
          * @memberOf me.Pointer
          */ this.pageY = 0;
                /**
          * the horizontal coordinate within the application's client area at which the event occurred
          * @public
          * @type {Number}
          * @name clientX
          * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientX
          * @memberOf me.Pointer
          */ this.clientX = 0;
                /**
          * the vertical coordinate within the application's client area at which the event occurred
          * @public
          * @type {Number}
          * @name clientY
          * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientY
          * @memberOf me.Pointer
          */ this.clientY = 0;
                /**
          * an unsigned long representing the unit of the delta values scroll amount
          * @public
          * @type {Number}
          * @name deltaMode
          * @see https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode
          * @memberOf me.Pointer
          */ this.deltaMode = 0;
                /**
          * a double representing the horizontal scroll amount in the Wheel Event deltaMode unit.
          * @public
          * @type {Number}
          * @name deltaX
          * @see https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaX
          * @memberOf me.Pointer
          */ this.deltaX = 0;
                /**
          * a double representing the vertical scroll amount in the Wheel Event deltaMode unit.
          * @public
          * @type {Number}
          * @name deltaY
          * @see https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaY
          * @memberOf me.Pointer
          */ this.deltaY = 0;
                /**
          * a double representing the scroll amount in the z-axis, in the Wheel Event deltaMode unit.
          * @public
          * @type {Number}
          * @name deltaZ
          * @see https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaZ
          * @memberOf me.Pointer
          */ this.deltaZ = 0;
                /**
          * Event normalized X coordinate within the game canvas itself<br>
          * <img src="images/event_coord.png"/>
          * @public
          * @type {Number}
          * @name gameX
          * @memberOf me.Pointer
          */ this.gameX = 0;
                /**
          * Event normalized Y coordinate within the game canvas itself<br>
          * <img src="images/event_coord.png"/>
          * @public
          * @type {Number}
          * @name gameY
          * @memberOf me.Pointer
          */ this.gameY = 0;
                /**
          * Event X coordinate relative to the viewport
          * @public
          * @type {Number}
          * @name gameScreenX
          * @memberOf me.Pointer
          */ this.gameScreenX = 0;
                /**
          * Event Y coordinate relative to the viewport
          * @public
          * @type {Number}
          * @name gameScreenY
          * @memberOf me.Pointer
          */ this.gameScreenY = 0;
                /**
          * Event X coordinate relative to the map
          * @public
          * @type {Number}
          * @name gameWorldX
          * @memberOf me.Pointer
          */ this.gameWorldX = 0;
                /**
          * Event Y coordinate relative to the map
          * @public
          * @type {Number}
          * @name gameWorldY
          * @memberOf me.Pointer
          */ this.gameWorldY = 0;
                /**
          * Event X coordinate relative to the holding container
          * @public
          * @type {Number}
          * @name gameLocalX
          * @memberOf me.Pointer
          */ this.gameLocalX = 0;
                /**
          * Event Y coordinate relative to the holding container
          * @public
          * @type {Number}
          * @name gameLocalY
          * @memberOf me.Pointer
          */ this.gameLocalY = 0;
                /**
          * The unique identifier of the contact for a touch, mouse or pen
          * @public
          * @type {Number}
          * @name pointerId
          * @memberOf me.Pointer
          * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
          */ this.pointerId = undefined; // parent constructor
                this._super(me.Rect, "init", [
                    x || 0,
                    y || 0,
                    w || 1,
                    h || 1
                ]);
            },
            /**
        * initialize the Pointer object using the given Event Object
        * @name me.Pointer#set
        * @private
        * @function
        * @param {Event} event the original Event object
        * @param {Number} pageX the horizontal coordinate at which the event occurred, relative to the left edge of the entire document
        * @param {Number} pageY the vertical coordinate at which the event occurred, relative to the left edge of the entire document
        * @param {Number} clientX the horizontal coordinate within the application's client area at which the event occurred
        * @param {Number} clientX the vertical coordinate within the application's client area at which the event occurred
        * @param {Number} pointedId the Pointer, Touch or Mouse event Id
        */ setEvent: function setEvent(event, pageX, pageY, clientX, clientY, pointerId) {
                var width = 1;
                var height = 1; // the original event object
                this.event = event;
                this.pageX = pageX || 0;
                this.pageY = pageY || 0;
                this.clientX = clientX || 0;
                this.clientY = clientY || 0; // translate to local coordinates
                me.input.globalToLocal(this.pageX, this.pageY, this.pos); // true if not originally a pointer event
                this.isNormalized = !me.device.PointerEvent || me.device.PointerEvent && !(event instanceof window.PointerEvent);
                if (event.type === "wheel") {
                    this.deltaMode = event.deltaMode || 0;
                    this.deltaX = event.deltaX || 0;
                    this.deltaY = event.deltaY || 0;
                    this.deltaZ = event.deltaZ || 0;
                } else {
                    this.deltaMode = 0;
                    this.deltaX = 0;
                    this.deltaY = 0;
                    this.deltaZ = 0;
                } // could be 0, so test if defined
                this.pointerId = typeof pointerId !== "undefined" ? pointerId : 1;
                this.isPrimary = typeof event.isPrimary !== "undefined" ? event.isPrimary : true; // in case of touch events, button is not defined
                this.button = event.button || 0;
                this.type = event.type;
                this.gameScreenX = this.pos.x;
                this.gameScreenY = this.pos.y; // get the current screen to world offset
                if (typeof me.game.viewport !== "undefined") me.game.viewport.localToWorld(this.gameScreenX, this.gameScreenY, viewportOffset);
                /* Initialize the two coordinate space properties. */ this.gameWorldX = viewportOffset.x;
                this.gameWorldY = viewportOffset.y; // get the pointer size
                if (this.isNormalized === false) {
                    // native PointerEvent
                    width = event.width || 1;
                    height = event.height || 1;
                } else if (typeof event.radiusX === "number") {
                    // TouchEvent
                    width = event.radiusX * 2 || 1;
                    height = event.radiusY * 2 || 1;
                } // resize the pointer object accordingly
                this.resize(width, height);
            }
        });
    })();
    (function() {
        /**
      * @namespace me.input
      * @memberOf me
      */ me.input = {
            /**
        * the default target element for keyboard events (usually the window element in which the game is running)
        * @public
        * @type EventTarget
        * @name keyBoardEventTarget
        * @memberOf me.input
        */ keyBoardEventTarget: null,
            /**
        * the default target element for pointer events (usually the canvas element in which the game is rendered)
        * @public
        * @type EventTarget
        * @name pointerEventTarget
        * @memberOf me.input
        */ pointerEventTarget: null,
            /**
        * specify if melonJS should prevent all default browser action on registered events.
        * @public
        * @type Boolean
        * @default true
        * @name preventDefault
        * @memberOf me.input
        */ preventDefault: true
        };
    })();
    (function(api) {
        /*
      * PRIVATE STUFF
      */ // corresponding actions
        var keyStatus = {
        }; // lock enable flag for keys
        var keyLock = {
        }; // actual lock status of each key
        var keyLocked = {
        }; // List of binded keys being held
        var keyRefs = {
        }; // whether default event should be prevented for a given keypress
        var preventDefaultForKeys = {
        }; // list of binded keys
        var keyBindings = {
        };
        /**
      * key down event
      * @ignore
      */ var keyDownEvent = function keyDownEvent1(e, keyCode, mouseButton) {
            keyCode = keyCode || e.keyCode || e.button;
            var action = keyBindings[keyCode]; // publish a message for keydown event
            me.event.publish(me.event.KEYDOWN, [
                action,
                keyCode,
                action ? !keyLocked[action] : true
            ]);
            if (action) {
                if (!keyLocked[action]) {
                    var trigger = typeof mouseButton !== "undefined" ? mouseButton : keyCode;
                    if (!keyRefs[action][trigger]) {
                        keyStatus[action]++;
                        keyRefs[action][trigger] = true;
                    }
                } // prevent event propagation
                if (preventDefaultForKeys[keyCode] && typeof e.preventDefault === "function") // "fake" events generated through triggerKeyEvent do not have a preventDefault fn
                return e.preventDefault();
                else return true;
            }
            return true;
        };
        /**
      * key up event
      * @ignore
      */ var keyUpEvent = function keyUpEvent1(e, keyCode, mouseButton) {
            keyCode = keyCode || e.keyCode || e.button;
            var action = keyBindings[keyCode]; // publish a message for keydown event
            me.event.publish(me.event.KEYUP, [
                action,
                keyCode
            ]);
            if (action) {
                var trigger = typeof mouseButton !== "undefined" ? mouseButton : keyCode;
                keyRefs[action][trigger] = undefined;
                if (keyStatus[action] > 0) keyStatus[action]--;
                keyLocked[action] = false; // prevent event propagation
                if (preventDefaultForKeys[keyCode] && typeof e.preventDefault === "function") // "fake" events generated through triggerKeyEvent do not have a preventDefault fn
                return e.preventDefault();
                else return true;
            }
            return true;
        };
        /*
      * PUBLIC STUFF
      */ /**
      * standard keyboard constants
      * @public
      * @enum {number}
      * @namespace KEY
      * @memberOf me.input
      */ api.KEY = {
            /** @memberOf me.input.KEY */ "BACKSPACE": 8,
            /** @memberOf me.input.KEY */ "TAB": 9,
            /** @memberOf me.input.KEY */ "ENTER": 13,
            /** @memberOf me.input.KEY */ "SHIFT": 16,
            /** @memberOf me.input.KEY */ "CTRL": 17,
            /** @memberOf me.input.KEY */ "ALT": 18,
            /** @memberOf me.input.KEY */ "PAUSE": 19,
            /** @memberOf me.input.KEY */ "CAPS_LOCK": 20,
            /** @memberOf me.input.KEY */ "ESC": 27,
            /** @memberOf me.input.KEY */ "SPACE": 32,
            /** @memberOf me.input.KEY */ "PAGE_UP": 33,
            /** @memberOf me.input.KEY */ "PAGE_DOWN": 34,
            /** @memberOf me.input.KEY */ "END": 35,
            /** @memberOf me.input.KEY */ "HOME": 36,
            /** @memberOf me.input.KEY */ "LEFT": 37,
            /** @memberOf me.input.KEY */ "UP": 38,
            /** @memberOf me.input.KEY */ "RIGHT": 39,
            /** @memberOf me.input.KEY */ "DOWN": 40,
            /** @memberOf me.input.KEY */ "PRINT_SCREEN": 42,
            /** @memberOf me.input.KEY */ "INSERT": 45,
            /** @memberOf me.input.KEY */ "DELETE": 46,
            /** @memberOf me.input.KEY */ "NUM0": 48,
            /** @memberOf me.input.KEY */ "NUM1": 49,
            /** @memberOf me.input.KEY */ "NUM2": 50,
            /** @memberOf me.input.KEY */ "NUM3": 51,
            /** @memberOf me.input.KEY */ "NUM4": 52,
            /** @memberOf me.input.KEY */ "NUM5": 53,
            /** @memberOf me.input.KEY */ "NUM6": 54,
            /** @memberOf me.input.KEY */ "NUM7": 55,
            /** @memberOf me.input.KEY */ "NUM8": 56,
            /** @memberOf me.input.KEY */ "NUM9": 57,
            /** @memberOf me.input.KEY */ "A": 65,
            /** @memberOf me.input.KEY */ "B": 66,
            /** @memberOf me.input.KEY */ "C": 67,
            /** @memberOf me.input.KEY */ "D": 68,
            /** @memberOf me.input.KEY */ "E": 69,
            /** @memberOf me.input.KEY */ "F": 70,
            /** @memberOf me.input.KEY */ "G": 71,
            /** @memberOf me.input.KEY */ "H": 72,
            /** @memberOf me.input.KEY */ "I": 73,
            /** @memberOf me.input.KEY */ "J": 74,
            /** @memberOf me.input.KEY */ "K": 75,
            /** @memberOf me.input.KEY */ "L": 76,
            /** @memberOf me.input.KEY */ "M": 77,
            /** @memberOf me.input.KEY */ "N": 78,
            /** @memberOf me.input.KEY */ "O": 79,
            /** @memberOf me.input.KEY */ "P": 80,
            /** @memberOf me.input.KEY */ "Q": 81,
            /** @memberOf me.input.KEY */ "R": 82,
            /** @memberOf me.input.KEY */ "S": 83,
            /** @memberOf me.input.KEY */ "T": 84,
            /** @memberOf me.input.KEY */ "U": 85,
            /** @memberOf me.input.KEY */ "V": 86,
            /** @memberOf me.input.KEY */ "W": 87,
            /** @memberOf me.input.KEY */ "X": 88,
            /** @memberOf me.input.KEY */ "Y": 89,
            /** @memberOf me.input.KEY */ "Z": 90,
            /** @memberOf me.input.KEY */ "WINDOW_KEY": 91,
            /** @memberOf me.input.KEY */ "NUMPAD0": 96,
            /** @memberOf me.input.KEY */ "NUMPAD1": 97,
            /** @memberOf me.input.KEY */ "NUMPAD2": 98,
            /** @memberOf me.input.KEY */ "NUMPAD3": 99,
            /** @memberOf me.input.KEY */ "NUMPAD4": 100,
            /** @memberOf me.input.KEY */ "NUMPAD5": 101,
            /** @memberOf me.input.KEY */ "NUMPAD6": 102,
            /** @memberOf me.input.KEY */ "NUMPAD7": 103,
            /** @memberOf me.input.KEY */ "NUMPAD8": 104,
            /** @memberOf me.input.KEY */ "NUMPAD9": 105,
            /** @memberOf me.input.KEY */ "MULTIPLY": 106,
            /** @memberOf me.input.KEY */ "ADD": 107,
            /** @memberOf me.input.KEY */ "SUBSTRACT": 109,
            /** @memberOf me.input.KEY */ "DECIMAL": 110,
            /** @memberOf me.input.KEY */ "DIVIDE": 111,
            /** @memberOf me.input.KEY */ "F1": 112,
            /** @memberOf me.input.KEY */ "F2": 113,
            /** @memberOf me.input.KEY */ "F3": 114,
            /** @memberOf me.input.KEY */ "F4": 115,
            /** @memberOf me.input.KEY */ "F5": 116,
            /** @memberOf me.input.KEY */ "F6": 117,
            /** @memberOf me.input.KEY */ "F7": 118,
            /** @memberOf me.input.KEY */ "F8": 119,
            /** @memberOf me.input.KEY */ "F9": 120,
            /** @memberOf me.input.KEY */ "F10": 121,
            /** @memberOf me.input.KEY */ "F11": 122,
            /** @memberOf me.input.KEY */ "F12": 123,
            /** @memberOf me.input.KEY */ "TILDE": 126,
            /** @memberOf me.input.KEY */ "NUM_LOCK": 144,
            /** @memberOf me.input.KEY */ "SCROLL_LOCK": 145,
            /** @memberOf me.input.KEY */ "SEMICOLON": 186,
            /** @memberOf me.input.KEY */ "PLUS": 187,
            /** @memberOf me.input.KEY */ "COMMA": 188,
            /** @memberOf me.input.KEY */ "MINUS": 189,
            /** @memberOf me.input.KEY */ "PERIOD": 190,
            /** @memberOf me.input.KEY */ "FORWAND_SLASH": 191,
            /** @memberOf me.input.KEY */ "GRAVE_ACCENT": 192,
            /** @memberOf me.input.KEY */ "OPEN_BRACKET": 219,
            /** @memberOf me.input.KEY */ "BACK_SLASH": 220,
            /** @memberOf me.input.KEY */ "CLOSE_BRACKET": 221,
            /** @memberOf me.input.KEY */ "SINGLE_QUOTE": 222
        };
        /**
      * enable keyboard event
      * @ignore
      */ api.initKeyboardEvent = function() {
            // make sure the keyboard is enable
            if (me.input.keyBoardEventTarget === null && me.device.isMobile === false) {
                me.input.keyBoardEventTarget = window;
                me.input.keyBoardEventTarget.addEventListener("keydown", keyDownEvent, false);
                me.input.keyBoardEventTarget.addEventListener("keyup", keyUpEvent, false);
            }
        };
        /**
      * return the key press status of the specified action
      * @name isKeyPressed
      * @memberOf me.input
      * @public
      * @function
      * @param {String} action user defined corresponding action
      * @return {Boolean} true if pressed
      * @example
      * if (me.input.isKeyPressed('left'))
      * {
      *    //do something
      * }
      * else if (me.input.isKeyPressed('right'))
      * {
      *    //do something else...
      * }
      *
      */ api.isKeyPressed = function(action) {
            if (keyStatus[action] && !keyLocked[action]) {
                if (keyLock[action]) keyLocked[action] = true;
                return true;
            }
            return false;
        };
        /**
      * return the key status of the specified action
      * @name keyStatus
      * @memberOf me.input
      * @public
      * @function
      * @param {String} action user defined corresponding action
      * @return {Boolean} down (true) or up(false)
      */ api.keyStatus = function(action) {
            return keyStatus[action] > 0;
        };
        /**
      * trigger the specified key (simulated) event <br>
      * @name triggerKeyEvent
      * @memberOf me.input
      * @public
      * @function
      * @param {me.input.KEY} keycode
      * @param {Boolean} [status=false] true to trigger a key down event, or false for key up event
      * @example
      * // trigger a key press
      * me.input.triggerKeyEvent(me.input.KEY.LEFT, true);
      */ api.triggerKeyEvent = function(keycode, status, mouseButton) {
            if (status === true) keyDownEvent({
            }, keycode, mouseButton);
            else keyUpEvent({
            }, keycode, mouseButton);
        };
        /**
      * associate a user defined action to a keycode
      * @name bindKey
      * @memberOf me.input
      * @public
      * @function
      * @param {me.input.KEY} keycode
      * @param {String} action user defined corresponding action
      * @param {Boolean} [lock=false] cancel the keypress event once read
      * @param {Boolean} [preventDefault=me.input.preventDefault] prevent default browser action
      * @example
      * // enable the keyboard
      * me.input.bindKey(me.input.KEY.LEFT,  "left");
      * me.input.bindKey(me.input.KEY.RIGHT, "right");
      * me.input.bindKey(me.input.KEY.X,     "jump", true);
      * me.input.bindKey(me.input.KEY.F1,    "options", true, true);
      */ api.bindKey = function(keycode, action, lock, preventDefault) {
            if (typeof preventDefault !== "boolean") preventDefault = me.input.preventDefault;
            keyBindings[keycode] = action;
            preventDefaultForKeys[keycode] = preventDefault;
            keyStatus[action] = 0;
            keyLock[action] = lock ? lock : false;
            keyLocked[action] = false;
            keyRefs[action] = {
            };
        };
        /**
      * return the action associated with the given keycode
      * @name getBindingKey
      * @memberOf me.input
      * @public
      * @function
      * @param {me.input.KEY} keycode
      * @return {String} user defined associated action
      */ api.getBindingKey = function(keycode) {
            return keyBindings[keycode];
        };
        /**
      * unlock a key manually
      * @name unlockKey
      * @memberOf me.input
      * @public
      * @function
      * @param {String} action user defined corresponding action
      * @example
      * // Unlock jump when touching the ground
      * if (!this.falling && !this.jumping) {
      *     me.input.unlockKey("jump");
      * }
      */ api.unlockKey = function(action) {
            keyLocked[action] = false;
        };
        /**
      * unbind the defined keycode
      * @name unbindKey
      * @memberOf me.input
      * @public
      * @function
      * @param {me.input.KEY} keycode
      * @example
      * me.input.unbindKey(me.input.KEY.LEFT);
      */ api.unbindKey = function(keycode) {
            // clear the event status
            var keybinding = keyBindings[keycode];
            keyStatus[keybinding] = 0;
            keyLock[keybinding] = false;
            keyRefs[keybinding] = {
            }; // remove the key binding
            keyBindings[keycode] = null;
            preventDefaultForKeys[keycode] = null;
        };
    })(me.input);
    (function(api) {
        /**
      * A pool of `Pointer` objects to cache pointer/touch event coordinates.
      * @type {Array.<Vector>}
      */ var T_POINTERS = []; // list of registered Event handlers
        var eventHandlers = new Map(); // a cache rect represeting the current pointer area
        var currentPointer = new me.Rect(0, 0, 1, 1); // some useful flags
        var pointerInitialized = false; // Track last event timestamp to prevent firing events out of order
        var lastTimeStamp = 0; // "active" list of supported events
        var activeEventList = []; // internal constants
        var WHEEL = [
            "wheel"
        ];
        var POINTER_MOVE = [
            "pointermove",
            "mousemove",
            "touchmove"
        ];
        var POINTER_DOWN = [
            "pointerdown",
            "mousedown",
            "touchstart"
        ];
        var POINTER_UP = [
            "pointerup",
            "mouseup",
            "touchend"
        ];
        var POINTER_CANCEL = [
            "pointercancel",
            "mousecancel",
            "touchcancel"
        ];
        var POINTER_ENTER = [
            "pointerenter",
            "mouseenter",
            "touchenter"
        ];
        var POINTER_OVER = [
            "pointerover",
            "mouseover",
            "touchover"
        ];
        var POINTER_LEAVE = [
            "pointerleave",
            "mouseleave",
            "touchleave"
        ]; // list of standard pointer event type
        var pointerEventList = [
            WHEEL[0],
            POINTER_MOVE[0],
            POINTER_DOWN[0],
            POINTER_UP[0],
            POINTER_CANCEL[0],
            POINTER_ENTER[0],
            POINTER_OVER[0],
            POINTER_LEAVE[0]
        ]; // legacy mouse event type
        var mouseEventList = [
            WHEEL[0],
            POINTER_MOVE[1],
            POINTER_DOWN[1],
            POINTER_UP[1],
            POINTER_CANCEL[1],
            POINTER_ENTER[1],
            POINTER_OVER[1],
            POINTER_LEAVE[1]
        ]; // iOS style touch event type
        var touchEventList = [
            POINTER_MOVE[2],
            POINTER_DOWN[2],
            POINTER_UP[2],
            POINTER_CANCEL[2],
            POINTER_ENTER[2],
            POINTER_OVER[2],
            POINTER_LEAVE[2]
        ];
        var pointerEventMap = {
            wheel: WHEEL,
            pointermove: POINTER_MOVE,
            pointerdown: POINTER_DOWN,
            pointerup: POINTER_UP,
            pointercancel: POINTER_CANCEL,
            pointerenter: POINTER_ENTER,
            pointerover: POINTER_OVER,
            pointerleave: POINTER_LEAVE
        };
        /**
      * Array of normalized events (mouse, touch, pointer)
      * @ignore
      */ var normalizedEvents = [];
        /**
      * addEventListerner for the specified event list and callback
      * @ignore
      */ function registerEventListener(eventList, callback) {
            for(var x = 0; x < eventList.length; x++)if (POINTER_MOVE.indexOf(eventList[x]) === -1) me.input.pointerEventTarget.addEventListener(eventList[x], callback, {
                passive: api.preventDefault === false
            });
        }
        /**
      * enable pointer event (Pointer/Mouse/Touch)
      * @ignore
      */ function enablePointerEvent() {
            if (!pointerInitialized) {
                // instantiate a pool of pointer catched
                for(var v = 0; v < me.device.maxTouchPoints; v++)T_POINTERS.push(new me.Pointer());
                if (me.input.pointerEventTarget === null) // default pointer event target
                me.input.pointerEventTarget = me.video.renderer.getScreenCanvas();
                if (me.device.PointerEvent) // standard Pointer Events
                activeEventList = pointerEventList;
                else // Regular Mouse events
                activeEventList = mouseEventList;
                if (me.device.touch && !me.device.PointerEvent) // touch event on mobile devices
                activeEventList = activeEventList.concat(touchEventList);
                registerEventListener(activeEventList, onPointerEvent); // set the PointerMove/touchMove/MouseMove event
                if (typeof api.throttlingInterval === "undefined") // set the default value
                api.throttlingInterval = ~~(1000 / me.timer.maxfps);
                if (me.sys.autoFocus === true) {
                    me.device.focus();
                    me.input.pointerEventTarget.addEventListener(activeEventList[2], function() {
                        me.device.focus();
                    }, {
                        passive: api.preventDefault === false
                    });
                } // if time interval <= 16, disable the feature
                var i;
                var events = findAllActiveEvents(activeEventList, POINTER_MOVE);
                if (api.throttlingInterval < 17) {
                    for(i = 0; i < events.length; i++)if (activeEventList.indexOf(events[i]) !== -1) me.input.pointerEventTarget.addEventListener(events[i], onMoveEvent, {
                        passive: true
                    } // do not preventDefault on Move events
                    );
                } else {
                    for(i = 0; i < events.length; i++)if (activeEventList.indexOf(events[i]) !== -1) me.input.pointerEventTarget.addEventListener(events[i], me.utils["function"].throttle(onMoveEvent, api.throttlingInterval, false), {
                        passive: true
                    } // do not preventDefault on Move events
                    );
                } // disable all gesture by default
                me.input.setTouchAction(me.input.pointerEventTarget);
                pointerInitialized = true;
            }
        }
        /**
      * @ignore
      */ function findActiveEvent(activeEventList1, eventTypes) {
            for(var i = 0; i < eventTypes.length; i++){
                var event = activeEventList1.indexOf(eventTypes[i]);
                if (event !== -1) return eventTypes[i];
            }
        }
        /**
      * @ignore
      */ function findAllActiveEvents(activeEventList1, eventTypes) {
            var events = [];
            for(var i = 0; i < eventTypes.length; i++){
                var event = activeEventList1.indexOf(eventTypes[i]);
                if (event !== -1) events.push(eventTypes[i]);
            }
            return events;
        }
        /**
      * @ignore
      */ function triggerEvent(handlers, type, pointer, pointerId) {
            var callback;
            if (handlers.callbacks[type]) {
                handlers.pointerId = pointerId;
                for(var i = handlers.callbacks[type].length - 1; i >= 0 && (callback = handlers.callbacks[type][i]); i--){
                    if (callback(pointer) === false) // stop propagating the event if return false
                    return true;
                }
            }
            return false;
        }
        /**
      * propagate events to registered objects
      * @ignore
      */ function dispatchEvent(normalizedEvents1) {
            var handled = false;
            while(normalizedEvents1.length > 0){
                // keep a reference to the last item
                var pointer = normalizedEvents1.pop(); // and put it back into our cache
                T_POINTERS.push(pointer); // Do not fire older events
                if (typeof pointer.event.timeStamp !== "undefined") {
                    if (pointer.event.timeStamp < lastTimeStamp) continue;
                    lastTimeStamp = pointer.event.timeStamp;
                }
                currentPointer.setShape(pointer.gameWorldX, pointer.gameWorldY, pointer.width, pointer.height); // trigger a global event for pointer move
                if (POINTER_MOVE.includes(pointer.type)) {
                    pointer.gameX = pointer.gameLocalX = pointer.gameScreenX;
                    pointer.gameY = pointer.gameLocalY = pointer.gameScreenY;
                    me.event.publish(me.event.POINTERMOVE, [
                        pointer
                    ]);
                }
                var candidates = me.game.world.broadphase.retrieve(currentPointer, me.Container.prototype._sortReverseZ); // add the main viewport to the list of candidates
                candidates = candidates.concat([
                    me.game.viewport
                ]);
                for(var c = candidates.length, candidate; c--, candidate = candidates[c];){
                    if (eventHandlers.has(candidate) && candidate.isKinematic !== true) {
                        var handlers = eventHandlers.get(candidate);
                        var region = handlers.region;
                        var ancestor = region.ancestor;
                        var bounds = region.getBounds();
                        var eventInBounds = false;
                        if (region.floating === true) {
                            pointer.gameX = pointer.gameLocalX = pointer.gameScreenX;
                            pointer.gameY = pointer.gameLocalY = pointer.gameScreenY;
                        } else {
                            pointer.gameX = pointer.gameLocalX = pointer.gameWorldX;
                            pointer.gameY = pointer.gameLocalY = pointer.gameWorldY;
                        } // adjust gameLocalX to specify coordinates
                        // within the region ancestor container
                        if (typeof ancestor !== "undefined") {
                            var parentPos = ancestor.getBounds().pos;
                            pointer.gameLocalX = pointer.gameX - parentPos.x;
                            pointer.gameLocalY = pointer.gameY - parentPos.y;
                        }
                        if (region instanceof me.Sprite) {
                            var gameX = pointer.gameX;
                            var gameY = pointer.gameY;
                            if (!region.currentTransform.isIdentity()) {
                                var invV = region.currentTransform.applyInverse(me.pool.pull("me.Vector2d", gameX, gameY));
                                gameX = invV.x;
                                gameY = invV.y;
                                me.pool.push(invV);
                            }
                            eventInBounds = bounds.containsPoint(gameX, gameY);
                        } else eventInBounds = bounds.containsPoint(pointer.gameX, pointer.gameY) && (bounds === region || region.containsPoint(pointer.gameLocalX, pointer.gameLocalY));
                        switch(pointer.type){
                            case POINTER_MOVE[0]:
                            case POINTER_MOVE[1]:
                            case POINTER_MOVE[2]:
                            case POINTER_MOVE[3]:
                                // moved out of bounds: trigger the POINTER_LEAVE callbacks
                                if (handlers.pointerId === pointer.pointerId && !eventInBounds) {
                                    if (triggerEvent(handlers, findActiveEvent(activeEventList, POINTER_LEAVE), pointer, null)) {
                                        handled = true;
                                        break;
                                    }
                                } else if (handlers.pointerId === null && eventInBounds) {
                                    if (triggerEvent(handlers, findActiveEvent(activeEventList, POINTER_ENTER), pointer, pointer.pointerId)) {
                                        handled = true;
                                        break;
                                    }
                                } // trigger the POINTER_MOVE callbacks
                                if (eventInBounds && triggerEvent(handlers, pointer.type, pointer, pointer.pointerId)) {
                                    handled = true;
                                    break;
                                }
                                break;
                            case POINTER_UP[0]:
                            case POINTER_UP[1]:
                            case POINTER_UP[2]:
                            case POINTER_UP[3]:
                                // pointer defined & inside of bounds: trigger the POINTER_UP callback
                                if (handlers.pointerId === pointer.pointerId && eventInBounds) // trigger the corresponding callback
                                {
                                    if (triggerEvent(handlers, pointer.type, pointer, null)) {
                                        handled = true;
                                        break;
                                    }
                                }
                                break;
                            case POINTER_CANCEL[0]:
                            case POINTER_CANCEL[1]:
                            case POINTER_CANCEL[2]:
                            case POINTER_CANCEL[3]:
                                // pointer defined: trigger the POINTER_CANCEL callback
                                if (handlers.pointerId === pointer.pointerId) // trigger the corresponding callback
                                {
                                    if (triggerEvent(handlers, pointer.type, pointer, null)) {
                                        handled = true;
                                        break;
                                    }
                                }
                                break;
                            default:
                                // event inside of bounds: trigger the POINTER_DOWN or WHEEL callback
                                if (eventInBounds) // trigger the corresponding callback
                                {
                                    if (triggerEvent(handlers, pointer.type, pointer, pointer.pointerId)) {
                                        handled = true;
                                        break;
                                    }
                                }
                                break;
                        }
                    }
                    if (handled === true) break;
                }
            }
            return handled;
        }
        /**
      * translate event coordinates
      * @ignore
      */ function normalizeEvent(event) {
            var pointer; // PointerEvent or standard Mouse event
            if (me.device.TouchEvent && event.changedTouches) // iOS/Android Touch event
            for(var i = 0, l = event.changedTouches.length; i < l; i++){
                var touchEvent = event.changedTouches[i];
                pointer = T_POINTERS.pop();
                pointer.setEvent(event, touchEvent.pageX, touchEvent.pageY, touchEvent.clientX, touchEvent.clientY, touchEvent.identifier);
                normalizedEvents.push(pointer);
            }
            else {
                // Mouse or PointerEvent
                pointer = T_POINTERS.pop();
                pointer.setEvent(event, event.pageX, event.pageY, event.clientX, event.clientY, event.pointerId);
                normalizedEvents.push(pointer);
            } // if event.isPrimary is defined and false, return
            if (event.isPrimary === false) return normalizedEvents;
             // else use the first entry to simulate mouse event
            normalizedEvents[0].isPrimary = true;
            Object.assign(api.pointer, normalizedEvents[0]);
            return normalizedEvents;
        }
        /**
      * mouse/touch/pointer event management (move)
      * @ignore
      */ function onMoveEvent(e) {
            // dispatch mouse event to registered object
            dispatchEvent(normalizeEvent(e)); // do not prevent default on moveEvent :
        }
        /**
      * mouse/touch/pointer event management (start/down, end/up)
      * @ignore
      */ function onPointerEvent(e) {
            // normalize eventTypes
            normalizeEvent(e); // remember/use the first "primary" normalized event for pointer.bind
            var button = normalizedEvents[0].button; // dispatch event to registered objects
            if (dispatchEvent(normalizedEvents) || e.type === "wheel") // always preventDefault for wheel event (?legacy code/behavior?)
            {
                if (api.preventDefault === true) e.preventDefault();
            }
            var keycode = api.pointer.bind[button]; // check if mapped to a key
            if (keycode) me.input.triggerKeyEvent(keycode, POINTER_DOWN.includes(e.type), button + 1);
        }
        /*
      * PUBLIC STUFF
      */ /**
      * Pointer information (current position and size) <br>
      * properties : <br>
      * LEFT : constant for left button <br>
      * MIDDLE : constant for middle button <br>
      * RIGHT : constant for right button
      * @public
      * @type {me.Rect}
      * @name pointer
      * @memberOf me.input
      */ api.pointer = new me.Pointer(0, 0, 1, 1); // bind list for mouse buttons
        api.pointer.bind = [
            0,
            0,
            0
        ]; // W3C button constants
        api.pointer.LEFT = 0;
        api.pointer.MIDDLE = 1;
        api.pointer.RIGHT = 2;
        /**
      * time interval for event throttling in milliseconds<br>
      * default value : "1000/me.timer.maxfps" ms<br>
      * set to 0 ms to disable the feature
      * @public
      * @type Number
      * @name throttlingInterval
      * @memberOf me.input
      */ api.throttlingInterval = undefined;
        /**
      * Translate the specified x and y values from the global (absolute)
      * coordinate to local (viewport) relative coordinate.
      * @name globalToLocal
      * @memberOf me.input
      * @public
      * @function
      * @param {Number} x the global x coordinate to be translated.
      * @param {Number} y the global y coordinate to be translated.
      * @param {Number} [v] an optional vector object where to set the
      * @return {me.Vector2d} A vector object with the corresponding translated coordinates.
      * @example
      * onMouseEvent : function (pointer) {
      *    // convert the given into local (viewport) relative coordinates
      *    var pos = me.input.globalToLocal(pointer.clientX, pointer.clientY);
      *    // do something with pos !
      * };
      */ api.globalToLocal = function(x, y, v) {
            v = v || new me.Vector2d();
            var rect = me.device.getElementBounds(me.video.renderer.getScreenCanvas());
            var pixelRatio = me.device.devicePixelRatio;
            x -= rect.left + (window.pageXOffset || 0);
            y -= rect.top + (window.pageYOffset || 0);
            var scale = me.video.scaleRatio;
            if (scale.x !== 1 || scale.y !== 1) {
                x /= scale.x;
                y /= scale.y;
            }
            return v.set(x * pixelRatio, y * pixelRatio);
        };
        /**
      * enable/disable all gestures on the given element.<br>
      * by default melonJS will disable browser handling of all panning and zooming gestures.
      * @name setTouchAction
      * @memberOf me.input
      * @see https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action
      * @public
      * @function
      * @param {HTMLCanvasElement} element
      * @param {String} [value="none"]
      */ api.setTouchAction = function(element, value) {
            element.style["touch-action"] = value || "none";
        };
        /**
      * Associate a pointer event to a keycode<br>
      * Left button – 0
      * Middle button – 1
      * Right button – 2
      * @name bindPointer
      * @memberOf me.input
      * @public
      * @function
      * @param {Number} [button=me.input.pointer.LEFT] (accordingly to W3C values : 0,1,2 for left, middle and right buttons)
      * @param {me.input.KEY} keyCode
      * @example
      * // enable the keyboard
      * me.input.bindKey(me.input.KEY.X, "shoot");
      * // map the left button click on the X key (default if the button is not specified)
      * me.input.bindPointer(me.input.KEY.X);
      * // map the right button click on the X key
      * me.input.bindPointer(me.input.pointer.RIGHT, me.input.KEY.X);
      */ api.bindPointer = function() {
            var button = arguments.length < 2 ? api.pointer.LEFT : arguments[0];
            var keyCode = arguments.length < 2 ? arguments[0] : arguments[1]; // make sure the mouse is initialized
            enablePointerEvent(); // throw an exception if no action is defined for the specified keycode
            if (!me.input.getBindingKey(keyCode)) throw new Error("no action defined for keycode " + keyCode);
             // map the mouse button to the keycode
            api.pointer.bind[button] = keyCode;
        };
        /**
      * unbind the defined keycode
      * @name unbindPointer
      * @memberOf me.input
      * @public
      * @function
      * @param {Number} [button=me.input.pointer.LEFT] (accordingly to W3C values : 0,1,2 for left, middle and right buttons)
      * @example
      * me.input.unbindPointer(me.input.pointer.LEFT);
      */ api.unbindPointer = function(button) {
            // clear the event status
            api.pointer.bind[typeof button === "undefined" ? api.pointer.LEFT : button] = null;
        };
        /**
      * allows registration of event listeners on the object target. <br>
      * melonJS will pass a me.Pointer object to the defined callback.
      * @see me.Pointer
      * @see {@link http://www.w3.org/TR/pointerevents/#list-of-pointer-events|W3C Pointer Event list}
      * @name registerPointerEvent
      * @memberOf me.input
      * @public
      * @function
      * @param {String} eventType The event type for which the object is registering <br>
      * melonJS currently supports: <br>
      * <ul>
      *   <li><code>"pointermove"</code></li>
      *   <li><code>"pointerdown"</code></li>
      *   <li><code>"pointerup"</code></li>
      *   <li><code>"pointerenter"</code></li>
      *   <li><code>"pointerover"</code></li>
      *   <li><code>"pointerleave"</code></li>
      *   <li><code>"pointercancel"</code></li>
      *   <li><code>"wheel"</code></li>
      * </ul>
      * @param {me.Rect|me.Polygon|me.Line|me.Ellipse} region a shape representing the region to register on
      * @param {Function} callback methods to be called when the event occurs.
      * Returning `false` from the defined callback will prevent the event to be propagated to other objects
      * @example
      *  // onActivate function
      *  onActivateEvent: function () {
      *     // register on the 'pointerdown' event
      *     me.input.registerPointerEvent('pointerdown', this, this.pointerDown.bind(this));
      *  },
      *
      *  // pointerDown event callback
      *  pointerDown: function (pointer) {
      *    // do something
      *    ....
      *    // don"t propagate the event to other objects
      *    return false;
      *  },
      */ api.registerPointerEvent = function(eventType, region, callback) {
            // make sure the mouse/touch events are initialized
            enablePointerEvent();
            if (pointerEventList.indexOf(eventType) === -1) throw new Error("invalid event type : " + eventType);
            if (typeof region === "undefined") throw new Error("registerPointerEvent: region for " + toString(region) + " event is undefined ");
            var eventTypes = findAllActiveEvents(activeEventList, pointerEventMap[eventType]); // register the event
            if (!eventHandlers.has(region)) eventHandlers.set(region, {
                region: region,
                callbacks: {
                },
                pointerId: null
            });
             // allocate array if not defined
            var handlers = eventHandlers.get(region);
            for(var i = 0; i < eventTypes.length; i++){
                eventType = eventTypes[i];
                if (handlers.callbacks[eventType]) handlers.callbacks[eventType].push(callback);
                else handlers.callbacks[eventType] = [
                    callback
                ];
            }
        };
        /**
      * allows the removal of event listeners from the object target.
      * @see {@link http://www.w3.org/TR/pointerevents/#list-of-pointer-events|W3C Pointer Event list}
      * @name releasePointerEvent
      * @memberOf me.input
      * @public
      * @function
      * @param {String} eventType The event type for which the object was registered. See {@link me.input.registerPointerEvent}
      * @param {me.Rect|me.Polygon|me.Line|me.Ellipse} region the registered region to release for this event
      * @param {Function} [callback="all"] if specified unregister the event only for the specific callback
      * @example
      * // release the registered region on the 'pointerdown' event
      * me.input.releasePointerEvent('pointerdown', this);
      */ api.releasePointerEvent = function(eventType, region, callback) {
            if (pointerEventList.indexOf(eventType) === -1) throw new Error("invalid event type : " + eventType);
             // convert to supported event type if pointerEvent not natively supported
            var eventTypes = findAllActiveEvents(activeEventList, pointerEventMap[eventType]);
            var handlers = eventHandlers.get(region);
            if (typeof handlers !== "undefined") {
                for(var i = 0; i < eventTypes.length; i++){
                    eventType = eventTypes[i];
                    if (handlers.callbacks[eventType]) {
                        if (typeof callback !== "undefined") me.utils.array.remove(handlers.callbacks[eventType], callback);
                        else while(handlers.callbacks[eventType].length > 0)handlers.callbacks[eventType].pop();
                         // free the array if empty
                        if (handlers.callbacks[eventType].length === 0) delete handlers.callbacks[eventType];
                    }
                }
                if (Object.keys(handlers.callbacks).length === 0) eventHandlers["delete"](region);
            }
        };
        /**
      * allows the removal of all registered event listeners from the object target.
      * @name releaseAllPointerEvents
      * @memberOf me.input
      * @public
      * @function
      * @param {me.Rect|me.Polygon|me.Line|me.Ellipse} region the registered region to release event from
      * @example
      * // release all registered event on the
      * me.input.releaseAllPointerEvents(this);
      */ api.releaseAllPointerEvents = function(region) {
            if (eventHandlers.has(region)) for(var i = 0; i < pointerEventList.length; i++)api.releasePointerEvent(pointerEventList[i], region);
        };
    })(me.input);
    (function(api) {
        /*
      * PRIVATE STUFF
      */ // Analog deadzone
        var deadzone = 0.1;
        /**
      * A function that returns a normalized value in range [-1.0..1.0], or 0.0 if the axis is unknown.
      * @callback me.input~normalize_fn
      * @param {Number} value The raw value read from the gamepad driver
      * @param {Number} axis The axis index from the standard mapping, or -1 if not an axis
      * @param {Number} button The button index from the standard mapping, or -1 if not a button
      */ function defaultNormalizeFn(value) {
            return value;
        }
        /**
      * Normalize axis values for wired Xbox 360
      * @ignore
      */ function wiredXbox360NormalizeFn(value, axis, button) {
            if (button === api.GAMEPAD.BUTTONS.L2 || button === api.GAMEPAD.BUTTONS.R2) return (value + 1) / 2;
            return value;
        }
        /**
      * Normalize axis values for OUYA
      * @ignore
      */ function ouyaNormalizeFn(value, axis, button) {
            if (value > 0) {
                if (button === api.GAMEPAD.BUTTONS.L2) // L2 is wonky; seems like the deadzone is around 20000
                // (That's over 15% of the total range!)
                value = Math.max(0, value - 20000) / 111070;
                else // Normalize [1..65536] => [0.0..0.5]
                value = (value - 1) / 131070;
            } else // Normalize [-65536..-1] => [0.5..1.0]
            value = (65536 + value) / 131070 + 0.5;
            return value;
        } // Match vendor and product codes for Firefox
        var vendorProductRE = /^([0-9a-f]{1,4})-([0-9a-f]{1,4})-/i; // Match leading zeros
        var leadingZeroRE = /^0+/;
        /**
      * Firefox reports different ids for gamepads depending on the platform:
      * - Windows: vendor and product codes contain leading zeroes
      * - Mac: vendor and product codes are sparse (no leading zeroes)
      *
      * This function normalizes the id to support both formats
      * @ignore
      */ function addMapping(id, mapping) {
            var expanded_id = id.replace(vendorProductRE, function(_, a, b) {
                return "000".substr(a.length - 1) + a + "-" + "000".substr(b.length - 1) + b + "-";
            });
            var sparse_id = id.replace(vendorProductRE, function(_, a, b) {
                return a.replace(leadingZeroRE, "") + "-" + b.replace(leadingZeroRE, "") + "-";
            }); // Normalize optional parameters
            mapping.analog = mapping.analog || mapping.buttons.map(function() {
                return -1;
            });
            mapping.normalize_fn = mapping.normalize_fn || defaultNormalizeFn;
            remap.set(expanded_id, mapping);
            remap.set(sparse_id, mapping);
        } // binding list
        var bindings = {
        }; // mapping list
        var remap = new Map();
        var updateEventHandler;
        /**
      * Default gamepad mappings
      * @ignore
      */ [
            [
                "45e-28e-Xbox 360 Wired Controller",
                {
                    "axes": [
                        0,
                        1,
                        3,
                        4
                    ],
                    "buttons": [
                        11,
                        12,
                        13,
                        14,
                        8,
                        9,
                        -1,
                        -1,
                        5,
                        4,
                        6,
                        7,
                        0,
                        1,
                        2,
                        3,
                        10
                    ],
                    "analog": [
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        2,
                        5,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1
                    ],
                    "normalize_fn": wiredXbox360NormalizeFn
                }
            ],
            [
                "54c-268-PLAYSTATION(R)3 Controller",
                {
                    "axes": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "buttons": [
                        14,
                        13,
                        15,
                        12,
                        10,
                        11,
                        8,
                        9,
                        0,
                        3,
                        1,
                        2,
                        4,
                        6,
                        7,
                        5,
                        16
                    ]
                }
            ],
            [
                "54c-5c4-Wireless Controller",
                {
                    "axes": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "buttons": [
                        1,
                        0,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        14,
                        15,
                        16,
                        17,
                        12,
                        13
                    ]
                }
            ],
            [
                "2836-1-OUYA Game Controller",
                {
                    "axes": [
                        0,
                        3,
                        7,
                        9
                    ],
                    "buttons": [
                        3,
                        6,
                        4,
                        5,
                        7,
                        8,
                        15,
                        16,
                        -1,
                        -1,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        -1
                    ],
                    "analog": [
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        5,
                        11,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1
                    ],
                    "normalize_fn": ouyaNormalizeFn
                }
            ],
            [
                "OUYA Game Controller (Vendor: 2836 Product: 0001)",
                {
                    "axes": [
                        0,
                        1,
                        3,
                        4
                    ],
                    "buttons": [
                        0,
                        3,
                        1,
                        2,
                        4,
                        5,
                        12,
                        13,
                        -1,
                        -1,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        -1
                    ],
                    "analog": [
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        2,
                        5,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1
                    ],
                    "normalize_fn": ouyaNormalizeFn
                }
            ]
        ].forEach(function(value) {
            addMapping(value[0], value[1]);
        });
        /**
      * Update gamepad status
      * @ignore
      */ var updateGamepads = function updateGamepads1() {
            var gamepads = navigator.getGamepads(); // Trigger button bindings
            Object.keys(bindings).forEach(function(index) {
                var gamepad = gamepads[index];
                if (!gamepad) return;
                var mapping = null;
                if (gamepad.mapping !== "standard") mapping = remap.get(gamepad.id);
                var binding = bindings[index]; // Iterate all buttons that have active bindings
                Object.keys(binding.buttons).forEach(function(button) {
                    var last = binding.buttons[button];
                    var mapped_button = button;
                    var mapped_axis = -1; // Remap buttons if necessary
                    if (mapping) {
                        mapped_button = mapping.buttons[button];
                        mapped_axis = mapping.analog[button];
                        if (mapped_button < 0 && mapped_axis < 0) // Button is not mapped
                        return;
                    } // Get mapped button
                    var current = gamepad.buttons[mapped_button] || {
                    }; // Remap an axis to an analog button
                    if (mapping) {
                        if (mapped_axis >= 0) {
                            var value = mapping.normalize_fn(gamepad.axes[mapped_axis], -1, +button); // Create a new object, because GamepadButton is read-only
                            current = {
                                "value": value,
                                "pressed": current.pressed || Math.abs(value) >= deadzone
                            };
                        }
                    }
                    me.event.publish(me.event.GAMEPAD_UPDATE, [
                        index,
                        "buttons",
                        +button,
                        current
                    ]); // Edge detection
                    if (!last.pressed && current.pressed) api.triggerKeyEvent(last.keyCode, true, mapped_button + 256);
                    else if (last.pressed && !current.pressed) api.triggerKeyEvent(last.keyCode, false, mapped_button + 256);
                     // Update last button state
                    last.value = current.value;
                    last.pressed = current.pressed;
                }); // Iterate all axes that have active bindings
                Object.keys(binding.axes).forEach(function(axis) {
                    var last = binding.axes[axis];
                    var mapped_axis = axis; // Remap buttons if necessary
                    if (mapping) {
                        mapped_axis = mapping.axes[axis];
                        if (mapped_axis < 0) // axe is not mapped
                        return;
                    } // retrieve the current value and normalize if necessary
                    var value = gamepad.axes[mapped_axis];
                    if (typeof value === "undefined") return;
                    if (mapping) value = mapping.normalize_fn(value, +axis, -1);
                     // normalize value into a [-1, 1] range value (treat 0 as positive)
                    var range = Math.sign(value) || 1;
                    if (last[range].keyCode === 0) return;
                    var pressed = Math.abs(value) >= deadzone + Math.abs(last[range].threshold);
                    me.event.publish(me.event.GAMEPAD_UPDATE, [
                        index,
                        "axes",
                        +axis,
                        value
                    ]); // Edge detection
                    if (!last[range].pressed && pressed) {
                        // Release the opposite direction, if necessary
                        if (last[-range].pressed) {
                            api.triggerKeyEvent(last[-range].keyCode, false, mapped_axis + 256);
                            last[-range].value = 0;
                            last[-range].pressed = false;
                        }
                        api.triggerKeyEvent(last[range].keyCode, true, mapped_axis + 256);
                    } else if ((last[range].pressed || last[-range].pressed) && !pressed) {
                        range = last[range].pressed ? range : -range;
                        api.triggerKeyEvent(last[range].keyCode, false, mapped_axis + 256);
                    } // Update last axis state
                    last[range].value = value;
                    last[range].pressed = pressed;
                });
            });
        };
        /**
      * gamepad connected callback
      * @ignore
      */ window.addEventListener("gamepadconnected", function(event) {
            me.event.publish(me.event.GAMEPAD_CONNECTED, [
                event.gamepad
            ]);
        }, false);
        /**
      * gamepad disconnected callback
      * @ignore
      */ window.addEventListener("gamepaddisconnected", function(event) {
            me.event.publish(me.event.GAMEPAD_DISCONNECTED, [
                event.gamepad
            ]);
        }, false);
        /*
      * PUBLIC STUFF
      */ /**
      * Namespace for standard gamepad mapping constants
      * @public
      * @namespace GAMEPAD
      * @memberOf me.input
      */ api.GAMEPAD = {
            /**
        * Standard gamepad mapping information for axes<br>
        * <ul>
        *   <li>Left control stick: <code>LX</code> (horizontal), <code>LY</code> (vertical)</li>
        *   <li>Right control stick: <code>RX</code> (horizontal), <code>RY</code> (vertical)</li>
        *   <li>Extras: <code>EXTRA_1</code>, <code>EXTRA_2</code>, <code>EXTRA_3</code>, <code>EXTRA_4</code></li>
        * </ul>
        * @public
        * @name AXES
        * @enum {Number}
        * @memberOf me.input.GAMEPAD
        * @see https://w3c.github.io/gamepad/#remapping
        */ "AXES": {
                "LX": 0,
                "LY": 1,
                "RX": 2,
                "RY": 3,
                "EXTRA_1": 4,
                "EXTRA_2": 5,
                "EXTRA_3": 6,
                "EXTRA_4": 7
            },
            /**
        * Standard gamepad mapping information for buttons<br>
        * <ul>
        *   <li>Face buttons: <code>FACE_1</code>, <code>FACE_2</code>, <code>FACE_3</code>, <code>FACE_4</code></li>
        *   <li>D-Pad: <code>UP</code>, <code>DOWN</code>, <code>LEFT</code>, <code>RIGHT</code></li>
        *   <li>Shoulder buttons: <code>L1</code>, <code>L2</code>, <code>R1</code>, <code>R2</code></li>
        *   <li>Analog stick (clicks): <code>L3</code>, <code>R3</code></li>
        *   <li>Navigation: <code>SELECT</code> (<code>BACK</code>), <code>START</code> (<code>FORWARD</code>), <code>HOME</code></li>
        *   <li>Extras: <code>EXTRA_1</code>, <code>EXTRA_2</code>, <code>EXTRA_3</code>, <code>EXTRA_4</code></li>
        * </ul>
        * @public
        * @name BUTTONS
        * @enum {Number}
        * @memberOf me.input.GAMEPAD
        * @see https://w3c.github.io/gamepad/#remapping
        */ "BUTTONS": {
                "FACE_1": 0,
                "FACE_2": 1,
                "FACE_3": 2,
                "FACE_4": 3,
                "L1": 4,
                "R1": 5,
                "L2": 6,
                "R2": 7,
                "SELECT": 8,
                "BACK": 8,
                "START": 9,
                "FORWARD": 9,
                "L3": 10,
                "R3": 11,
                "UP": 12,
                "DOWN": 13,
                "LEFT": 14,
                "RIGHT": 15,
                "HOME": 16,
                "EXTRA_1": 17,
                "EXTRA_2": 18,
                "EXTRA_3": 19,
                "EXTRA_4": 20
            }
        };
        /**
      * Associate a gamepad event to a keycode
      * @name bindGamepad
      * @memberOf me.input
      * @public
      * @function
      * @param {Number} index Gamepad index
      * @param {Object} button Button/Axis definition
      * @param {String} button.type "buttons" or "axes"
      * @param {me.input.GAMEPAD.BUTTONS|me.input.GAMEPAD.AXES} button.code button or axis code id
      * @param {Number} [button.threshold=1] value indicating when the axis should trigger the keycode (e.g. -0.5 or 0.5)
      * @param {me.input.KEY} keyCode
      * @example
      * // enable the keyboard
      * me.input.bindKey(me.input.KEY.X, "shoot");
      * ...
      * // map the lower face button on the first gamepad to the X key
      * me.input.bindGamepad(0, {type:"buttons", code: me.input.GAMEPAD.BUTTONS.FACE_1}, me.input.KEY.X);
      * // map the left axis value on the first gamepad to the LEFT key
      * me.input.bindGamepad(0, {type:"axes", code: me.input.GAMEPAD.AXES.LX, threshold: -0.5}, me.input.KEY.LEFT);
      */ api.bindGamepad = function(index, button, keyCode) {
            // Throw an exception if no action is defined for the specified keycode
            if (!me.input.getBindingKey(keyCode)) throw new Error("no action defined for keycode " + keyCode);
             // register to the the update event if not yet done and supported by the browser
            // if not supported, the function will fail silently (-> update loop won't be called)
            if (typeof updateEventHandler === "undefined" && typeof navigator.getGamepads === "function") updateEventHandler = me.event.subscribe(me.event.GAME_UPDATE, updateGamepads);
             // Allocate bindings if not defined
            if (!bindings[index]) bindings[index] = {
                "axes": {
                },
                "buttons": {
                }
            };
            var mapping = {
                "keyCode": keyCode,
                "value": 0,
                "pressed": false,
                "threshold": button.threshold // can be undefined
            };
            var binding = bindings[index][button.type]; // Map the gamepad button or axis to the keycode
            if (button.type === "buttons") // buttons are defined by a `gamePadButton` object
            binding[button.code] = mapping;
            else if (button.type === "axes") {
                // normalize threshold into a value that can represent both side of the axis
                var range = Math.sign(button.threshold) || 1; // axes are defined using two objects; one for negative and one for positive
                if (!binding[button.code]) binding[button.code] = {
                };
                var axes = binding[button.code];
                axes[range] = mapping; // Ensure the opposite axis exists
                if (!axes[-range]) axes[-range] = {
                    "keyCode": 0,
                    "value": 0,
                    "pressed": false,
                    "threshold": -range
                };
            }
        };
        /**
      * unbind the defined keycode
      * @name unbindGamepad
      * @memberOf me.input
      * @public
      * @function
      * @param {Number} index Gamepad index
      * @param {me.input.GAMEPAD.BUTTONS} button
      * @example
      * me.input.unbindGamepad(0, me.input.GAMEPAD.BUTTONS.FACE_1);
      */ api.unbindGamepad = function(index, button) {
            if (!bindings[index]) throw new Error("no bindings for gamepad " + index);
            bindings[index].buttons[button] = {
            };
        };
        /**
      * Set deadzone for analog gamepad inputs<br>
      * The default deadzone is 0.1 (10%) Analog values less than this will be ignored
      * @name setGamepadDeadzone
      * @memberOf me.input
      * @public
      * @function
      * @param {Number} value Deadzone value
      */ api.setGamepadDeadzone = function(value) {
            deadzone = value;
        };
        /**
      * specify a custom mapping for a specific gamepad id<br>
      * see below for the default mapping : <br>
      * <center><img src="images/gamepad_diagram.png"/></center><br>
      * @name setGamepadMapping
      * @memberOf me.input
      * @public
      * @function
      * @param {String} id Gamepad id string
      * @param {Object} mapping A hash table
      * @param {Number[]} mapping.axes Standard analog control stick axis locations
      * @param {Number[]} mapping.buttons Standard digital button locations
      * @param {Number[]} [mapping.analog] Analog axis locations for buttons
      * @param {me.input~normalize_fn} [mapping.normalize_fn] Axis normalization function
      * @example
      * // A weird controller that has its axis mappings reversed
      * me.input.setGamepadMapping("Generic USB Controller", {
      *   "axes" : [ 3, 2, 1, 0 ],
      *   "buttons" : [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ]
      * });
      *
      * // Mapping extra axes to analog buttons
      * me.input.setGamepadMapping("Generic Analog Controller", {
      *   "axes" : [ 0, 1, 2, 3 ],
      *   "buttons" : [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ],
      *
      *   // Raw axis 4 is mapped to GAMEPAD.BUTTONS.FACE_1
      *   // Raw axis 5 is mapped to GAMEPAD.BUTTONS.FACE_2
      *   // etc...
      *   // Also maps left and right triggers
      *   "analog" : [ 4, 5, 6, 7, -1, -1, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1 ],
      *
      *   // Normalize the value of button L2: [-1.0..1.0] => [0.0..1.0]
      *   "normalize_fn" : function (value, axis, button) {
      *     return ((button === me.input.GAMEPAD.BUTTONS.L2) ? ((value + 1) / 2) : value) || 0;
      *   }
      * });
      */ api.setGamepadMapping = addMapping;
    })(me.input);
    (function() {
        /**
      * a collection of utility functions
      * @namespace me.utils
      * @memberOf me
      */ me.utils = (function() {
            // hold public stuff in our singleton
            var api = {
            };
            /*
        * PRIVATE STUFF
        */ // guid default value
            var GUID_base = "";
            var GUID_index = 0;
            /*
        * PUBLIC STUFF
        */ /**
        * display a deprecation warning in the console
        * @public
        * @function
        * @memberOf me.deprecated
        * @name deprecated
        * @param {String} deprecated deprecated class,function or property name
        * @param {String} replacement the replacement class, function, or property name
        * @param {String} version the version since when the lass,function or property is deprecated
        */ api.deprecated = function(deprecated, replacement, version) {
                console.warn("melonJS: %s is deprecated since version %s, please use %s", deprecated, version, replacement);
            };
            /**
        * Get image pixels
        * @public
        * @function
        * @memberOf me.utils
        * @name getPixels
        * @param {Image|Canvas} image Image to read
        * @return {ImageData} Canvas ImageData object
        */ api.getPixels = function(arg) {
                if (arg instanceof HTMLImageElement) {
                    var _context = me.CanvasRenderer.getContext2d(me.video.createCanvas(arg.width, arg.height));
                    _context.drawImage(arg, 0, 0);
                    return _context.getImageData(0, 0, arg.width, arg.height);
                } else // canvas !
                return arg.getContext("2d").getImageData(0, 0, arg.width, arg.height);
            };
            /**
        * Compare two version strings
        * @public
        * @function
        * @memberOf me.utils
        * @name checkVersion
        * @param {String} first First version string to compare
        * @param {String} [second=me.version] Second version string to compare
        * @return {Number} comparison result <br>&lt; 0 : first &lt; second<br>
        * 0 : first == second<br>
        * &gt; 0 : first &gt; second
        * @example
        * if (me.utils.checkVersion("7.0.0") > 0) {
        *     console.error(
        *         "melonJS is too old. Expected: 7.0.0, Got: 6.3.0"
        *     );
        * }
        */ api.checkVersion = function(first, second) {
                second = second || me.version;
                var a = first.split(".");
                var b = second.split(".");
                var len = Math.min(a.length, b.length);
                var result = 0;
                for(var i = 0; i < len; i++){
                    if (result = +a[i] - +b[i]) break;
                }
                return result ? result : a.length - b.length;
            };
            /**
        * parse the fragment (hash) from a URL and returns them into
        * @public
        * @function
        * @memberOf me.utils
        * @name getUriFragment
        * @param {String} [url=document.location] an optional params string or URL containing fragment (hash) params to be parsed
        * @return {Object} an object representing the deserialized params string.
        * @property {Boolean} [hitbox=false] draw the hitbox in the debug panel (if enabled)
        * @property {Boolean} [velocity=false] draw the entities velocity in the debug panel (if enabled)
        * @property {Boolean} [quadtree=false] draw the quadtree in the debug panel (if enabled)
        * @property {Boolean} [webgl=false] force the renderer to WebGL
        * @property {Boolean} [debug=false] display the debug panel (if preloaded)
        * @property {String} [debugToggleKey="s"] show/hide the debug panel (if preloaded)
        * @example
        * // http://www.example.com/index.html#debug&hitbox=true&mytag=value
        * var UriFragment = me.utils.getUriFragment();
        * console.log(UriFragment["mytag"]); //> "value"
        */ api.getUriFragment = (function(url) {
                var UriFragments = {
                };
                var parsed = false;
                return function(url1) {
                    var hash;
                    if (typeof url1 === "undefined") {
                        hash = UriFragments;
                        if (parsed === true) return hash;
                        url1 = document.location;
                        parsed = true;
                    } else // never cache if a url is passed as parameter
                    hash = {
                    };
                     // No "document.location" exist for Wechat mini game platform.
                    if (url1 && url1.hash) url1.hash.substr(1).split("&").filter(function(value) {
                        return value !== "";
                    }).forEach(function(value) {
                        var kv = value.split("=");
                        var k = kv.shift();
                        var v = kv.join("=");
                        hash[k] = v || true;
                    });
                    return hash;
                };
            })();
            /**
        * reset the GUID Base Name
        * the idea here being to have a unique ID
        * per level / object
        * @ignore
        */ api.resetGUID = function(base, index) {
                // also ensure it's only 8bit ASCII characters
                GUID_base = me.utils.string.toHex(base.toString().toUpperCase());
                GUID_index = index || 0;
            };
            /**
        * create and return a very simple GUID
        * Game Unique ID
        * @ignore
        */ api.createGUID = function(index) {
                // to cover the case of undefined id for groups
                GUID_index += index || 1;
                return GUID_base + "-" + (index || GUID_index);
            }; // return our object
            return api;
        })();
    })();
    (function(api) {
        /**
      * a collection of file utility functions
      * @namespace me.utils.file
      * @memberOf me
      */ var file = function() {
            // hold public stuff in our singleton
            var api1 = {
            }; // regexp to deal with file name & path
            var REMOVE_PATH = /^.*(\\|\/|\:)/;
            var REMOVE_EXT = /\.[^\.]*$/;
            /**
        * return the base name of the file without path info
        * @public
        * @function
        * @memberOf me.utils.file
        * @name getBasename
        * @param  {String} path path containing the filename
        * @return {String} the base name without path information.
        */ api1.getBasename = function(path) {
                return path.replace(REMOVE_PATH, "").replace(REMOVE_EXT, "");
            };
            /**
        * return the extension of the file in the given path
        * @public
        * @function
        * @memberOf me.utils.file
        * @name getExtension
        * @param  {String} path path containing the filename
        * @return {String} filename extension.
        */ api1.getExtension = function(path) {
                return path.substring(path.lastIndexOf(".") + 1, path.length);
            }; // return our object
            return api1;
        }();
        api.file = file;
    })(me.utils);
    (function(api) {
        /**
      * a collection of utility functions
      * @namespace me.utils.function
      * @memberOf me
      */ var fn = function() {
            // hold public stuff in our singleton
            var api1 = {
            };
            /**
        * Executes a function as soon as the interpreter is idle (stack empty).
        * @public
        * @function
        * @memberOf me.utils.function
        * @name defer
        * @param {Function} fn The function to be deferred.
        * @param {Object} scope The execution scope of the deferred function.
        * @param {} [arguments...] Optional additional arguments to carry for the
        * function.
        * @return {Number} id that can be used to clear the deferred function using
        * clearTimeout
        * @example
        * // execute myFunc() when the stack is empty,
        * // with the current context and 'myArgument' as parameter
        * me.utils.function.defer(fn, this, 'myArgument');
        */ api1.defer = function(fn1, scope) {
                var args = Array.prototype.slice.call(arguments, 1);
                return setTimeout(fn1.bind.apply(fn1, args), 0.01);
            };
            /**
        * returns a function that, when invoked will only be triggered at most
        * once during a given window of time
        * @public
        * @function
        * @memberOf me.utils.function
        * @name throttle
        * @param {Function} fn the function to be throttled.
        * @param {Number} delay The delay in ms
        * @param {no_trailing} no_trailing disable the execution on the trailing edge
        */ api1.throttle = function(fn1, delay, no_trailing) {
                var last = window.performance.now(), deferTimer; // `no_trailing` defaults to false.
                if (typeof no_trailing !== "boolean") no_trailing = false;
                return function() {
                    var now = window.performance.now();
                    var elasped = now - last;
                    var args = arguments;
                    if (elasped < delay) {
                        if (no_trailing === false) {
                            // hold on to it
                            clearTimeout(deferTimer);
                            deferTimer = setTimeout(function() {
                                last = now;
                                return fn1.apply(null, args);
                            }, elasped);
                        }
                    } else {
                        last = now;
                        return fn1.apply(null, args);
                    }
                };
            }; // return our object
            return api1;
        }();
        api["function"] = fn;
    })(me.utils);
    (function(api) {
        /**
      * a collection of array utility functions
      * @namespace me.utils.array
      * @memberOf me
      */ var array = function() {
            // hold public stuff in our singleton
            var api1 = {
            };
            /**
        * Remove the specified object from the given Array
        * @public
        * @function
        * @memberOf me.utils.array
        * @name remove
        * @param {Array} arr array from which to remove an object
        * @param {Object} object to be removed
        * @return {Array} the modified Array
        */ api1.remove = function(arr, obj) {
                var i = Array.prototype.indexOf.call(arr, obj);
                if (i !== -1) Array.prototype.splice.call(arr, i, 1);
                return arr;
            };
            /**
        * return a random array element
        * @public
        * @function
        * @memberOf me.utils.array
        * @name random
        * @param {Array} arr array to pick a element
        * @return {any} random member of array
        * @example
        * // Select a random array element
        * var arr = [ "foo", "bar", "baz" ];
        * console.log(me.utils.array.random(arr));
        */ api1.random = function(arr) {
                return arr[me.Math.random(0, arr.length)];
            };
            /**
        * return a weighted random array element, favoring the earlier entries
        * @public
        * @function
        * @memberOf me.utils.array
        * @name weightedRandom
        * @param {Array} arr array to pick a element
        * @return {any} random member of array
        */ api1.weightedRandom = function(arr) {
                return arr[me.Math.weightedRandom(0, arr.length)];
            }; // return our object
            return api1;
        }();
        api.array = array;
    })(me.utils);
    (function(api) {
        /**
      * a collection of string utility functions
      * @namespace me.utils.string
      * @memberOf me
      */ var string = function() {
            // hold public stuff in our singleton
            var api1 = {
            };
            /**
        * converts the first character of the given string to uppercase
        * @public
        * @function
        * @memberOf me.utils.string
        * @name capitalize
        * @param {String} string the string to be capitalized
        * @return {string} the capitalized string
        */ api1.capitalize = function(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            };
            /**
        * returns the string stripped of whitespace from the left.
        * @public
        * @function
        * @memberOf me.utils.string
        * @name trimLeft
        * @param {String} string the string to be trimmed
        * @return {string} trimmed string
        */ api1.trimLeft = function(str) {
                return str.replace(/^\s+/, "");
            };
            /**
        * returns the string stripped of whitespace from the right.
        * @public
        * @function
        * @memberOf me.utils.string
        * @name trimRight
        * @param {String} string the string to be trimmed
        * @return {string} trimmed string
        */ api1.trimRight = function(str) {
                return str.replace(/\s+$/, "");
            };
            /**
        * returns true if the given string contains a numeric value
        * @public
        * @function
        * @memberOf me.utils.string
        * @name isNumeric
        * @param {String} string the string to be tested
        * @return {Boolean} true if string contains only digits
        */ api1.isNumeric = function(str) {
                return !isNaN(str) && str.trim() !== "";
            };
            /**
        * returns true if the given string contains a true or false
        * @public
        * @function
        * @memberOf me.utils.string
        * @name isBoolean
        * @param {String} string the string to be tested
        * @return {Boolean} true if the string is either true or false
        */ api1.isBoolean = function(str) {
                var trimmed = str.trim();
                return trimmed === "true" || trimmed === "false";
            };
            /**
        * convert a string to the corresponding hexadecimal value
        * @public
        * @function
        * @memberOf me.utils.string
        * @name toHex
        * @param {String} string the string to be converted
        * @return {String}
        */ api1.toHex = function(str) {
                var res = "", c = 0;
                while(c < str.length)res += str.charCodeAt(c++).toString(16);
                return res;
            }; // return our object
            return api1;
        }();
        api.string = string;
    })(me.utils);
    (function() {
        // convert a give color component to it hexadecimal value
        var _toHex = function toHex(component) {
            return "0123456789ABCDEF".charAt(component - component % 16 >> 4) + "0123456789ABCDEF".charAt(component % 16);
        };
        var rgbaRx = /^rgba?\((\d+), ?(\d+), ?(\d+)(, ?([\d\.]+))?\)$/;
        var hex3Rx = /^#([\da-fA-F])([\da-fA-F])([\da-fA-F])$/;
        var hex4Rx = /^#([\da-fA-F])([\da-fA-F])([\da-fA-F])([\da-fA-F])$/;
        var hex6Rx = /^#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})$/;
        var hex8Rx = /^#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})$/;
        var cssToRGB = new Map();
        [
            [
                "black",
                [
                    0,
                    0,
                    0
                ]
            ],
            [
                "silver",
                [
                    192,
                    192,
                    129
                ]
            ],
            [
                "gray",
                [
                    128,
                    128,
                    128
                ]
            ],
            [
                "white",
                [
                    255,
                    255,
                    255
                ]
            ],
            [
                "maroon",
                [
                    128,
                    0,
                    0
                ]
            ],
            [
                "red",
                [
                    255,
                    0,
                    0
                ]
            ],
            [
                "purple",
                [
                    128,
                    0,
                    128
                ]
            ],
            [
                "fuchsia",
                [
                    255,
                    0,
                    255
                ]
            ],
            [
                "green",
                [
                    0,
                    128,
                    0
                ]
            ],
            [
                "lime",
                [
                    0,
                    255,
                    0
                ]
            ],
            [
                "olive",
                [
                    128,
                    128,
                    0
                ]
            ],
            [
                "yellow",
                [
                    255,
                    255,
                    0
                ]
            ],
            [
                "navy",
                [
                    0,
                    0,
                    128
                ]
            ],
            [
                "blue",
                [
                    0,
                    0,
                    255
                ]
            ],
            [
                "teal",
                [
                    0,
                    128,
                    128
                ]
            ],
            [
                "aqua",
                [
                    0,
                    255,
                    255
                ]
            ],
            [
                "orange",
                [
                    255,
                    165,
                    0
                ]
            ],
            [
                "aliceblue",
                [
                    240,
                    248,
                    245
                ]
            ],
            [
                "antiquewhite",
                [
                    250,
                    235,
                    215
                ]
            ],
            [
                "aquamarine",
                [
                    127,
                    255,
                    212
                ]
            ],
            [
                "azure",
                [
                    240,
                    255,
                    255
                ]
            ],
            [
                "beige",
                [
                    245,
                    245,
                    220
                ]
            ],
            [
                "bisque",
                [
                    255,
                    228,
                    196
                ]
            ],
            [
                "blanchedalmond",
                [
                    255,
                    235,
                    205
                ]
            ],
            [
                "blueviolet",
                [
                    138,
                    43,
                    226
                ]
            ],
            [
                "brown",
                [
                    165,
                    42,
                    42
                ]
            ],
            [
                "burlywood",
                [
                    222,
                    184,
                    35
                ]
            ],
            [
                "cadetblue",
                [
                    95,
                    158,
                    160
                ]
            ],
            [
                "chartreuse",
                [
                    127,
                    255,
                    0
                ]
            ],
            [
                "chocolate",
                [
                    210,
                    105,
                    30
                ]
            ],
            [
                "coral",
                [
                    255,
                    127,
                    80
                ]
            ],
            [
                "cornflowerblue",
                [
                    100,
                    149,
                    237
                ]
            ],
            [
                "cornsilk",
                [
                    255,
                    248,
                    220
                ]
            ],
            [
                "crimson",
                [
                    220,
                    20,
                    60
                ]
            ],
            [
                "darkblue",
                [
                    0,
                    0,
                    139
                ]
            ],
            [
                "darkcyan",
                [
                    0,
                    139,
                    139
                ]
            ],
            [
                "darkgoldenrod",
                [
                    184,
                    134,
                    11
                ]
            ],
            [
                "darkgray[*]",
                [
                    169,
                    169,
                    169
                ]
            ],
            [
                "darkgreen",
                [
                    0,
                    100,
                    0
                ]
            ],
            [
                "darkgrey[*]",
                [
                    169,
                    169,
                    169
                ]
            ],
            [
                "darkkhaki",
                [
                    189,
                    183,
                    107
                ]
            ],
            [
                "darkmagenta",
                [
                    139,
                    0,
                    139
                ]
            ],
            [
                "darkolivegreen",
                [
                    85,
                    107,
                    47
                ]
            ],
            [
                "darkorange",
                [
                    255,
                    140,
                    0
                ]
            ],
            [
                "darkorchid",
                [
                    153,
                    50,
                    204
                ]
            ],
            [
                "darkred",
                [
                    139,
                    0,
                    0
                ]
            ],
            [
                "darksalmon",
                [
                    233,
                    150,
                    122
                ]
            ],
            [
                "darkseagreen",
                [
                    143,
                    188,
                    143
                ]
            ],
            [
                "darkslateblue",
                [
                    72,
                    61,
                    139
                ]
            ],
            [
                "darkslategray",
                [
                    47,
                    79,
                    79
                ]
            ],
            [
                "darkslategrey",
                [
                    47,
                    79,
                    79
                ]
            ],
            [
                "darkturquoise",
                [
                    0,
                    206,
                    209
                ]
            ],
            [
                "darkviolet",
                [
                    148,
                    0,
                    211
                ]
            ],
            [
                "deeppink",
                [
                    255,
                    20,
                    147
                ]
            ],
            [
                "deepskyblue",
                [
                    0,
                    191,
                    255
                ]
            ],
            [
                "dimgray",
                [
                    105,
                    105,
                    105
                ]
            ],
            [
                "dimgrey",
                [
                    105,
                    105,
                    105
                ]
            ],
            [
                "dodgerblue",
                [
                    30,
                    144,
                    255
                ]
            ],
            [
                "firebrick",
                [
                    178,
                    34,
                    34
                ]
            ],
            [
                "floralwhite",
                [
                    255,
                    250,
                    240
                ]
            ],
            [
                "forestgreen",
                [
                    34,
                    139,
                    34
                ]
            ],
            [
                "gainsboro",
                [
                    220,
                    220,
                    220
                ]
            ],
            [
                "ghostwhite",
                [
                    248,
                    248,
                    255
                ]
            ],
            [
                "gold",
                [
                    255,
                    215,
                    0
                ]
            ],
            [
                "goldenrod",
                [
                    218,
                    165,
                    32
                ]
            ],
            [
                "greenyellow",
                [
                    173,
                    255,
                    47
                ]
            ],
            [
                "grey",
                [
                    128,
                    128,
                    128
                ]
            ],
            [
                "honeydew",
                [
                    240,
                    255,
                    240
                ]
            ],
            [
                "hotpink",
                [
                    255,
                    105,
                    180
                ]
            ],
            [
                "indianred",
                [
                    205,
                    92,
                    92
                ]
            ],
            [
                "indigo",
                [
                    75,
                    0,
                    130
                ]
            ],
            [
                "ivory",
                [
                    255,
                    255,
                    240
                ]
            ],
            [
                "khaki",
                [
                    240,
                    230,
                    140
                ]
            ],
            [
                "lavender",
                [
                    230,
                    230,
                    250
                ]
            ],
            [
                "lavenderblush",
                [
                    255,
                    240,
                    245
                ]
            ],
            [
                "lawngreen",
                [
                    124,
                    252,
                    0
                ]
            ],
            [
                "lemonchiffon",
                [
                    255,
                    250,
                    205
                ]
            ],
            [
                "lightblue",
                [
                    173,
                    216,
                    230
                ]
            ],
            [
                "lightcoral",
                [
                    240,
                    128,
                    128
                ]
            ],
            [
                "lightcyan",
                [
                    224,
                    255,
                    255
                ]
            ],
            [
                "lightgoldenrodyellow",
                [
                    250,
                    250,
                    210
                ]
            ],
            [
                "lightgray",
                [
                    211,
                    211,
                    211
                ]
            ],
            [
                "lightgreen",
                [
                    144,
                    238,
                    144
                ]
            ],
            [
                "lightgrey",
                [
                    211,
                    211,
                    211
                ]
            ],
            [
                "lightpink",
                [
                    255,
                    182,
                    193
                ]
            ],
            [
                "lightsalmon",
                [
                    255,
                    160,
                    122
                ]
            ],
            [
                "lightseagreen",
                [
                    32,
                    178,
                    170
                ]
            ],
            [
                "lightskyblue",
                [
                    135,
                    206,
                    250
                ]
            ],
            [
                "lightslategray",
                [
                    119,
                    136,
                    153
                ]
            ],
            [
                "lightslategrey",
                [
                    119,
                    136,
                    153
                ]
            ],
            [
                "lightsteelblue",
                [
                    176,
                    196,
                    222
                ]
            ],
            [
                "lightyellow",
                [
                    255,
                    255,
                    224
                ]
            ],
            [
                "limegreen",
                [
                    50,
                    205,
                    50
                ]
            ],
            [
                "linen",
                [
                    250,
                    240,
                    230
                ]
            ],
            [
                "mediumaquamarine",
                [
                    102,
                    205,
                    170
                ]
            ],
            [
                "mediumblue",
                [
                    0,
                    0,
                    205
                ]
            ],
            [
                "mediumorchid",
                [
                    186,
                    85,
                    211
                ]
            ],
            [
                "mediumpurple",
                [
                    147,
                    112,
                    219
                ]
            ],
            [
                "mediumseagreen",
                [
                    60,
                    179,
                    113
                ]
            ],
            [
                "mediumslateblue",
                [
                    123,
                    104,
                    238
                ]
            ],
            [
                "mediumspringgreen",
                [
                    0,
                    250,
                    154
                ]
            ],
            [
                "mediumturquoise",
                [
                    72,
                    209,
                    204
                ]
            ],
            [
                "mediumvioletred",
                [
                    199,
                    21,
                    133
                ]
            ],
            [
                "midnightblue",
                [
                    25,
                    25,
                    112
                ]
            ],
            [
                "mintcream",
                [
                    245,
                    255,
                    250
                ]
            ],
            [
                "mistyrose",
                [
                    255,
                    228,
                    225
                ]
            ],
            [
                "moccasin",
                [
                    255,
                    228,
                    181
                ]
            ],
            [
                "navajowhite",
                [
                    255,
                    222,
                    173
                ]
            ],
            [
                "oldlace",
                [
                    253,
                    245,
                    230
                ]
            ],
            [
                "olivedrab",
                [
                    107,
                    142,
                    35
                ]
            ],
            [
                "orangered",
                [
                    255,
                    69,
                    0
                ]
            ],
            [
                "orchid",
                [
                    218,
                    112,
                    214
                ]
            ],
            [
                "palegoldenrod",
                [
                    238,
                    232,
                    170
                ]
            ],
            [
                "palegreen",
                [
                    152,
                    251,
                    152
                ]
            ],
            [
                "paleturquoise",
                [
                    175,
                    238,
                    238
                ]
            ],
            [
                "palevioletred",
                [
                    219,
                    112,
                    147
                ]
            ],
            [
                "papayawhip",
                [
                    255,
                    239,
                    213
                ]
            ],
            [
                "peachpuff",
                [
                    255,
                    218,
                    185
                ]
            ],
            [
                "peru",
                [
                    205,
                    133,
                    63
                ]
            ],
            [
                "pink",
                [
                    255,
                    192,
                    203
                ]
            ],
            [
                "plum",
                [
                    221,
                    160,
                    221
                ]
            ],
            [
                "powderblue",
                [
                    176,
                    224,
                    230
                ]
            ],
            [
                "rosybrown",
                [
                    188,
                    143,
                    143
                ]
            ],
            [
                "royalblue",
                [
                    65,
                    105,
                    225
                ]
            ],
            [
                "saddlebrown",
                [
                    139,
                    69,
                    19
                ]
            ],
            [
                "salmon",
                [
                    250,
                    128,
                    114
                ]
            ],
            [
                "sandybrown",
                [
                    244,
                    164,
                    96
                ]
            ],
            [
                "seagreen",
                [
                    46,
                    139,
                    87
                ]
            ],
            [
                "seashell",
                [
                    255,
                    245,
                    238
                ]
            ],
            [
                "sienna",
                [
                    160,
                    82,
                    45
                ]
            ],
            [
                "skyblue",
                [
                    135,
                    206,
                    235
                ]
            ],
            [
                "slateblue",
                [
                    106,
                    90,
                    205
                ]
            ],
            [
                "slategray",
                [
                    112,
                    128,
                    144
                ]
            ],
            [
                "slategrey",
                [
                    112,
                    128,
                    144
                ]
            ],
            [
                "snow",
                [
                    255,
                    250,
                    250
                ]
            ],
            [
                "springgreen",
                [
                    0,
                    255,
                    127
                ]
            ],
            [
                "steelblue",
                [
                    70,
                    130,
                    180
                ]
            ],
            [
                "tan",
                [
                    210,
                    180,
                    140
                ]
            ],
            [
                "thistle",
                [
                    216,
                    191,
                    216
                ]
            ],
            [
                "tomato",
                [
                    255,
                    99,
                    71
                ]
            ],
            [
                "turquoise",
                [
                    64,
                    224,
                    208
                ]
            ],
            [
                "violet",
                [
                    238,
                    130,
                    238
                ]
            ],
            [
                "wheat",
                [
                    245,
                    222,
                    179
                ]
            ],
            [
                "whitesmoke",
                [
                    245,
                    245,
                    245
                ]
            ],
            [
                "yellowgreen",
                [
                    154,
                    205,
                    50
                ]
            ]
        ].forEach(function(value) {
            cssToRGB.set(value[0], value[1]);
        });
        /**
      * A color manipulation object.
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      * @param {Float32Array|Number} [r=0] red component or array of color components
      * @param {Number} [g=0] green component
      * @param {Number} [b=0] blue component
      * @param {Number} [alpha=1.0] alpha value
      */ me.Color = me.Object.extend({
            /**
        * @ignore
        */ init: function init(r, g, b, alpha) {
                /**
          * Color components in a Float32Array suitable for WebGL
          * @name glArray
          * @memberOf me.Color
          * @type {Float32Array}
          * @readonly
          */ if (typeof this.glArray === "undefined") this.glArray = new Float32Array([
                    0,
                    0,
                    0,
                    1
                ]);
                return this.setColor(r, g, b, alpha);
            },
            /**
        * Set this color to the specified value.
        * @name setColor
        * @memberOf me.Color
        * @function
        * @param {Number} r red component [0 .. 255]
        * @param {Number} g green component [0 .. 255]
        * @param {Number} b blue component [0 .. 255]
        * @param {Number} [alpha=1.0] alpha value [0.0 .. 1.0]
        * @return {me.Color} Reference to this object for method chaining
        */ setColor: function setColor(r, g, b, alpha) {
                // Private initialization: copy Color value directly
                if (r instanceof me.Color) {
                    this.glArray.set(r.glArray);
                    return r;
                }
                this.r = r;
                this.g = g;
                this.b = b;
                this.alpha = alpha;
                return this;
            },
            /**
        * Create a new copy of this color object.
        * @name clone
        * @memberOf me.Color
        * @function
        * @return {me.Color} Reference to the newly cloned object
        */ clone: function clone() {
                return me.pool.pull("me.Color", this);
            },
            /**
        * Copy a color object or CSS color into this one.
        * @name copy
        * @memberOf me.Color
        * @function
        * @param {me.Color|String} color
        * @return {me.Color} Reference to this object for method chaining
        */ copy: function copy(color) {
                if (color instanceof me.Color) {
                    this.glArray.set(color.glArray);
                    return this;
                }
                return this.parseCSS(color);
            },
            /**
        * Blend this color with the given one using addition.
        * @name add
        * @memberOf me.Color
        * @function
        * @param {me.Color} color
        * @return {me.Color} Reference to this object for method chaining
        */ add: function add(color) {
                this.glArray[0] = me.Math.clamp(this.glArray[0] + color.glArray[0], 0, 1);
                this.glArray[1] = me.Math.clamp(this.glArray[1] + color.glArray[1], 0, 1);
                this.glArray[2] = me.Math.clamp(this.glArray[2] + color.glArray[2], 0, 1);
                this.glArray[3] = (this.glArray[3] + color.glArray[3]) / 2;
                return this;
            },
            /**
        * Darken this color value by 0..1
        * @name darken
        * @memberOf me.Color
        * @function
        * @param {Number} scale
        * @return {me.Color} Reference to this object for method chaining
        */ darken: function darken(scale) {
                scale = me.Math.clamp(scale, 0, 1);
                this.glArray[0] *= scale;
                this.glArray[1] *= scale;
                this.glArray[2] *= scale;
                return this;
            },
            /**
        * Linearly interpolate between this color and the given one.
        * @name lerp
        * @memberOf me.Color
        * @function
        * @param {me.Color} color
        * @param {Number} alpha with alpha = 0 being this color, and alpha = 1 being the given one.
        * @return {me.Color} Reference to this object for method chaining
        */ lerp: function lerp(color, alpha) {
                alpha = me.Math.clamp(alpha, 0, 1);
                this.glArray[0] += (color.glArray[0] - this.glArray[0]) * alpha;
                this.glArray[1] += (color.glArray[1] - this.glArray[1]) * alpha;
                this.glArray[2] += (color.glArray[2] - this.glArray[2]) * alpha;
                return this;
            },
            /**
        * Lighten this color value by 0..1
        * @name lighten
        * @memberOf me.Color
        * @function
        * @param {Number} scale
        * @return {me.Color} Reference to this object for method chaining
        */ lighten: function lighten(scale) {
                scale = me.Math.clamp(scale, 0, 1);
                this.glArray[0] = me.Math.clamp(this.glArray[0] + (1 - this.glArray[0]) * scale, 0, 1);
                this.glArray[1] = me.Math.clamp(this.glArray[1] + (1 - this.glArray[1]) * scale, 0, 1);
                this.glArray[2] = me.Math.clamp(this.glArray[2] + (1 - this.glArray[2]) * scale, 0, 1);
                return this;
            },
            /**
        * Generate random r,g,b values for this color object
        * @name random
        * @memberOf me.Color
        * @function
        * @param {Number} [min=0] minimum value for the random range
        * @param {Number} [max=255] maxmium value for the random range
        * @return {me.Color} Reference to this object for method chaining
        */ random: function random(min, max) {
                if (typeof min === "undefined" || min < 0) min = 0;
                if (typeof max === "undefined" || min > 255) max = 255;
                return this.setColor(me.Math.random(min, max), me.Math.random(min, max), me.Math.random(min, max), this.alpha);
            },
            /**
        * Return true if the r,g,b,a values of this color are equal with the
        * given one.
        * @name equals
        * @memberOf me.Color
        * @function
        * @param {me.Color} color
        * @return {Boolean}
        */ equals: function equals1(color) {
                return this.glArray[0] === color.glArray[0] && this.glArray[1] === color.glArray[1] && this.glArray[2] === color.glArray[2] && this.glArray[3] === color.glArray[3];
            },
            /**
        * Parse a CSS color string and set this color to the corresponding
        * r,g,b values
        * @name parseCSS
        * @memberOf me.Color
        * @function
        * @param {String} color
        * @return {me.Color} Reference to this object for method chaining
        */ parseCSS: function parseCSS(cssColor) {
                // TODO : Memoize this function by caching its input
                if (cssToRGB.has(cssColor)) return this.setColor.apply(this, cssToRGB.get(cssColor));
                return this.parseRGB(cssColor);
            },
            /**
        * Parse an RGB or RGBA CSS color string
        * @name parseRGB
        * @memberOf me.Color
        * @function
        * @param {String} color
        * @return {me.Color} Reference to this object for method chaining
        */ parseRGB: function parseRGB(rgbColor) {
                // TODO : Memoize this function by caching its input
                var match = rgbaRx.exec(rgbColor);
                if (match) return this.setColor(+match[1], +match[2], +match[3], +match[5]);
                return this.parseHex(rgbColor);
            },
            /**
        * Parse a Hex color ("#RGB", "#RGBA" or "#RRGGBB", "#RRGGBBAA" format) and set this color to
        * the corresponding r,g,b,a values
        * @name parseHex
        * @memberOf me.Color
        * @function
        * @param {String} color
        * @return {me.Color} Reference to this object for method chaining
        */ parseHex: function parseHex(hexColor) {
                // TODO : Memoize this function by caching its input
                var match;
                if (match = hex8Rx.exec(hexColor)) // #AARRGGBB
                return this.setColor(parseInt(match[1], 16), parseInt(match[2], 16), parseInt(match[3], 16), (me.Math.clamp(parseInt(match[4], 16), 0, 255) / 255).toFixed(1));
                if (match = hex6Rx.exec(hexColor)) // #RRGGBB
                return this.setColor(parseInt(match[1], 16), parseInt(match[2], 16), parseInt(match[3], 16));
                if (match = hex4Rx.exec(hexColor)) // #ARGB
                return this.setColor(parseInt(match[1] + match[1], 16), parseInt(match[2] + match[2], 16), parseInt(match[3] + match[3], 16), (me.Math.clamp(parseInt(match[4] + match[4], 16), 0, 255) / 255).toFixed(1));
                if (match = hex3Rx.exec(hexColor)) // #RGB
                return this.setColor(parseInt(match[1] + match[1], 16), parseInt(match[2] + match[2], 16), parseInt(match[3] + match[3], 16));
                throw new Error("invalid parameter: " + hexColor);
            },
            /**
        * return an array representation of this object
        * @name toArray
        * @memberOf me.Color
        * @function
        * @return {Float32Array}
        */ toArray: function toArray() {
                return this.glArray;
            },
            /**
        * Get the color in "#RRGGBB" format
        * @name toHex
        * @memberOf me.Color
        * @function
        * @return {String}
        */ toHex: function toHex1() {
                // TODO : Memoize this function by caching its result until any of
                // the r,g,b,a values are changed
                return "#" + _toHex(this.r) + _toHex(this.g) + _toHex(this.b);
            },
            /**
        * Get the color in "#RRGGBBAA" format
        * @name toHex8
        * @memberOf me.Color
        * @function
        * @return {String}
        */ toHex8: function toHex8() {
                // TODO : Memoize this function by caching its result until any of
                // the r,g,b,a values are changed
                return "#" + _toHex(this.r) + _toHex(this.g) + _toHex(this.b) + _toHex(this.alpha * 255);
            },
            /**
        * Get the color in "rgb(R,G,B)" format
        * @name toRGB
        * @memberOf me.Color
        * @function
        * @return {String}
        */ toRGB: function toRGB() {
                // TODO : Memoize this function by caching its result until any of
                // the r,g,b,a values are changed
                return "rgb(" + this.r + "," + this.g + "," + this.b + ")";
            },
            /**
        * Get the color in "rgba(R,G,B,A)" format
        * @name toRGBA
        * @memberOf me.Color
        * @function
        * @return {String}
        */ toRGBA: function toRGBA() {
                // TODO : Memoize this function by caching its result until any of
                // the r,g,b,a values are changed
                return "rgba(" + this.r + "," + this.g + "," + this.b + "," + this.alpha + ")";
            }
        });
        /**
      * Color Red Component
      * @type Number
      * @name r
      * @readonly
      * @memberOf me.Color
      */ Object.defineProperty(me.Color.prototype, "r", {
            /**
        * @ignore
        */ get: function get() {
                return ~~(this.glArray[0] * 255);
            },
            /**
        * @ignore
        */ set: function set(value) {
                this.glArray[0] = me.Math.clamp(~~value || 0, 0, 255) / 255;
            },
            enumerable: true,
            configurable: true
        });
        /**
      * Color Green Component
      * @type Number
      * @name g
      * @readonly
      * @memberOf me.Color
      */ Object.defineProperty(me.Color.prototype, "g", {
            /**
        * @ignore
        */ get: function get() {
                return ~~(this.glArray[1] * 255);
            },
            /**
        * @ignore
        */ set: function set(value) {
                this.glArray[1] = me.Math.clamp(~~value || 0, 0, 255) / 255;
            },
            enumerable: true,
            configurable: true
        });
        /**
      * Color Blue Component
      * @type Number
      * @name b
      * @readonly
      * @memberOf me.Color
      */ Object.defineProperty(me.Color.prototype, "b", {
            /**
        * @ignore
        */ get: function get() {
                return ~~(this.glArray[2] * 255);
            },
            /**
        * @ignore
        */ set: function set(value) {
                this.glArray[2] = me.Math.clamp(~~value || 0, 0, 255) / 255;
            },
            enumerable: true,
            configurable: true
        });
        /**
      * Color Alpha Component
      * @type Number
      * @name alpha
      * @readonly
      * @memberOf me.Color
      */ Object.defineProperty(me.Color.prototype, "alpha", {
            /**
        * @ignore
        */ get: function get() {
                return this.glArray[3];
            },
            /**
        * @ignore
        */ set: function set(value) {
                this.glArray[3] = typeof value === "undefined" ? 1 : me.Math.clamp(+value, 0, 1);
            },
            enumerable: true,
            configurable: true
        });
    })();
    (function() {
        /**
      * A singleton object to access the device localStorage area
      * @example
      * // Initialize "score" and "lives" with default values
      * // This loads the properties from localStorage if they exist, else it sets the given defaults
      * me.save.add({ score : 0, lives : 3 });
      *
      * // Print all
      * // On first load, this prints { score : 0, lives : 3 }
      * // On further reloads, it prints { score : 31337, lives : 3, complexObject : ... }
      * // Because the following changes will be saved to localStorage
      * console.log(JSON.stringify(me.save));
      *
      * // Save score
      * me.save.score = 31337;
      *
      * // Also supports complex objects thanks to the JSON backend
      * me.save.add({ complexObject : {} })
      * me.save.complexObject = { a : "b", c : [ 1, 2, 3, "d" ], e : { f : [{}] } };
      *
      * // WARNING: Do not set any child properties of complex objects directly!
      * // Changes made that way will not save. Always set the entire object value at once.
      * // If you cannot live with this limitation, there's a workaround:
      * me.save.complexObject.c.push("foo"); // Modify a child property
      * me.save.complexObject = me.save.complexObject; // Save the entire object!
      *
      * // Remove "lives" from localStorage
      * me.save.remove("lives");
      * @namespace me.save
      * @memberOf me
      */ me.save = (function() {
            // Variable to hold the object data
            var data = {
            }; // a function to check if the given key is a reserved word
            function isReserved(key) {
                return key === "add" || key === "remove";
            } // Public API
            var api = {
                /**
          * @ignore
          */ init: function init() {
                    // Load previous data if local Storage is supported
                    if (me.device.localStorage === true) {
                        var me_save_content = localStorage.getItem("me.save");
                        if (typeof me_save_content === "string" && me_save_content.length > 0) {
                            var keys = JSON.parse(me_save_content) || [];
                            keys.forEach(function(key) {
                                data[key] = JSON.parse(localStorage.getItem("me.save." + key));
                            });
                        }
                    }
                },
                /**
          * Add new keys to localStorage and set them to the given default values if they do not exist
          * @name add
          * @memberOf me.save
          * @function
          * @param {Object} props key and corresponding values
          * @example
          * // Initialize "score" and "lives" with default values
          * me.save.add({ score : 0, lives : 3 });
          */ add: function add(props) {
                    Object.keys(props).forEach(function(key) {
                        if (isReserved(key)) return;
                        (function(prop) {
                            Object.defineProperty(api, prop, {
                                configurable: true,
                                enumerable: true,
                                /**
                  * @ignore
                  */ get: function get() {
                                    return data[prop];
                                },
                                /**
                  * @ignore
                  */ set: function set(value) {
                                    data[prop] = value;
                                    if (me.device.localStorage === true) localStorage.setItem("me.save." + prop, JSON.stringify(value));
                                }
                            });
                        })(key); // Set default value for key
                        if (!(key in data)) api[key] = props[key];
                    }); // Save keys
                    if (me.device.localStorage === true) localStorage.setItem("me.save", JSON.stringify(Object.keys(data)));
                },
                /**
          * Remove a key from localStorage
          * @name remove
          * @memberOf me.save
          * @function
          * @param {String} key key to be removed
          * @example
          * // Remove the "score" key from localStorage
          * me.save.remove("score");
          */ remove: function remove(key) {
                    if (!isReserved(key)) {
                        if (typeof data[key] !== "undefined") {
                            delete data[key];
                            if (me.device.localStorage === true) {
                                localStorage.removeItem("me.save." + key);
                                localStorage.setItem("me.save", JSON.stringify(Object.keys(data)));
                            }
                        }
                    }
                }
            };
            return api;
        })();
    })();
    (function() {
        /**
      * a level manager object <br>
      * once ressources loaded, the level director contains all references of defined levels<br>
      * There is no constructor function for me.levelDirector, this is a static object
      * @namespace me.levelDirector
      * @memberOf me
      */ me.levelDirector = (function() {
            // hold public stuff in our singletong
            var api = {
            };
            /*
        * PRIVATE STUFF
        */ // our levels
            var levels = {
            }; // level index table
            var levelIdx = []; // current level index
            var currentLevelIdx = 0;
            function safeLoadLevel(levelId, options, restart) {
                // clean the destination container
                options.container.reset(); // reset the renderer
                me.game.reset(); // clean the current (previous) level
                if (levels[api.getCurrentLevelId()]) levels[api.getCurrentLevelId()].destroy();
                 // update current level index
                currentLevelIdx = levelIdx.indexOf(levelId); // add the specified level to the game world
                loadTMXLevel(levelId, options.container, options.flatten, options.setViewportBounds); // publish the corresponding message
                me.event.publish(me.event.LEVEL_LOADED, [
                    levelId
                ]); // fire the callback
                options.onLoaded(levelId);
                if (restart) // resume the game loop if it was previously running
                me.state.restart();
            }
            /**
        * Load a TMX level
        * @name loadTMXLevel
        * @memberOf me.game
        * @private
        * @param {String} level level id
        * @param {me.Container} target container
        * @param {boolean} [flatten=true] if true, flatten all objects into the given container
        * @param {boolean} [setViewportBounds=false] if true, set the viewport bounds to the map size, this should be set to true especially if adding a level to the game world container.
        * @ignore
        * @function
        */ function loadTMXLevel(levelId, container, flatten, setViewportBounds) {
                var level = levels[levelId]; // reset the GUID generator
                // and pass the level id as parameter
                me.utils.resetGUID(levelId, level.nextobjectid); // Tiled use 0,0 anchor coordinates
                container.anchorPoint.set(0, 0); // add all level elements to the target container
                level.addTo(container, flatten, setViewportBounds);
            }
            /*
        * PUBLIC STUFF
        */ /**
        * initialize the level director
        * @ignore
        */ api.init = function() {
            };
            /**
        * reset the level director
        * @ignore
        */ api.reset = function() {
            };
            /**
        * add a level
        * @ignore
        */ api.addLevel = function() {
                throw new Error("no level loader defined");
            };
            /**
        * add a TMX level
        * @ignore
        */ api.addTMXLevel = function(levelId, callback) {
                // just load the level with the XML stuff
                if (levels[levelId] == null) {
                    //console.log("loading "+ levelId);
                    levels[levelId] = new me.TMXTileMap(levelId, me.loader.getTMX(levelId)); // level index
                    levelIdx.push(levelId);
                } else //console.log("level %s already loaded", levelId);
                return false;
                 // call the callback if defined
                if (callback) callback();
                 // true if level loaded
                return true;
            };
            /**
        * load a level into the game manager<br>
        * (will also create all level defined entities, etc..)
        * @name loadLevel
        * @memberOf me.levelDirector
        * @public
        * @function
        * @param {String} level level id
        * @param {Object} [options] additional optional parameters
        * @param {me.Container} [options.container=me.game.world] container in which to load the specified level
        * @param {function} [options.onLoaded=me.game.onLevelLoaded] callback for when the level is fully loaded
        * @param {boolean} [options.flatten=me.game.mergeGroup] if true, flatten all objects into the given container
        * @param {boolean} [options.setViewportBounds=true] if true, set the viewport bounds to the map size
        * @example
        * // the game assets to be be preloaded
        * // TMX maps
        * var resources = [
        *     {name: "a4_level1",   type: "tmx",   src: "data/level/a4_level1.tmx"},
        *     {name: "a4_level2",   type: "tmx",   src: "data/level/a4_level2.tmx"},
        *     {name: "a4_level3",   type: "tmx",   src: "data/level/a4_level3.tmx"},
        *     // ...
        * ];
        *
        * // ...
        *
        * // load a level into the game world
        * me.levelDirector.loadLevel("a4_level1");
        * ...
        * ...
        * // load a level into a specific container
        * var levelContainer = new me.Container();
        * me.levelDirector.loadLevel("a4_level2", {container:levelContainer});
        * // add a simple transformation
        * levelContainer.currentTransform.translate(levelContainer.width / 2, levelContainer.height / 2 );
        * levelContainer.currentTransform.rotate(0.05);
        * levelContainer.currentTransform.translate(-levelContainer.width / 2, -levelContainer.height / 2 );
        * // add it to the game world
        * me.game.world.addChild(levelContainer);
        */ api.loadLevel = function(levelId, options) {
                options = Object.assign({
                    "container": me.game.world,
                    "onLoaded": me.game.onLevelLoaded,
                    "flatten": me.game.mergeGroup,
                    "setViewportBounds": true
                }, options || {
                }); // throw an exception if not existing
                if (typeof levels[levelId] === "undefined") throw new Error("level " + levelId + " not found");
                if (levels[levelId] instanceof me.TMXTileMap) {
                    // check the status of the state mngr
                    var wasRunning = me.state.isRunning();
                    if (wasRunning) {
                        // stop the game loop to avoid
                        // some silly side effects
                        me.state.stop();
                        me.utils["function"].defer(safeLoadLevel, this, levelId, options, true);
                    } else safeLoadLevel(levelId, options);
                } else throw new Error("no level loader defined");
                return true;
            };
            /**
        * return the current level id<br>
        * @name getCurrentLevelId
        * @memberOf me.levelDirector
        * @public
        * @function
        * @return {String}
        */ api.getCurrentLevelId = function() {
                return levelIdx[currentLevelIdx];
            };
            /**
        * return the current level definition.
        * for a reference to the live instantiated level,
        * rather use the container in which it was loaded (e.g. me.game.world)
        * @name getCurrentLevel
        * @memberOf me.levelDirector
        * @public
        * @function
        * @return {me.TMXTileMap}
        */ api.getCurrentLevel = function() {
                return levels[api.getCurrentLevelId()];
            };
            /**
        * reload the current level
        * @name reloadLevel
        * @memberOf me.levelDirector
        * @public
        * @function
        * @param {Object} [options] additional optional parameters
        * @param {me.Container} [options.container=me.game.world] container in which to load the specified level
        * @param {function} [options.onLoaded=me.game.onLevelLoaded] callback for when the level is fully loaded
        * @param {boolean} [options.flatten=me.game.mergeGroup] if true, flatten all objects into the given container
        */ api.reloadLevel = function(options) {
                // reset the level to initial state
                //levels[currentLevel].reset();
                return api.loadLevel(api.getCurrentLevelId(), options);
            };
            /**
        * load the next level<br>
        * @name nextLevel
        * @memberOf me.levelDirector
        * @public
        * @function
        * @param {Object} [options] additional optional parameters
        * @param {me.Container} [options.container=me.game.world] container in which to load the specified level
        * @param {function} [options.onLoaded=me.game.onLevelLoaded] callback for when the level is fully loaded
        * @param {boolean} [options.flatten=me.game.mergeGroup] if true, flatten all objects into the given container
        */ api.nextLevel = function(options) {
                //go to the next level
                if (currentLevelIdx + 1 < levelIdx.length) return api.loadLevel(levelIdx[currentLevelIdx + 1], options);
                else return false;
            };
            /**
        * load the previous level<br>
        * @name previousLevel
        * @memberOf me.levelDirector
        * @public
        * @function
        * @param {Object} [options] additional optional parameters
        * @param {me.Container} [options.container=me.game.world] container in which to load the specified level
        * @param {function} [options.onLoaded=me.game.onLevelLoaded] callback for when the level is fully loaded
        * @param {boolean} [options.flatten=me.game.mergeGroup] if true, flatten all objects into the given container
        */ api.previousLevel = function(options) {
                // go to previous level
                if (currentLevelIdx - 1 >= 0) return api.loadLevel(levelIdx[currentLevelIdx - 1], options);
                else return false;
            };
            /**
        * return the amount of level preloaded<br>
        * @name levelCount
        * @memberOf me.levelDirector
        * @public
        * @function
        */ api.levelCount = function() {
                return levelIdx.length;
            }; // return our object
            return api;
        })();
    })();
    (function() {
        /**
      * a collection of TMX utility Function
      * @final
      * @memberOf me
      * @ignore
      */ me.TMXUtils = (function() {
            /*
        * PUBLIC
        */ // hold public stuff in our singleton
            var api = {
            };
            /**
        * set and interpret a TMX property value
        * @ignore
        */ function setTMXValue(name, type, value) {
                var match;
                if (typeof value !== "string") // Value is already normalized (e.g. with JSON maps)
                return value;
                switch(type){
                    case "int":
                    case "float":
                        value = Number(value);
                        break;
                    case "bool":
                        value = value === "true";
                        break;
                    default:
                        // try to parse it anyway
                        if (!value || me.utils.string.isBoolean(value)) // if value not defined or boolean
                        value = value ? value === "true" : true;
                        else if (me.utils.string.isNumeric(value)) // check if numeric
                        value = Number(value);
                        else if (value.search(/^json:/i) === 0) {
                            // try to parse it
                            match = value.split(/^json:/i)[1];
                            try {
                                value = JSON.parse(match);
                            } catch (e) {
                                throw new Error("Unable to parse JSON: " + match);
                            }
                        } else if (value.search(/^eval:/i) === 0) {
                            // try to evaluate it
                            match = value.split(/^eval:/i)[1];
                            try {
                                // eslint-disable-next-line
                                value = eval(match);
                            } catch (e) {
                                throw new Error("Unable to evaluate: " + match);
                            }
                        } else if ((match = value.match(/^#([\da-fA-F])([\da-fA-F]{3})$/)) || (match = value.match(/^#([\da-fA-F]{2})([\da-fA-F]{6})$/))) value = "#" + match[2] + match[1];
                         // normalize values
                        if (name.search(/^(ratio|anchorPoint)$/) === 0) // convert number to vector
                        {
                            if (typeof value === "number") value = {
                                "x": value,
                                "y": value
                            };
                        }
                } // return the interpreted value
                return value;
            }
            function parseAttributes(obj, elt) {
                // do attributes
                if (elt.attributes && elt.attributes.length > 0) for(var j = 0; j < elt.attributes.length; j++){
                    var attribute = elt.attributes.item(j);
                    if (typeof attribute.name !== "undefined") // DOM4 (Attr no longer inherit from Node)
                    obj[attribute.name] = attribute.value;
                    else // else use the deprecated ones
                    obj[attribute.nodeName] = attribute.nodeValue;
                }
            }
            /**
        * decompress zlib/gzip data (NOT IMPLEMENTED)
        * @ignore
        * @function
        * @memberOf me.TMXUtils
        * @name decompress
        * @param  {Number[]} data Array of bytes
        * @param  {String} format compressed data format ("gzip","zlib")
        * @return {Number[]} Decompressed data
        */ api.decompress = function() {
                throw new Error("GZIP/ZLIB compressed TMX Tile Map not supported!");
            };
            /**
        * Decode a CSV encoded array into a binary array
        * @ignore
        * @function
        * @memberOf me.TMXUtils
        * @name decodeCSV
        * @param  {String} input CSV formatted data (only numbers, everything else will be converted to NaN)
        * @return {Number[]} Decoded data
        */ api.decodeCSV = function(input) {
                var entries = input.replace("\n", "").trim().split(",");
                var result = [];
                for(var i = 0; i < entries.length; i++)result.push(+entries[i]);
                return result;
            };
            /**
        * Decode a base64 encoded string into a byte array
        * @ignore
        * @function
        * @memberOf me.TMXUtils
        * @name decodeBase64AsArray
        * @param {String} input Base64 encoded data
        * @param {Number} [bytes] number of bytes per array entry
        * @return {Uint32Array} Decoded data
        */ api.decodeBase64AsArray = function(input, bytes) {
                bytes = bytes || 1;
                var i, j, len;
                var dec = window.atob(input.replace(/[^A-Za-z0-9\+\/\=]/g, ""));
                var ar = new Uint32Array(dec.length / bytes);
                for(i = 0, len = dec.length / bytes; i < len; i++){
                    ar[i] = 0;
                    for(j = bytes - 1; j >= 0; --j)ar[i] += dec.charCodeAt(i * bytes + j) << (j << 3);
                }
                return ar;
            };
            /**
        * Decode the given data
        * @ignore
        */ api.decode = function(data, encoding, compression) {
                compression = compression || "none";
                encoding = encoding || "none";
                switch(encoding){
                    case "csv":
                        return api.decodeCSV(data);
                    case "base64":
                        var decoded = api.decodeBase64AsArray(data, 4);
                        return compression === "none" ? decoded : api.decompress(decoded, compression);
                    case "none":
                        return data;
                    case "xml":
                        throw new Error("XML encoding is deprecated, use base64 instead");
                    default:
                        throw new Error("Unknown layer encoding: " + encoding);
                }
            };
            /**
        * Normalize TMX format to Tiled JSON format
        * @ignore
        */ api.normalize = function(obj, item) {
                var nodeName = item.nodeName;
                switch(nodeName){
                    case "data":
                        var data = api.parse(item); // #956 Support for Infinite map
                        // workaround to prevent the parsing code from crashing
                        data.text = data.text || data.chunk.text; // When no encoding is given, the tiles are stored as individual XML tile elements.
                        data.encoding = data.encoding || "xml";
                        obj.data = api.decode(data.text, data.encoding, data.compression);
                        obj.encoding = "none";
                        break;
                    case "imagelayer":
                    case "layer":
                    case "objectgroup":
                    case "group":
                        var layer = api.parse(item);
                        layer.type = nodeName === "layer" ? "tilelayer" : nodeName;
                        if (layer.image) layer.image = layer.image.source;
                        obj.layers = obj.layers || [];
                        obj.layers.push(layer);
                        break;
                    case "animation":
                        obj.animation = api.parse(item).frames;
                        break;
                    case "frame":
                    case "object":
                        var name = nodeName + "s";
                        obj[name] = obj[name] || [];
                        obj[name].push(api.parse(item));
                        break;
                    case "tile":
                        var tile = api.parse(item);
                        if (tile.image) {
                            tile.imagewidth = tile.image.width;
                            tile.imageheight = tile.image.height;
                            tile.image = tile.image.source;
                        }
                        obj.tiles = obj.tiles || {
                        };
                        obj.tiles[tile.id] = tile;
                        break;
                    case "tileset":
                        var tileset = api.parse(item);
                        if (tileset.image) {
                            tileset.imagewidth = tileset.image.width;
                            tileset.imageheight = tileset.image.height;
                            tileset.image = tileset.image.source;
                        }
                        obj.tilesets = obj.tilesets || [];
                        obj.tilesets.push(tileset);
                        break;
                    case "polygon":
                    case "polyline":
                        obj[nodeName] = []; // Get a point array
                        var points = api.parse(item).points.split(" "); // And normalize them into an array of vectors
                        for(var i = 0, v; i < points.length; i++){
                            v = points[i].split(",");
                            obj[nodeName].push({
                                "x": +v[0],
                                "y": +v[1]
                            });
                        }
                        break;
                    case "properties":
                        obj.properties = api.parse(item);
                        break;
                    case "property":
                        var property = api.parse(item); // for custom properties, text is used
                        var value = typeof property.value !== "undefined" ? property.value : property.text;
                        obj[property.name] = setTMXValue(property.name, property.type || "string", value);
                        break;
                    default:
                        obj[nodeName] = api.parse(item);
                        break;
                }
            };
            /**
        * Parse a XML TMX object and returns the corresponding javascript object
        * @ignore
        */ api.parse = function(xml) {
                // Create the return object
                var obj = {
                };
                var text = "";
                if (xml.nodeType === 1) // do attributes
                parseAttributes(obj, xml);
                 // do children
                if (xml.hasChildNodes()) for(var i = 0; i < xml.childNodes.length; i++){
                    var item = xml.childNodes.item(i);
                    switch(item.nodeType){
                        case 1:
                            api.normalize(obj, item);
                            break;
                        case 3:
                            text += item.nodeValue.trim();
                            break;
                    }
                }
                if (text) obj.text = text;
                return obj;
            };
            /**
        * Apply TMX Properties to the given object
        * @ignore
        */ api.applyTMXProperties = function(obj, data) {
                var properties = data.properties;
                var types = data.propertytypes;
                if (typeof properties !== "undefined") {
                    for(var property in properties)if (properties.hasOwnProperty(property)) {
                        var type = "string";
                        var name = property;
                        var value = properties[property]; // proof-check for new and old JSON format
                        if (typeof properties[property].name !== "undefined") name = properties[property].name;
                        if (typeof types !== "undefined") type = types[property];
                        else if (typeof properties[property].type !== "undefined") type = properties[property].type;
                        if (typeof properties[property].value !== "undefined") value = properties[property].value;
                         // set the value
                        obj[name] = setTMXValue(name, type, value);
                    }
                }
            }; // return our object
            return api;
        })();
    })();
    (function() {
        /**
      * TMX Group <br>
      * contains an object group definition as defined in Tiled. <br>
      * note : object group definition is translated into the virtual `me.game.world` using `me.Container`.
      * @see me.Container
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      */ me.TMXGroup = me.Object.extend({
            /**
        * @ignore
        */ init: function init(map, data, z) {
                /**
          * group name
          * @public
          * @type String
          * @name name
          * @memberOf me.TMXGroup
          */ this.name = data.name;
                /**
          * group width
          * @public
          * @type Number
          * @name width
          * @memberOf me.TMXGroup
          */ this.width = data.width || 0;
                /**
          * group height
          * @public
          * @type Number
          * @name height
          * @memberOf me.TMXGroup
          */ this.height = data.height || 0;
                /**
          * group z order
          * @public
          * @type Number
          * @name z
          * @memberOf me.TMXGroup
          */ this.z = z;
                /**
          * group objects list definition
          * @see me.TMXObject
          * @public
          * @type Array
          * @name name
          * @memberOf me.TMXGroup
          */ this.objects = [];
                var visible = typeof data.visible !== "undefined" ? data.visible : true;
                this.opacity = visible === true ? me.Math.clamp(+data.opacity || 1, 0, 1) : 0; // check if we have any user-defined properties
                me.TMXUtils.applyTMXProperties(this, data); // parse all child objects/layers
                var self = this;
                if (data.objects) {
                    var _objects = data.objects;
                    _objects.forEach(function(object) {
                        self.objects.push(new me.TMXObject(map, object, z));
                    });
                }
                if (data.layers) {
                    var _layers = data.layers;
                    _layers.forEach(function(data1) {
                        var layer = new me.TMXLayer(data1, map.tilewidth, map.tileheight, map.orientation, map.tilesets, z++); // set a renderer
                        layer.setRenderer(map.getRenderer()); // resize container accordingly
                        self.width = Math.max(self.width, layer.width);
                        self.height = Math.max(self.height, layer.height);
                        self.objects.push(layer);
                    });
                }
            },
            /**
        * reset function
        * @ignore
        * @function
        */ destroy: function destroy() {
                // clear all allocated objects
                this.objects = null;
            },
            /**
        * return the object count
        * @ignore
        * @function
        */ getObjectCount: function getObjectCount() {
                return this.objects.length;
            },
            /**
        * returns the object at the specified index
        * @ignore
        * @function
        */ getObjectByIndex: function getObjectByIndex(idx) {
                return this.objects[idx];
            }
        });
    })();
    (function() {
        /**
      * a TMX Object defintion, as defined in Tiled. <br>
      * note : object definition are translated into the virtual `me.game.world` using `me.Entity`.
      * @see me.Entity
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      */ me.TMXObject = me.Object.extend({
            /**
        * @ignore
        */ init: function init(map, settings, z) {
                /**
          * point list in JSON format
          * @public
          * @type Object[]
          * @name points
          * @memberOf me.TMXObject
          */ this.points = undefined;
                /**
          * object name
          * @public
          * @type String
          * @name name
          * @memberOf me.TMXObject
          */ this.name = settings.name;
                /**
          * object x position
          * @public
          * @type Number
          * @name x
          * @memberOf me.TMXObject
          */ this.x = +settings.x;
                /**
          * object y position
          * @public
          * @type Number
          * @name y
          * @memberOf me.TMXObject
          */ this.y = +settings.y;
                /**
          * object z order
          * @public
          * @type Number
          * @name z
          * @memberOf me.TMXObject
          */ this.z = +z;
                /**
          * object width
          * @public
          * @type Number
          * @name width
          * @memberOf me.TMXObject
          */ this.width = +settings.width || 0;
                /**
          * object height
          * @public
          * @type Number
          * @name height
          * @memberOf me.TMXObject
          */ this.height = +settings.height || 0;
                /**
          * object gid value
          * when defined the object is a tiled object
          * @public
          * @type Number
          * @name gid
          * @memberOf me.TMXObject
          */ this.gid = +settings.gid || null;
                /**
          * object type
          * @public
          * @type String
          * @name type
          * @memberOf me.TMXObject
          */ this.type = settings.type;
                /**
          * object text
          * @public
          * @type Object
          * @see http://docs.mapeditor.org/en/stable/reference/tmx-map-format/#text
          * @name type
          * @memberOf me.TMXObject
          */ this.type = settings.type;
                /**
          * The rotation of the object in radians clockwise (defaults to 0)
          * @public
          * @type Number
          * @name rotation
          * @memberOf me.TMXObject
          */ this.rotation = me.Math.degToRad(+settings.rotation || 0);
                /**
          * object unique identifier per level (Tiled 0.11.x+)
          * @public
          * @type Number
          * @name id
          * @memberOf me.TMXObject
          */ this.id = +settings.id || undefined;
                /**
          * object orientation (orthogonal or isometric)
          * @public
          * @type String
          * @name orientation
          * @memberOf me.TMXObject
          */ this.orientation = map.orientation;
                /**
          * the collision shapes defined for this object
          * @public
          * @type Array
          * @name shapes
          * @memberOf me.TMXObject
          */ this.shapes = undefined;
                /**
          * if true, the object is an Ellipse
          * @public
          * @type Boolean
          * @name isEllipse
          * @memberOf me.TMXObject
          */ this.isEllipse = false;
                /**
          * if true, the object is a Polygon
          * @public
          * @type Boolean
          * @name isPolygon
          * @memberOf me.TMXObject
          */ this.isPolygon = false;
                /**
          * if true, the object is a PolyLine
          * @public
          * @type Boolean
          * @name isPolyLine
          * @memberOf me.TMXObject
          */ this.isPolyLine = false; // check if the object has an associated gid
                if (typeof this.gid === "number") this.setTile(map.tilesets);
                else {
                    if (typeof settings.ellipse !== "undefined") this.isEllipse = true;
                    else if (typeof settings.polygon !== "undefined") {
                        this.points = settings.polygon;
                        this.isPolygon = true;
                    } else if (typeof settings.polyline !== "undefined") {
                        this.points = settings.polyline;
                        this.isPolyLine = true;
                    }
                } // check for text information
                if (typeof settings.text !== "undefined") {
                    // a text object
                    this.text = settings.text; // normalize field name and default value the melonjs way
                    this.text.font = settings.text.fontfamily || "sans-serif";
                    this.text.size = settings.text.pixelsize || 16;
                    this.text.fillStyle = settings.text.color || "#000000";
                    this.text.textAlign = settings.text.halign || "left";
                    this.text.textBaseline = settings.text.valign || "top";
                    this.text.width = this.width;
                    this.text.height = this.height; // set the object properties
                    me.TMXUtils.applyTMXProperties(this.text, settings);
                } else {
                    // set the object properties
                    me.TMXUtils.applyTMXProperties(this, settings); // a standard object
                    if (!this.shapes) // else define the object shapes if required
                    this.shapes = this.parseTMXShapes();
                } // Adjust the Position to match Tiled
                if (!map.isEditor) map.getRenderer().adjustPosition(this);
            },
            /**
        * set the object image (for Tiled Object)
        * @ignore
        * @function
        */ setTile: function setTile(tilesets) {
                // get the corresponding tileset
                var tileset = tilesets.getTilesetByGid(this.gid);
                if (tileset.isCollection === false) {
                    // set width and height equal to tile size
                    this.width = this.framewidth = tileset.tilewidth;
                    this.height = this.frameheight = tileset.tileheight;
                } // the object corresponding tile object
                this.tile = new me.Tile(this.x, this.y, this.gid, tileset);
            },
            /**
        * parses the TMX shape definition and returns a corresponding array of me.Shape object
        * @name parseTMXShapes
        * @memberOf me.TMXObject
        * @private
        * @function
        * @return {me.Polygon[]|me.Line[]|me.Ellipse[]} an array of shape objects
        */ parseTMXShapes: function parseTMXShapes() {
                var i = 0;
                var shapes = []; // add an ellipse shape
                if (this.isEllipse === true) // ellipse coordinates are the center position, so set default to the corresonding radius
                shapes.push(new me.Ellipse(this.width / 2, this.height / 2, this.width, this.height).rotate(this.rotation));
                else if (this.isPolygon === true) shapes.push(new me.Polygon(0, 0, this.points).rotate(this.rotation));
                else if (this.isPolyLine === true) {
                    var p = this.points;
                    var p1, p2;
                    var segments = p.length - 1;
                    for(i = 0; i < segments; i++){
                        // clone the value before, as [i + 1]
                        // is reused later by the next segment
                        p1 = new me.Vector2d(p[i].x, p[i].y);
                        p2 = new me.Vector2d(p[i + 1].x, p[i + 1].y);
                        if (this.rotation !== 0) {
                            p1 = p1.rotate(this.rotation);
                            p2 = p2.rotate(this.rotation);
                        }
                        shapes.push(new me.Line(0, 0, [
                            p1,
                            p2
                        ]));
                    }
                } else shapes.push(new me.Polygon(0, 0, [
                    new me.Vector2d(),
                    new me.Vector2d(this.width, 0),
                    new me.Vector2d(this.width, this.height),
                    new me.Vector2d(0, this.height)
                ]).rotate(this.rotation));
                 // Apply isometric projection
                if (this.orientation === "isometric") for(i = 0; i < shapes.length; i++)shapes[i].toIso();
                return shapes;
            },
            /**
        * getObjectPropertyByName
        * @ignore
        * @function
        */ getObjectPropertyByName: function getObjectPropertyByName(name) {
                return this[name];
            }
        });
    })();
    (function() {
        // bitmask constants to check for flipped & rotated tiles
        var TMX_FLIP_H = 2147483648, TMX_FLIP_V = 1073741824, TMX_FLIP_AD = 536870912, TMX_CLEAR_BIT_MASK = 536870911;
        /**
      * a basic tile object
      * @class
      * @extends me.Rect
      * @memberOf me
      * @constructor
      * @param {Number} x x index of the Tile in the map
      * @param {Number} y y index of the Tile in the map
      * @param {Number} gid tile gid
      * @param {me.TMXTileset} tileset the corresponding tileset object
      */ me.Tile = me.Rect.extend({
            /** @ignore */ init: function init(x, y, gid, tileset) {
                var width, height; // determine the tile size
                if (tileset.isCollection) {
                    var image = tileset.getTileImage(gid & TMX_CLEAR_BIT_MASK);
                    width = image.width;
                    height = image.height;
                } else {
                    width = tileset.tilewidth;
                    height = tileset.tileheight;
                } // call the parent constructor
                this._super(me.Rect, "init", [
                    x * width,
                    y * height,
                    width,
                    height
                ]);
                /**
          * tileset
          * @public
          * @type me.TMXTileset
          * @name me.Tile#tileset
          */ this.tileset = tileset;
                /**
          * the tile transformation matrix (if defined)
          * @ignore
          */ this.currentTransform = null; // Tile col / row pos
                this.col = x;
                this.row = y;
                /**
          * tileId
          * @public
          * @type Number
          * @name me.Tile#tileId
          */ this.tileId = gid;
                /**
          * True if the tile is flipped horizontally<br>
          * @public
          * @type Boolean
          * @name me.Tile#flipX
          */ this.flippedX = (this.tileId & TMX_FLIP_H) !== 0;
                /**
          * True if the tile is flipped vertically<br>
          * @public
          * @type Boolean
          * @name me.Tile#flippedY
          */ this.flippedY = (this.tileId & TMX_FLIP_V) !== 0;
                /**
          * True if the tile is flipped anti-diagonally<br>
          * @public
          * @type Boolean
          * @name me.Tile#flippedAD
          */ this.flippedAD = (this.tileId & TMX_FLIP_AD) !== 0;
                /**
          * Global flag that indicates if the tile is flipped<br>
          * @public
          * @type Boolean
          * @name me.Tile#flipped
          */ this.flipped = this.flippedX || this.flippedY || this.flippedAD; // create and apply transformation matrix if required
                if (this.flipped === true) {
                    if (this.currentTransform === null) this.currentTransform = new me.Matrix2d();
                    this.setTileTransform(this.currentTransform.identity());
                } // clear out the flags and set the tileId
                this.tileId &= TMX_CLEAR_BIT_MASK;
            },
            /**
        * set the transformation matrix for this tile
        * @return {me.Matrix2d) a transformation matrix
        * @ignore
        */ setTileTransform: function setTileTransform(transform) {
                transform.translate(this.width / 2, this.height / 2);
                if (this.flippedAD) {
                    transform.rotate(-90 * Math.PI / 180);
                    transform.scale(-1, 1);
                }
                if (this.flippedX) transform.scale(this.flippedAD ? 1 : -1, this.flippedAD ? -1 : 1);
                if (this.flippedY) transform.scale(this.flippedAD ? -1 : 1, this.flippedAD ? 1 : -1);
                transform.translate(-this.width / 2, -this.height / 2);
            },
            /**
        * return a renderable object for this Tile object
        * @name me.Tile#getRenderable
        * @public
        * @function
        * @param {Object} [settings] see {@link me.Sprite}
        * @return {me.Renderable} a me.Sprite object
        */ getRenderable: function getRenderable(settings) {
                var renderable;
                var tileset = this.tileset;
                if (tileset.animations.has(this.tileId)) {
                    var frames = [];
                    var frameId = [];
                    tileset.animations.get(this.tileId).frames.forEach(function(frame) {
                        frameId.push(frame.tileid);
                        frames.push({
                            name: "" + frame.tileid,
                            delay: frame.duration
                        });
                    });
                    renderable = tileset.texture.createAnimationFromName(frameId, settings);
                    renderable.addAnimation(this.tileId - tileset.firstgid, frames);
                    renderable.setCurrentAnimation(this.tileId - tileset.firstgid);
                } else if (tileset.isCollection === true) {
                    var image = tileset.getTileImage(this.tileId);
                    renderable = new me.Sprite(0, 0, Object.assign({
                        image: image
                    }) //, settings)
                    );
                    renderable.anchorPoint.set(0, 0);
                    renderable.scale(settings.width / this.width, settings.height / this.height);
                    if (typeof settings.rotation !== "undefined") {
                        renderable.anchorPoint.set(0.5, 0.5);
                        renderable.currentTransform.rotate(settings.rotation);
                        renderable.currentTransform.translate(settings.width / 2, settings.height / 2); // TODO : move the rotation related code from TMXTiledMap to here (under)
                        settings.rotation = undefined;
                    }
                } else renderable = tileset.texture.createSpriteFromName(this.tileId - tileset.firstgid, settings);
                 // any H/V flipping to apply?
                if (this.flippedX) renderable.currentTransform.scaleX(-1);
                if (this.flippedY) renderable.currentTransform.scaleY(-1);
                return renderable;
            }
        });
    })();
    (function() {
        // bitmask constants to check for flipped & rotated tiles
        var TMX_CLEAR_BIT_MASK = 536870911;
        /**
      * a TMX Tile Set Object
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      * @param {Object} tileset tileset data in JSON format ({@link http://docs.mapeditor.org/en/stable/reference/tmx-map-format/#tileset})
      */ me.TMXTileset = me.Object.extend({
            /**
        * constructor
        * @ignore
        */ init: function init(tileset) {
                var i = 0; // first gid
                // tile properties (collidable, etc..)
                this.TileProperties = []; // hold reference to each tile image
                this.imageCollection = [];
                this.firstgid = this.lastgid = +tileset.firstgid; // check if an external tileset is defined
                if (typeof tileset.source !== "undefined") {
                    var src = tileset.source;
                    var ext = me.utils.file.getExtension(src);
                    if (ext === "tsx" || ext === "json") {
                        // load the external tileset (TSX/JSON)
                        tileset = me.loader.getTMX(me.utils.file.getBasename(src));
                        if (!tileset) throw new Error(src + " external TSX/JSON tileset not found");
                    }
                }
                this.name = tileset.name;
                this.tilewidth = +tileset.tilewidth;
                this.tileheight = +tileset.tileheight;
                this.spacing = +tileset.spacing || 0;
                this.margin = +tileset.margin || 0; // set tile offset properties (if any)
                this.tileoffset = new me.Vector2d();
                /**
          * Tileset contains animated tiles
          * @public
          * @type Boolean
          * @name me.TMXTileset#isAnimated
          */ this.isAnimated = false;
                /**
          * true if the tileset is a "Collection of Image" Tileset
          * @public
          * @type Boolean
          * @name me.TMXTileset#isCollection
          */ this.isCollection = false;
                /**
          * Tileset animations
          * @private
          * @type Map
          * @name me.TMXTileset#animations
          */ this.animations = new Map();
                /**
          * Remember the last update timestamp to prevent too many animation updates
          * @private
          * @type Map
          * @name me.TMXTileset#_lastUpdate
          */ this._lastUpdate = 0;
                var tiles = tileset.tiles;
                for(i in tiles)if (tiles.hasOwnProperty(i)) {
                    if ("animation" in tiles[i]) {
                        this.isAnimated = true;
                        this.animations.set(tiles[+i].animation[0].tileid, {
                            dt: 0,
                            idx: 0,
                            frames: tiles[+i].animation,
                            cur: tiles[+i].animation[0]
                        });
                    } // set tile properties, if any (XML format)
                    if ("properties" in tiles[i]) this.setTileProperty(+i + this.firstgid, tiles[i].properties);
                    if ("image" in tiles[i]) {
                        var image = me.loader.getImage(tiles[i].image);
                        if (!image) throw new Error("melonJS: '" + tiles[i].image + "' file for tile '" + (+i + this.firstgid) + "' not found!");
                        this.imageCollection[+i + this.firstgid] = image;
                    }
                }
                this.isCollection = this.imageCollection.length > 0;
                var offset = tileset.tileoffset;
                if (offset) {
                    this.tileoffset.x = +offset.x;
                    this.tileoffset.y = +offset.y;
                } // set tile properties, if any (JSON format)
                var tileInfo = tileset.tileproperties;
                if (tileInfo) {
                    for(i in tileInfo)if (tileInfo.hasOwnProperty(i)) this.setTileProperty(+i + this.firstgid, tileInfo[i]);
                } // if not a tile image collection
                if (this.isCollection === false) {
                    // get the global tileset texture
                    this.image = me.loader.getImage(tileset.image);
                    if (!this.image) throw new Error("melonJS: '" + tileset.image + "' file for tileset '" + this.name + "' not found!");
                     // create a texture atlas for the given tileset
                    this.texture = me.video.renderer.cache.get(this.image, {
                        framewidth: this.tilewidth,
                        frameheight: this.tileheight,
                        margin: this.margin,
                        spacing: this.spacing
                    });
                    this.atlas = this.texture.getAtlas(); // calculate the number of tiles per horizontal line
                    var hTileCount = +tileset.columns || Math.round(this.image.width / (this.tilewidth + this.spacing));
                    var vTileCount = Math.round(this.image.height / (this.tileheight + this.spacing));
                    if (tileset.tilecount % hTileCount > 0) ++vTileCount;
                     // compute the last gid value in the tileset
                    this.lastgid = this.firstgid + (hTileCount * vTileCount - 1 || 0);
                    if (tileset.tilecount && this.lastgid - this.firstgid + 1 !== +tileset.tilecount) console.warn("Computed tilecount (" + (this.lastgid - this.firstgid + 1) + ") does not match expected tilecount (" + tileset.tilecount + ")");
                }
            },
            /**
        * return the tile image from a "Collection of Image" tileset
        * @name me.TMXTileset#getTileImage
        * @public
        * @function
        * @param {Number} gid
        * @return {Image} corresponding image or undefined
        */ getTileImage: function getTileImage(gid) {
                return this.imageCollection[gid];
            },
            /**
        * set the tile properties
        * @ignore
        * @function
        */ setTileProperty: function setTileProperty(gid, prop) {
                // set the given tile id
                this.TileProperties[gid] = prop;
            },
            /**
        * return true if the gid belongs to the tileset
        * @name me.TMXTileset#contains
        * @public
        * @function
        * @param {Number} gid
        * @return {Boolean}
        */ contains: function contains(gid) {
                return gid >= this.firstgid && gid <= this.lastgid;
            },
            /**
        * Get the view (local) tile ID from a GID, with animations applied
        * @name me.TMXTileset#getViewTileId
        * @public
        * @function
        * @param {Number} gid Global tile ID
        * @return {Number} View tile ID
        */ getViewTileId: function getViewTileId(gid) {
                var localId = gid - this.firstgid;
                if (this.animations.has(localId)) // return the current corresponding tile id if animated
                return this.animations.get(localId).cur.tileid;
                return localId;
            },
            /**
        * return the properties of the specified tile
        * @name me.TMXTileset#getTileProperties
        * @public
        * @function
        * @param {Number} tileId
        * @return {Object}
        */ getTileProperties: function getTileProperties(tileId) {
                return this.TileProperties[tileId];
            },
            // update tile animations
            update: function update(dt) {
                var duration = 0, now = me.timer.getTime(), result = false;
                if (this._lastUpdate !== now) {
                    this._lastUpdate = now;
                    this.animations.forEach(function(anim) {
                        anim.dt += dt;
                        duration = anim.cur.duration;
                        while(anim.dt >= duration){
                            anim.dt -= duration;
                            anim.idx = (anim.idx + 1) % anim.frames.length;
                            anim.cur = anim.frames[anim.idx];
                            duration = anim.cur.duration;
                            result = true;
                        }
                    });
                }
                return result;
            },
            // draw the x,y tile
            drawTile: function drawTile(renderer, dx, dy, tmxTile) {
                // check if any transformation is required
                if (tmxTile.flipped) {
                    renderer.save(); // apply the tile current transform
                    renderer.translate(dx, dy);
                    renderer.transform(tmxTile.currentTransform); // reset both values as managed through transform();
                    dx = dy = 0;
                } // check if the tile has an associated image
                if (this.isCollection === true) // draw the tile
                renderer.drawImage(this.imageCollection[tmxTile.tileId], 0, 0, tmxTile.width, tmxTile.height, dx, dy, tmxTile.width, tmxTile.height);
                else {
                    // use the tileset texture
                    var offset = this.atlas[this.getViewTileId(tmxTile.tileId)].offset; // draw the tile
                    renderer.drawImage(this.image, offset.x, offset.y, this.tilewidth, this.tileheight, dx, dy, this.tilewidth + renderer.uvOffset, this.tileheight + renderer.uvOffset);
                }
                if (tmxTile.flipped) // restore the context to the previous state
                renderer.restore();
            }
        });
        /**
      * an object containing all tileset
      * @class
      * @memberOf me
      * @constructor
      */ me.TMXTilesetGroup = me.Object.extend({
            /**
        * constructor
        * @ignore
        */ init: function init() {
                this.tilesets = [];
                this.length = 0;
            },
            /**
        * add a tileset to the tileset group
        * @name me.TMXTilesetGroup#add
        * @public
        * @function
        * @param  {me.TMXTileset} tileset
        */ add: function add(tileset) {
                this.tilesets.push(tileset);
                this.length++;
            },
            /**
        * return the tileset at the specified index
        * @name me.TMXTilesetGroup#getTilesetByIndex
        * @public
        * @function
        * @param {Number} i
        * @return {me.TMXTileset} corresponding tileset
        */ getTilesetByIndex: function getTilesetByIndex(i) {
                return this.tilesets[i];
            },
            /**
        * return the tileset corresponding to the specified id <br>
        * will throw an exception if no matching tileset is found
        * @name me.TMXTilesetGroup#getTilesetByGid
        * @public
        * @function
        * @param {Number} gid
        * @return {me.TMXTileset} corresponding tileset
        */ getTilesetByGid: function getTilesetByGid(gid) {
                var invalidRange = -1; // clear the gid of all flip/rotation flags
                gid &= TMX_CLEAR_BIT_MASK; // cycle through all tilesets
                for(var i = 0, len = this.tilesets.length; i < len; i++){
                    // return the corresponding tileset if matching
                    if (this.tilesets[i].contains(gid)) return this.tilesets[i];
                     // typically indicates a layer with no asset loaded (collision?)
                    if (this.tilesets[i].firstgid === this.tilesets[i].lastgid && gid >= this.tilesets[i].firstgid) // store the id if the [firstgid .. lastgid] is invalid
                    invalidRange = i;
                } // return the tileset with the invalid range
                if (invalidRange !== -1) return this.tilesets[invalidRange];
                else throw new Error("no matching tileset found for gid " + gid);
            }
        });
    })();
    (function() {
        /**
      * Create required arrays for the given layer object
      * @ignore
      */ function initArray(layer) {
            // initialize the array
            layer.layerData = new Array(layer.cols);
            for(var x = 0; x < layer.cols; x++){
                layer.layerData[x] = new Array(layer.rows);
                for(var y = 0; y < layer.rows; y++)layer.layerData[x][y] = null;
            }
        }
        /**
      * Set a tiled layer Data
      * @ignore
      */ function setLayerData(layer, data) {
            var idx = 0; // initialize the array
            initArray(layer); // set everything
            for(var y = 0; y < layer.rows; y++)for(var x = 0; x < layer.cols; x++){
                // get the value of the gid
                var gid = data[idx++]; // fill the array
                if (gid !== 0) // add a new tile to the layer
                layer.setTile(x, y, gid);
            }
        }
        /**
      * a TMX Tile Layer Object
      * Tiled QT 0.7.x format
      * @class
      * @extends me.Renderable
      * @memberOf me
      * @constructor
      * @param {Object} data layer data in JSON format ({@link http://docs.mapeditor.org/en/stable/reference/tmx-map-format/#layer})
      * @param {Number} tilewidth width of each tile in pixels
      * @param {Number} tileheight height of each tile in pixels
      * @param {String} orientation "isometric" or "orthogonal"
      * @param {me.TMXTilesetGroup} tilesets tileset as defined in Tiled
      * @param {Number} z z-index position
      */ me.TMXLayer = me.Renderable.extend({
            /**
        * @ignore
        */ init: function init(data, tilewidth, tileheight, orientation, tilesets, z) {
                // super constructor
                this._super(me.Renderable, "init", [
                    0,
                    0,
                    0,
                    0
                ]); // tile width & height
                this.tilewidth = data.tilewidth || tilewidth;
                this.tileheight = data.tileheight || tileheight; // layer orientation
                this.orientation = orientation;
                /**
          * The Layer corresponding Tilesets
          * @public
          * @type me.TMXTilesetGroup
          * @name me.TMXLayer#tilesets
          */ this.tilesets = tilesets; // the default tileset
                // XXX: Is this even used?
                this.tileset = this.tilesets ? this.tilesets.getTilesetByIndex(0) : null; // Biggest tile size to draw
                this.maxTileSize = {
                    "width": 0,
                    "height": 0
                };
                for(var i = 0; i < this.tilesets.length; i++){
                    var tileset = this.tilesets.getTilesetByIndex(i);
                    this.maxTileSize.width = Math.max(this.maxTileSize.width, tileset.tilewidth);
                    this.maxTileSize.height = Math.max(this.maxTileSize.height, tileset.tileheight);
                }
                /**
          * All animated tilesets in this layer
          * @ignore
          * @type Array
          * @name me.TMXLayer#animatedTilesets
          */ this.animatedTilesets = [];
                /**
          * Layer contains tileset animations
          * @public
          * @type Boolean
          * @name me.TMXLayer#isAnimated
          */ this.isAnimated = false;
                /**
          * the order in which tiles on orthogonal tile layers are rendered.
          * (valid values are "left-down", "left-up", "right-down", "right-up")
          * @public
          * @type {String}
          * @default "right-down"
          * @name me.TMXLayer#renderorder
          */ this.renderorder = data.renderorder || "right-down"; // for displaying order
                this.pos.z = z; // tiled default coordinates are top-left
                this.anchorPoint.set(0, 0); // additional TMX flags
                this.name = data.name;
                this.cols = +data.width;
                this.rows = +data.height; // layer opacity
                var visible = typeof data.visible !== "undefined" ? +data.visible : 1;
                this.setOpacity(visible ? +data.opacity : 0); // layer "real" size
                if (this.orientation === "isometric") {
                    this.width = (this.cols + this.rows) * (this.tilewidth / 2);
                    this.height = (this.cols + this.rows) * (this.tileheight / 2);
                } else {
                    this.width = this.cols * this.tilewidth;
                    this.height = this.rows * this.tileheight;
                } // check if we have any user-defined properties
                me.TMXUtils.applyTMXProperties(this, data); // check for the correct rendering method
                if (typeof this.preRender === "undefined") this.preRender = me.sys.preRender;
                 // initialize and set the layer data
                setLayerData(this, me.TMXUtils.decode(data.data, data.encoding, data.compression));
            },
            // called when the layer is added to the game world or a container
            onActivateEvent: function onActivateEvent() {
                if (this.animatedTilesets === undefined) this.animatedTilesets = [];
                if (this.tilesets) {
                    var tileset = this.tilesets.tilesets;
                    for(var i = 0; i < tileset.length; i++)if (tileset[i].isAnimated) this.animatedTilesets.push(tileset[i]);
                }
                this.isAnimated = this.animatedTilesets.length > 0; // Force pre-render off when tileset animation is used
                if (this.isAnimated) this.preRender = false;
                 // Resize the bounding rect
                var bounds = this.getRenderer().getBounds(this);
                this.getBounds().resize(bounds.width, bounds.height); // if pre-rendering method is use, create an offline canvas/renderer
                if (this.preRender === true && !this.canvasRenderer) this.canvasRenderer = new me.CanvasRenderer(me.video.createCanvas(this.width, this.height), this.width, this.height, {
                    transparent: true
                });
            },
            // called when the layer is removed from the game world or a container
            onDeactivateEvent: function onDeactivateEvent() {
                // clear all allocated objects
                //this.layerData = undefined;
                this.animatedTilesets = undefined;
            },
            /**
        * Set the TMX renderer for this layer object
        * @name setRenderer
        * @memberOf me.TMXLayer
        * @public
        * @function
        * @param {me.TMXRenderer} renderer
        * @example
        * // use the parent map default renderer
        * var layer = new me.TMXLayer(...);
        * layer.setRenderer(map.getRenderer());
        */ setRenderer: function setRenderer(renderer) {
                this.renderer = renderer;
            },
            /**
        * Return the layer current renderer object
        * @name getRenderer
        * @memberOf me.TMXLayer
        * @public
        * @function
        * @return {me.TMXRenderer} renderer
        */ getRenderer: function getRenderer(renderer) {
                return this.renderer;
            },
            /**
        * Return the TileId of the Tile at the specified position
        * @name getTileId
        * @memberOf me.TMXLayer
        * @public
        * @function
        * @param {Number} x X coordinate (in world/pixels coordinates)
        * @param {Number} y Y coordinate (in world/pixels coordinates)
        * @return {Number} TileId or null if there is no Tile at the given position
        */ getTileId: function getTileId(x, y) {
                var tile = this.getTile(x, y);
                return tile ? tile.tileId : null;
            },
            /**
        * Return the Tile object at the specified position
        * @name getTile
        * @memberOf me.TMXLayer
        * @public
        * @function
        * @param {Number} x X coordinate (in world/pixels coordinates)
        * @param {Number} y Y coordinate (in world/pixels coordinates)
        * @return {me.Tile} corresponding tile or null if there is no defined tile at the coordinate or if outside of the layer bounds
        * @example
        * // get the TMX Map Layer called "Front layer"
        * var layer = me.game.world.getChildByName("Front Layer")[0];
        * // get the tile object corresponding to the latest pointer position
        * var tile = layer.getTile(me.input.pointer.pos.x, me.input.pointer.pos.y);
        */ getTile: function getTile(x, y) {
                var tile = null;
                if (this.containsPoint(x, y)) {
                    var coord = this.renderer.pixelToTileCoords(x, y, me.pool.pull("me.Vector2d"));
                    tile = this.cellAt(coord.x, coord.y);
                    me.pool.push(coord);
                }
                return tile;
            },
            /**
        * Return the Tile object at the specified tile coordinates
        * @name cellAt
        * @memberOf me.TMXLayer
        * @public
        * @function
        * @param {Number} x x position of the tile (in Tile unit)
        * @param {Number} y x position of the tile (in Tile unit)
        * @param {Number} [boundsCheck=true] check first if within the layer bounds
        * @return {me.Tile} corresponding tile or null if there is no defined tile at the position or if outside of the layer bounds
        * @example
        * // return the first tile at offset 0, 0
        * var tile = layer.cellAt(0, 0);
        */ cellAt: function cellAt(x, y, boundsCheck) {
                var _x = ~~x;
                var _y = ~~y; // boundsCheck only used internally by the tiled renderer, when the layer bound check was already done
                if (boundsCheck === false || _x >= 0 && _x < this.renderer.cols && _y >= 0 && _y < this.renderer.rows) return this.layerData[_x][_y];
                else return null;
            },
            /**
        * Create a new Tile at the specified position
        * @name setTile
        * @memberOf me.TMXLayer
        * @public
        * @function
        * @param {Number} x X coordinate (in map coordinates: row/column)
        * @param {Number} y Y coordinate (in map coordinates: row/column)
        * @param {Number} tileId tileId
        * @return {me.Tile} the corresponding newly created tile object
        */ setTile: function setTile(x, y, tileId) {
                if (!this.tileset.contains(tileId)) // look for the corresponding tileset
                this.tileset = this.tilesets.getTilesetByGid(tileId);
                var tile = this.layerData[x][y] = new me.Tile(x, y, tileId, this.tileset); // draw the corresponding tile
                if (this.preRender) this.renderer.drawTile(this.canvasRenderer, x, y, tile);
                return tile;
            },
            /**
        * clear the tile at the specified position
        * @name clearTile
        * @memberOf me.TMXLayer
        * @public
        * @function
        * @param {Number} x X coordinate (in map coordinates: row/column)
        * @param {Number} y Y coordinate (in map coordinates: row/column)
        * @example
        * me.game.world.getChildByType(me.TMXLayer).forEach(function(layer) {
        *     // clear all tiles at the given x,y coordinates
        *     layer.clearTile(x, y);
        * });
        */ clearTile: function clearTile(x, y) {
                // clearing tile
                this.layerData[x][y] = null; // erase the corresponding area in the canvas
                if (this.preRender) this.canvasRenderer.clearRect(x * this.tilewidth, y * this.tileheight, this.tilewidth, this.tileheight);
            },
            /**
        * update animations in a tileset layer
        * @ignore
        */ update: function update(dt) {
                if (this.isAnimated) {
                    var result = false;
                    for(var i = 0; i < this.animatedTilesets.length; i++)result = this.animatedTilesets[i].update(dt) || result;
                    return result;
                }
                return false;
            },
            /**
        * draw a tileset layer
        * @ignore
        */ draw: function draw(renderer, rect) {
                // use the offscreen canvas
                if (this.preRender) {
                    var width = Math.min(rect.width, this.width);
                    var height = Math.min(rect.height, this.height); // draw using the cached canvas
                    renderer.drawImage(this.canvasRenderer.getCanvas(), rect.pos.x, rect.pos.y, width, height, rect.pos.x, rect.pos.y, width, height // dw,dh
                    );
                } else // draw the layer
                this.renderer.drawTileLayer(renderer, this, rect);
            }
        });
    })();
    (function() {
        // constant to identify the collision object layer
        var COLLISION_GROUP = "collision"; // onresize handler
        var onresize_handler = null;
        /**
      * set a compatible renderer object
      * for the specified map
      * @ignore
      */ function getNewDefaultRenderer(map) {
            switch(map.orientation){
                case "orthogonal":
                    return new me.TMXOrthogonalRenderer(map);
                case "isometric":
                    return new me.TMXIsometricRenderer(map);
                case "hexagonal":
                    return new me.TMXHexagonalRenderer(map);
                case "staggered":
                    return new me.TMXStaggeredRenderer(map);
                // if none found, throw an exception
                default:
                    throw new Error(map.orientation + " type TMX Tile Map not supported!");
            }
        }
        /**
      * read the layer Data
      * @ignore
      */ function readLayer(map, data, z) {
            var layer = new me.TMXLayer(data, map.tilewidth, map.tileheight, map.orientation, map.tilesets, z); // set a renderer
            layer.setRenderer(map.getRenderer());
            return layer;
        }
        /**
      * read the Image Layer Data
      * @ignore
      */ function readImageLayer(map, data, z) {
            // Normalize properties
            me.TMXUtils.applyTMXProperties(data.properties, data); // create the layer
            var imageLayer = me.pool.pull("me.ImageLayer", +data.offsetx || +data.x || 0, +data.offsety || +data.y || 0, Object.assign({
                name: data.name,
                image: data.image,
                z: z
            }, data.properties)); // set some additional flags
            var visible = typeof data.visible !== "undefined" ? data.visible : true;
            imageLayer.setOpacity(visible ? +data.opacity : 0);
            return imageLayer;
        }
        /**
      * read the tileset Data
      * @ignore
      */ function readTileset(data) {
            return new me.TMXTileset(data);
        }
        /**
      * read the object group Data
      * @ignore
      */ function readObjectGroup(map, data, z) {
            return new me.TMXGroup(map, data, z);
        }
        /**
      * a TMX Tile Map Object
      * Tiled QT +0.7.x format
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      * @param {String} levelId name of TMX map
      * @param {Object} data TMX map in JSON format
      * @example
      * // create a new level object based on the TMX JSON object
      * var level = new me.TMXTileMap(levelId, me.loader.getTMX(levelId));
      * // add the level to the game world container
      * level.addTo(me.game.world, true);
      */ me.TMXTileMap = me.Object.extend({
            // constructor
            init: function init(levelId, data) {
                /**
          * the level data (JSON)
          * @ignore
          */ this.data = data;
                /**
          * name of the tilemap
          * @public
          * @type {String}
          * @name me.TMXTileMap#name
          */ this.name = levelId;
                /**
          * width of the tilemap in tiles
          * @public
          * @type {Number}
          * @name me.TMXTileMap#cols
          */ this.cols = +data.width;
                /**
          * height of the tilemap in tiles
          * @public
          * @type {Number}
          * @name me.TMXTileMap#rows
          */ this.rows = +data.height;
                /**
          * Tile width
          * @public
          * @type {Number}
          * @name me.TMXTileMap#tilewidth
          */ this.tilewidth = +data.tilewidth;
                /**
          * Tile height
          * @public
          * @type {Number}
          * @name me.TMXTileMap#tileheight
          */ this.tileheight = +data.tileheight;
                /**
          * is the map an infinite map
          * @public
          * @type {Number}
          * @default 0
          * @name me.TMXTileMap#infinite
          */ this.infinite = +data.infinite;
                /**
          * the map orientation type. melonJS supports “orthogonal”, “isometric”, “staggered” and “hexagonal”.
          * @public
          * @type {String}
          * @default "orthogonal"
          * @name me.TMXTileMap#orientation
          */ this.orientation = data.orientation;
                /**
         * the order in which tiles on orthogonal tile layers are rendered.
         * (valid values are "left-down", "left-up", "right-down", "right-up")
          * @public
          * @type {String}
          * @default "right-down"
          * @name me.TMXTileMap#renderorder
          */ this.renderorder = data.renderorder || "right-down";
                /**
          * the TMX format version
          * @public
          * @type {String}
          * @name me.TMXTileMap#version
          */ this.version = data.version;
                /**
          * The Tiled version used to save the file (since Tiled 1.0.1).
          * @public
          * @type {String}
          * @name me.TMXTileMap#tiledversion
          */ this.tiledversion = data.tiledversion; // tilesets for this map
                this.tilesets = null; // layers
                if (typeof this.layers === "undefined") this.layers = [];
                 // group objects
                if (typeof this.objectGroups === "undefined") this.objectGroups = [];
                 // Check if map is from melon editor
                this.isEditor = data.editor === "melon-editor"; // object id
                this.nextobjectid = +data.nextobjectid || undefined; // hex/iso properties
                this.hexsidelength = +data.hexsidelength;
                this.staggeraxis = data.staggeraxis;
                this.staggerindex = data.staggerindex; // calculate the map bounding rect
                this.bounds = this.getRenderer().getBounds(); // map "real" size
                this.width = this.bounds.width;
                this.height = this.bounds.height; // background color
                this.backgroundcolor = data.backgroundcolor; // set additional map properties (if any)
                me.TMXUtils.applyTMXProperties(this, data); // internal flag
                this.initialized = false;
                if (this.infinite === 1) // #956 Support for Infinite map
                // see as well in me.TMXUtils
                throw new Error("Tiled Infinite Map not supported!");
            },
            /**
        * Return the map default renderer
        * @name getRenderer
        * @memberOf me.TMXTileMap
        * @public
        * @function
        * @return {me.TMXRenderer} a TMX renderer
        */ getRenderer: function getRenderer() {
                if (typeof this.renderer === "undefined" || !this.renderer.canRender(this)) this.renderer = getNewDefaultRenderer(this);
                return this.renderer;
            },
            /**
        * return the map bounding rect
        * @name me.TMXRenderer#getBounds
        * @public
        * @function
        * @return {me.Rect}
        */ getBounds: function getBounds() {
                // calculated in the constructor
                return this.bounds;
            },
            /**
        * parse the map
        * @ignore
        */ readMapObjects: function readMapObjects(data) {
                if (this.initialized === true) return;
                 // to automatically increment z index
                var zOrder1 = 0;
                var self = this; // Tileset information
                if (!this.tilesets) // make sure we have a TilesetGroup Object
                this.tilesets = new me.TMXTilesetGroup();
                 // parse all tileset objects
                if (typeof data.tilesets !== "undefined") {
                    var tilesets = data.tilesets;
                    tilesets.forEach(function(tileset) {
                        // add the new tileset
                        self.tilesets.add(readTileset(tileset));
                    });
                } // check if a user-defined background color is defined
                if (this.backgroundcolor) this.layers.push(me.pool.pull("me.ColorLayer", "background_color", this.backgroundcolor, zOrder1++));
                 // check if a background image is defined
                if (this.background_image) // add a new image layer
                this.layers.push(me.pool.pull("me.ImageLayer", 0, 0, {
                    name: "background_image",
                    image: this.background_image,
                    z: zOrder1++
                }));
                data.layers.forEach(function(layer) {
                    switch(layer.type){
                        case "imagelayer":
                            self.layers.push(readImageLayer(self, layer, zOrder1++));
                            break;
                        case "tilelayer":
                            self.layers.push(readLayer(self, layer, zOrder1++));
                            break;
                        // get the object groups information
                        case "objectgroup":
                            self.objectGroups.push(readObjectGroup(self, layer, zOrder1++));
                            break;
                        // get the object groups information
                        case "group":
                            self.objectGroups.push(readObjectGroup(self, layer, zOrder1++));
                            break;
                    }
                });
                this.initialized = true;
            },
            /**
        * add all the map layers and objects to the given container.
        * note : this will not automatically update the camera viewport
        * @name me.TMXTileMap#addTo
        * @public
        * @function
        * @param {me.Container} target container
        * @param {boolean} [flatten=true] if true, flatten all objects into the given container, else a `me.Container` object will be created for each corresponding groups
        * @param {boolean} [setViewportBounds=false] if true, set the viewport bounds to the map size, this should be set to true especially if adding a level to the game world container.
        * @example
        * // create a new level object based on the TMX JSON object
        * var level = new me.TMXTileMap(levelId, me.loader.getTMX(levelId));
        * // add the level to the game world container
        * level.addTo(me.game.world, true, true);
        */ addTo: function addTo(container, flatten, setViewportBounds) {
                var _sort = container.autoSort;
                var _depth = container.autoDepth;
                var levelBounds = this.getBounds(); // disable auto-sort and auto-depth
                container.autoSort = false;
                container.autoDepth = false; // add all layers instances
                this.getLayers().forEach(function(layer) {
                    container.addChild(layer);
                }); // add all Object instances
                this.getObjects(flatten).forEach(function(object) {
                    container.addChild(object);
                }); // resize the container accordingly
                container.resize(this.bounds.width, this.bounds.height); // sort everything (recursively)
                container.sort(true); // callback funtion for the viewport resize event
                function _setBounds(width, height) {
                    // adjust the viewport bounds if level is smaller
                    me.game.viewport.setBounds(0, 0, Math.max(levelBounds.width, width), Math.max(levelBounds.height, height)); // center the map if smaller than the current viewport
                    container.pos.set(Math.max(0, ~~((width - levelBounds.width) / 2)), Math.max(0, ~~((height - levelBounds.height) / 2)), container.pos.z);
                }
                if (setViewportBounds === true) {
                    // force viewport bounds update
                    _setBounds(me.game.viewport.width, me.game.viewport.height); // Replace the resize handler
                    if (onresize_handler) me.event.unsubscribe(onresize_handler);
                    onresize_handler = me.event.subscribe(me.event.VIEWPORT_ONRESIZE, _setBounds);
                } //  set back auto-sort and auto-depth
                container.autoSort = _sort;
                container.autoDepth = _depth;
            },
            /**
        * return an Array of instantiated objects, based on the map object definition
        * @name me.TMXTileMap#getObjects
        * @public
        * @function
        * @param {boolean} [flatten=true] if true, flatten all objects into the returned array.
        * when false, a `me.Container` object will be created for each corresponding groups
        * @return {me.Renderable[]} Array of Objects
        */ getObjects: function getObjects(flatten) {
                var objects = [];
                var isCollisionGroup = false;
                var targetContainer; // parse the map for objects
                this.readMapObjects(this.data);
                for(var g = 0; g < this.objectGroups.length; g++){
                    var group = this.objectGroups[g]; // check if this is the collision shape group
                    isCollisionGroup = group.name.toLowerCase().includes(COLLISION_GROUP);
                    if (flatten === false) {
                        // create a new container
                        targetContainer = new me.Container(0, 0, this.width, this.height); // tiled uses 0,0 by default
                        targetContainer.anchorPoint.set(0, 0); // set additional properties
                        targetContainer.name = group.name;
                        targetContainer.pos.z = group.z;
                        targetContainer.setOpacity(group.opacity); // disable auto-sort and auto-depth
                        targetContainer.autoSort = false;
                        targetContainer.autoDepth = false;
                    } // iterate through the group and add all object into their
                    // corresponding target Container
                    for(var o = 0; o < group.objects.length; o++){
                        // TMX object settings
                        var settings = group.objects[o]; // reference to the instantiated object
                        var obj; // Tiled uses 0,0 by default
                        if (typeof settings.anchorPoint === "undefined") settings.anchorPoint = {
                            x: 0,
                            y: 0
                        };
                         // groups can contains either text, objects or layers
                        if (settings instanceof me.TMXLayer) // layers are already instantiated & initialized
                        obj = settings; // z value set already
                        else if (_typeof(settings.text) === "object") {
                            // Tiled uses 0,0 by default
                            if (typeof settings.text.anchorPoint === "undefined") settings.text.anchorPoint = settings.anchorPoint;
                            if (settings.text.bitmap === true) obj = me.pool.pull("me.BitmapText", settings.x, settings.y, settings.text);
                            else obj = me.pool.pull("me.Text", settings.x, settings.y, settings.text);
                             // set the obj z order
                            obj.pos.z = settings.z;
                        } else {
                            // pull the corresponding entity from the object pool
                            obj = me.pool.pull(settings.name || "me.Entity", settings.x, settings.y, settings); // set the obj z order
                            obj.pos.z = settings.z;
                        } // check if a me.Tile object is embedded
                        if (_typeof(settings.tile) === "object" && !obj.renderable) {
                            obj.renderable = settings.tile.getRenderable(settings); // adjust position if necessary
                            switch(settings.rotation){
                                case Math.PI:
                                    obj.translate(-obj.renderable.width, obj.renderable.height);
                                    break;
                                case Math.PI / 2:
                                    obj.translate(0, obj.renderable.height);
                                    break;
                                case -(Math.PI / 2):
                                    obj.translate(-obj.renderable.width, 0);
                                    break;
                            } // tile object use use left-bottom coordinates
                        //obj.anchorPoint.set(0, 1);
                        }
                        if (isCollisionGroup && !settings.name) // configure the body accordingly
                        obj.body.collisionType = me.collision.types.WORLD_SHAPE;
                         //apply group opacity value to the child objects if group are merged
                        if (flatten !== false) {
                            if (obj.isRenderable === true) {
                                obj.setOpacity(obj.getOpacity() * group.opacity); // and to child renderables if any
                                if (obj.renderable instanceof me.Renderable) obj.renderable.setOpacity(obj.renderable.getOpacity() * group.opacity);
                            } // directly add the obj into the objects array
                            objects.push(obj);
                        } else // add it to the new container
                        targetContainer.addChild(obj);
                    } // if we created a new container
                    if (flatten === false && targetContainer.children.length > 0) {
                        // re-enable auto-sort and auto-depth
                        targetContainer.autoSort = true;
                        targetContainer.autoDepth = true; // add our container to the world
                        objects.push(targetContainer);
                    }
                }
                return objects;
            },
            /**
        * return all the existing layers
        * @name me.TMXTileMap#getLayers
        * @public
        * @function
        * @return {me.TMXLayer[]} Array of Layers
        */ getLayers: function getLayers() {
                // parse the map for objects
                this.readMapObjects(this.data);
                return this.layers;
            },
            /**
        * destroy function, clean all allocated objects
        * @name me.TMXTileMap#destroy
        * @public
        * @function
        */ destroy: function destroy() {
                this.tilesets = undefined;
                this.layers.length = 0;
                this.objectGroups.length = 0;
                this.initialized = false;
            }
        });
    })();
    (function() {
        /**
      * The map renderer base class
      * @class
      * @extends me.Object
      * @memberOf me
      * @constructor
      * @param {Number} cols width of the tilemap in tiles
      * @param {Number} rows height of the tilemap in tiles
      * @param {Number} tilewidth width of each tile in pixels
      * @param {Number} tileheight height of each tile in pixels
      */ me.TMXRenderer = me.Object.extend({
            // constructor
            init: function init(cols, rows, tilewidth, tileheight) {
                this.cols = cols;
                this.rows = rows;
                this.tilewidth = tilewidth;
                this.tileheight = tileheight;
                this.bounds = new me.Rect(0, 0, 0, 0);
            },
            /**
        * return true if the renderer can render the specified map or layer
        * @name me.TMXRenderer#canRender
        * @public
        * @function
        * @param {me.TMXTileMap|me.TMXLayer} component TMX Map or Layer
        * @return {boolean}
        */ canRender: function canRender(component) {
                return(/*
           // layers can have different size within
           // the same maps, so commenting these two lines
           (this.cols === component.cols) &&
           (this.rows === component.rows) &&
           */ this.tilewidth === component.tilewidth && this.tileheight === component.tileheight);
            },
            /**
        * return the bounding rect for this map renderer
        * @name me.TMXRenderer#getBounds
        * @public
        * @function
        * @param {me.TMXLayer} [layer] calculate the bounding rect for a specific layer (will return a new bounds object)
        * @return {me.Rect}
        */ getBounds: function getBounds(layer) {
                var bounds = layer instanceof me.TMXLayer ? me.pool.pull("me.Rect", 0, 0, 0, 0) : this.bounds;
                bounds.setShape(0, 0, this.cols * this.tilewidth, this.rows * this.tileheight);
                return bounds;
            },
            /**
        * return the tile position corresponding to the specified pixel
        * @name me.TMXRenderer#pixelToTileCoords
        * @public
        * @function
        * @param {Number} x X coordinate
        * @param {Number} y Y coordinate
        * @param {me.Vector2d} [vector] an optional vector object where to put the return values
        * @return {me.Vector2d}
        */ pixelToTileCoords: function pixelToTileCoords(x, y, v) {
                return v;
            },
            /**
        * return the pixel position corresponding of the specified tile
        * @name me.TMXRenderer#tileToPixelCoords
        * @public
        * @function
        * @param {Number} col tile horizontal position
        * @param {Number} row tile vertical position
        * @param {me.Vector2d} [vector] an optional vector object where to put the return values
        * @return {me.Vector2d}
        */ tileToPixelCoords: function tileToPixelCoords(x, y, v) {
                return v;
            },
            /**
        * draw the given tile at the specified layer
        * @name me.TMXRenderer#drawTile
        * @public
        * @function
        * @param {me.CanvasRenderer|me.WebGLRenderer} renderer a renderer object
        * @param {Number} x X coordinate where to draw the tile
        * @param {Number} y Y coordinate where to draw the tile
        * @param {me.Tile} tile the tile object to draw
        */ drawTile: function drawTile(renderer, x, y, tile) {
            },
            /**
        * draw the given TMX Layer for the given area
        * @name me.TMXRenderer#drawTileLayer
        * @public
        * @function
        * @param {me.CanvasRenderer|me.WebGLRenderer} renderer a renderer object
        * @param {me.TMXLayer} layer a TMX Layer object
        * @param {me.Rect} rect the area of the layer to draw
        */ drawTileLayer: function drawTileLayer(renderer, layer, rect) {
            }
        });
    })();
    (function() {
        /**
      * an Orthogonal Map Renderder
      * @memberOf me
      * @extends me.TMXRenderer
      * @memberOf me
      * @constructor
      * @param {me.TMXTileMap} map the TMX map
      */ me.TMXOrthogonalRenderer = me.TMXRenderer.extend({
            // constructor
            init: function init(map) {
                this._super(me.TMXRenderer, "init", [
                    map.cols,
                    map.rows,
                    map.tilewidth,
                    map.tileheight
                ]);
            },
            /**
        * return true if the renderer can render the specified layer
        * @ignore
        */ canRender: function canRender(layer) {
                return layer.orientation === "orthogonal" && this._super(me.TMXRenderer, "canRender", [
                    layer
                ]);
            },
            /**
        * return the tile position corresponding to the specified pixel
        * @ignore
        */ pixelToTileCoords: function pixelToTileCoords(x, y, v) {
                var ret = v || new me.Vector2d();
                return ret.set(x / this.tilewidth, y / this.tileheight);
            },
            /**
        * return the pixel position corresponding of the specified tile
        * @ignore
        */ tileToPixelCoords: function tileToPixelCoords(x, y, v) {
                var ret = v || new me.Vector2d();
                return ret.set(x * this.tilewidth, y * this.tileheight);
            },
            /**
        * fix the position of Objects to match
        * the way Tiled places them
        * @ignore
        */ adjustPosition: function adjustPosition(obj) {
                // only adjust position if obj.gid is defined
                if (typeof obj.gid === "number") // Tiled objects origin point is "bottom-left" in Tiled,
                // "top-left" in melonJS)
                obj.y -= obj.height;
            },
            /**
        * draw the tile map
        * @ignore
        */ drawTile: function drawTile(renderer, x, y, tmxTile) {
                var tileset = tmxTile.tileset; // draw the tile
                tileset.drawTile(renderer, tileset.tileoffset.x + x * this.tilewidth, tileset.tileoffset.y + (y + 1) * this.tileheight - tileset.tileheight, tmxTile);
            },
            /**
        * draw the tile map
        * @ignore
        */ drawTileLayer: function drawTileLayer(renderer, layer, rect) {
                var incX = 1, incY = 1; // get top-left and bottom-right tile position
                var start = this.pixelToTileCoords(Math.max(rect.pos.x - (layer.maxTileSize.width - layer.tilewidth), 0), Math.max(rect.pos.y - (layer.maxTileSize.height - layer.tileheight), 0), me.pool.pull("me.Vector2d")).floorSelf();
                var end = this.pixelToTileCoords(rect.pos.x + rect.width + this.tilewidth, rect.pos.y + rect.height + this.tileheight, me.pool.pull("me.Vector2d")).ceilSelf(); //ensure we are in the valid tile range
                end.x = end.x > this.cols ? this.cols : end.x;
                end.y = end.y > this.rows ? this.rows : end.y;
                switch(layer.renderorder){
                    case "right-up":
                        // swapping start.y and end.y
                        end.y = start.y + (start.y = end.y) - end.y;
                        incY = -1;
                        break;
                    case "left-down":
                        // swapping start.x and end.x
                        end.x = start.x + (start.x = end.x) - end.x;
                        incX = -1;
                        break;
                    case "left-up":
                        // swapping start.x and end.x
                        end.x = start.x + (start.x = end.x) - end.x; // swapping start.y and end.y
                        end.y = start.y + (start.y = end.y) - end.y;
                        incX = -1;
                        incY = -1;
                        break;
                } // main drawing loop
                for(var y = start.y; y !== end.y; y += incY)for(var x = start.x; x !== end.x; x += incX){
                    var tmxTile = layer.cellAt(x, y, false);
                    if (tmxTile) this.drawTile(renderer, x, y, tmxTile);
                }
                me.pool.push(start);
                me.pool.push(end);
            }
        });
    })();
    (function() {
        /**
      * an Isometric Map Renderder
      * @memberOf me
      * @extends me.TMXRenderer
      * @memberOf me
      * @constructor
      * @param {me.TMXTileMap} map the TMX map
      */ me.TMXIsometricRenderer = me.TMXRenderer.extend({
            // constructor
            init: function init(map) {
                this._super(me.TMXRenderer, "init", [
                    map.cols,
                    map.rows,
                    map.tilewidth,
                    map.tileheight
                ]);
                this.hTilewidth = this.tilewidth / 2;
                this.hTileheight = this.tileheight / 2;
                this.originX = this.rows * this.hTilewidth;
            },
            /**
        * return true if the renderer can render the specified layer
        * @ignore
        */ canRender: function canRender(layer) {
                return layer.orientation === "isometric" && this._super(me.TMXRenderer, "canRender", [
                    layer
                ]);
            },
            /**
        * return the bounding rect for this map renderer
        * @name me.TMXIsometricRenderer#getBounds
        * @public
        * @function
        * @param {me.TMXLayer} [layer] calculate the bounding rect for a specific layer (will return a new bounds object)
        * @return {me.Rect}
        */ getBounds: function getBounds(layer) {
                var bounds = layer instanceof me.TMXLayer ? me.pool.pull("me.Rect", 0, 0, 0, 0) : this.bounds;
                bounds.setShape(0, 0, (this.cols + this.rows) * (this.tilewidth / 2), (this.cols + this.rows) * (this.tileheight / 2));
                return bounds;
            },
            /**
        * return the tile position corresponding to the specified pixel
        * @ignore
        */ pixelToTileCoords: function pixelToTileCoords(x, y, v) {
                var ret = v || new me.Vector2d();
                return ret.set(y / this.tileheight + (x - this.originX) / this.tilewidth, y / this.tileheight - (x - this.originX) / this.tilewidth);
            },
            /**
        * return the pixel position corresponding of the specified tile
        * @ignore
        */ tileToPixelCoords: function tileToPixelCoords(x, y, v) {
                var ret = v || new me.Vector2d();
                return ret.set((x - y) * this.hTilewidth + this.originX, (x + y) * this.hTileheight);
            },
            /**
        * fix the position of Objects to match
        * the way Tiled places them
        * @ignore
        */ adjustPosition: function adjustPosition(obj) {
                var tileX = obj.x / this.hTilewidth;
                var tileY = obj.y / this.tileheight;
                var isoPos = me.pool.pull("me.Vector2d");
                this.tileToPixelCoords(tileX, tileY, isoPos);
                obj.x = isoPos.x;
                obj.y = isoPos.y;
                me.pool.push(isoPos);
            },
            /**
        * draw the tile map
        * @ignore
        */ drawTile: function drawTile(renderer, x, y, tmxTile) {
                var tileset = tmxTile.tileset; // draw the tile
                tileset.drawTile(renderer, (this.cols - 1) * tileset.tilewidth + (x - y) * tileset.tilewidth >> 1, -tileset.tilewidth + (x + y) * tileset.tileheight >> 2, tmxTile);
            },
            /**
        * draw the tile map
        * @ignore
        */ drawTileLayer: function drawTileLayer(renderer, layer, rect) {
                // cache a couple of useful references
                var tileset = layer.tileset; // get top-left and bottom-right tile position
                var rowItr = this.pixelToTileCoords(rect.pos.x - tileset.tilewidth, rect.pos.y - tileset.tileheight, me.pool.pull("me.Vector2d")).floorSelf();
                var tileEnd = this.pixelToTileCoords(rect.pos.x + rect.width + tileset.tilewidth, rect.pos.y + rect.height + tileset.tileheight, me.pool.pull("me.Vector2d")).ceilSelf();
                var rectEnd = this.tileToPixelCoords(tileEnd.x, tileEnd.y, me.pool.pull("me.Vector2d")); // Determine the tile and pixel coordinates to start at
                var startPos = this.tileToPixelCoords(rowItr.x, rowItr.y, me.pool.pull("me.Vector2d"));
                startPos.x -= this.hTilewidth;
                startPos.y += this.tileheight;
                /* Determine in which half of the tile the top-left corner of the area we
          * need to draw is. If we're in the upper half, we need to start one row
          * up due to those tiles being visible as well. How we go up one row
          * depends on whether we're in the left or right half of the tile.
          */ var inUpperHalf = startPos.y - rect.pos.y > this.hTileheight;
                var inLeftHalf = rect.pos.x - startPos.x < this.hTilewidth;
                if (inUpperHalf) {
                    if (inLeftHalf) {
                        rowItr.x--;
                        startPos.x -= this.hTilewidth;
                    } else {
                        rowItr.y--;
                        startPos.x += this.hTilewidth;
                    }
                    startPos.y -= this.hTileheight;
                } // Determine whether the current row is shifted half a tile to the right
                var shifted = inUpperHalf ^ inLeftHalf; // initialize the columItr vector
                var columnItr = rowItr.clone(); // main drawing loop
                for(var y = startPos.y * 2; y - this.tileheight * 2 < rectEnd.y * 2; y += this.tileheight){
                    columnItr.setV(rowItr);
                    for(var x = startPos.x; x < rectEnd.x; x += this.tilewidth){
                        var tmxTile = layer.cellAt(columnItr.x, columnItr.y); // render if a valid tile position
                        if (tmxTile) {
                            tileset = tmxTile.tileset; // offset could be different per tileset
                            var offset = tileset.tileoffset; // draw our tile
                            tileset.drawTile(renderer, offset.x + x, offset.y + y / 2 - tileset.tileheight, tmxTile);
                        } // Advance to the next column
                        columnItr.x++;
                        columnItr.y--;
                    } // Advance to the next row
                    if (!shifted) {
                        rowItr.x++;
                        startPos.x += this.hTilewidth;
                        shifted = true;
                    } else {
                        rowItr.y++;
                        startPos.x -= this.hTilewidth;
                        shifted = false;
                    }
                }
                me.pool.push(columnItr);
                me.pool.push(rowItr);
                me.pool.push(tileEnd);
                me.pool.push(rectEnd);
                me.pool.push(startPos);
            }
        });
    })();
    (function() {
        // scope global var & constants
        var offsetsStaggerX = [
            {
                x: 0,
                y: 0
            },
            {
                x: 1,
                y: -1
            },
            {
                x: 1,
                y: 0
            },
            {
                x: 2,
                y: 0
            }
        ];
        var offsetsStaggerY = [
            {
                x: 0,
                y: 0
            },
            {
                x: -1,
                y: 1
            },
            {
                x: 0,
                y: 1
            },
            {
                x: 0,
                y: 2
            }
        ];
        /**
      * an Hexagonal Map Renderder
      * @memberOf me
      * @extends me.TMXRenderer
      * @memberOf me
      * @constructor
      * @param {me.TMXTileMap} map the TMX map
      */ me.TMXHexagonalRenderer = me.TMXRenderer.extend({
            // constructor
            init: function init(map) {
                this._super(me.TMXRenderer, "init", [
                    map.cols,
                    map.rows,
                    map.tilewidth & -2,
                    map.tileheight & -2
                ]);
                this.hexsidelength = map.hexsidelength || 0;
                this.staggerX = map.staggeraxis === "x";
                this.staggerEven = map.staggerindex === "even";
                this.sidelengthx = 0;
                this.sidelengthy = 0;
                if (map.orientation === "hexagonal") {
                    if (this.staggerX) this.sidelengthx = this.hexsidelength;
                    else this.sidelengthy = this.hexsidelength;
                }
                this.sideoffsetx = (this.tilewidth - this.sidelengthx) / 2;
                this.sideoffsety = (this.tileheight - this.sidelengthy) / 2;
                this.columnwidth = this.sideoffsetx + this.sidelengthx;
                this.rowheight = this.sideoffsety + this.sidelengthy;
                this.centers = [
                    new me.Vector2d(),
                    new me.Vector2d(),
                    new me.Vector2d(),
                    new me.Vector2d()
                ];
            },
            /**
        * return true if the renderer can render the specified layer
        * @ignore
        */ canRender: function canRender(layer) {
                return layer.orientation === "hexagonal" && this._super(me.TMXRenderer, "canRender", [
                    layer
                ]);
            },
            /**
        * return the bounding rect for this map renderer
        * @name me.TMXHexagonalRenderer#getBounds
        * @public
        * @function
        * @param {me.TMXLayer} [layer] calculate the bounding rect for a specific layer (will return a new bounds object)
        * @return {me.Rect}
        */ getBounds: function getBounds(layer) {
                var bounds = layer instanceof me.TMXLayer ? me.pool.pull("me.Rect", 0, 0, 0, 0) : this.bounds; // origin is always 0 for finite maps
                bounds.pos.set(0, 0); // The map size is the same regardless of which indexes are shifted.
                if (this.staggerX) {
                    bounds.resize(this.cols * this.columnwidth + this.sideoffsetx, this.rows * (this.tileheight + this.sidelengthy));
                    if (bounds.width > 1) bounds.height += this.rowheight;
                } else {
                    bounds.resize(this.cols * (this.tilewidth + this.sidelengthx), this.rows * this.rowheight + this.sideoffsety);
                    if (bounds.height > 1) bounds.width += this.columnwidth;
                }
                return bounds;
            },
            /**
        * @ignore
        */ doStaggerX: function doStaggerX(x) {
                return this.staggerX && x & 1 ^ this.staggerEven;
            },
            /**
        * @ignore
        */ doStaggerY: function doStaggerY(y) {
                return !this.staggerX && y & 1 ^ this.staggerEven;
            },
            /**
        * @ignore
        */ topLeft: function topLeft(x, y, v) {
                var ret = v || new me.Vector2d();
                if (!this.staggerX) {
                    if (y & 1 ^ this.staggerEven) ret.set(x, y - 1);
                    else ret.set(x - 1, y - 1);
                } else if (x & 1 ^ this.staggerEven) ret.set(x - 1, y);
                else ret.set(x - 1, y - 1);
                return ret;
            },
            /**
        * @ignore
        */ topRight: function topRight(x, y, v) {
                var ret = v || new me.Vector2d();
                if (!this.staggerX) {
                    if (y & 1 ^ this.staggerEven) ret.set(x + 1, y - 1);
                    else ret.set(x, y - 1);
                } else if (x & 1 ^ this.staggerEven) ret.set(x + 1, y);
                else ret.set(x + 1, y - 1);
                return ret;
            },
            /**
        * @ignore
        */ bottomLeft: function bottomLeft(x, y, v) {
                var ret = v || new me.Vector2d();
                if (!this.staggerX) {
                    if (y & 1 ^ this.staggerEven) ret.set(x, y + 1);
                    else ret.set(x - 1, y + 1);
                } else if (x & 1 ^ this.staggerEven) ret.set(x - 1, y + 1);
                else ret.set(x - 1, y);
                return ret;
            },
            /**
        * @ignore
        */ bottomRight: function bottomRight(x, y, v) {
                var ret = v || new me.Vector2d();
                if (!this.staggerX) {
                    if (y & 1 ^ this.staggerEven) ret.set(x + 1, y + 1);
                    else ret.set(x, y + 1);
                } else if (x & 1 ^ this.staggerEven) ret.set(x + 1, y + 1);
                else ret.set(x + 1, y);
                return ret;
            },
            /**
        * return the tile position corresponding to the specified pixel
        * @ignore
        */ pixelToTileCoords: function pixelToTileCoords(x, y, v) {
                var ret = v || new me.Vector2d();
                if (this.staggerX) //flat top
                x -= this.staggerEven ? this.tilewidth : this.sideoffsetx;
                else //pointy top
                y -= this.staggerEven ? this.tileheight : this.sideoffsety;
                 // Start with the coordinates of a grid-aligned tile
                var referencePoint = me.pool.pull("me.Vector2d", Math.floor(x / (this.columnwidth * 2)), Math.floor(y / (this.rowheight * 2))); // Relative x and y position on the base square of the grid-aligned tile
                var rel = me.pool.pull("me.Vector2d", x - referencePoint.x * (this.columnwidth * 2), y - referencePoint.y * (this.rowheight * 2)); // Adjust the reference point to the correct tile coordinates
                if (this.staggerX) {
                    referencePoint.x = referencePoint.x * 2;
                    if (this.staggerEven) ++referencePoint.x;
                } else {
                    referencePoint.y = referencePoint.y * 2;
                    if (this.staggerEven) ++referencePoint.y;
                } // Determine the nearest hexagon tile by the distance to the center
                var left, top, centerX, centerY;
                if (this.staggerX) {
                    left = this.sidelengthx / 2;
                    centerX = left + this.columnwidth;
                    centerY = this.tileheight / 2;
                    this.centers[0].set(left, centerY);
                    this.centers[1].set(centerX, centerY - this.rowheight);
                    this.centers[2].set(centerX, centerY + this.rowheight);
                    this.centers[3].set(centerX + this.columnwidth, centerY);
                } else {
                    top = this.sidelengthy / 2;
                    centerX = this.tilewidth / 2;
                    centerY = top + this.rowheight;
                    this.centers[0].set(centerX, top);
                    this.centers[1].set(centerX - this.columnwidth, centerY);
                    this.centers[2].set(centerX + this.columnwidth, centerY);
                    this.centers[3].set(centerX, centerY + this.rowheight);
                }
                var nearest = 0;
                var minDist = Number.MAX_VALUE;
                for(var i = 0; i < 4; ++i){
                    var dc = this.centers[i].sub(rel).length2();
                    if (dc < minDist) {
                        minDist = dc;
                        nearest = i;
                    }
                }
                var offsets = this.staggerX ? offsetsStaggerX : offsetsStaggerY;
                ret.set(referencePoint.x + offsets[nearest].x, referencePoint.y + offsets[nearest].y);
                me.pool.push(referencePoint);
                me.pool.push(rel);
                return ret;
            },
            /**
        * return the pixel position corresponding of the specified tile
        * @ignore
        */ tileToPixelCoords: function tileToPixelCoords(x, y, v) {
                var tileX = Math.floor(x), tileY = Math.floor(y);
                var ret = v || new me.Vector2d();
                if (this.staggerX) {
                    ret.y = tileY * (this.tileheight + this.sidelengthy);
                    if (this.doStaggerX(tileX)) ret.y += this.rowheight;
                    ret.x = tileX * this.columnwidth;
                } else {
                    ret.x = tileX * (this.tilewidth + this.sidelengthx);
                    if (this.doStaggerY(tileY)) ret.x += this.columnwidth;
                    ret.y = tileY * this.rowheight;
                }
                return ret;
            },
            /**
        * fix the position of Objects to match
        * the way Tiled places them
        * @ignore
        */ adjustPosition: function adjustPosition(obj) {
                // only adjust position if obj.gid is defined
                if (typeof obj.gid === "number") // Tiled objects origin point is "bottom-left" in Tiled,
                // "top-left" in melonJS)
                obj.y -= obj.height;
            },
            /**
        * draw the tile map
        * @ignore
        */ drawTile: function drawTile(renderer, x, y, tmxTile) {
                var tileset = tmxTile.tileset;
                var point = this.tileToPixelCoords(x, y, me.pool.pull("me.Vector2d")); // draw the tile
                tileset.drawTile(renderer, tileset.tileoffset.x + point.x, tileset.tileoffset.y + point.y + (this.tileheight - tileset.tileheight), tmxTile);
                me.pool.push(point);
            },
            /**
        * draw the tile map
        * @ignore
        */ drawTileLayer: function drawTileLayer(renderer, layer, rect) {
                var tile; // get top-left and bottom-right tile position
                var startTile = this.pixelToTileCoords(rect.pos.x, rect.pos.y, me.pool.pull("me.Vector2d")); // Compensate for the layer position
                startTile.sub(layer.pos); // get top-left and bottom-right tile position
                var startPos = this.tileToPixelCoords(startTile.x + layer.pos.x, startTile.y + layer.pos.y, me.pool.pull("me.Vector2d"));
                var rowTile = startTile.clone();
                var rowPos = startPos.clone();
                /* Determine in which half of the tile the top-left corner of the area we
          * need to draw is. If we're in the upper half, we need to start one row
          * up due to those tiles being visible as well. How we go up one row
          * depends on whether we're in the left or right half of the tile.
          */ var inUpperHalf = rect.pos.y - startPos.y < this.sideoffsety;
                var inLeftHalf = rect.pos.x - startPos.x < this.sideoffsetx;
                if (inUpperHalf) startTile.y--;
                if (inLeftHalf) startTile.x--;
                var endX = layer.cols;
                var endY = layer.rows;
                if (this.staggerX) {
                    //ensure we are in the valid tile range
                    startTile.x = Math.max(0, startTile.x);
                    startTile.y = Math.max(0, startTile.y);
                    startPos = this.tileToPixelCoords(startTile.x + layer.pos.x, startTile.y + layer.pos.y);
                    var staggeredRow = this.doStaggerX(startTile.x + layer.pos.x); // main drawing loop
                    for(; startPos.y < rect.bottom && startTile.y < endY;){
                        rowTile.setV(startTile);
                        rowPos.setV(startPos);
                        for(; rowPos.x < rect.right && rowTile.x < endX; rowTile.x += 2){
                            tile = layer.cellAt(rowTile.x, rowTile.y, false);
                            if (tile) // draw the tile
                            tile.tileset.drawTile(renderer, rowPos.x, rowPos.y, tile);
                            rowPos.x += this.tilewidth + this.sidelengthx;
                        }
                        if (staggeredRow) {
                            startTile.x -= 1;
                            startTile.y += 1;
                            startPos.x -= this.columnwidth;
                            staggeredRow = false;
                        } else {
                            startTile.x += 1;
                            startPos.x += this.columnwidth;
                            staggeredRow = true;
                        }
                        startPos.y += this.rowheight;
                    }
                    me.pool.push(rowTile);
                    me.pool.push(rowPos);
                } else {
                    //ensure we are in the valid tile range
                    startTile.x = Math.max(0, startTile.x);
                    startTile.y = Math.max(0, startTile.y);
                    startPos = this.tileToPixelCoords(startTile.x + layer.pos.x, startTile.y + layer.pos.y); // Odd row shifting is applied in the rendering loop, so un-apply it here
                    if (this.doStaggerY(startTile.y)) startPos.x -= this.columnwidth;
                     // main drawing loop
                    for(; startPos.y < rect.bottom && startTile.y < endY; startTile.y++){
                        rowTile.setV(startTile);
                        rowPos.setV(startPos);
                        if (this.doStaggerY(startTile.y)) rowPos.x += this.columnwidth;
                        for(; rowPos.x < rect.right && rowTile.x < endX; rowTile.x++){
                            tile = layer.cellAt(rowTile.x, rowTile.y, false);
                            if (tile) // draw the tile
                            tile.tileset.drawTile(renderer, rowPos.x, rowPos.y, tile);
                            rowPos.x += this.tilewidth + this.sidelengthx;
                        }
                        startPos.y += this.rowheight;
                    }
                    me.pool.push(rowTile);
                    me.pool.push(rowPos);
                }
                me.pool.push(startTile);
                me.pool.push(startPos);
            }
        });
    })();
    (function() {
        /**
      * a Staggered Map Renderder
      * @memberOf me
      * @extends me.TMXRenderer
      * @memberOf me
      * @constructor
      * @param {me.TMXTileMap} map the TMX map
      */ me.TMXStaggeredRenderer = me.TMXHexagonalRenderer.extend({
            /**
        * return true if the renderer can render the specified layer
        * @ignore
        */ canRender: function canRender(layer) {
                return layer.orientation === "staggered" && this._super(me.TMXRenderer, "canRender", [
                    layer
                ]);
            },
            /**
        * return the tile position corresponding to the specified pixel
        * @ignore
        */ pixelToTileCoords: function pixelToTileCoords(x, y, v) {
                var ret = v || new me.Vector2d();
                var alignedX = x, alignedY = y;
                if (this.staggerX) alignedX -= this.staggerEven ? this.sideoffsetx : 0;
                else alignedY -= this.staggerEven ? this.sideoffsety : 0;
                 // Start with the coordinates of a grid-aligned tile
                var referencePoint = me.pool.pull("me.Vector2d", Math.floor(alignedX / this.tilewidth), Math.floor(alignedY / this.tileheight)); // Adjust the reference point to the correct tile coordinates
                if (this.staggerX) {
                    referencePoint.x = referencePoint.x * 2;
                    if (this.staggerEven) ++referencePoint.x;
                } else {
                    referencePoint.y = referencePoint.y * 2;
                    if (this.staggerEven) ++referencePoint.y;
                } // Relative x and y position on the base square of the grid-aligned tile
                var rel = me.pool.pull("me.Vector2d", alignedX - referencePoint.x * this.tilewidth, alignedY - referencePoint.y * this.tileheight); // Check whether the cursor is in any of the corners (neighboring tiles)
                var y_pos = rel.x * (this.tileheight / this.tilewidth);
                if (this.sideoffsety - y_pos > rel.y) referencePoint = this.topLeft(referencePoint.x, referencePoint.y, referencePoint);
                if (-this.sideoffsety + y_pos > rel.y) referencePoint = this.topRight(referencePoint.x, referencePoint.y, referencePoint);
                if (this.sideoffsety + y_pos < rel.y) referencePoint = this.bottomLeft(referencePoint.x, referencePoint.y, referencePoint);
                if (this.sideoffsety * 3 - y_pos < rel.y) referencePoint = this.bottomRight(referencePoint.x, referencePoint.y, referencePoint);
                ret = this.tileToPixelCoords(referencePoint.x, referencePoint.y, ret);
                ret.set(x - ret.x, y - ret.y); // Start with the coordinates of a grid-aligned tile
                ret.set(ret.x - this.tilewidth / 2, ret.y * (this.tilewidth / this.tileheight));
                ret.div(this.tilewidth / Math.sqrt(2)).rotate(me.Math.degToRad(-45)).add(referencePoint);
                me.pool.push(referencePoint);
                me.pool.push(rel);
                return ret;
            }
        });
    })();
    /**
    * Tween.js - Licensed under the MIT license
    * https://github.com/tweenjs/tween.js
    */ /* eslint-disable quotes, keyword-spacing, comma-spacing, no-return-assign */ (function() {
        /**
      * Javascript Tweening Engine<p>
      * Super simple, fast and easy to use tweening engine which incorporates optimised Robert Penner's equation<p>
      * <a href="https://github.com/sole/Tween.js">https://github.com/sole/Tween.js</a><p>
      * author sole / http://soledadpenades.com<br>
      * author mr.doob / http://mrdoob.com<br>
      * author Robert Eisele / http://www.xarg.org<br>
      * author Philippe / http://philippe.elsass.me<br>
      * author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html<br>
      * author Paul Lewis / http://www.aerotwist.com/<br>
      * author lechecacharro<br>
      * author Josh Faul / http://jocafa.com/
      * @class
      * @memberOf me
      * @constructor
      * @param {Object} object object on which to apply the tween
      * @example
      * // add a tween to change the object pos.y variable to 200 in 3 seconds
      * tween = new me.Tween(myObject.pos).to({y: 200}, 3000).onComplete(myFunc);
      * tween.easing(me.Tween.Easing.Bounce.Out);
      * tween.start();
      */ me.Tween = function(object) {
            var _object = null;
            var _valuesStart = null;
            var _valuesEnd = null;
            var _valuesStartRepeat = null;
            var _duration = null;
            var _repeat = null;
            var _yoyo = null;
            var _delayTime = null;
            var _startTime = null;
            var _easingFunction = null;
            var _interpolationFunction = null;
            var _chainedTweens = null;
            var _onStartCallback = null;
            var _onStartCallbackFired = null;
            var _onUpdateCallback = null;
            var _onCompleteCallback = null;
            var _tweenTimeTracker = null; // comply with the container contract
            this.isRenderable = false;
            /**
        * @ignore
        */ this._resumeCallback = function(elapsed) {
                if (_startTime) _startTime += elapsed;
            };
            /**
        * @ignore
        */ this.setProperties = function(object1) {
                _object = object1;
                _valuesStart = {
                };
                _valuesEnd = {
                };
                _valuesStartRepeat = {
                };
                _duration = 1000;
                _repeat = 0;
                _yoyo = false;
                _delayTime = 0;
                _startTime = null;
                _easingFunction = me.Tween.Easing.Linear.None;
                _interpolationFunction = me.Tween.Interpolation.Linear;
                _chainedTweens = [];
                _onStartCallback = null;
                _onStartCallbackFired = false;
                _onUpdateCallback = null;
                _onCompleteCallback = null;
                _tweenTimeTracker = me.timer.lastUpdate; // reset flags to default value
                this.isPersistent = false; // this is not really supported
                this.updateWhenPaused = false; // Set all starting values present on the target object
                for(var field in object1)if (_typeof(object1) !== 'object') _valuesStart[field] = parseFloat(object1[field]);
            };
            this.setProperties(object);
            /**
        * reset the tween object to default value
        * @ignore
        */ this.onResetEvent = function(object1) {
                this.setProperties(object1);
            };
            /**
        * subscribe to the resume event when added
        * @ignore
        */ this.onActivateEvent = function() {
                me.event.subscribe(me.event.STATE_RESUME, this._resumeCallback);
            };
            /**
        * Unsubscribe when tween is removed
        * @ignore
        */ this.onDeactivateEvent = function() {
                me.event.unsubscribe(me.event.STATE_RESUME, this._resumeCallback);
            };
            /**
        * object properties to be updated and duration
        * @name me.Tween#to
        * @public
        * @function
        * @param {Object} properties hash of properties
        * @param {Number} [duration=1000] tween duration
        */ this.to = function(properties, duration) {
                if (duration !== undefined) _duration = duration;
                _valuesEnd = properties;
                return this;
            };
            /**
        * start the tween
        * @name me.Tween#start
        * @public
        * @function
        */ this.start = function(_time) {
                _onStartCallbackFired = false; // add the tween to the object pool on start
                me.game.world.addChild(this);
                _startTime = (typeof _time === 'undefined' ? me.timer.getTime() : _time) + _delayTime;
                for(var property in _valuesEnd){
                    // check if an Array was provided as property value
                    if (_valuesEnd[property] instanceof Array) {
                        if (_valuesEnd[property].length === 0) continue;
                         // create a local copy of the Array with the start value at the front
                        _valuesEnd[property] = [
                            _object[property]
                        ].concat(_valuesEnd[property]);
                    }
                    _valuesStart[property] = _object[property];
                    if (_valuesStart[property] instanceof Array === false) _valuesStart[property] *= 1; // Ensures we're using numbers, not strings
                    _valuesStartRepeat[property] = _valuesStart[property] || 0;
                }
                return this;
            };
            /**
        * stop the tween
        * @name me.Tween#stop
        * @public
        * @function
        */ this.stop = function() {
                // remove the tween from the world container
                me.game.world.removeChildNow(this);
                return this;
            };
            /**
        * delay the tween
        * @name me.Tween#delay
        * @public
        * @function
        * @param {Number} amount delay amount expressed in milliseconds
        */ this.delay = function(amount) {
                _delayTime = amount;
                return this;
            };
            /**
        * Repeat the tween
        * @name me.Tween#repeat
        * @public
        * @function
        * @param {Number} times amount of times the tween should be repeated
        */ this.repeat = function(times) {
                _repeat = times;
                return this;
            };
            /**
        * Allows the tween to bounce back to their original value when finished.
        * To be used together with repeat to create endless loops.
        * @name me.Tween#yoyo
        * @public
        * @function
        * @see me.Tween#repeat
        * @param {Boolean} yoyo
        */ this.yoyo = function(yoyo) {
                _yoyo = yoyo;
                return this;
            };
            /**
        * set the easing function
        * @name me.Tween#easing
        * @public
        * @function
        * @param {me.Tween.Easing} fn easing function
        */ this.easing = function(easing) {
                if (typeof easing !== 'function') throw new Error("invalid easing function for me.Tween.easing()");
                _easingFunction = easing;
                return this;
            };
            /**
        * set the interpolation function
        * @name me.Tween#interpolation
        * @public
        * @function
        * @param {me.Tween.Interpolation} fn interpolation function
        */ this.interpolation = function(interpolation) {
                _interpolationFunction = interpolation;
                return this;
            };
            /**
        * chain the tween
        * @name me.Tween#chain
        * @public
        * @function
        * @param {me.Tween} chainedTween Tween to be chained
        */ this.chain = function() {
                _chainedTweens = arguments;
                return this;
            };
            /**
        * onStart callback
        * @name me.Tween#onStart
        * @public
        * @function
        * @param {Function} onStartCallback callback
        */ this.onStart = function(callback) {
                _onStartCallback = callback;
                return this;
            };
            /**
        * onUpdate callback
        * @name me.Tween#onUpdate
        * @public
        * @function
        * @param {Function} onUpdateCallback callback
        */ this.onUpdate = function(callback) {
                _onUpdateCallback = callback;
                return this;
            };
            /**
        * onComplete callback
        * @name me.Tween#onComplete
        * @public
        * @function
        * @param {Function} onCompleteCallback callback
        */ this.onComplete = function(callback) {
                _onCompleteCallback = callback;
                return this;
            };
            /** @ignore */ this.update = function(dt) {
                // the original Tween implementation expect
                // a timestamp and not a time delta
                _tweenTimeTracker = me.timer.lastUpdate > _tweenTimeTracker ? me.timer.lastUpdate : _tweenTimeTracker + dt;
                var time = _tweenTimeTracker;
                var property;
                if (time < _startTime) return true;
                if (_onStartCallbackFired === false) {
                    if (_onStartCallback !== null) _onStartCallback.call(_object);
                    _onStartCallbackFired = true;
                }
                var elapsed = (time - _startTime) / _duration;
                elapsed = elapsed > 1 ? 1 : elapsed;
                var value = _easingFunction(elapsed);
                for(property in _valuesEnd){
                    var start = _valuesStart[property] || 0;
                    var end = _valuesEnd[property];
                    if (end instanceof Array) _object[property] = _interpolationFunction(end, value);
                    else {
                        // Parses relative end values with start as base (e.g.: +10, -3)
                        if (typeof end === "string") end = start + parseFloat(end);
                         // protect against non numeric properties.
                        if (typeof end === "number") _object[property] = start + (end - start) * value;
                    }
                }
                if (_onUpdateCallback !== null) _onUpdateCallback.call(_object, value);
                if (elapsed === 1) {
                    if (_repeat > 0) {
                        if (isFinite(_repeat)) _repeat--;
                         // reassign starting values, restart by making startTime = now
                        for(property in _valuesStartRepeat){
                            if (typeof _valuesEnd[property] === "string") _valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property]);
                            if (_yoyo) {
                                var tmp = _valuesStartRepeat[property];
                                _valuesStartRepeat[property] = _valuesEnd[property];
                                _valuesEnd[property] = tmp;
                            }
                            _valuesStart[property] = _valuesStartRepeat[property];
                        }
                        _startTime = time + _delayTime;
                        return true;
                    } else {
                        // remove the tween from the world container
                        me.game.world.removeChildNow(this);
                        if (_onCompleteCallback !== null) _onCompleteCallback.call(_object);
                        for(var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++)_chainedTweens[i].start(time);
                        return false;
                    }
                }
                return true;
            };
        };
        /**
      * Easing Function :<br>
      * <p>
      * me.Tween.Easing.Linear.None<br>
      * me.Tween.Easing.Quadratic.In<br>
      * me.Tween.Easing.Quadratic.Out<br>
      * me.Tween.Easing.Quadratic.InOut<br>
      * me.Tween.Easing.Cubic.In<br>
      * me.Tween.Easing.Cubic.Out<br>
      * me.Tween.Easing.Cubic.InOut<br>
      * me.Tween.Easing.Quartic.In<br>
      * me.Tween.Easing.Quartic.Out<br>
      * me.Tween.Easing.Quartic.InOut<br>
      * me.Tween.Easing.Quintic.In<br>
      * me.Tween.Easing.Quintic.Out<br>
      * me.Tween.Easing.Quintic.InOut<br>
      * me.Tween.Easing.Sinusoidal.In<br>
      * me.Tween.Easing.Sinusoidal.Out<br>
      * me.Tween.Easing.Sinusoidal.InOut<br>
      * me.Tween.Easing.Exponential.In<br>
      * me.Tween.Easing.Exponential.Out<br>
      * me.Tween.Easing.Exponential.InOut<br>
      * me.Tween.Easing.Circular.In<br>
      * me.Tween.Easing.Circular.Out<br>
      * me.Tween.Easing.Circular.InOut<br>
      * me.Tween.Easing.Elastic.In<br>
      * me.Tween.Easing.Elastic.Out<br>
      * me.Tween.Easing.Elastic.InOut<br>
      * me.Tween.Easing.Back.In<br>
      * me.Tween.Easing.Back.Out<br>
      * me.Tween.Easing.Back.InOut<br>
      * me.Tween.Easing.Bounce.In<br>
      * me.Tween.Easing.Bounce.Out<br>
      * me.Tween.Easing.Bounce.InOut
      * </p>
      * @public
      * @constant
      * @type enum
      * @name Easing
      * @memberOf me.Tween
      */ me.Tween.Easing = {
            Linear: {
                /** @ignore */ None: function None(k) {
                    return k;
                }
            },
            Quadratic: {
                /** @ignore */ In: function In(k) {
                    return k * k;
                },
                /** @ignore */ Out: function Out(k) {
                    return k * (2 - k);
                },
                /** @ignore */ InOut: function InOut(k) {
                    if ((k *= 2) < 1) return 0.5 * k * k;
                    return -0.5 * ((--k) * (k - 2) - 1);
                }
            },
            Cubic: {
                /** @ignore */ In: function In(k) {
                    return k * k * k;
                },
                /** @ignore */ Out: function Out(k) {
                    return (--k) * k * k + 1;
                },
                /** @ignore */ InOut: function InOut(k) {
                    if ((k *= 2) < 1) return 0.5 * k * k * k;
                    return 0.5 * ((k -= 2) * k * k + 2);
                }
            },
            Quartic: {
                /** @ignore */ In: function In(k) {
                    return k * k * k * k;
                },
                /** @ignore */ Out: function Out(k) {
                    return 1 - (--k) * k * k * k;
                },
                /** @ignore */ InOut: function InOut(k) {
                    if ((k *= 2) < 1) return 0.5 * k * k * k * k;
                    return -0.5 * ((k -= 2) * k * k * k - 2);
                }
            },
            Quintic: {
                /** @ignore */ In: function In(k) {
                    return k * k * k * k * k;
                },
                /** @ignore */ Out: function Out(k) {
                    return (--k) * k * k * k * k + 1;
                },
                /** @ignore */ InOut: function InOut(k) {
                    if ((k *= 2) < 1) return 0.5 * k * k * k * k * k;
                    return 0.5 * ((k -= 2) * k * k * k * k + 2);
                }
            },
            Sinusoidal: {
                /** @ignore */ In: function In(k) {
                    return 1 - Math.cos(k * Math.PI / 2);
                },
                /** @ignore */ Out: function Out(k) {
                    return Math.sin(k * Math.PI / 2);
                },
                /** @ignore */ InOut: function InOut(k) {
                    return 0.5 * (1 - Math.cos(Math.PI * k));
                }
            },
            Exponential: {
                /** @ignore */ In: function In(k) {
                    return k === 0 ? 0 : Math.pow(1024, k - 1);
                },
                /** @ignore */ Out: function Out(k) {
                    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
                },
                /** @ignore */ InOut: function InOut(k) {
                    if (k === 0) return 0;
                    if (k === 1) return 1;
                    if ((k *= 2) < 1) return 0.5 * Math.pow(1024, k - 1);
                    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
                }
            },
            Circular: {
                /** @ignore */ In: function In(k) {
                    return 1 - Math.sqrt(1 - k * k);
                },
                /** @ignore */ Out: function Out(k) {
                    return Math.sqrt(1 - (--k) * k);
                },
                /** @ignore */ InOut: function InOut(k) {
                    if ((k *= 2) < 1) return -0.5 * (Math.sqrt(1 - k * k) - 1);
                    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
                }
            },
            Elastic: {
                /** @ignore */ In: function In(k) {
                    if (k === 0) return 0;
                    if (k === 1) return 1;
                    return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
                },
                /** @ignore */ Out: function Out(k) {
                    if (k === 0) return 0;
                    if (k === 1) return 1;
                    return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
                },
                /** @ignore */ InOut: function InOut(k) {
                    if (k === 0) return 0;
                    if (k === 1) return 1;
                    k *= 2;
                    if (k < 1) return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
                    return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;
                }
            },
            Back: {
                /** @ignore */ In: function In(k) {
                    var s = 1.70158;
                    return k * k * ((s + 1) * k - s);
                },
                /** @ignore */ Out: function Out(k) {
                    var s = 1.70158;
                    return (--k) * k * ((s + 1) * k + s) + 1;
                },
                /** @ignore */ InOut: function InOut(k) {
                    var s = 2.5949095;
                    if ((k *= 2) < 1) return 0.5 * (k * k * ((s + 1) * k - s));
                    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
                }
            },
            Bounce: {
                /** @ignore */ In: function In(k) {
                    return 1 - me.Tween.Easing.Bounce.Out(1 - k);
                },
                /** @ignore */ Out: function Out(k) {
                    if (k < 1 / 2.75) return 7.5625 * k * k;
                    else if (k < 2 / 2.75) return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
                    else if (k < 2.5 / 2.75) return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
                    else return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
                },
                /** @ignore */ InOut: function InOut(k) {
                    if (k < 0.5) return me.Tween.Easing.Bounce.In(k * 2) * 0.5;
                    return me.Tween.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
                }
            }
        };
        /**
      * Interpolation Function :<br>
      * <p>
      * me.Tween.Interpolation.Linear<br>
      * me.Tween.Interpolation.Bezier<br>
      * me.Tween.Interpolation.CatmullRom
      * </p>
      * @public
      * @constant
      * @type enum
      * @name Interpolation
      * @memberOf me.Tween
      */ me.Tween.Interpolation = {
            /** @ignore */ Linear: function Linear(v, k) {
                var m = v.length - 1, f = m * k, i = Math.floor(f), fn = me.Tween.Interpolation.Utils.Linear;
                if (k < 0) return fn(v[0], v[1], f);
                if (k > 1) return fn(v[m], v[m - 1], m - f);
                return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
            },
            /** @ignore */ Bezier: function Bezier(v, k) {
                var b = 0, n = v.length - 1, pw = Math.pow, bn = me.Tween.Interpolation.Utils.Bernstein, i;
                for(i = 0; i <= n; i++)b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
                return b;
            },
            /** @ignore */ CatmullRom: function CatmullRom(v, k) {
                var m = v.length - 1, f = m * k, i = Math.floor(f), fn = me.Tween.Interpolation.Utils.CatmullRom;
                if (v[0] === v[m]) {
                    if (k < 0) i = Math.floor(f = m * (1 + k));
                    return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
                } else {
                    if (k < 0) return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
                    if (k > 1) return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
                    return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
                }
            },
            Utils: {
                /** @ignore */ Linear: function Linear1(p0, p1, t) {
                    return (p1 - p0) * t + p0;
                },
                /** @ignore */ Bernstein: function Bernstein(n, i) {
                    var fc = me.Tween.Interpolation.Utils.Factorial;
                    return fc(n) / fc(i) / fc(n - i);
                },
                /** @ignore */ Factorial: (function() {
                    var a = [
                        1
                    ];
                    return function(n) {
                        var s = 1, i;
                        if (a[n]) return a[n];
                        for(i = n; i > 1; i--)s *= i;
                        return a[n] = s;
                    };
                })(),
                /** @ignore */ CatmullRom: function CatmullRom1(p0, p1, p2, p3, t) {
                    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;
                    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
                }
            }
        };
    })();
    /* eslint-enable quotes, keyword-spacing, comma-spacing, no-return-assign */ (function() {
        /**
      * There is no constructor function for me.plugins<br>
      * This namespace is a container for all registered plugins.
      * @see me.plugin.register
      * @namespace me.plugins
      * @memberOf me
      */ me.plugins = {
        };
        /**
      * There is no constructor function for me.plugin
      * @namespace me.plugin
      * @memberOf me
      */ me.plugin = (function() {
            // hold public stuff inside the singleton
            var singleton = {
            };
            /*--------------
           PUBLIC
         --------------*/ /**
       * a base Object for plugin <br>
       * plugin must be installed using the register function
       * @see me.plugin
       * @class
       * @extends me.Object
       * @name plugin.Base
       * @memberOf me
       * @constructor
       */ singleton.Base = me.Object.extend({
                /** @ignore */ init: function init() {
                    /**
            * define the minimum required version of melonJS<br>
            * this can be overridden by the plugin
            * @public
            * @type String
            * @default "8.0.1"
            * @name me.plugin.Base#version
            */ this.version = "8.0.1";
                }
            });
            /**
        * patch a melonJS function
        * @name patch
        * @memberOf me.plugin
        * @public
        * @function
        * @param {Object} proto target object
        * @param {String} name target function
        * @param {Function} fn replacement function
        * @example
        * // redefine the me.game.update function with a new one
        * me.plugin.patch(me.game, "update", function () {
        *   // display something in the console
        *   console.log("duh");
        *   // call the original me.game.update function
        *   this._patched();
        * });
        */ singleton.patch = function(proto, name, fn) {
                // use the object prototype if possible
                if (typeof proto.prototype !== "undefined") proto = proto.prototype;
                 // reuse the logic behind me.Object.extend
                if (typeof proto[name] === "function") {
                    // save the original function
                    var _parent = proto[name]; // override the function with the new one
                    Object.defineProperty(proto, name, {
                        "configurable": true,
                        "value": function(name1, fn1) {
                            return function() {
                                this._patched = _parent;
                                var ret = fn1.apply(this, arguments);
                                this._patched = null;
                                return ret;
                            };
                        }(name, fn)
                    });
                } else throw new Error(name + " is not an existing function");
            };
            /**
        * Register a plugin.
        * @name register
        * @memberOf me.plugin
        * @see me.plugin.Base
        * @public
        * @function
        * @param {me.plugin.Base} plugin Plugin to instiantiate and register
        * @param {String} name
        * @param {} [arguments...] all extra parameters will be passed to the plugin constructor
        * @example
        * // register a new plugin
        * me.plugin.register(TestPlugin, "testPlugin");
        * // the plugin then also become available
        * // under then me.plugins namespace
        * me.plugins.testPlugin.myfunction ();
        */ singleton.register = function(plugin, name) {
                // ensure me.plugin[name] is not already "used"
                if (me.plugin[name]) throw new Error("plugin " + name + " already registered");
                 // get extra arguments
                var _args = [];
                if (arguments.length > 2) // store extra arguments if any
                _args = Array.prototype.slice.call(arguments, 1);
                 // try to instantiate the plugin
                _args[0] = plugin;
                var instance = new (plugin.bind.apply(plugin, _args))(); // inheritance check
                if (typeof instance === "undefined" || !(instance instanceof me.plugin.Base)) throw new Error("Plugin should extend the me.plugin.Base Class !");
                 // compatibility testing
                if (me.utils.checkVersion(instance.version) > 0) throw new Error("Plugin version mismatch, expected: " + instance.version + ", got: " + me.version);
                 // create a reference to the new plugin
                me.plugins[name] = instance;
            }; // return our singleton
            return singleton;
        })();
    })();
    /**
    * Used to make a game entity draggable
    * @class
    * @extends me.Entity
    * @memberOf me
    * @constructor
    * @param {Number} x the x coordinates of the entity object
    * @param {Number} y the y coordinates of the entity object
    * @param {Object} settings Entity properties (see {@link me.Entity})
    */ me.DraggableEntity = (function(Entity, Input, Event1, Vector) {
        return Entity.extend({
            /**
        * Constructor
        * @name init
        * @memberOf me.DraggableEntity
        * @function
        * @param {Number} x the x postion of the entity
        * @param {Number} y the y postion of the entity
        * @param {Object} settings the additional entity settings
        */ init: function init(x, y, settings) {
                this._super(Entity, "init", [
                    x,
                    y,
                    settings
                ]);
                this.dragging = false;
                this.dragId = null;
                this.grabOffset = new Vector(0, 0);
                this.onPointerEvent = Input.registerPointerEvent;
                this.removePointerEvent = Input.releasePointerEvent;
                this.initEvents();
            },
            /**
        * Initializes the events the modules needs to listen to
        * It translates the pointer events to me.events
        * in order to make them pass through the system and to make
        * this module testable. Then we subscribe this module to the
        * transformed events.
        * @name initEvents
        * @memberOf me.DraggableEntity
        * @function
        */ initEvents: function initEvents() {
                var self = this;
                /**
          * @ignore
          */ this.mouseDown = function(e) {
                    this.translatePointerEvent(e, Event1.DRAGSTART);
                };
                /**
          * @ignore
          */ this.mouseUp = function(e) {
                    this.translatePointerEvent(e, Event1.DRAGEND);
                };
                this.onPointerEvent("pointerdown", this, this.mouseDown.bind(this));
                this.onPointerEvent("pointerup", this, this.mouseUp.bind(this));
                this.onPointerEvent("pointercancel", this, this.mouseUp.bind(this));
                Event1.subscribe(Event1.POINTERMOVE, this.dragMove.bind(this));
                Event1.subscribe(Event1.DRAGSTART, function(e, draggable) {
                    if (draggable === self) self.dragStart(e);
                });
                Event1.subscribe(Event1.DRAGEND, function(e, draggable) {
                    if (draggable === self) self.dragEnd(e);
                });
            },
            /**
        * Translates a pointer event to a me.event
        * @name translatePointerEvent
        * @memberOf me.DraggableEntity
        * @function
        * @param {Object} e the pointer event you want to translate
        * @param {String} translation the me.event you want to translate
        * the event to
        */ translatePointerEvent: function translatePointerEvent(e, translation) {
                Event1.publish(translation, [
                    e,
                    this
                ]);
            },
            /**
        * Gets called when the user starts dragging the entity
        * @name dragStart
        * @memberOf me.DraggableEntity
        * @function
        * @param {Object} x the pointer event
        */ dragStart: function dragStart(e) {
                if (this.dragging === false) {
                    this.dragging = true;
                    this.grabOffset.set(e.gameX, e.gameY);
                    this.grabOffset.sub(this.pos);
                    return false;
                }
            },
            /**
        * Gets called when the user drags this entity around
        * @name dragMove
        * @memberOf me.DraggableEntity
        * @function
        * @param {Object} x the pointer event
        */ dragMove: function dragMove(e) {
                if (this.dragging === true) {
                    this.pos.set(e.gameX, e.gameY, this.pos.z); //TODO : z ?
                    this.pos.sub(this.grabOffset);
                }
            },
            /**
        * Gets called when the user stops dragging the entity
        * @name dragEnd
        * @memberOf me.DraggableEntity
        * @function
        * @param {Object} x the pointer event
        */ dragEnd: function dragEnd() {
                if (this.dragging === true) {
                    this.dragging = false;
                    return false;
                }
            },
            /**
        * Destructor
        * @name destroy
        * @memberOf me.DraggableEntity
        * @function
        */ destroy: function destroy() {
                Event1.unsubscribe(Event1.POINTERMOVE, this.dragMove);
                Event1.unsubscribe(Event1.DRAGSTART, this.dragStart);
                Event1.unsubscribe(Event1.DRAGEND, this.dragEnd);
                this.removePointerEvent("pointerdown", this);
                this.removePointerEvent("pointerup", this);
            }
        });
    })(me.Entity, me.input, me.event, me.Vector2d);
    /**
    * Used to make a game entity a droptarget
    * @class
    * @extends me.Entity
    * @memberOf me
    * @constructor
    * @param {Number} x the x coordinates of the entity object
    * @param {Number} y the y coordinates of the entity object
    * @param {Object} settings Entity properties (see {@link me.Entity})
    */ me.DroptargetEntity = (function(Entity, Event1) {
        return Entity.extend({
            /**
        * Constructor
        * @name init
        * @memberOf me.DroptargetEntity
        * @function
        * @param {Number} x the x postion of the entity
        * @param {Number} y the y postion of the entity
        * @param {Object} settings the additional entity settings
        */ init: function init(x, y, settings) {
                /**
          * constant for the overlaps method
          * @public
          * @constant
          * @type String
          * @name CHECKMETHOD_OVERLAP
          * @memberOf me.DroptargetEntity
          */ this.CHECKMETHOD_OVERLAP = "overlaps";
                /**
          * constant for the contains method
          * @public
          * @constant
          * @type String
          * @name CHECKMETHOD_CONTAINS
          * @memberOf me.DroptargetEntity
          */ this.CHECKMETHOD_CONTAINS = "contains";
                /**
          * the checkmethod we want to use
          * @public
          * @constant
          * @type String
          * @name checkMethod
          * @memberOf me.DroptargetEntity
          */ this.checkMethod = null;
                this._super(Entity, "init", [
                    x,
                    y,
                    settings
                ]);
                Event1.subscribe(Event1.DRAGEND, this.checkOnMe.bind(this));
                this.checkMethod = this[this.CHECKMETHOD_OVERLAP];
            },
            /**
        * Sets the collision method which is going to be used to check a valid drop
        * @name setCheckMethod
        * @memberOf me.DroptargetEntity
        * @function
        * @param {Constant} checkMethod the checkmethod (defaults to CHECKMETHOD_OVERLAP)
        */ setCheckMethod: function setCheckMethod(checkMethod) {
                //  We can improve this check,
                //  because now you can use every method in theory
                if (typeof this[checkMethod] !== "undefined") this.checkMethod = this[checkMethod];
            },
            /**
        * Checks if a dropped entity is dropped on the current entity
        * @name checkOnMe
        * @memberOf me.DroptargetEntity
        * @function
        * @param {Object} draggableEntity the draggable entity that is dropped
        */ checkOnMe: function checkOnMe(e, draggableEntity) {
                if (draggableEntity && this.checkMethod(draggableEntity.getBounds())) // call the drop method on the current entity
                this.drop(draggableEntity);
            },
            /**
        * Gets called when a draggable entity is dropped on the current entity
        * @name drop
        * @memberOf me.DroptargetEntity
        * @function
        * @param {Object} draggableEntity the draggable entity that is dropped
        */ drop: function drop() {
            },
            /**
        * Destructor
        * @name destroy
        * @memberOf me.DroptargetEntity
        * @function
        */ destroy: function destroy() {
                Event1.unsubscribe(Event1.DRAGEND, this.checkOnMe);
            }
        });
    })(me.Entity, me.event);
    (function() {
        /**
      * @class
      * @extends me.Entity
      * @memberOf me
      * @constructor
      * @param {Number} x the x coordinates of the entity object
      * @param {Number} y the y coordinates of the entity object
      * @param {Object} settings See {@link me.Entity}
      */ me.CollectableEntity = me.Entity.extend({
            /**
        * @ignore
        */ init: function init(x, y, settings) {
                // call the super constructor
                this._super(me.Entity, "init", [
                    x,
                    y,
                    settings
                ]);
                this.body.collisionType = me.collision.types.COLLECTABLE_OBJECT;
            }
        });
    })();
    (function() {
        /**
      * @class
      * @extends me.Entity
      * @memberOf me
      * @constructor
      * @param {Number} x the x coordinates of the object
      * @param {Number} y the y coordinates of the object
      * @param {Object} settings See {@link me.Entity}
      * @param {String} [settings.duration] Fade duration (in ms)
      * @param {String|me.Color} [settings.color] Fade color
      * @param {String} [settings.to] TMX level to load
      * @param {String|me.Container} [settings.container] Target container. See {@link me.levelDirector.loadLevel}
      * @param {Function} [settings.onLoaded] Level loaded callback. See {@link me.levelDirector.loadLevel}
      * @param {Boolean} [settings.flatten] Flatten all objects into the target container. See {@link me.levelDirector.loadLevel}
      * @param {Boolean} [settings.setViewportBounds] Resize the viewport to match the level. See {@link me.levelDirector.loadLevel}
      * @example
      * me.game.world.addChild(new me.LevelEntity(
      *     x, y, {
      *         "duration" : 250,
      *         "color" : "#000",
      *         "to" : "mymap2"
      *     }
      * ));
      */ me.LevelEntity = me.Entity.extend({
            /**
        * @ignore
        */ init: function init(x, y, settings) {
                this._super(me.Entity, "init", [
                    x,
                    y,
                    settings
                ]);
                this.nextlevel = settings.to;
                this.fade = settings.fade;
                this.duration = settings.duration;
                this.fading = false;
                this.name = "levelEntity"; // a temp variable
                this.gotolevel = settings.to; // Collect the defined level settings
                this.loadLevelSettings = {
                };
                [
                    "container",
                    "onLoaded",
                    "flatten",
                    "setViewportBounds"
                ].forEach((function(v) {
                    if (typeof settings[v] !== "undefined") this.loadLevelSettings[v] = settings[v];
                }).bind(this));
                this.body.collisionType = me.collision.types.ACTION_OBJECT;
            },
            /**
        * @ignore
        */ getlevelSettings: function getlevelSettings() {
                // Lookup for the container instance
                if (typeof this.loadLevelSettings.container === "string") this.loadLevelSettings.container = me.game.world.getChildByName(this.loadLevelSettings.container)[0];
                return this.loadLevelSettings;
            },
            /**
        * @ignore
        */ onFadeComplete: function onFadeComplete() {
                me.levelDirector.loadLevel(this.gotolevel, this.getlevelSettings());
                me.game.viewport.fadeOut(this.fade, this.duration);
            },
            /**
        * go to the specified level
        * @name goTo
        * @memberOf me.LevelEntity
        * @function
        * @param {String} [level=this.nextlevel] name of the level to load
        * @protected
        */ goTo: function goTo(level) {
                this.gotolevel = level || this.nextlevel; // load a level
                //console.log("going to : ", to);
                if (this.fade && this.duration) {
                    if (!this.fading) {
                        this.fading = true;
                        me.game.viewport.fadeIn(this.fade, this.duration, this.onFadeComplete.bind(this));
                    }
                } else me.levelDirector.loadLevel(this.gotolevel, this.getlevelSettings());
            },
            /** @ignore */ onCollision: function onCollision() {
                if (this.name === "levelEntity") this.goTo.apply(this);
                return false;
            }
        });
    })();
    (function() {
        // generate a default image for the particles
        var pixel = function() {
            var canvas = me.video.createCanvas(1, 1);
            var context = canvas.getContext("2d");
            context.fillStyle = "#fff";
            context.fillRect(0, 0, 1, 1);
            return canvas;
        }();
        /**
      * me.ParticleEmitterSettings contains the default settings for me.ParticleEmitter.<br>
      *
      * @protected
      * @class
      * @memberOf me
      * @see me.ParticleEmitter
      */ me.ParticleEmitterSettings = {
            /**
        * Width of the particle spawn area.<br>
        * @public
        * @type Number
        * @name width
        * @memberOf me.ParticleEmitterSettings
        * @default 0
        */ width: 0,
            /**
        * Height of the particle spawn area.<br>
        * @public
        * @type Number
        * @name height
        * @memberOf me.ParticleEmitterSettings
        * @default 0
        */ height: 0,
            /**
        * Image used for particles.<br>
        * @public
        * @type CanvasImageSource
        * @name image
        * @memberOf me.ParticleEmitterSettings
        * @default 1x1 white pixel
        * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasimagesource
        */ image: pixel,
            /**
        * Total number of particles in the emitter.<br>
        * @public
        * @type Number
        * @name totalParticles
        * @default 50
        * @memberOf me.ParticleEmitterSettings
        */ totalParticles: 50,
            /**
        * Start angle for particle launch in Radians.<br>
        * @public
        * @type Number
        * @name angle
        * @default Math.PI / 2
        * @memberOf me.ParticleEmitterSettings
        */ angle: Math.PI / 2,
            /**
        * Variation in the start angle for particle launch in Radians.<br>
        * @public
        * @type Number
        * @name angleVariation
        * @default 0
        * @memberOf me.ParticleEmitterSettings
        */ angleVariation: 0,
            /**
        * Minimum time each particle lives once it is emitted in ms.<br>
        * @public
        * @type Number
        * @name minLife
        * @default 1000
        * @memberOf me.ParticleEmitterSettings
        */ minLife: 1000,
            /**
        * Maximum time each particle lives once it is emitted in ms.<br>
        * @public
        * @type Number
        * @name maxLife
        * @default 3000
        * @memberOf me.ParticleEmitterSettings
        */ maxLife: 3000,
            /**
        * Start speed of particles.<br>
        * @public
        * @type Number
        * @name speed
        * @default 2
        * @memberOf me.ParticleEmitterSettings
        */ speed: 2,
            /**
        * Variation in the start speed of particles.<br>
        * @public
        * @type Number
        * @name speedVariation
        * @default 1
        * @memberOf me.ParticleEmitterSettings
        */ speedVariation: 1,
            /**
        * Minimum start rotation for particles sprites in Radians.<br>
        * @public
        * @type Number
        * @name minRotation
        * @default 0
        * @memberOf me.ParticleEmitterSettings
        */ minRotation: 0,
            /**
        * Maximum start rotation for particles sprites in Radians.<br>
        * @public
        * @type Number
        * @name maxRotation
        * @default 0
        * @memberOf me.ParticleEmitterSettings
        */ maxRotation: 0,
            /**
        * Minimum start scale ratio for particles (1 = no scaling).<br>
        * @public
        * @type Number
        * @name minStartScale
        * @default 1
        * @memberOf me.ParticleEmitterSettings
        */ minStartScale: 1,
            /**
        * Maximum start scale ratio for particles (1 = no scaling).<br>
        * @public
        * @type Number
        * @name maxStartScale
        * @default 1
        * @memberOf me.ParticleEmitterSettings
        */ maxStartScale: 1,
            /**
        * Minimum end scale ratio for particles.<br>
        * @public
        * @type Number
        * @name minEndScale
        * @default 0
        * @memberOf me.ParticleEmitterSettings
        */ minEndScale: 0,
            /**
        * Maximum end scale ratio for particles.<br>
        * @public
        * @type Number
        * @name maxEndScale
        * @default 0
        * @memberOf me.ParticleEmitterSettings
        */ maxEndScale: 0,
            /**
        * Vertical force (Gravity) for each particle.<br>
        * @public
        * @type Number
        * @name gravity
        * @default 0
        * @memberOf me.ParticleEmitterSettings
        * @see me.sys.gravity
        */ gravity: 0,
            /**
        * Horizontal force (like a Wind) for each particle.<br>
        * @public
        * @type Number
        * @name wind
        * @default 0
        * @memberOf me.ParticleEmitterSettings
        */ wind: 0,
            /**
        * Update the rotation of particle in accordance the particle trajectory.<br>
        * The particle sprite should aim at zero angle (draw from left to right).<br>
        * Override the particle minRotation and maxRotation.<br>
        * @public
        * @type Boolean
        * @name followTrajectory
        * @default false
        * @memberOf me.ParticleEmitterSettings
        */ followTrajectory: false,
            /**
        * Enable the Texture Additive by canvas composite operation (lighter).<br>
        * WARNING: Composite Operation may decreases performance!.<br>
        * @public
        * @type Boolean
        * @name textureAdditive
        * @default false
        * @memberOf me.ParticleEmitterSettings
        */ textureAdditive: false,
            /**
        * Update particles only in the viewport, remove it when out of viewport.<br>
        * @public
        * @type Boolean
        * @name onlyInViewport
        * @default true
        * @memberOf me.ParticleEmitterSettings
        */ onlyInViewport: true,
            /**
        * Render particles in screen space. <br>
        * @public
        * @type Boolean
        * @name floating
        * @default false
        * @memberOf me.ParticleEmitterSettings
        */ floating: false,
            /**
        * Maximum number of particles launched each time in this emitter (used only if emitter is Stream).<br>
        * @public
        * @type Number
        * @name maxParticles
        * @default 10
        * @memberOf me.ParticleEmitterSettings
        */ maxParticles: 10,
            /**
        * How often a particle is emitted in ms (used only if emitter is Stream).<br>
        * Necessary that value is greater than zero.<br>
        * @public
        * @type Number
        * @name frequency
        * @default 100
        * @memberOf me.ParticleEmitterSettings
        */ frequency: 100,
            /**
        * Duration that the emitter releases particles in ms (used only if emitter is Stream).<br>
        * After this period, the emitter stop the launch of particles.<br>
        * @public
        * @type Number
        * @name duration
        * @default Infinity
        * @memberOf me.ParticleEmitterSettings
        */ duration: Infinity,
            /**
        * Skip n frames after updating the particle system once. <br>
        * This can be used to reduce the performance impact of emitters with many particles.<br>
        * @public
        * @type Number
        * @name framesToSkip
        * @default 0
        * @memberOf me.ParticleEmitterSettings
        */ framesToSkip: 0
        };
        /**
      * Particle Emitter Object.
      * @class
      * @extends Rect
      * @memberOf me
      * @constructor
      * @param {Number} x x-position of the particle emitter
      * @param {Number} y y-position of the particle emitter
      * @param {object} settings An object containing the settings for the particle emitter. See {@link me.ParticleEmitterSettings}
      * @example
      *
      * // Create a basic emitter at position 100, 100
      * var emitter = new me.ParticleEmitter(100, 100);
      *
      * // Adjust the emitter properties
      * emitter.totalParticles = 200;
      * emitter.minLife = 1000;
      * emitter.maxLife = 3000;
      * emitter.z = 10;
      *
      * // Add the emitter to the game world
      * me.game.world.addChild(emitter);
      *
      * // Launch all particles one time and stop, like a explosion
      * emitter.burstParticles();
      *
      * // Launch constantly the particles, like a fountain
      * emitter.streamParticles();
      *
      * // At the end, remove emitter from the game world
      * // call this in onDestroyEvent function
      * me.game.world.removeChild(emitter);
      *
      */ me.ParticleEmitter = me.Rect.extend({
            /**
        * @ignore
        */ init: function init(x, y, settings) {
                // Emitter is Stream, launch particles constantly
                /** @ignore */ this._stream = false; // Frequency timer (in ms) for emitter launch new particles
                // used only in stream emitter
                /** @ignore */ this._frequencyTimer = 0; // Time of live (in ms) for emitter launch new particles
                // used only in stream emitter
                /** @ignore */ this._durationTimer = 0; // Emitter is emitting particles
                /** @ignore */ this._enabled = false; // Emitter will always update
                this.isRenderable = false; // call the super constructor
                this._super(me.Rect, "init", [
                    x,
                    y,
                    Infinity,
                    Infinity
                ]); // don't sort the particles by z-index
                this.autoSort = false;
                this.container = new me.ParticleContainer(this);
                /**
          * @ignore
          */ Object.defineProperty(this.pos, "z", {
                    /**
            * @ignore
            */ get: (function() {
                        return this.container.pos.z;
                    }).bind(this),
                    /**
            * @ignore
            */ set: (function(value) {
                        this.container.pos.z = value;
                    }).bind(this),
                    enumerable: true,
                    configurable: true
                });
                /**
          * Floating property for particles, value is forwarded to the particle container <br>
          * @type Boolean
          * @name floating
          * @memberOf me.ParticleEmitter
          */ Object.defineProperty(this, "floating", {
                    /**
            * @ignore
            */ get: function get() {
                        return this.container.floating;
                    },
                    /**
            * @ignore
            */ set: function set(value) {
                        this.container.floating = value;
                    },
                    enumerable: true,
                    configurable: true
                }); // Reset the emitter to defaults
                this.reset(settings);
            },
            /**
        * @ignore
        */ onActivateEvent: function onActivateEvent() {
                this.ancestor.addChild(this.container);
                this.container.pos.z = this.pos.z;
                if (!this.ancestor.autoSort) this.ancestor.sort();
            },
            /**
        * @ignore
        */ onDeactivateEvent: function onDeactivateEvent() {
                if (this.ancestor.hasChild(this.container)) this.ancestor.removeChildNow(this.container);
            },
            /**
        * @ignore
        */ destroy: function destroy() {
                this.reset();
            },
            /**
        * returns a random point inside the bounds x axis of this emitter
        * @name getRandomPointX
        * @memberOf me.ParticleEmitter
        * @function
        * @return {Number}
        */ getRandomPointX: function getRandomPointX() {
                return this.pos.x + me.Math.randomFloat(0, this.width);
            },
            /**
        * returns a random point inside the bounds y axis of this emitter
        * @name getRandomPointY
        * @memberOf me.ParticleEmitter
        * @function
        * @return {Number}
        */ getRandomPointY: function getRandomPointY() {
                return this.pos.y + me.Math.randomFloat(0, this.height);
            },
            /**
        * Reset the emitter with default values.<br>
        * @function
        * @param {Object} settings [optional] object with emitter settings. See {@link me.ParticleEmitterSettings}
        * @name reset
        * @memberOf me.ParticleEmitter
        */ reset: function reset(settings) {
                // check if settings exists and create a dummy object if necessary
                settings = settings || {
                };
                var defaults = me.ParticleEmitterSettings;
                var width = typeof settings.width === "number" ? settings.width : defaults.width;
                var height = typeof settings.height === "number" ? settings.height : defaults.height;
                this.resize(width, height);
                Object.assign(this, defaults, settings); // reset particle container values
                this.container.reset();
            },
            // Add count particles in the game world
            /** @ignore */ addParticles: function addParticles(count) {
                for(var i = 0; i < ~~count; i++){
                    // Add particle to the container
                    var particle = me.pool.pull("me.Particle", this);
                    this.container.addChild(particle);
                }
            },
            /**
        * Emitter is of type stream and is launching particles <br>
        * @function
        * @returns {Boolean} Emitter is Stream and is launching particles
        * @name isRunning
        * @memberOf me.ParticleEmitter
        */ isRunning: function isRunning() {
                return this._enabled && this._stream;
            },
            /**
        * Launch particles from emitter constantly <br>
        * Particles example: Fountains
        * @param {Number} duration [optional] time that the emitter releases particles in ms
        * @function
        * @name streamParticles
        * @memberOf me.ParticleEmitter
        */ streamParticles: function streamParticles(duration) {
                this._enabled = true;
                this._stream = true;
                this.frequency = Math.max(this.frequency, 1);
                this._durationTimer = typeof duration === "number" ? duration : this.duration;
            },
            /**
        * Stop the emitter from generating new particles (used only if emitter is Stream) <br>
        * @function
        * @name stopStream
        * @memberOf me.ParticleEmitter
        */ stopStream: function stopStream() {
                this._enabled = false;
            },
            /**
        * Launch all particles from emitter and stop <br>
        * Particles example: Explosions <br>
        * @param {Number} total [optional] number of particles to launch
        * @function
        * @name burstParticles
        * @memberOf me.ParticleEmitter
        */ burstParticles: function burstParticles(total) {
                this._enabled = true;
                this._stream = false;
                this.addParticles(typeof total === "number" ? total : this.totalParticles);
                this._enabled = false;
            },
            /**
        * @ignore
        */ update: function update(dt) {
                // Launch new particles, if emitter is Stream
                if (this._enabled && this._stream) {
                    // Check if the emitter has duration set
                    if (this._durationTimer !== Infinity) {
                        this._durationTimer -= dt;
                        if (this._durationTimer <= 0) {
                            this.stopStream();
                            return false;
                        }
                    } // Increase the emitter launcher timer
                    this._frequencyTimer += dt; // Check for new particles launch
                    var particlesCount = this.container.children.length;
                    if (particlesCount < this.totalParticles && this._frequencyTimer >= this.frequency) {
                        if (particlesCount + this.maxParticles <= this.totalParticles) this.addParticles(this.maxParticles);
                        else this.addParticles(this.totalParticles - particlesCount);
                        this._frequencyTimer = 0;
                    }
                }
                return true;
            }
        });
    })();
    (function() {
        /**
      * Particle Container Object.
      * @class
      * @extends me.Container
      * @memberOf me
      * @constructor
      * @param {me.ParticleEmitter} emitter the emitter which owns this container
      */ me.ParticleContainer = me.Container.extend({
            /**
        * @ignore
        */ init: function init(emitter) {
                // call the super constructor
                this._super(me.Container, "init", [
                    me.game.viewport.pos.x,
                    me.game.viewport.pos.y,
                    me.game.viewport.width,
                    me.game.viewport.height
                ]); // don't sort the particles by z-index
                this.autoSort = false; // count the updates
                this._updateCount = 0; // internally store how much time was skipped when frames are skipped
                this._dt = 0; // cache the emitter for later use
                this._emitter = emitter;
                this.autoTransform = false;
                this.anchorPoint.set(0, 0);
                this.isKinematic = true;
            },
            /**
        * @ignore
        */ update: function update(dt) {
                // skip frames if necessary
                if ((++this._updateCount) > this._emitter.framesToSkip) this._updateCount = 0;
                if (this._updateCount > 0) {
                    this._dt += dt;
                    return false;
                } // apply skipped delta time
                dt += this._dt;
                this._dt = 0; // Update particles and remove them if they are dead
                var viewport = me.game.viewport;
                for(var i = this.children.length - 1; i >= 0; --i){
                    var particle = this.children[i];
                    particle.inViewport = viewport.isVisible(particle, this.floating);
                    if (!particle.update(dt)) this.removeChildNow(particle);
                }
                return true;
            },
            /**
        * @ignore
        */ draw: function draw(renderer, rect) {
                if (this.children.length > 0) {
                    var context = renderer.getContext(), gco; // Check for additive draw
                    if (this._emitter.textureAdditive) {
                        gco = context.globalCompositeOperation;
                        context.globalCompositeOperation = "lighter";
                    }
                    this._super(me.Container, "draw", [
                        renderer,
                        rect
                    ]); // Restore globalCompositeOperation
                    if (this._emitter.textureAdditive) context.globalCompositeOperation = gco;
                }
            }
        });
    })();
    (function() {
        /**
      * Single Particle Object.
      * @class
      * @extends me.Renderable
      * @memberOf me
      * @constructor
      * @param {me.ParticleEmitter} particle emitter
      */ me.Particle = me.Renderable.extend({
            /**
        * @ignore
        */ init: function init(emitter) {
                // Call the super constructor
                this._super(me.Renderable, "init", [
                    emitter.getRandomPointX(),
                    emitter.getRandomPointY(),
                    emitter.image.width,
                    emitter.image.height
                ]); // Particle will always update
                this.alwaysUpdate = true; // Cache the image reference
                this.image = emitter.image; // Set the start particle Angle and Speed as defined in emitter
                var angle = emitter.angle + (emitter.angleVariation > 0 ? (me.Math.randomFloat(0, 2) - 1) * emitter.angleVariation : 0);
                var speed = emitter.speed + (emitter.speedVariation > 0 ? (me.Math.randomFloat(0, 2) - 1) * emitter.speedVariation : 0); // Set the start particle Velocity
                this.vel = new me.Vector2d(speed * Math.cos(angle), -speed * Math.sin(angle)); // Set the start particle Time of Life as defined in emitter
                this.life = me.Math.randomFloat(emitter.minLife, emitter.maxLife);
                this.startLife = this.life; // Set the start and end particle Scale as defined in emitter
                // clamp the values as minimum and maximum scales range
                this.startScale = me.Math.clamp(me.Math.randomFloat(emitter.minStartScale, emitter.maxStartScale), emitter.minStartScale, emitter.maxStartScale);
                this.endScale = me.Math.clamp(me.Math.randomFloat(emitter.minEndScale, emitter.maxEndScale), emitter.minEndScale, emitter.maxEndScale); // Set the particle Gravity and Wind (horizontal gravity) as defined in emitter
                this.gravity = emitter.gravity;
                this.wind = emitter.wind; // Set if the particle update the rotation in accordance the trajectory
                this.followTrajectory = emitter.followTrajectory; // Set if the particle update only in Viewport
                this.onlyInViewport = emitter.onlyInViewport; // Set the particle Z Order
                this.pos.z = emitter.z; // cache inverse of the expected delta time
                this._deltaInv = me.timer.maxfps / 1000; // Set the start particle rotation as defined in emitter
                // if the particle not follow trajectory
                if (!emitter.followTrajectory) this.angle = me.Math.randomFloat(emitter.minRotation, emitter.maxRotation);
            },
            /**
        * Update the Particle <br>
        * This is automatically called by the game manager {@link me.game}
        * @name update
        * @memberOf me.Particle
        * @function
        * @ignore
        * @param {Number} dt time since the last update in milliseconds
        */ update: function update(dt) {
                // move things forward independent of the current frame rate
                var skew = dt * this._deltaInv; // Decrease particle life
                this.life = this.life > dt ? this.life - dt : 0; // Calculate the particle Age Ratio
                var ageRatio = this.life / this.startLife; // Resize the particle as particle Age Ratio
                var scale = this.startScale;
                if (this.startScale > this.endScale) {
                    scale *= ageRatio;
                    scale = scale < this.endScale ? this.endScale : scale;
                } else if (this.startScale < this.endScale) {
                    scale /= ageRatio;
                    scale = scale > this.endScale ? this.endScale : scale;
                } // Set the particle opacity as Age Ratio
                this.alpha = ageRatio; // Adjust the particle velocity
                this.vel.x += this.wind * skew;
                this.vel.y += this.gravity * skew; // If necessary update the rotation of particle in accordance the particle trajectory
                var angle = this.followTrajectory ? Math.atan2(this.vel.y, this.vel.x) : this.angle;
                this.pos.x += this.vel.x * skew;
                this.pos.y += this.vel.y * skew; // Update particle transform
                this.currentTransform.setTransform(scale, 0, 0, 0, scale, 0, this.pos.x, this.pos.y, 1).rotate(angle); // Return true if the particle is not dead yet
                return (this.inViewport || !this.onlyInViewport) && this.life > 0;
            },
            /**
        * @ignore
        */ preDraw: function preDraw(renderer) {
                // restore is called in postDraw
                renderer.save(); // particle alpha value
                renderer.setGlobalAlpha(renderer.globalAlpha() * this.alpha); // translate to the defined anchor point and scale it
                renderer.transform(this.currentTransform);
            },
            /**
        * @ignore
        */ draw: function draw(renderer) {
                var w = this.width, h = this.height;
                renderer.drawImage(this.image, 0, 0, w, h, -w / 2, -h / 2, w, h);
            }
        });
    })();
    // placeholder for all deprecated classes,
    // and corresponding alias for backward compatibility
    /**
    * @function me.device.getPixelRatio
    * @deprecated since 5.1.0
    * @see me.device.devicePixelRatio
    */ me.device.getPixelRatio = function() {
        me.utils.deprecated("me.device.getPixelRatio()", "me.device.devicePixelRatio", "5.1.0");
        return me.device.devicePixelRatio;
    };
    /**
    * @class me.Font
    * @deprecated since 6.1.0
    * @see me.Text
    */ me.Font = me.Text.extend({
        /** @ignore */ init: function init(font, size, fillStyle, textAlign) {
            var settings = {
                font: font,
                size: size,
                fillStyle: fillStyle,
                textAlign: textAlign
            }; // super constructor
            this._super(me.Text, "init", [
                0,
                0,
                settings
            ]); // deprecation warning
            me.utils.deprecated("me.Font", "me.Text", "6.1.0");
        },
        /** @ignore */ setFont: function setFont(font, size, fillStyle, textAlign) {
            // apply fillstyle if defined
            if (typeof fillStyle !== "undefined") this.fillStyle.copy(fillStyle);
             // h alignement if defined
            if (typeof textAlign !== "undefined") this.textAlign = textAlign;
             // super constructor
            return this._super(me.Text, "setFont", [
                font,
                size
            ]);
        }
    });
    /**
    * @ignore
    */ me.BitmapFontData = me.BitmapTextData;
    /**
    * @class me.BitmapFont
    * @deprecated since 6.1.0
    * @see me.BitmapText
    */ me.BitmapFont = me.BitmapText.extend({
        /** @ignore */ init: function init(data, fontImage, scale, textAlign, textBaseline) {
            var settings = {
                font: fontImage,
                fontData: data,
                size: scale,
                textAlign: textAlign,
                textBaseline: textBaseline
            }; // super constructor
            this._super(me.BitmapText, "init", [
                0,
                0,
                settings
            ]); // deprecation warning
            me.utils.deprecated("me.BitmapFont", "me.BitmapText", "6.1.0");
        }
    });
    /**
    * @class me.ScreenObject
    * @deprecated since 6.2.0
    * @see me.Stage
    */ me.ScreenObject = me.Stage.extend({
        /** @ignore */ init: function init(settings) {
            // super constructor
            this._super(me.Stage, "init", settings); // deprecation warning
            me.utils.deprecated("me.ScreenObject", "me.Stage", "6.2.0");
        }
    });
    /**
    * @function me.Renderer.drawShape
    * @deprecated since 6.3.0
    * @see me.Renderer.stroke
    */ me.Renderer.prototype.drawShape = function() {
        me.utils.deprecated("drawShape()", "the stroke() or fill()", "6.3.0");
        me.Renderer.prototype.stroke.apply(this, arguments);
    };
    /**
    * @ignore
    */ me.CanvasRenderer.prototype.Texture = me.Renderer.prototype.Texture;
    /**
    * @ignore
    */ me.WebGLRenderer.prototype.Texture = me.Renderer.prototype.Texture;
    /**
    * @function me.video.getPos
    * @deprecated since 7.0.0
    * @see me.device.getElementBounds
    */ me.video.getPos = function() {
        me.utils.deprecated("me.video.getPos()", "me.device.getElementBounds(me.video.renderer.getScreenCanvas());", "7.0.0");
        return me.device.getElementBounds(me.video.renderer.getScreenCanvas());
    };
    /**
    * melonJS base class for exception handling.
    * @class
    * @extends me.Object
    * @memberOf me
    * @constructor
    * @deprecated since 7.0.0
    * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error
    * @param {String} msg Error message.
    */ me.Error = me.Object.extend.bind(Error)({
        /**
      * @ignore
      */ init: function init(msg) {
            this.name = "me.Error";
            this.message = msg;
        }
    });
    /**
    * @function me.sys.checkVersion
    * @deprecated since 7.1.0
    * @see me.utils.checkVersion
    */ me.sys.checkVersion = function(first, second) {
        me.utils.deprecated("me.sys.checkVersion()", "me.utils.checkVersion()", "7.1.0");
        return me.utils.checkVersion(first, second);
    };
    /**
    * @public
    * @type {Object}
    * @name HASH
    * @memberOf me.game
    * @deprecated since 7.1.0
    * @see me.utils.getUriFragment
    */ Object.defineProperty(me.game, "HASH", {
        /**
      * @ignore
      */ get: function get() {
            me.utils.deprecated("me.game.HASH", "me.utils.getUriFragment()", "7.1.0");
            return me.utils.getUriFragment();
        },
        configurable: false
    });
    /**
    * @function me.video.updateDisplaySize
    * @deprecated since 7.1.0
    * @see me.video.scale
    */ me.video.updateDisplaySize = function(x, y) {
        me.utils.deprecated("me.video.updateDisplaySize()", "me.video.scale()", "7.1.0");
        return me.video.scale(x, y);
    };
    /**
    * @function me.Renderer.scaleCanvas
    * @deprecated since 7.1.0
    * @see me.video.scale
    */ me.Renderer.prototype.scaleCanvas = function(x, y) {
        me.utils.deprecated("scaleCanvas()", "me.video.scale()", "7.1.0");
        return me.video.scale(x, y);
    };
    /**
    * @function me.Entity.distanceToPoint
    * @deprecated since 7.1.0
    * @see me.Renderable.distanceTo
   */ me.Entity.prototype.distanceToPoint = function(v) {
        me.utils.deprecated("distanceToPoint()", "me.Renderable.distanceTo()", "7.1.0");
        return this.distanceTo(v);
    };
    /**
    * @function me.Entity.angleToPoint
    * @deprecated since 7.1.0
    * @see me.Renderable.angleTo
   */ me.Entity.prototype.angleToPoint = function(v) {
        me.utils.deprecated("angleToPoint()", "me.Renderable.angleTo()", "7.1.0");
        return this.angleTo(v);
    };
    /**
    * @public
    * @type {Number}
    * @name gravity
    * @memberOf me.sys
    * @deprecated since 8.0.0
    * @see me.World.gravity
    */ Object.defineProperty(me.sys, "gravity", {
        /**
      * @ignore
      */ get: function get() {
            me.utils.deprecated("me.sys.gravity", "me.game.world.gravity", "8.0.0");
            return me.game.world ? me.game.world.gravity.y : undefined;
        },
        /**
      * @ignore
      */ set: function set(value) {
            me.utils.deprecated("me.sys.gravity", "me.game.world.gravity", "8.0.0");
            if (me.game.world) me.game.world.gravity.y = value;
        },
        configurable: false
    });
    /**
    * @ignore
    */ me.WebGLRenderer.Compositor = me.WebGLCompositor;
    /**
    * Draw triangle(s)
    * @name drawTriangle
    * @deprecated since 8.0.0
    * @see me.WebGLRenderer.Compositor
    * @memberOf me.WebGLRenderer.Compositor.drawVertices
    * @function
    * @param {me.Vector2d[]} points vertices
    * @param {Number} [len=points.length] amount of points defined in the points array
    * @param {Boolean} [strip=false] Whether the array defines a serie of connected triangles, sharing vertices
    */ me.WebGLRenderer.Compositor.prototype.drawTriangle = function(points, len, strip) {
        var gl = this.gl;
        this.drawVertices(strip === true ? gl.TRIANGLE_STRIP : gl.TRIANGLES, points, len);
        me.utils.deprecated("drawTriangle()", "drawVertices()", "8.0.0");
    };
    /**
    * Draw a line
    * @name drawLine
    * @deprecated since 8.0.0
    * @memberOf me.WebGLRenderer.Compositor.drawVertices
    * @memberOf me.WebGLRenderer.Compositor
    * @function
    * @param {me.Vector2d[]} points Line vertices
    * @param {Number} [len=points.length] amount of points defined in the points array
    * @param {Boolean} [open=false] Whether the line is open (true) or closed (false)
    */ me.WebGLRenderer.Compositor.prototype.drawLine = function(points, len, open) {
        var gl = this.gl;
        this.drawVertices(open === true ? gl.LINE_STRIP : gl.LINE_LOOP, points, len);
        me.utils.deprecated("drawLine()", "drawVertices()", "8.0.0");
    };
    /**
    * @public
    * @type {me.Vector2d}
    * @name scale
    * @memberOf me.sys
    * @deprecated since 8.0.0
    * @see me.video.scaleRatio
    */ Object.defineProperty(me.sys, "scale", {
        /**
      * @ignore
      */ get: function get() {
            me.utils.deprecated("me.sys.scale", "me.video.scaleRatio", "8.0.0");
            return me.video.scaleRatio;
        },
        configurable: false
    });
    /**
    * @function me.video.getWrapper
    * @deprecated since 8.0.0
    * @see me.video.getParent
    */ me.video.getWrapper = function() {
        me.utils.deprecated("me.video.getWrapper()", "me.device.getParent()", "8.0.0");
        return me.video.getParent();
    };
    /**
    * Set game FPS limiting
    * @public
    * @type {Number}
    * @name fps
    * @memberOf me.sys
    * @deprecated since 8.0.0
    * @see me.timer.maxfps
    */ Object.defineProperty(me.sys, "fps", {
        /**
      * @ignore
      */ get: function get() {
            me.utils.deprecated("me.sys.fps", "me.timer.maxfps", "8.0.0");
            return me.timer.maxfps;
        },
        /**
      * @ignore
      */ set: function set(value) {
            me.utils.deprecated("me.sys.fps", "me.timer.maxfps", "8.0.0");
            me.timer.maxfps = value;
        },
        configurable: false
    });
    /**
    * Rate at which the game physic updates;
    * may be greater than or lower than the display fps
    * @public
    * @type {Number}
    * @name updatesPerSecond
    * @memberOf me.sys
    * @deprecated since 8.0.0
    * @see me.World.fps
    */ Object.defineProperty(me.sys, "updatesPerSecond", {
        /**
      * @ignore
      */ get: function get() {
            me.utils.deprecated("me.sys.updatesPerSecond", "me.game.world.fps", "8.0.0");
            return me.game.world.fps;
        },
        /**
      * @ignore
      */ set: function set(value) {
            me.utils.deprecated("me.sys.updatesPerSecond", "me.game.world.fps", "8.0.0");
            me.game.world.fps = value;
        },
        configurable: false
    });
    /**
    * Enable/disable frame interpolation
    * @public
    * @type {Boolean}
    * @name interpolation
    * @memberOf me.sys
    * @deprecated since 8.0.0
    * @see me.timer.interpolation
    */ Object.defineProperty(me.sys, "interpolation", {
        /**
      * @ignore
      */ get: function get() {
            me.utils.deprecated("me.sys.interpolation", "me.timer.interpolation", "8.0.0");
            return me.timer.interpolation;
        },
        /**
      * @ignore
      */ set: function set(value) {
            me.utils.deprecated("me.sys.interpolation", "me.timer.interpolation", "8.0.0");
            me.timer.interpolation = value;
        },
        configurable: false
    });
    /**
    * add collision mesh based on a given Physics Editor JSON object
    * @name addShapesFromJSON
    * @deprecated since 8.0.0
    * @see me.Body.fromJSON
    * @memberOf me.Body
    * @function
    * @param {me.Rect|me.Polygon|me.Line|me.Ellipse|Object} shape a shape or JSON object
    * @param {Boolean} batchInsert if true the body bounds won't be updated after adding a shape
    * @return {Number} the shape array length
    */ me.Body.prototype.addShapesFromJSON = function(json, id) {
        me.utils.deprecated("addShapesFromJSON()", "fromJSON()", "8.0.0");
        return this.fromJSON(json, id);
    };
})(); //# sourceMappingURL=melonjs.js.map

},{}],"gQ0md":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-undef */ var _netCommunicator = require("./NetCommunicator");
var _netCommunicatorDefault = parcelHelpers.interopDefault(_netCommunicator);
exports.default = game = {
    // an object where to store game information
    data: {
        // score
        score: 0
    },
    mode: null,
    // Run on page load.
    "onload": function() {
        // Initialize the video.
        if (!me.video.init(320, 240, {
            parent: "screen",
            scale: "auto",
            scaleMethod: "flex-width"
        })) {
            alert("Your browser does not support HTML5 canvas.");
            return;
        }
        // Initialize the audio.
        me.audio.init("wav");
        // set and load all resources.
        // (game will also automatically switch to the loading screen)
        me.loader.preload(game.resources, game.loaded.bind(game));
    },
    // Run on game resources loaded.
    "loaded": function() {
        me.state.set(me.state.PLAY, new game.PlayScreen());
        // add our player entity in the entity pool
        me.pool.register("Commander", game.PlayerEntity);
        me.pool.register("Water", game.Water);
        me.pool.register("Thorn", game.Thorn);
        me.pool.register("Torch", game.Torch);
        me.pool.register("Platform", game.Platform);
        me.pool.register("LaserBlast", game.LaserBlast);
        me.pool.register("LaserBlastRetep", game.LaserBlastRetep);
        me.pool.register("KektusThorn", game.KektusThorn);
        me.pool.register("Bloog", game.Bloog);
        me.pool.register("Slug", game.Slug);
        me.pool.register("Kektus", game.Kektus);
        me.pool.register("Mushroom", game.Mushroom);
        me.pool.register("LevelEntity", game.LevelEntity);
        me.pool.register("Retep", game.Retep);
        me.input.bindKey(me.input.KEY.LEFT, "left");
        me.input.bindKey(me.input.KEY.RIGHT, "right");
        me.input.bindKey(me.input.KEY.UP, "jump", true);
        me.input.bindKey(me.input.KEY.SPACE, "shoot", true);
        me.state.change(me.state.PLAY);
    },
    reinitiateRetep () {
        if (game.retep !== null) game.retep = me.game.world.addChild(me.pool.pull("Retep", 32, 544, game.netCom.getOpponentName()));
    },
    netCom: null,
    commander: null,
    retep: null,
    playerName: "",
    opponentName: "",
    onGameDataReceived (data) {
        if (data !== undefined && game.retep !== null) {
            if (data.entity === "retep") game.retep.onNetworkUpdate(data);
            else if (data.entity === "retepShot") me.game.world.addChild(me.pool.pull("LaserBlastRetep", data.posX, data.posY, data.direction));
        }
    },
    onOpponentConnected (opponentName) {
        if (game.retep === null) {
            game.retep = me.game.world.addChild(me.pool.pull("Retep", 32, 544, opponentName));
            game.opponentName = opponentName;
        }
    },
    sendGameData (data) {
        if (game.netCom === null) return;
        game.netCom.exchangeGameData(data);
    },
    setPlayerName (name) {
        game.playerName = name;
    },
    setMode (mode) {
        game.mode = mode;
    },
    setNetCom (netCom) {
        game.netCom = netCom;
    }
};

},{"./NetCommunicator":"7pzfP","@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"7pzfP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var ClientState;
(function(ClientState1) {
    ClientState1[ClientState1["DISCONNECTED"] = 0] = "DISCONNECTED";
    ClientState1[ClientState1["WAITING"] = 1] = "WAITING";
    ClientState1[ClientState1["BUSY"] = 2] = "BUSY";
})(ClientState || (ClientState = {
}));
class NetCommunicator {
    constructor(playerName1, host){
        this.host = "wss://18.192.24.53:8080";
        this.ws = null;
        this.otherPlayers = null;
        this.id = -1;
        this.opponentId = -1;
        this.opponentName = "";
        this.state = ClientState.DISCONNECTED;
        this.playerName = "";
        this.onGameDataReceived = ()=>{
        };
        this.onOpponentConnected = ()=>{
        };
        this.onChatDataReceived = ()=>{
        };
        this.onPlayersDataReceived = ()=>{
        };
        this.onGameRequestReceived = ()=>{
        };
        this.onGameRequestAckReceived = ()=>{
        };
        this.onGameRequestRejectReceived = ()=>{
        };
        this.playerName = playerName1;
        this.host = host;
        this.connect();
    }
    connect() {
        this.ws = new WebSocket(this.host);
        this.ws.onmessage = this.onMessage.bind(this);
    }
    onMessage(event) {
        let sm = JSON.parse(event.data);
        switch(sm.type){
            case "connect_confirmation":
                this.id = sm.data.id;
                this.state = ClientState.WAITING;
                let request = {
                    type: "id_confirmation",
                    id: this.id,
                    data: {
                        playerName: this.playerName
                    }
                };
                this.send(JSON.stringify(request));
                break;
            case "game_initiation_ack":
                this.state = ClientState.BUSY;
                this.opponentId = sm.data.opponentId;
                this.opponentName = sm.data.opponentName;
                this.onOpponentConnected();
                break;
            case "exchange_game_data":
                this.onGameDataReceived(sm.data);
                break;
            case "exchange_chat_data":
                this.onChatDataReceived(sm.data);
                break;
            case "all_players":
                this.onPlayersDataReceived(sm.data);
                break;
            case "error":
                console.log("Server-Error: " + sm.data.description);
                break;
            case "game_request":
                this.onGameRequestReceived(sm.opponentId, sm.data);
                break;
            case "game_request_ack":
                this.onGameRequestAckReceived(sm.opponentId, sm.data);
                break;
            case "game_request_reject":
                this.onGameRequestRejectReceived(sm.opponentId, sm.data);
                break;
            default:
                console.log("Received unkown message.");
        }
    }
    send(request) {
        if (this.state !== ClientState.DISCONNECTED) this.ws?.send(request);
    }
    setOnOpponentConnected(callback) {
        this.onOpponentConnected = ()=>{
        };
    }
    getOpponentName() {
        return this.opponentName;
    }
    doGameInitiation(opponentId) {
        if (this.state === ClientState.BUSY) return;
        let request = {
            type: "game_initiation",
            id: this.id,
            opponentId: opponentId
        };
        this.send(JSON.stringify(request));
    }
    exchangeGameData(gameData) {
        if (this.state !== ClientState.BUSY) return;
        let request = {
            type: "exchange_game_data",
            id: this.id,
            opponentId: this.opponentId,
            data: gameData
        };
        this.send(JSON.stringify(request));
    }
    exchangeChatData(chatData) {
        if (this.state === ClientState.BUSY) return;
        let request = {
            type: "exchange_chat_data",
            id: this.id,
            data: chatData
        };
        this.send(JSON.stringify(request));
    }
    doGameRequest(playerName, opponentId) {
        if (this.state === ClientState.BUSY) return;
        let request = {
            type: "game_request",
            id: this.id,
            opponentId: opponentId,
            data: {
                opponentName: playerName
            }
        };
        this.send(JSON.stringify(request));
    }
    doGameRequestAck(playerName, opponentId) {
        if (this.state === ClientState.BUSY) return;
        let request = {
            type: "game_request_ack",
            id: this.id,
            opponentId: opponentId,
            data: {
                opponentName: playerName
            }
        };
        this.send(JSON.stringify(request));
    }
    doGameRequestReject(playerName, opponentId) {
        if (this.state === ClientState.BUSY) return;
        let request = {
            type: "game_request_reject",
            id: this.id,
            opponentId: opponentId,
            data: {
                opponentName: playerName
            }
        };
        this.send(JSON.stringify(request));
    }
}
exports.default = NetCommunicator;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}],"hvrzO":[function(require,module,exports) {
/* eslint-disable no-undef */ game.resources = [
    {
        name: 'Arial',
        type: 'image',
        src: 'data/fnt/arial.png'
    },
    {
        name: 'Arial',
        type: 'binary',
        src: 'data/fnt/arial.fnt'
    },
    {
        name: 'walk',
        type: 'audio',
        src: 'data/sfx/'
    },
    {
        name: 'jump',
        type: 'audio',
        src: 'data/sfx/'
    },
    {
        name: 'win',
        type: 'audio',
        src: 'data/sfx/'
    },
    {
        name: 'die',
        type: 'audio',
        src: 'data/sfx/'
    },
    {
        name: 'land',
        type: 'audio',
        src: 'data/sfx/'
    },
    {
        name: 'shoot',
        type: 'audio',
        src: 'data/sfx/'
    },
    {
        name: 'kektusshoot',
        type: 'audio',
        src: 'data/sfx/'
    },
    {
        name: 'laserhit',
        type: 'audio',
        src: 'data/sfx/'
    },
    {
        name: 'layer1',
        type: 'image',
        src: 'data/img/layer1.png'
    },
    {
        name: 'layer2',
        type: 'image',
        src: 'data/img/layer2.png'
    },
    {
        name: 'layer3',
        type: 'image',
        src: 'data/img/layer3.png'
    },
    {
        name: 'clouds',
        type: 'image',
        src: 'data/img/clouds.png'
    },
    {
        name: 'desert_tiles',
        type: 'image',
        src: 'data/img/map/desert_tiles.png'
    },
    {
        name: '16x16tiles',
        type: 'image',
        src: 'data/img/sprite/16x16tiles.png'
    },
    {
        name: 'platform',
        type: 'image',
        src: 'data/img/sprite/platform.png'
    },
    {
        name: 'commander',
        type: 'image',
        src: 'data/img/sprite/commander.png'
    },
    {
        name: 'retep',
        type: 'image',
        src: 'data/img/sprite/retep.png'
    },
    {
        name: 'flag',
        type: 'image',
        src: 'data/img/sprite/flag.png'
    },
    {
        name: 'bloog',
        type: 'image',
        src: 'data/img/sprite/bloog.png'
    },
    {
        name: 'mushroom',
        type: 'image',
        src: 'data/img/sprite/mushroom.png'
    },
    {
        name: 'kektus',
        type: 'image',
        src: 'data/img/sprite/kektus.png'
    },
    {
        name: 'slug',
        type: 'image',
        src: 'data/img/sprite/slug.png'
    },
    {
        name: 'desert',
        type: 'tmx',
        src: 'data/map/desert.tmx'
    },
    {
        name: 'desert_tiles',
        type: 'tsx',
        src: 'data/map/desert_tiles.tsx'
    }, 
];

},{}],"1HPyh":[function(require,module,exports) {
/* eslint-disable no-undef */ game.TitleScreen = me.Stage.extend({
    /**
     *  action to perform on state change
     */ onResetEvent: function() {
    },
    /**
     *  action to perform when leaving this screen (state change)
     */ onDestroyEvent: function() {
    }
});

},{}],"kS1di":[function(require,module,exports) {
/* eslint-disable no-undef */ game.PlayScreen = me.Stage.extend({
    onResetEvent: function() {
        // load a level
        me.levelDirector.loadLevel("desert");
        if (game.mode === "multiplayer" && game.netCom !== null) {
            game.retep = me.game.world.addChild(me.pool.pull("Retep", 32, 544, game.netCom.getOpponentName()));
            game.netCom.onGameDataReceived = game.onGameDataReceived.bind(game);
        }
    },
    onDestroyEvent: function() {
        // remove the HUD from the game world
        me.game.world.removeChild(this.HUD);
    }
});

},{}],"9aMV9":[function(require,module,exports) {
/* eslint-disable no-undef */ game.Bloog = me.Sprite.extend({
    init: function(x, y, settings) {
        var width = settings.width;
        settings.image = "bloog";
        settings.framewidth = settings.width = 48;
        settings.frameheight = settings.height = 48;
        this._super(me.Sprite, 'init', [
            x,
            y,
            settings
        ]);
        this.body = new me.Body(this);
        this.body.addShape(new me.Rect(0, 0, settings.framewidth, settings.frameheight));
        this.body.setMaxVelocity(4, 6);
        this.body.setFriction(0.4, 0);
        this.isKinematic = false;
        x = this.pos.x;
        this.startX = x;
        this.pos.x = this.endX = x + width - this.width;
        this.walkRight = true;
        this.alive = true;
        this.addAnimation("walk_left", [
            0,
            1,
            2,
            3
        ]);
        this.addAnimation("walk_right", [
            4,
            5,
            6,
            7
        ]);
        this.addAnimation("dead", [
            8
        ]);
        this.setCurrentAnimation("walk_right");
        this.body.collisionType = me.collision.types.ENEMY_OBJECT;
        this.type = "monster";
    },
    update: function(dt) {
        if (this.alive) {
            if (!this.walkRight && this.pos.x <= this.startX) {
                this.walkRight = true;
                this.setCurrentAnimation("walk_right");
                this.body.force.x = this.body.maxVel.x;
            } else if (this.walkRight && this.pos.x >= this.endX) {
                this.walkRight = false;
                this.body.force.x = -this.body.maxVel.x;
                this.setCurrentAnimation("walk_left");
            }
        } else this.body.force.x = 0;
        this.body.update(dt);
        me.collision.check(this);
        return this._super(me.Sprite, 'update', [
            dt
        ]) || this.body.vel.x !== 0 || this.body.vel.y !== 0;
    },
    onCollision: function(response, other) {
        if (this.alive && other.body.collisionType === me.collision.types.PROJECTILE_OBJECT) {
            this.alive = false;
            this.setCurrentAnimation("dead");
        } else if (other.body.collisionType === me.collision.types.ENEMY_OBJECT) return false;
        else if (other.body.collisionType === me.collision.types.PLAYER_OBJECT) return false;
        return true;
    }
});
game.Slug = me.Sprite.extend({
    init: function(x, y, settings) {
        var width = settings.width;
        settings.image = "slug";
        settings.framewidth = settings.width = 32;
        settings.frameheight = settings.height = 32;
        this._super(me.Sprite, 'init', [
            x,
            y,
            settings
        ]);
        this.body = new me.Body(this);
        this.body.addShape(new me.Rect(0, 0, settings.framewidth, settings.frameheight));
        this.body.setMaxVelocity(1, 0);
        this.body.setFriction(0.4, 0);
        this.isKinematic = false;
        x = this.pos.x;
        this.startX = x;
        this.pos.x = x;
        this.endX = x + width - this.width;
        this.walkRight = false;
        this.alive = true;
        this.addAnimation("walk_left", [
            0,
            1,
            2
        ]);
        this.addAnimation("walk_right", [
            3,
            4,
            5
        ]);
        this.addAnimation("dead", [
            6,
            7
        ], 200);
        this.setCurrentAnimation("walk_right");
        this.body.collisionType = me.collision.types.ENEMY_OBJECT;
        this.type = "monster";
    },
    update: function(dt) {
        if (this.alive) {
            if (!this.walkRight && this.pos.x <= this.startX) {
                this.walkRight = true;
                this.setCurrentAnimation("walk_right");
                this.body.force.x = this.body.maxVel.x;
            } else if (this.walkRight && this.pos.x >= this.endX) {
                this.walkRight = false;
                this.body.force.x = -this.body.maxVel.x;
                this.setCurrentAnimation("walk_left");
            }
        } else this.body.force.x = 0;
        this.body.update(dt);
        me.collision.check(this);
        return this._super(me.Sprite, 'update', [
            dt
        ]) || this.body.vel.x !== 0 || this.body.vel.y !== 0;
    },
    onCollision: function(response, other) {
        if (this.alive && other.body.collisionType === me.collision.types.PROJECTILE_OBJECT) {
            this.alive = false;
            this.setCurrentAnimation("dead", ()=>false
            );
        } else if (other.body.collisionType === me.collision.types.ENEMY_OBJECT) return false;
        else if (other.body.collisionType === me.collision.types.PLAYER_OBJECT) return false;
        return true;
    }
});
game.Kektus = me.Sprite.extend({
    init: function(x, y, settings) {
        var width = settings.width;
        settings.image = "kektus";
        settings.framewidth = settings.width = 80;
        settings.frameheight = settings.height = 80;
        this._super(me.Sprite, 'init', [
            x,
            y,
            settings
        ]);
        this.body = new me.Body(this);
        this.body.addShape(new me.Rect(0, 0, settings.framewidth, settings.frameheight));
        this.body.setMaxVelocity(1, 0);
        this.body.setFriction(0.4, 0);
        this.isKinematic = false;
        this.walkRight = false;
        this.alwaysUpdate = true;
        this.alive = true;
        this.awaken = 0; // counts the time to awaken fully
        this.sleeping = true;
        this.shootRepition = 0; // counts the time to repeat shooting
        this.addAnimation("sleep", [
            0,
            1
        ], 300);
        this.addAnimation("dead", [
            7,
            8
        ], 300);
        this.addAnimation("attack", [
            3,
            4,
            5,
            6
        ], 300);
        this.setCurrentAnimation("sleep");
        this.body.collisionType = me.collision.types.ENEMY_OBJECT;
        this.type = "monster";
    },
    update: function(dt) {
        if (this.awaken > 0 && this.sleeping) {
            this.awaken++;
            if (this.awaken === 300) {
                this.sleeping = false;
                this.setCurrentAnimation("attack");
                this.shoot();
            }
        }
        if (!this.sleeping && this.alive) {
            this.shootRepition++;
            if (this.shootRepition === 150) {
                this.shootRepition = 0;
                this.shoot();
            }
        }
        this.body.update(dt);
        me.collision.check(this);
        return this._super(me.Sprite, 'update', [
            dt
        ]) || this.body.vel.x !== 0 || this.body.vel.y !== 0;
    },
    shoot: function() {
        let m = [
            2,
            1.75,
            1.5,
            1.25,
            1,
            0.75,
            0.5,
            0.25,
            0,
            0.25,
            0.5,
            0.75,
            1,
            1.25,
            1.5,
            1.75,
            2,
            1.75,
            1.5,
            1.25,
            1,
            0.75,
            0.5,
            0.25,
            0,
            0.25,
            0.5,
            0.75,
            1,
            1.25,
            1.5,
            1.75,
            2
        ];
        let directionX, directionY = 0;
        let posX = this.pos.x + this.width / 2;
        let posY = this.pos.y + this.height / 2;
        for(let i = 0; i < 33; i++){
            if (i <= 7) {
                directionX = 1;
                directionY = -1;
            } else if (i <= 15) {
                directionX = 1;
                directionY = 1;
            } else if (i <= 23) {
                directionX = -1;
                directionY = 1;
            } else if (i <= 32) {
                directionX = -1;
                directionY = -1;
            }
            me.audio.play("kektusshoot");
            me.game.world.addChild(me.pool.pull("KektusThorn", posX, posY, directionX, directionY, m[i]));
        }
    },
    onCollision: function(response, other) {
        if (this.alive && !this.sleeping && other.body.collisionType === me.collision.types.PROJECTILE_OBJECT) {
            if (other.type !== "kektusthorn") {
                this.alive = false;
                this.setCurrentAnimation("dead");
            }
            return false;
        } else if (other.body.collisionType === me.collision.types.ENEMY_OBJECT) return false;
        else if (other.body.collisionType === me.collision.types.PLAYER_OBJECT) return false;
        return true;
    },
    onVisibilityChange: function() {
        if (this.awaken === 0) this.awaken = 1;
    }
});
game.Mushroom = me.Sprite.extend({
    init: function(x, y, settings) {
        var areaHeight = settings.height;
        settings.image = "mushroom";
        settings.framewidth = settings.width = 32;
        settings.frameheight = settings.height = 32;
        this._super(me.Sprite, 'init', [
            x,
            y,
            settings
        ]);
        this.body = new me.Body(this);
        this.body.addShape(new me.Rect(0, 0, settings.framewidth, settings.frameheight));
        this.body.setMaxVelocity(0, 2.5);
        this.body.setFriction(0.4, 0);
        this.isKinematic = false;
        this.startY = this.pos.y + areaHeight - this.height;
        this.endY = this.pos.y;
        this.pos.y = this.startY;
        this.jumpUp = false;
        this.alive = true;
        this.addAnimation("jump_left", [
            0,
            1
        ]);
        this.addAnimation("jump_right", [
            2,
            3
        ]); // not implemented yet
        this.setCurrentAnimation("jump_left");
        this.animationpause = true;
        this.body.collisionType = me.collision.types.ENEMY_OBJECT;
        this.type = "monster";
    },
    // manage the enemy movement
    update: function(dt) {
        if (this.alive) {
            if (this.jumpUp && this.pos.y <= this.endY) {
                this.body.force.y = this.body.maxVel.y;
                this.jumpUp = false;
                this.setAnimationFrame((this.getCurrentAnimationFrame() + 1) % 2);
            } else if (!this.jumpUp && this.pos.y >= this.startY) {
                this.body.force.y = -this.body.maxVel.y;
                this.jumpUp = true;
                this.setAnimationFrame((this.getCurrentAnimationFrame() + 1) % 2);
            }
        } else this.body.force.y = 0;
        me.collision.check(this);
        this.body.update(dt);
        return this._super(me.Sprite, 'update', [
            dt
        ]) || this.body.vel.x !== 0 || this.body.vel.y !== 0;
    },
    onCollision: function(response, other) {
        if (this.alive && other.body.collisionType === me.collision.types.PROJECTILE_OBJECT) {
            this.alive = false;
            this.setAnimationFrame();
        }
        if (other.body.collisionType === me.collision.types.WORLD_SHAPE) return true;
        else return false;
    }
});
game.KektusThorn = me.Entity.extend({
    init: function(x, y, directionX, directionY, m) {
        let settings = {
            image: '16x16tiles',
            width: 16,
            height: 16,
            framewidth: 16
        };
        this._super(me.Entity, 'init', [
            x,
            y,
            settings
        ]);
        this.directionX = directionX;
        this.directionY = directionY;
        this.body.setMaxVelocity(3, 3 * m);
        this.alwaysUpdate = true;
        this.renderable.addAnimation("shoot", [
            18,
            19,
            20,
            21,
            22
        ]);
        this.renderable.addAnimation("explode", [
            23
        ], 100);
        this.renderable.setCurrentAnimation("shoot");
        this.type = "kektusthorn";
        this.body.collisionType = me.collision.types.PROJECTILE_OBJECT;
        this.body.update();
    },
    update: function(dt) {
        let bounds = me.game.world.getBounds();
        if (!this.collided) {
            this.body.force.x = this.body.maxVel.x * this.directionX;
            this.body.force.y = this.body.maxVel.y * this.directionY;
            me.collision.check(this);
        }
        if (this.pos.y + this.height <= 0 || this.pos.y >= bounds.height || this.pos.x + this.width <= 0 || this.pos.x >= bounds.width) me.game.world.removeChild(this);
        this.body.update();
        return this._super(me.Entity, 'update', [
            dt
        ]) || this.body.vel.x !== 0 || this.body.vel.y !== 0;
    },
    onCollision: function(response, other) {
        if (this.collided) return false;
        if (other.body.collisionType === me.collision.types.PLAYER_OBJECT) {
            this.body.setMaxVelocity(0, 0);
            me.audio.stop();
            me.audio.play("laserhit");
            this.renderable.setCurrentAnimation("explode", (function() {
                console.log("wasted");
                me.game.world.removeChild(this);
                return false;
            }).bind(this));
            this.collided = true;
        }
        return false;
    }
});

},{}],"asKw9":[function(require,module,exports) {
/* eslint-disable no-undef */ game.PlayerEntity = me.Entity.extend({
    init: function(x, y, settings) {
        this._super(me.Entity, 'init', [
            x,
            y,
            settings
        ]);
        me.game.viewport.follow(this.pos, me.game.viewport.AXIS.BOTH, 0.4);
        this.alwaysUpdate = true;
        this.renderable.addAnimation("walk_left", [
            0,
            3
        ]);
        this.renderable.addAnimation("walk_right", [
            4,
            7
        ]);
        this.renderable.addAnimation("jump_left", [
            8
        ]);
        this.renderable.addAnimation("jump_right", [
            11
        ]);
        this.renderable.addAnimation("fall_left", [
            9,
            10
        ], 200);
        this.renderable.addAnimation("fall_right", [
            11,
            12,
            200
        ]);
        this.renderable.addAnimation("stand_left", [
            27
        ]);
        this.renderable.addAnimation("stand_right", [
            28
        ]);
        this.renderable.addAnimation("shoot_walk_right", [
            19
        ], 120);
        this.renderable.addAnimation("shoot_walk_left", [
            14
        ], 120);
        this.renderable.addAnimation("shoot_jump_right", [
            20
        ], 120);
        this.renderable.addAnimation("shoot_jump_left", [
            15
        ], 120);
        this.renderable.addAnimation("surf", [
            29
        ]);
        this.renderable.addAnimation("die", [
            25,
            26
        ], 200);
        this.renderable.addAnimation("freeze", [
            30
        ], 500);
        this.renderable.setCurrentAnimation("stand_right");
        this.body.setMaxVelocity(3, 15);
        this.body.setFriction(0.4, 0.5);
        this.body.removeShapeAt(0);
        this.body.addShape(new me.Rect(0, 16, 16, 48));
        this.body.collisionType = me.collision.types.PLAYER_OBJECT;
        // specific values
        this.walkRight = true;
        this.type = "commander";
        this.shooting = false;
        this.freezed = false;
        this.dead = false;
        this.landing = false;
        this.platforming = false;
        this.platformingForce = 0;
        this.curAnimation = "stand_right";
        this.lastAnimation = "";
        this.updateCounter = 0;
        this.font = new me.BitmapText(0, 0, {
            font: "Arial",
            size: 1
        });
        game.commander = this;
    },
    draw: function(renderer) {
        this._super(me.Entity, 'draw', [
            renderer
        ]);
        this.font.draw(renderer, game.playerName, -10, 0);
    },
    update: function(dt) {
        if (game.mode === "multiplayer") {
            //put onNetUpdate, if you want to limit update rate
            if (this.updateCounter === 0) {
                if (this.lastAnimation.indexOf("stand") === -1 || this.curAnimation !== this.lastAnimation) {
                    this.updateRetep();
                    this.lastAnimation = this.curAnimation;
                }
            }
            this.updateCounter = (this.updateCounter + 1) % 1;
        }
        if (this.dead) {
            this.body.update(dt);
            return this._super(me.Entity, 'update', [
                dt
            ]) || this.body.vel.x !== 0 || this.body.vel.y !== 0;
        }
        if (this.shooting || this.freezed) return this._super(me.Entity, 'update', [
            dt
        ]);
        // walking
        if (me.input.isKeyPressed('right')) {
            this.body.force.x = this.body.maxVel.x;
            this.walkRight = true;
            if (!this.isBlockedAnimation() && !this.renderable.isCurrentAnimation("walk_right")) {
                this.renderable.setCurrentAnimation("walk_right", ()=>me.audio.play("walk")
                );
                this.curAnimation = "walk_right";
            }
        } else if (me.input.isKeyPressed('left')) {
            this.body.force.x = -this.body.maxVel.x;
            this.walkRight = false;
            if (!this.isBlockedAnimation() && !this.renderable.isCurrentAnimation("walk_left")) {
                this.renderable.setCurrentAnimation("walk_left", ()=>me.audio.play("walk")
                );
                this.curAnimation = "walk_left";
            }
        } else // standing or surfing
        if (this.platforming) {
            this.body.force.x = 0;
            if (!this.renderable.isCurrentAnimation("surf")) {
                this.renderable.setCurrentAnimation("surf");
                this.curAnimation = "surf";
            }
        } else {
            this.body.force.x = 0;
            if (this.walkRight) {
                if (!this.isBlockedAnimation() && !this.renderable.isCurrentAnimation("stand_right")) {
                    this.renderable.setCurrentAnimation("stand_right");
                    this.curAnimation = "stand_right";
                }
            } else if (!this.isBlockedAnimation() && !this.renderable.isCurrentAnimation("stand_left")) {
                this.renderable.setCurrentAnimation("stand_left");
                this.curAnimation = "stand_left";
            }
        }
        // initiate jumping
        if (me.input.isKeyPressed('jump')) {
            if (!this.body.jumping && !this.body.falling) {
                this.body.force.y = -this.body.maxVel.y;
                me.audio.play("jump");
                this.landing = true;
            }
            this.body.jumping = true;
        } else this.body.force.y = 0;
        // handle jumping or falling animation
        if (this.body.falling) {
            if (this.walkRight) {
                if (!this.renderable.isCurrentAnimation("fall_right")) {
                    this.renderable.setCurrentAnimation("fall_right");
                    this.curAnimation = "fall_right";
                }
            } else if (!this.renderable.isCurrentAnimation("fall_left")) {
                this.renderable.setCurrentAnimation("fall_left");
                this.curAnimation = "fall_left";
            }
        } else if (this.body.jumping) {
            if (this.walkRight) {
                if (!this.renderable.isCurrentAnimation("jump_right")) {
                    this.renderable.setCurrentAnimation("jump_right");
                    this.curAnimation = "jump_right";
                }
            } else if (!this.renderable.isCurrentAnimation("jump_left")) {
                this.renderable.setCurrentAnimation("jump_left");
                this.curAnimation = "jump_left";
            }
        }
        // shooting
        if (me.input.isKeyPressed('shoot')) {
            this.shooting = 1;
            let direction, posX = 0;
            let curAni = "";
            if (this.body.jumping || this.body.falling) curAni = "shoot_jump";
            else curAni = "shoot_walk";
            if (this.walkRight) {
                this.renderable.setCurrentAnimation(curAni + "_right", (function() {
                    this.shooting = false;
                }).bind(this));
                this.curAnimation = curAni + "_right";
                direction = 1;
                posX = this.pos.x;
            } else {
                this.renderable.setCurrentAnimation(curAni + "_left", (function() {
                    this.shooting = false;
                }).bind(this));
                this.curAnimation = curAni + "_left";
                direction = -1;
                posX = this.pos.x + 16;
            }
            me.audio.play("shoot");
            this.shooting = true;
            me.game.world.addChild(me.pool.pull("LaserBlast", posX, this.pos.y + 35, direction));
            if (game.mode === "multiplayer") this.initiateRetepShot(posX, this.pos.y + 35, direction);
        }
        this.body.update(dt);
        me.collision.check(this);
        return this._super(me.Entity, 'update', [
            dt
        ]) || this.body.vel.x !== 0 || this.body.vel.y !== 0;
    },
    isBlockedAnimation: function() {
        return this.body.jumping || this.body.falling || this.shooting;
    },
    onCollision: function(response, other) {
        switch(other.body.collisionType){
            case me.collision.types.WORLD_SHAPE:
                if (this.landing) {
                    this.landing = false;
                    me.audio.play("land");
                }
                if (other.type === "platform") {
                    this.platforming = true;
                    this.platformingForce = other;
                } else this.platforming = false;
                return true;
            case me.collision.types.ENEMY_OBJECT:
                if (!(other.type === 'monster') || other.alive && !this.dead) this.die();
                return false;
            case me.collision.types.PROJECTILE_OBJECT:
                if (other.type === "kektusthorn") this.die();
                else if (other.type === "laserblastretep") this.freeze();
                return false;
            default:
                return false;
        }
    },
    freeze () {
        if (this.freezed) return;
        this.freezed = true;
        this.curAnimation = "freeze";
        this.renderable.setCurrentAnimation("freeze", (function() {
            this.freezed = false;
        }).bind(this));
    },
    die () {
        this.dead = true;
        this.renderable.setCurrentAnimation("die");
        this.curAnimation = "die";
        this.body.vel.y = -200;
        this.body.force.x = 0;
        me.audio.play("die");
        window.setTimeout(()=>me.levelDirector.reloadLevel({
                onLoaded: game.reinitiateRetep.bind(game)
            })
        , 2000);
    },
    updateRetep () {
        const data = {
            entity: "retep",
            posX: this.pos.x,
            posY: this.pos.y,
            currentAnimation: this.curAnimation
        };
        game.sendGameData(data);
    },
    initiateRetepShot (posX, posY, direction) {
        const data = {
            entity: "retepShot",
            posX: posX,
            posY: posY,
            direction: direction
        };
        game.sendGameData(data);
    }
});
game.LaserBlast = me.Entity.extend({
    init: function(x, y, direction) {
        let settings = {
            image: '16x16tiles',
            width: 16,
            height: 16,
            framewidth: 16
        };
        this._super(me.Entity, 'init', [
            x,
            y,
            settings
        ]);
        this.alwaysUpdate = true;
        this.renderable.addAnimation("shoot", [
            12,
            13,
            14,
            15,
            16
        ]);
        this.renderable.addAnimation("explode", [
            17
        ], 100);
        this.renderable.setCurrentAnimation("shoot");
        this.body.collisionType = me.collision.types.PROJECTILE_OBJECT;
        this.body.setMaxVelocity(7, 0);
        this.body.update();
        this.type = "laserblast";
        this.direction = direction;
        this.collided = false;
    },
    update: function(dt) {
        let bounds = me.game.viewport.getBounds();
        game.sendGameData();
        if (!this.collided) {
            this.body.force.x = this.body.maxVel.x * this.direction;
            me.collision.check(this); // don't call collision.check once the blast collided because this will abort callback of explode-animation
        }
        // remove from world, if left viewport
        if (this.pos.y <= bounds.pos.y || this.pos.y + this.height >= bounds.pos.y + bounds.height || this.pos.x + this.width <= bounds.pos.x || this.pos.x + this.width >= bounds.pos.x + bounds.width) me.game.world.removeChild(this);
        this.body.update();
        return this._super(me.Entity, 'update', [
            dt
        ]) || this.body.vel.x !== 0 || this.body.vel.y !== 0;
    },
    onCollision: function(response, other) {
        if (this.collided) return false;
        if (other.body.collisionType === me.collision.types.PLAYER_OBJECT && other.type === "commander") return false;
        this.body.setMaxVelocity(0, 0);
        me.audio.play("laserhit");
        this.renderable.setCurrentAnimation("explode", (function() {
            me.game.world.removeChild(this);
            return false;
        }).bind(this));
        this.collided = true;
        return false;
    }
});
game.LaserBlastRetep = me.Entity.extend({
    init: function(x, y, direction) {
        let settings = {
            image: '16x16tiles',
            width: 16,
            height: 16,
            framewidth: 16
        };
        this._super(me.Entity, 'init', [
            x,
            y,
            settings
        ]);
        this.alwaysUpdate = true;
        this.renderable.addAnimation("shoot", [
            12,
            13,
            14,
            15,
            16
        ]);
        this.renderable.addAnimation("explode", [
            17
        ], 100);
        this.renderable.setCurrentAnimation("shoot");
        this.body.collisionType = me.collision.types.PROJECTILE_OBJECT;
        this.body.setMaxVelocity(7, 0);
        this.body.update();
        this.type = "laserblastretep";
        this.direction = direction;
        this.collided = false;
    },
    update: function(dt) {
        let bounds = me.game.viewport.getBounds();
        game.sendGameData();
        if (!this.collided) {
            this.body.force.x = this.body.maxVel.x * this.direction;
            me.collision.check(this); // don't call collision.check once the blast collided because this will abort callback of explode-animation
        }
        // remove from world, if left viewport
        if (this.pos.y <= bounds.pos.y || this.pos.y + this.height >= bounds.pos.y + bounds.height || this.pos.x + this.width <= bounds.pos.x || this.pos.x + this.width >= bounds.pos.x + bounds.width) me.game.world.removeChild(this);
        this.body.update();
        return this._super(me.Entity, 'update', [
            dt
        ]) || this.body.vel.x !== 0 || this.body.vel.y !== 0;
    },
    onCollision: function(response, other) {
        if (this.collided) return false;
        if (other.body.collisionType === me.collision.types.PLAYER_OBJECT && other.type === "retep") return false;
        this.body.setMaxVelocity(0, 0);
        me.audio.play("laserhit");
        this.renderable.setCurrentAnimation("explode", (function() {
            me.game.world.removeChild(this);
            return false;
        }).bind(this));
        this.collided = true;
        return false;
    }
});

},{}],"ghQWU":[function(require,module,exports) {
/* eslint-disable no-undef */ game.Retep = me.Entity.extend({
    init: function(x, y, opponentName) {
        const settings = {
            image: "retep",
            framewidth: 48,
            frameheight: 48,
            width: 48,
            height: 48
        };
        this._super(me.Entity, 'init', [
            x,
            y,
            settings
        ]);
        this.body.removeShapeAt(0);
        this.body.addShape(new me.Rect(0, 16, 16, 48));
        this.isKinematic = false;
        this.renderable.addAnimation("walk_left", [
            0,
            3
        ]);
        this.renderable.addAnimation("walk_right", [
            4,
            7
        ]);
        this.renderable.addAnimation("jump_left", [
            8
        ]);
        this.renderable.addAnimation("jump_right", [
            11
        ]);
        this.renderable.addAnimation("fall_left", [
            9,
            10
        ], 200);
        this.renderable.addAnimation("fall_right", [
            11,
            12,
            200
        ]);
        this.renderable.addAnimation("stand_left", [
            27
        ]);
        this.renderable.addAnimation("stand_right", [
            28
        ]);
        this.renderable.addAnimation("shoot_walk_right", [
            19
        ], 120);
        this.renderable.addAnimation("shoot_walk_left", [
            14
        ], 120);
        this.renderable.addAnimation("shoot_jump_right", [
            20
        ], 120);
        this.renderable.addAnimation("shoot_jump_left", [
            15
        ], 120);
        this.renderable.addAnimation("surf", [
            29
        ]);
        this.renderable.addAnimation("die", [
            25,
            26
        ], 200);
        this.renderable.addAnimation("freeze", [
            30
        ], 500);
        this.renderable.setCurrentAnimation("stand_right");
        this.currentAnimation = "stand_right";
        this.alwaysUpdate = true;
        this.opponentName = opponentName;
        this.font = new me.BitmapText(0, 0, {
            font: "Arial",
            size: 1
        });
        this.body.collisionType = me.collision.types.PLAYER_OBJECT;
        this.type = "retep";
    },
    draw: function(renderer) {
        this._super(me.Entity, 'draw', [
            renderer
        ]);
        this.font.draw(renderer, this.opponentName, -40, -23);
    },
    onNetworkUpdate: function(data) {
        this.pos.x = data.posX;
        this.pos.y = data.posY;
        this.setMyCurrentAnimation(data.currentAnimation);
    },
    setMyCurrentAnimation: function(animation) {
        if (animation !== this.currentAnimation) {
            this.currentAnimation = animation;
            this.renderable.setCurrentAnimation(this.currentAnimation);
        }
    },
    update: function(dt) {
        this._super(me.Entity, "update", [
            dt
        ]);
        me.collision.check(this);
        return true;
    },
    onCollision: function(response, other) {
        /*
        if(other.body.collisionType === me.collision.types.PLAYER_OBJECT){
            return false;
        }else if(other.body.collisionType === me.collision.types.PROJECTILE_OBJECT){
            return false;
        }
       // return true;
       */ return false;
    }
});

},{}],"821Be":[function(require,module,exports) {
/* eslint-disable no-undef */ game.Water = me.Entity.extend({
    init: function(x, y, settings) {
        settings = {
            image: '16x16tiles',
            width: 16,
            height: 16,
            framewidth: 16
        };
        this._super(me.Entity, 'init', [
            x,
            y,
            settings
        ]);
        this.renderable.addAnimation("wave", [
            6,
            7,
            8,
            9
        ]);
        this.renderable.setCurrentAnimation("wave");
        this.body.collisionType = me.collision.types.ENEMY_OBJECT;
        this.type = "obstacle";
    },
    onCollision: function(response, other) {
        return false;
    }
});
game.Thorn = me.Entity.extend({
    init: function(x, y, settings) {
        // image is implemented as tile in tiled
        this._super(me.Entity, 'init', [
            x,
            y,
            settings
        ]);
        this.body.collisionType = me.collision.types.ENEMY_OBJECT;
        this.type = "obstacle";
    },
    onCollision: function(response, other) {
        return false;
    }
});
game.Torch = me.Entity.extend({
    init: function(x, y, settings) {
        settings = {
            image: '16x16tiles',
            width: 16,
            height: 16,
            framewidth: 16
        };
        this._super(me.Entity, 'init', [
            x,
            y,
            settings
        ]);
        this.body.collisionType = me.collision.types.NO_OBJECT;
        this.renderable.addAnimation("burn", [
            0,
            1,
            2,
            3
        ]);
        this.renderable.setCurrentAnimation("burn");
    },
    onCollision: function(response, other) {
        return false;
    }
});
game.Platform = me.Sprite.extend({
    init: function(x, y, settings) {
        let areaWidth = settings.width;
        settings.image = "platform";
        settings.framewidth = settings.width = 48;
        settings.frameheight = settings.height = 16;
        this._super(me.Sprite, 'init', [
            x,
            y,
            settings
        ]);
        this.body = new me.Body(this);
        this.body.addShape(new me.Rect(0, 8, settings.framewidth, settings.frameheight));
        this.body.setMaxVelocity(1, 0);
        this.body.setFriction(0, 0);
        this.isKinematic = false;
        this.alwaysUpdate = true;
        this.startX = this.pos.x;
        this.endX = this.startX + areaWidth - this.width;
        this.walkRight = false;
        this.body.collisionType = me.collision.types.WORLD_SHAPE;
        this.type = "platform";
    },
    update: function(dt) {
        if (!this.walkRight && this.pos.x <= this.startX) {
            this.walkRight = true;
            this.body.force.x = this.body.maxVel.x;
        } else if (this.walkRight && this.pos.x >= this.endX) {
            this.walkRight = false;
            this.body.force.x = -this.body.maxVel.x;
        }
        this.body.update(dt);
        return this._super(me.Sprite, 'update', [
            dt
        ]) || this.body.vel.x !== 0 || this.body.vel.y !== 0;
    },
    onCollision: function(response, other) {
        return false;
    }
});
game.LevelEntity = me.LevelEntity.extend({
    init: function(x, y, settings) {
        this._super(me.LevelEntity, 'init', [
            x,
            y,
            settings
        ]);
        this.win = false;
    },
    onCollision: function(response, other) {
        if (other.body.collisionType === me.collision.types.PLAYER_OBJECT) {
            if (!this.win) me.audio.play("win");
            this.win = true;
            window.setTimeout((function() {
                this.goTo("desert");
            }).bind(this), 3000);
        }
        return false;
    }
});

},{}],"8b08R":[function(require,module,exports) {

},{}],"bUdck":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StartParams", ()=>StartParams
);
class StartParams {
    constructor(){
        this.playerName = "";
        this.host = "";
        this.gameMode = 0;
        this.netCommunicator = null;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"4N8i7"}]},["dTQGj","4Memt","fpYkd"], "fpYkd", "parcelRequire7cf7")

